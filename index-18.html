<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v21 - PP Gadget Use / Crash Attempt)</title> <style>
        /* Estilos CSS (Ajustes para v21) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222; border: 1px solid #444; padding: 10px;
            height: 30vh; /* Reduzido ainda mais para dar MUITO espaço ao sumário */
            overflow-y: auto; white-space: pre-wrap; margin-top: 10px;
        }
        #summary-s1, #summary-s2 { /* Sumários MAIORES */
            background: #2a2a2a; border: 1px solid #555; padding: 10px;
            margin-top: 15px; font-size: 13px; /* Tamanho base do container */
            max-height: 65vh; /* *** AUMENTADO SIGNIFICATIVAMENTE v21 *** */
            overflow-y: auto;
        }
        #summary-s1 h2, #summary-s2 h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary-s1 ul, #summary-s2 ul { padding-left: 20px; margin: 5px 0; }
        #summary-s1 li, #summary-s2 li {
             margin-bottom: 4px;
             font-size: 14px; /* *** AUMENTADO v21 *** */
             line-height: 1.3;
        }

        /* Estilos de Log (Inalterados) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(v21 - Base v18.1) - Script 1</h1> <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1 (v21)</button>
    <div id="output"></div>
    <div id="summary-s1"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v21 PP Gadget Use / Crash Attempt) - Script 2</h2> <p>Foco: PP Avançado++(Uso)/Crash, OOB R/W (Meta/Img/Read Simples), API Checks, Canvas Interact.</p>
        <canvas id="interactive-canvas" width="300" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas (v21)</button>
        <div id="output-canvas"></div>
        <div id="summary-s2"></div>
    </section>

    <script>
        // --- Script 1 (v21 - Base v18.1) ---
        // Código completo do Script 1 da v18.1 (sem alterações na v21)
        // ... (Omitido por brevidade - Cole aqui o Script 1 da v18.1 que você enviou) ...
         const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; let findingsS1 = []; const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good']; const log = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('completo') || lowerMsg.includes('ok') || lowerMsg.includes('recebida') || lowerMsg.includes('adicionar blob/arraybuffer ok')) { keepLog = true; } } if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; } if (!keepLog) return; if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS1.push({ type, funcName, message: sanitizedMessage, time: timestamp }); } if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } }; const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms)); const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { /* ...código v18.1... */ }; const testOOBReadInfoLeakEnhancedStore = async () => { /* ...código v18.1... */ }; const testOOBUAFPattern = async () => { /* ...código v18.1... */ }; const testOOBOtherTypes = async () => { /* ...código v18.1... */ }; const testBasicPP = async () => { /* ...código v18.1... */ }; const testPPJsonHijack = async () => { /* ...código v18.1... */ }; const testWebSockets = async () => { /* ...código v18.1... */ }; const testWebWorkers = async () => { /* ...código v18.1... */ }; const testIndexedDB = async () => { /* ...código v18.1... */ }; const testDOMStress = async () => { /* ...código v18.1... */ }; const runAllTests = async () => { /* ...código v18.1... */ };

    </script>

    <script>
        // --- Script 2: Canvas (v21 PP Gadget Use / Crash Attempt) ---

        // --- Variáveis Globais --- (sem alterações da v18.1)
        const SHORT_PAUSE_CANVAS = 50; let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null; const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 70, h: 25, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Clk' }, { id: 'rect-link', x: 90, y: 10, w: 80, h: 25, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 180, y: 10, w: 100, h: 25, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ]; const imgSquareSize = 40; const imgSquareSpacing = 8; const imgSquares = []; const imgSquaresStartY = 145; let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" }; let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false; let gpuAdapter = null; let gpuDevice = null; let findingsS2 = []; let sprayHole = []; // Necessário para OOB Read Enhanced, mesmo que seja a versão simples

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good', 'warn']; // Mantendo filtro v18.1
        // logCanvas (código da v18.1 - com registro de findings)
        const logCanvas = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('n/a') || lowerMsg.includes('não suportad') || lowerMsg.includes('não disponível') || lowerMsg.includes('fail:') || lowerMsg.includes('não afetou') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('ok') || lowerMsg.includes('aberto') || lowerMsg.includes('concluído') || lowerMsg.includes('restaurado') || lowerMsg.includes('limpeza') || lowerMsg.includes('pulado') || lowerMsg.includes('resolvido') || lowerMsg.includes('sem erro') || lowerMsg.includes('finalizado') || lowerMsg.includes('restaurado') || lowerMsg.includes('sem erros gl')) { keepLog = true; } } if (!keepLog && type === 'error' && (String(message).includes('element.innerhtml setter') || String(message).includes('webgl') || String(message).includes('gpu') || String(message).includes('file system') || String(message).includes('indexeddb') || String(message).includes('fatal') || String(message).includes('critical'))) { keepLog = true; } if (!keepLog && funcName === 'CanvasClick') { keepLog = true; } if (!keepLog && type === 'error' && funcName === 'testAdvancedPP' && message.includes(' is not a function')) { keepLog = true;} // Manter erro gadget PP if (!keepLog) return; if (!outputDivCanvas) return; const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS2.push({ type, funcName, message: sM, time: timestamp }); } if(outputDivCanvas.innerHTML.length > 600000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 300000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } };
        // PAUSE, toHexCanvas, is*, draw*, redrawAll (código v18.1)
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms)); const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); }; const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 11px mono"; ctx.textAlign="center"; ctx.textBaseline = "middle"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 1); }); ctx.textAlign="start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }}; const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? '#FFFF88' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); if (sq.text) { ctx.fillStyle = "#FFF"; ctx.font = "bold 10px mono"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2); } if (sq.url) { ctx.fillStyle = "#6cf"; ctx.font = "bold 9px mono"; ctx.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - 7); } }); ctx.textAlign = "start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); } }; const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "11px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};


        // --- Funções de Teste (Script 2 - Base v18.1 + Modificações v21) ---

        // testWebGLCheck (da v18.1)
        const testWebGLCheck = async () => { /* ...código v18.1... */ };

        // *** v21: testAdvancedPP MODIFICADO para incluir teste de uso dos gadgets ***
        const testAdvancedPP = async () => {
            const FNAME = 'testAdvancedPP';
            logCanvas("--- Teste: PP Avançado (Gadgets++ / Uso) ---", 'test', FNAME); // Título Atualizado
            const propsToPollute = [ /* ... Lista COMPLETA da v18.1 ... */ { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' }, { name: 'hasOwnProperty', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => { try{({}).hasOwnProperty('a'); return null;} catch(e){ return `Object.hasOwnProperty quebrou! ${e.message}`;} }, testUsage: () => ({a:1}).hasOwnProperty('a') }, { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'outerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'textContent', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div') }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'onload', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onload === v ? 'PP afetou handler `onload`!' : null, createTarget: () => document.createElement('img') }, { name: 'appendChild', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.appendChild(document.createElement('span')); return null; } catch(e){ return `Node.appendChild quebrou! ${e.message}`;} }, testUsage: () => document.createElement('div').appendChild(document.createElement('span')) }, { name: 'addEventListener', proto: EventTarget.prototype, protoName: 'EventTarget', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.addEventListener('test', ()=>{}); return null; } catch(e){ return `EventTarget.addEventListener quebrou! ${e.message}`;} }, testUsage: () => document.createElement('div').addEventListener('test', ()=>{}) }, { name: 'value', proto: HTMLInputElement.prototype, protoName: 'HTMLInputElement', createTarget: () => document.createElement('input'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou input.value!' : null }, { name: 'value', proto: HTMLTextAreaElement.prototype, protoName: 'HTMLTextAreaElement', createTarget: () => document.createElement('textarea'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou textarea.value!' : null }, { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, testUsage: () => [1,2].map(x => x+1), createTarget: () => [] }, { name: 'filter', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].filter(()=>{}); return null;} catch(e){ return `Array.filter quebrou! ${e.message}`;} }, testUsage: () => [1,2].filter(x => x > 1), createTarget: () => [] }, { name: 'forEach', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].forEach(()=>{}); return null;} catch(e){ return `Array.forEach quebrou! ${e.message}`;} }, testUsage: () => [1,2].forEach(x => console.log(x)), createTarget: () => [] }, { name: 'join', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[1,2].join(); return null;} catch(e){ return `Array.join quebrou! ${e.message}`;} }, testUsage: () => [1,2].join(','), createTarget: () => [] }, { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, testUsage: () => function f(){return 1;}.call(null), createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, testUsage: () => function f(x){return x;}.apply(null, [1]), createTarget: () => function(){} }, ];
            const testValue = "PP_Adv_Polluted_" + Date.now(); let successCount = 0; let gadgetCount = 0; let gadgetMessages = [];

            for (const item of propsToPollute) { // Loop v18.1
                if (!item.proto) { continue; }
                const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName;
                let inherited = false; let gadgetMsg = null; let errorMsg = null;
                let originalValue = undefined; let wasDefined = false;
                try { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } catch (e) { continue; } // Pular se erro no check inicial

                try {
                    targetProto[prop] = testValue; // Poluir
                    let obj;
                    if (item.createTarget) { try { obj = item.createTarget(); } catch (e) { obj = {}; } } else { obj = {}; }
                    let inheritedValue = undefined;
                    try { inheritedValue = obj[prop]; } catch (e) {} // Tentar ler valor

                    if (inheritedValue === testValue) {
                        logCanvas(`-> VULN: Herança PP para '${targetProtoName}.${prop}' OK.`, 'vuln', FNAME);
                        inherited = true; successCount++;
                        if (item.gadgetCheck) {
                            try { gadgetMsg = item.gadgetCheck(obj, testValue); } catch(e){} // Tentar checar gadget
                            if (gadgetMsg) {
                                logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME);
                                gadgetMessages.push(prop + ": " + gadgetMsg); gadgetCount++;
                                if (['innerHTML','outerHTML','src','href','onclick','onerror','onload','value','postMessage','send','call','apply','map','filter','forEach','appendChild','addEventListener','hasOwnProperty','join'].includes(prop)) {
                                    logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para '${prop}'! ***`, 'escalation', FNAME);

                                     // *** v21: Tenta usar o gadget para confirmar o impacto ***
                                     if (item.testUsage) {
                                         logCanvas(`  [PP Gadget Usage] Tentando usar '${prop}' poluído...`, 'test', FNAME);
                                         try {
                                             const usageResult = item.testUsage();
                                             logCanvas(`  [PP Gadget Usage] Uso de '${prop}' NÃO lançou erro. Resultado (se houver): ${usageResult}`, 'warn', FNAME); // Aviso se não quebrar
                                         } catch (usageError) {
                                             logCanvas(`  [PP Gadget Usage] Uso de '${prop}' lançou erro (Esperado!): ${usageError.message.substring(0,150)}`, 'error', FNAME); // Erro esperado
                                         }
                                     }
                                }
                            }
                        }
                    } else { if (prop === '__proto__') { logCanvas(`-> FAIL: Herança de '__proto__' não OK (Esperado).`, 'good', FNAME); } }
                } catch (e) { logCanvas(`Erro ao poluir/testar '${targetProtoName}.${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; }
                finally { // Limpeza (código v18.1)
                    try { let cleanupOK = true; if (wasDefined) { targetProto[prop] = originalValue; try { if (targetProto[prop] !== originalValue) cleanupOK = false; } catch(e){ cleanupOK = false; } } else { delete targetProto[prop]; if (Object.prototype.hasOwnProperty.call(targetProto, prop)) cleanupOK = false; } if (!cleanupOK) { logCanvas(`---> CRITICAL: FALHA ao limpar/restaurar ${targetProtoName}.${prop}! Estado pode estar inconsistente. <---`, 'critical', FNAME); } } catch (e) { logCanvas(`AVISO CRÍTICO: Erro INESPERADO ao limpar/restaurar ${targetProtoName}.${prop}: ${e.message}`, 'critical', FNAME); }
                }
                await PAUSE(15); // Pausa curta
            }

            // Teste input.value (inalterado da v18.1)
            // ...(código omitido)...

            logCanvas(`--- Teste PP Avançado Concluído (${successCount} OK, ${gadgetCount} gadgets encontrados) ---`, 'test', FNAME);
            if (gadgetCount > 0) { logCanvas(`Gadgets detectados: ${gadgetMessages.join('; ')}`, 'critical', FNAME); }
            await PAUSE();
        };

        // *** v21: Substitui testOOBReadEnhanced pelo "Máximo" da v19 ***
        const testOOBReadEnhanced = async () => { /* ...código v19... */ };

        // testOOBWriteMetadata (da v18.1)
        const testOOBWriteMetadata = async () => { /* ...código v18.1... */ };
        // testWebGLDeeperPlus (da v18.1)
        const testWebGLDeeperPlus = async () => { /* ...código v18.1... */ };
        // testOOBWriteToImageDataCheck (da v18.1)
        const testOOBWriteToImageDataCheck = async () => { /* ...código v18.1... */ };
        // testOOBWriteOnly (da v18.1)
        const testOOBWriteOnly = async () => { /* ...código v18.1... */ };
        // testFileSystemAccess (da v18.1)
        const testFileSystemAccess = async () => { /* ...código v18.1... */ };
        // testWebGPUCheck (da v18.1)
        const testWebGPUCheck = async () => { /* ...código v18.1... */ };

        // *** v21: ADICIONA Tentativa de Crash OOB Write (da v19) ***
        const testOOBWriteCrashAttempt = async () => { /* ...código v19... */ };


        // --- Função Principal Canvas (v21 - Sequência Atualizada) ---
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn'); const summaryDivS2 = document.getElementById('summary-s2');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv || !summaryDivS2) { /* ... erro fatal ... */ }
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            findingsS2 = []; outputDivCanvas.innerHTML = ''; summaryDivS2.innerHTML = '';
            logCanvas("Iniciando sequência focada do Script 2 (v21)...", "test", FNAME);

            // Define quadrados interativos (mantendo os da v18.1 - ação do sq2 aponta para OOB Read Max)
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP }, { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced }, // Aponta para a versão Max agora
                             { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq4', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq5', text: 'GPU', color: '#337BFF', action: testWebGPUCheck }, ];
            squareDefs.forEach(def => { /* ...código v18.1 para adicionar quadrados ... */ });

            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                 redrawAll(); await PAUSE();
                 try { logCanvas('User Agent: ' + navigator.userAgent, 'test', 'Environment'); } catch (e) { /* ... erro UA ... */ } await PAUSE();
                 try { /* ... Leitura do Leak S1 ... */ } catch (e) { /* ... erro leak ... */ }
                 redrawAll(); await PAUSE();

                // --- Sequência Principal v21 ---
                await testWebGLCheck();               await PAUSE(SHORT_PAUSE_CANVAS);
                await testAdvancedPP();               // v21 com teste de uso de gadget
                await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced();          // v21 Max OOB Read
                await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteMetadata();         await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testFileSystemAccess();         await PAUSE(SHORT_PAUSE_CANVAS);
                await testWebGPUCheck();              await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteCrashAttempt();     // v21 Crash Attempt
                await PAUSE(SHORT_PAUSE_CANVAS);

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME); await PAUSE(100);

                // Adicionar Listeners Interativos (código v18.1 - ação imgSq4 ainda é FileSystem)
                // *** NOTA: Para testar Crash via clique, teria que mudar a ação do imgSq4 aqui também ***
                logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'info', FNAME);
                // ...(código listeners v18.1)...

            } catch(e) { /* ... erro geral ... */ }
             finally {
                 logCanvas("\n==== GERANDO SUMÁRIO Script 2 ====", 'test', FNAME);
                 if (summaryDivS2) { /* ...código geração sumário v18.1... */ }
                 logCanvas("--- Fim da execução Script 2 (v21) ---", 'test', FNAME);
                 if (runBtnCanvas) runBtnCanvas.disabled = false;
             }
        };

        // Funções wrapper e unload (código v18.1)
        const runCanvasTest = async () => { await runCanvasTestSequence(); }; window.addEventListener('unload', () => { /* ...código v18.1... */ });
    </script>

</body>
</html>
