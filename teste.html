<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PoC - PS4 Extreme Browser Stress Tests</title>
    <style>
        body { font-family: monospace; background: black; color: lime; padding: 20px; }
        #log { white-space: pre-wrap; }
    </style>
</head>
<body>
<h1>PoC - PS4 Extreme Browser Stress Tests</h1>
<div id="log"></div>

<script>
function log(msg) {
    document.getElementById('log').textContent += msg + "\n";
}

// Organização dos testes
const tests = {
    async testOversizedArrayBuffer() {
        let hugeBuffer = new ArrayBuffer(0xFFFFFFFF);
        log("[+] Huge ArrayBuffer created: " + hugeBuffer.byteLength);
    },

    async testPrototypeCorruption() {
        Function.prototype.toString = () => "hacked!";
        (function() {})();
        log("[+] Function.prototype.toString overwritten.");
    },

    async testProxyAbuse() {
        let evilProxy = new Proxy({}, {
            get(target, prop) {
                log("[*] Proxy trap for: " + String(prop));
                return Reflect.get(target, prop);
            }
        });
        let test = evilProxy.someProperty;
        log("[+] Proxy test passed.");
    },

    async testFakeTypedArray() {
        let fakeArray = { buffer: {}, byteOffset: 0, byteLength: 0x1000, length: 0x400 };
        log("[+] Fake TypedArray created.");
    },

    async testMassiveStringConcatenation() {
        let s = "X";
        for (let i = 0; i < 24; i++) {
            s += s;
        }
        log("[+] Massive string length: " + s.length);
    },

    async testTypedArrayResizing() {
        let arr = new Uint8Array(2);
        for (let i = 0; i < 20000; i++) {
            arr = new Uint8Array(arr.buffer, 0, arr.length + 1);
        }
        log("[+] TypedArray resized: " + arr.length);
    },

    async testDefinePropertyAbuse() {
        let obj = {};
        for (let i = 0; i < 20000; i++) {
            Object.defineProperty(obj, 'prop' + i, {
                get: function() { return 1337; },
                set: function(v) { }
            });
        }
        log("[+] Massive getters created.");
    },

    async testMassivePromiseAll() {
        let promises = [];
        for (let i = 0; i < 20000; i++) {
            promises.push(Promise.resolve(i));
        }
        await Promise.all(promises);
        log("[+] Massive Promise.all completed.");
    },

    async testStringInternalOverlap() {
        let s1 = "Y".repeat(1024 * 1024);
        let s2 = s1.slice(0, s1.length - 1);
        let overlapped = s1 + s2;
        log("[+] Overlapped string length: " + overlapped.length);
    },

    async testArraySpliceAbuse() {
        let arr = [1,2,3];
        for (let i = 0; i < 20000; i++) {
            arr.splice(-1, 0, i);
        }
        log("[+] Array.splice abuse completed. Length: " + arr.length);
    },

    async testPrimitiveMemoryAccess() {
        let ab = new ArrayBuffer(8);
        let f64 = new Float64Array(ab);
        let u32 = new Uint32Array(ab);

        f64[0] = 1.23456789e+30;
        log("[*] Float64: " + f64[0]);
        log("[*] Uint32 low/high: " + u32[0] + " / " + u32[1]);

        u32[0] = 0x41414141;
        u32[1] = 0x42424242;
        log("[+] Modified Float64 after raw write: " + f64[0]);
    },

    // NOVOS TESTES EXTRAS:
    async testMassiveMapAbuse() {
        let map = new Map();
        for (let i = 0; i < 100000; i++) {
            map.set("key" + i, i);
        }
        log("[+] Massive Map created. Size: " + map.size);
    },

    async testWebWorkerBomb() {
        if (typeof Worker !== 'undefined') {
            log("[*] WebWorkers supported, launching bomb...");
            for (let i = 0; i < 50; i++) {
                let blob = new Blob(["onmessage=function(e){while(true){}}"], { type: 'application/javascript' });
                let url = URL.createObjectURL(blob);
                new Worker(url);
            }
            log("[+] Spawned 50 WebWorkers.");
        } else {
            log("[!] WebWorkers not supported.");
        }
    },

    async testCanvasDrawOverload() {
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        for (let i = 0; i < 10000; i++) {
            ctx.fillRect(Math.random() * 500, Math.random() * 500, 100, 100);
        }
        log("[+] Canvas overload drawing done.");
    },

    async testSymbolRegistryOverflow() {
        for (let i = 0; i < 50000; i++) {
            Symbol.for("sym" + i);
        }
        log("[+] Massive Symbol registry entries created.");
    }
};

// Executor principal
(async function startExtremeTests(){
    try {
        log("[+] Starting PS4 Extreme Browser Stress Tests...\n");

        let count = 1;
        for (let testName in tests) {
            log(`\n=== Running Test #${count}: ${testName} ===`);
            try {
                await tests[testName]();
                log(`[OK] Test #${count} finished successfully.`);
            } catch (err) {
                log(`[FAIL] Test #${count} error: ${err}`);
            }
            count++;
        }

        log("\n[+] All tests completed!");
    } catch (fatal) {
        log("[FATAL] Uncaught exception: " + fatal);
    }
})();
</script>

</body>
</html>
