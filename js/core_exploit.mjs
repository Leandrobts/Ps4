// js/core_exploit.mjs
import { AdvancedInt64 } from './int64.mjs';
import { log, toHexS1, PAUSE_LAB } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

export function getOOBAllocationSize() { updateOOBConfigFromUI(); return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { updateOOBConfigFromUI(); return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { updateOOBConfigFromUI(); return OOB_CONFIG.INITIAL_BUFFER_SIZE; }
// export function getJSCOffsets() { return JSC_OFFSETS; } // Já exportado por config.mjs

export async function triggerOOB_primitive() {
    const FNAME = 'CoreExploit.triggerOOB_primitive';
    updateOOBConfigFromUI();
    log(`--- Iniciando ${FNAME} ---`, 'test', FNAME);
    log(`   Config OOB: AllocSize=${OOB_CONFIG.ALLOCATION_SIZE}, BaseOffsetDV=${OOB_CONFIG.BASE_OFFSET_IN_DV}, InitialBufSize=${OOB_CONFIG.INITIAL_BUFFER_SIZE}`, 'info', FNAME);

    oob_array_buffer_real = null; oob_dataview_real = null;
    try {
        // Esta é a parte que "constrói" a capacidade OOB para o laboratório.
        // Em um exploit real, esta seção seria substituída pelo código que explora
        // a vulnerabilidade específica para obter uma capacidade similar de R/W OOB.
        const totalSizeNeeded = OOB_CONFIG.BASE_OFFSET_IN_DV + OOB_CONFIG.ALLOCATION_SIZE + 64; // +64 para margem
        oob_array_buffer_real = new ArrayBuffer(totalSizeNeeded);
        // A "janela" oob_dataview_real é menor que o oob_array_buffer_real,
        // e as funções oob_read/write_relative são escritas para acessar
        // dados dentro do oob_array_buffer_real, mesmo que fora da janela nominal do oob_dataview_real.
        oob_dataview_real = new DataView(oob_array_buffer_real, OOB_CONFIG.BASE_OFFSET_IN_DV, OOB_CONFIG.ALLOCATION_SIZE);

        // Log ajustado:
        log(`Ambiente para Operações OOB CONFIGURADO.`, 'vuln', FNAME); // Alterado de "ATIVADA (simulada)"
        log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME);
        log(`   oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME);
        log(`   --> Leituras/escritas OOB relativas usarão offsets que podem exceder a 'janela controlada', acessando o 'oob_array_buffer_real' maior.`, 'info', FNAME);

    } catch (e) {
        log(`ERRO ao tentar configurar ambiente OOB: ${e.message}`, "error", FNAME);
        console.error(e);
        oob_array_buffer_real = null;
        oob_dataview_real = null;
    }
    log(`--- ${FNAME} Concluído ---`, 'test', FNAME);
}

// As funções oob_read_relative e oob_write_relative permanecem as mesmas.
// Elas são as ferramentas que USAM a capacidade OOB, seja ela "simulada" ou "real".
export function oob_read_relative(relative_offset, byteLength = 4) {
    if (!oob_dataview_real || !oob_array_buffer_real) {
        log("ERRO: Ambiente OOB não ativo para leitura.", "error", "CoreExploit.Read");
        throw new Error("OOB Read: Ambiente não ativo.");
    }
    updateOOBConfigFromUI(); // Garante que OOB_CONFIG está atualizado

    // Offset relativo ao início da "janela útil" do DataView,
    // mas o acesso será no oob_array_buffer_real maior.
    const dv_offset_from_logical_start_of_oob_window = relative_offset - OOB_CONFIG.INITIAL_BUFFER_SIZE;
    const absoluteReadOffsetInRealBuffer = OOB_CONFIG.BASE_OFFSET_IN_DV + dv_offset_from_logical_start_of_oob_window;

    if (absoluteReadOffsetInRealBuffer < 0 || absoluteReadOffsetInRealBuffer + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Leitura OOB: Offset absoluto ${absoluteReadOffsetInRealBuffer} (relativo ${relative_offset}) está FORA dos limites do oob_array_buffer_real total (${oob_array_buffer_real.byteLength} bytes).`, "error", "CoreExploit.Read");
        throw new RangeError("OOB Read: Tentativa de leitura fora dos limites do buffer real.");
    }

    // Log informativo sobre o acesso OOB em relação à janela nominal do oob_dataview_real
    if (dv_offset_from_logical_start_of_oob_window < 0 || dv_offset_from_logical_start_of_oob_window + byteLength > oob_dataview_real.byteLength) {
         log(`AVISO Leitura OOB: Offset ${dv_offset_from_logical_start_of_oob_window} (rel ${relative_offset}) está fora da JANELA NOMINAL do oob_dataview_real (${oob_dataview_real.byteLength}b). Este é um acesso OOB em relação à janela.`, "vuln", "CoreExploit.Read");
    }

    const tempView = new DataView(oob_array_buffer_real); // Sempre use o buffer real maior
    try {
        if (byteLength === 1) return tempView.getUint8(absoluteReadOffsetInRealBuffer);
        if (byteLength === 2) return tempView.getUint16(absoluteReadOffsetInRealBuffer, true);
        if (byteLength === 4) return tempView.getUint32(absoluteReadOffsetInRealBuffer, true);
        if (byteLength === 8) {
            const low = tempView.getUint32(absoluteReadOffsetInRealBuffer, true);
            const high = tempView.getUint32(absoluteReadOffsetInRealBuffer + 4, true);
            return new AdvancedInt64(low, high);
        }
        throw new Error("Tamanho de leitura OOB inválido: " + byteLength);
    } catch (e) {
        log(`Exceção durante oob_read_relative em offset abs ${absoluteReadOffsetInRealBuffer} (rel ${relative_offset}): ${e.message}`, "error", "CoreExploit.Read");
        throw e;
    }
}

export function oob_write_relative(relative_offset, value, byteLength = 4) {
    if (!oob_dataview_real || !oob_array_buffer_real) {
        log("ERRO: Ambiente OOB não ativo para escrita.", "error", "CoreExploit.Write");
        throw new Error("OOB Write: Ambiente não ativo.");
    }
    updateOOBConfigFromUI();

    const dv_offset_from_logical_start_of_oob_window = relative_offset - OOB_CONFIG.INITIAL_BUFFER_SIZE;
    const absoluteWriteOffsetInRealBuffer = OOB_CONFIG.BASE_OFFSET_IN_DV + dv_offset_from_logical_start_of_oob_window;

    if (absoluteWriteOffsetInRealBuffer < 0 || absoluteWriteOffsetInRealBuffer + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Escrita OOB: Offset absoluto ${absoluteWriteOffsetInRealBuffer} (relativo ${relative_offset}) está FORA dos limites do oob_array_buffer_real total (${oob_array_buffer_real.byteLength} bytes).`, "error", "CoreExploit.Write");
        throw new RangeError("OOB Write: Tentativa de escrita fora dos limites do buffer real.");
    }

    if (dv_offset_from_logical_start_of_oob_window < 0 || dv_offset_from_logical_start_of_oob_window + byteLength > oob_dataview_real.byteLength) {
        log(`AVISO Escrita OOB: Offset ${dv_offset_from_logical_start_of_oob_window} (rel ${relative_offset}) está fora da JANELA NOMINAL do oob_dataview_real (${oob_dataview_real.byteLength}b). Este é um acesso OOB em relação à janela.`, "vuln", "CoreExploit.Write");
    }
    
    const tempView = new DataView(oob_array_buffer_real);
    try {
        if (byteLength === 1) { tempView.setUint8(absoluteWriteOffsetInRealBuffer, Number(value)); return; }
        if (byteLength === 2) { tempView.setUint16(absoluteWriteOffsetInRealBuffer, Number(value), true); return; }
        if (byteLength === 4) { tempView.setUint32(absoluteWriteOffsetInRealBuffer, Number(value), true); return; }
        if (byteLength === 8 && value instanceof AdvancedInt64) {
            tempView.setUint32(absoluteWriteOffsetInRealBuffer, value.low(), true);
            tempView.setUint32(absoluteWriteOffsetInRealBuffer + 4, value.high(), true);
            return;
        }
        // Se for 8 bytes e um número simples, trata como a parte baixa de um Int64
        if (byteLength === 8 && typeof value === 'number') {
             const int64Val = AdvancedInt64.fromNumber(value);
             tempView.setUint32(absoluteWriteOffsetInRealBuffer, int64Val.low(), true);
             tempView.setUint32(absoluteWriteOffsetInRealBuffer + 4, int64Val.high(), true);
             return;
        }
        throw new Error("Tamanho/valor de escrita OOB inválido: " + byteLength + ", valor: " + value);
    } catch (e) {
        log(`Exceção durante oob_write_relative em offset abs ${absoluteWriteOffsetInRealBuffer} (rel ${relative_offset}): ${e.message}`, "error", "CoreExploit.Write");
        throw e;
    }
}

// A função testModule pode permanecer, ela testa a funcionalidade de oob_read/write_relative
export async function testModule(logFnParam) {
    const FNAME_TEST = "CoreExploit.testModule";
    const currentLog = logFnParam || log; // Usa o log da UI se passado, senão o log interno do módulo.
    
    currentLog(`--- Testando Módulo CoreExploit (core_exploit.mjs) ---`, "test", FNAME_TEST);
    await triggerOOB_primitive(); 
    if (!oob_dataview_real) {
        currentLog("Falha ao configurar ambiente OOB. Teste abortado.", "error", FNAME_TEST);
        return;
    }
    
    // O offset relativo aqui é a partir do início da "janela OOB lógica"
    // que é OOB_CONFIG.INITIAL_BUFFER_SIZE bytes após o início do oob_dataview_real
    // (se BASE_OFFSET_IN_DV fosse 0).
    // Ou, mais simples, é o offset que será usado por oob_read_relative/oob_write_relative.
    // Um offset de `OOB_CONFIG.INITIAL_BUFFER_SIZE` em oob_read_relative acessa
    // BASE_OFFSET_IN_DV no oob_array_buffer_real.
    const test_rel_offset = OOB_CONFIG.INITIAL_BUFFER_SIZE + 0; // Testa escrita/leitura no início da janela OOB lógica
    const test_val32 = 0x12345678;
    const test_val64 = new AdvancedInt64("0xAABBCCDDEEFF0011");

    try {
        currentLog(`Escrevendo ${toHexS1(test_val32)} em offset OOB relativo ${test_rel_offset}`, "info", FNAME_TEST);
        oob_write_relative(test_rel_offset, test_val32, 4);
        const read_val32 = oob_read_relative(test_rel_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexS1(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexS1(read_val32)}, esperado ${toHexS1(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_rel_offset + 4;
        currentLog(`Escrevendo ${test_val64.toString(true)} em offset OOB relativo ${next_offset}`, "info", FNAME_TEST);
        oob_write_relative(next_offset, test_val64, 8);
        const read_val64 = oob_read_relative(next_offset, 8);
        if (read_val64 && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${read_val64 ? read_val64.toString(true) : 'ERRO_LEITURA'}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO durante o teste do módulo CoreExploit: ${e.message}`, "error", FNAME_TEST);
        console.error(e);
    }
    currentLog(`--- Teste CoreExploit Concluído ---`, "test", FNAME_TEST);
}
