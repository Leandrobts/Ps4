// js/core_exploit.mjs
import { AdvancedInt64 } from './int64.mjs';
import { log, toHexS1, PAUSE_LAB } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

export function getOOBAllocationSize() { updateOOBConfigFromUI(); return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { updateOOBConfigFromUI(); return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { updateOOBConfigFromUI(); return OOB_CONFIG.INITIAL_BUFFER_SIZE; }
export function getJSCOffsets() { return JSC_OFFSETS; } // Já exportado por config.mjs, mas ok

// A função que realmente ativa a capacidade OOB
// ASSUME-SE QUE EXISTE UMA VULNERABILIDADE NO MOTOR JS QUE PERMITE ESTA CONFIGURAÇÃO OOB
// Esta função SIMULA a ativação dessa primitiva.
export async function triggerOOB_primitive() {
    const FNAME = 'CoreExploit.triggerOOB_primitive';
    updateOOBConfigFromUI(); // Garante que as configs da UI sejam lidas
    log(`--- Iniciando ${FNAME} ---`, 'test', FNAME);
    log(`   Config OOB: AllocSize=${OOB_CONFIG.ALLOCATION_SIZE}, BaseOffsetDV=${OOB_CONFIG.BASE_OFFSET_IN_DV}, InitialBufSize=${OOB_CONFIG.INITIAL_BUFFER_SIZE}`, 'info', FNAME);

    const writeValueToTriggerOOB = 0xEE; // Valor de exemplo para escrever OOB
    // O offset OOB é relativo ao início LÓGICO do buffer que o DataView cobre,
    // não ao início do oob_array_buffer_real.
    const oobWriteOffsetFromLogicalStart = OOB_CONFIG.INITIAL_BUFFER_SIZE;

    oob_array_buffer_real = null; oob_dataview_real = null; // Reset
    try {
        // O tamanho total precisa acomodar o buffer "antes", a área OOB, e o DataView base.
        // A área OOB em si terá OOB_CONFIG.ALLOCATION_SIZE.
        const totalSizeNeeded = OOB_CONFIG.BASE_OFFSET_IN_DV + oobWriteOffsetFromLogicalStart + OOB_CONFIG.ALLOCATION_SIZE + 64; // +64 de margem
        oob_array_buffer_real = new ArrayBuffer(totalSizeNeeded);
        
        // oob_dataview_real cobre uma "janela" do oob_array_buffer_real.
        // O '0' lógico deste DataView está em OOB_CONFIG.BASE_OFFSET_IN_DV do oob_array_buffer_real.
        // O DataView pode escrever até OOB_CONFIG.ALLOCATION_SIZE bytes A PARTIR de OOB_CONFIG.BASE_OFFSET_IN_DV.
        // Esta é a nossa "janela de escrita OOB" principal.
        oob_dataview_real = new DataView(oob_array_buffer_real, OOB_CONFIG.BASE_OFFSET_IN_DV, OOB_CONFIG.ALLOCATION_SIZE);

        // Simula a escrita que "quebra" os limites ou configura o estado OOB.
        // A escrita OOB real aconteceria devido a uma vulnerabilidade. Aqui simulamos o efeito.
        // Vamos assumir que oob_dataview_real agora pode ler/escrever em offsets
        // relativos a OOB_CONFIG.BASE_OFFSET_IN_DV, mesmo que esses offsets
        // caiam fora da sua "janela" nominal (0 a OOB_CONFIG.ALLOCATION_SIZE -1),
        // mas ainda dentro dos limites do oob_array_buffer_real (ou além, se for full R/W).
        // Para este laboratório, oob_read/write_relative farão os cálculos.

        // Preenche uma parte do buffer para visualização
        const initDV = new DataView(oob_array_buffer_real);
        for(let i=0; i < Math.min(16, OOB_CONFIG.BASE_OFFSET_IN_DV); i++) { initDV.setUint8(i, 0xAA); } // Antes do base offset
        for(let i=0; i < Math.min(16, oob_dataview_real.byteLength); i++) { oob_dataview_real.setUint8(i, 0xDD); } // Início da janela do oob_dataview_real

        log(`Primitiva OOB ATIVADA (simulada).`, 'vuln', FNAME);
        log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME);
        log(`   oob_dataview_real (janela OOB): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME);
        log(`   --> Leituras/escritas OOB relativas usarão offsets a partir de oob_dataview_real mais o BASE_OFFSET_IN_DV.`, 'info', FNAME);

    } catch (e) {
        log(`ERRO ao tentar ativar primitiva OOB: ${e.message}`, "error", FNAME);
        console.error(e);
        oob_array_buffer_real = null;
        oob_dataview_real = null;
    }
    log(`--- ${FNAME} Concluído ---`, 'test', FNAME);
}


// Lê `byteLength` bytes do oob_array_buffer_real.
// `relative_offset` é a partir do INÍCIO LÓGICO do buffer OOB "antes" (OOB_CONFIG.INITIAL_BUFFER_SIZE),
// mas o acesso é feito através do oob_dataview_real que já tem um base offset.
export function oob_read_relative(relative_offset, byteLength = 4) {
    if (!oob_dataview_real || !oob_array_buffer_real) {
        log("ERRO: Primitiva OOB não ativa para leitura.", "error", "CoreExploit.Read");
        throw new Error("OOB Read: Primitiva não ativa.");
    }
    // O offset REAL dentro do oob_dataview_real para acessar a posição `relative_offset`
    // A "base" do nosso oob_dataview_real (seu offset 0) corresponde ao
    // OOB_CONFIG.BASE_OFFSET_IN_DV do oob_array_buffer_real.
    // `relative_offset` é dado como se o "buffer útil" começasse após `INITIAL_BUFFER_SIZE`
    // e esse "buffer útil" está dentro da janela do oob_dataview_real.
    // O offset para DataView é: relative_offset - OOB_CONFIG.INITIAL_BUFFER_SIZE
    // Este cálculo é chave e depende de como o exploit OOB original funciona.
    // Assumimos que OOB_CONFIG.BASE_OFFSET_IN_DV é onde nosso DataView começa,
    // e OOB_CONFIG.INITIAL_BUFFER_SIZE é um "pre-buffer" lógico dentro dessa visão.
    const dv_offset = relative_offset - OOB_CONFIG.INITIAL_BUFFER_SIZE;

    if (dv_offset < -OOB_CONFIG.BASE_OFFSET_IN_DV || dv_offset + byteLength > oob_array_buffer_real.byteLength - OOB_CONFIG.BASE_OFFSET_IN_DV) {
        log(`AVISO Leitura OOB: Offset ${dv_offset} (rel ${relative_offset}) pode estar fora dos limites do oob_array_buffer_real total.`, "warn", "CoreExploit.Read");
    }
    if (dv_offset < 0 || dv_offset + byteLength > oob_dataview_real.byteLength) {
         log(`AVISO Leitura OOB: Offset ${dv_offset} (rel ${relative_offset}) está fora da JANELA INICIAL do oob_dataview_real (${oob_dataview_real.byteLength}b). Isso É OOB.`, "vuln", "CoreExploit.Read");
    }


    // Usamos um DataView temporário sobre o buffer REAL para permitir leituras em qualquer offset
    // A primitiva oob_dataview_real original nos deu a capacidade de acessar oob_array_buffer_real
    const tempView = new DataView(oob_array_buffer_real);
    const absoluteReadOffset = OOB_CONFIG.BASE_OFFSET_IN_DV + dv_offset;


    if (absoluteReadOffset < 0 || absoluteReadOffset + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Leitura OOB: Offset absoluto ${absoluteReadOffset} (rel ${relative_offset}) está FORA dos limites do oob_array_buffer_real.`, "error", "CoreExploit.Read");
        throw new RangeError("OOB Read: Tentativa de leitura fora dos limites do buffer real.");
    }

    try {
        if (byteLength === 1) return tempView.getUint8(absoluteReadOffset);
        if (byteLength === 2) return tempView.getUint16(absoluteReadOffset, true); // Little Endian
        if (byteLength === 4) return tempView.getUint32(absoluteReadOffset, true); // Little Endian
        if (byteLength === 8) { // Retorna como objeto AdvancedInt64
            const low = tempView.getUint32(absoluteReadOffset, true);
            const high = tempView.getUint32(absoluteReadOffset + 4, true);
            return new AdvancedInt64(low, high);
        }
        throw new Error("Tamanho de leitura OOB inválido: " + byteLength);
    } catch (e) {
        log(`Exceção durante oob_read_relative em offset abs ${absoluteReadOffset} (rel ${relative_offset}): ${e.message}`, "error", "CoreExploit.Read");
        throw e;
    }
}

export function oob_write_relative(relative_offset, value, byteLength = 4) {
    if (!oob_dataview_real || !oob_array_buffer_real) {
        log("ERRO: Primitiva OOB não ativa para escrita.", "error", "CoreExploit.Write");
        throw new Error("OOB Write: Primitiva não ativa.");
    }
    const dv_offset = relative_offset - OOB_CONFIG.INITIAL_BUFFER_SIZE;

    if (dv_offset < -OOB_CONFIG.BASE_OFFSET_IN_DV || dv_offset + byteLength > oob_array_buffer_real.byteLength - OOB_CONFIG.BASE_OFFSET_IN_DV) {
        log(`AVISO Escrita OOB: Offset ${dv_offset} (rel ${relative_offset}) pode estar fora dos limites do oob_array_buffer_real total.`, "warn", "CoreExploit.Write");
    }
    if (dv_offset < 0 || dv_offset + byteLength > oob_dataview_real.byteLength) {
        log(`AVISO Escrita OOB: Offset ${dv_offset} (rel ${relative_offset}) está fora da JANELA INICIAL do oob_dataview_real (${oob_dataview_real.byteLength}b). Isso É OOB.`, "vuln", "CoreExploit.Write");
    }

    const tempView = new DataView(oob_array_buffer_real);
    const absoluteWriteOffset = OOB_CONFIG.BASE_OFFSET_IN_DV + dv_offset;

    if (absoluteWriteOffset < 0 || absoluteWriteOffset + byteLength > oob_array_buffer_real.byteLength) {
        log(`ERRO Escrita OOB: Offset absoluto ${absoluteWriteOffset} (rel ${relative_offset}) está FORA dos limites do oob_array_buffer_real.`, "error", "CoreExploit.Write");
        throw new RangeError("OOB Write: Tentativa de escrita fora dos limites do buffer real.");
    }
    
    try {
        if (byteLength === 1) return tempView.setUint8(absoluteWriteOffset, value);
        if (byteLength === 2) return tempView.setUint16(absoluteWriteOffset, value, true); // Little Endian
        if (byteLength === 4) return tempView.setUint32(absoluteWriteOffset, value, true); // Little Endian
        if (byteLength === 8 && value instanceof AdvancedInt64) {
            tempView.setUint32(absoluteWriteOffset, value.low(), true);
            tempView.setUint32(absoluteWriteOffset + 4, value.high(), true);
            return;
        }
        if (byteLength === 8 && typeof value === 'number') { // Se passar um número para escrita 64bit, assume que é o low part
             tempView.setUint32(absoluteWriteOffset, value, true);
             tempView.setUint32(absoluteWriteOffset + 4, (value < 0 ? 0xFFFFFFFF : 0), true); // Sinal estendido
             return;
        }
        throw new Error("Tamanho/valor de escrita OOB inválido: " + byteLength);
    } catch (e) {
        log(`Exceção durante oob_write_relative em offset abs ${absoluteWriteOffset} (rel ${relative_offset}): ${e.message}`, "error", "CoreExploit.Write");
        throw e;
    }
}


export function testModule(logFnParam) {
    const FNAME_TEST = "CoreExploit.testModule";
    const oldLog = log; // Salva o log original do módulo, se houver
    log = logFnParam || log; // Usa o log passado ou o do módulo
    
    log(`--- Testando Módulo CoreExploit (core_exploit.mjs) ---`, "test", FNAME_TEST);
    triggerOOB_primitive(); // Ativa a primitiva OOB com as configurações da UI
    if (!oob_dataview_real) {
        log("Falha ao ativar primitiva OOB. Teste abortado.", "error", FNAME_TEST);
        log = oldLog; // Restaura o log
        return;
    }
    // O offset relativo aqui é a partir do "início lógico" do buffer que queremos corromper.
    // Se INITIAL_BUFFER_SIZE é 32, um offset de 32 significa o primeiro byte FORA desse buffer inicial.
    const test_rel_offset = OOB_CONFIG.INITIAL_BUFFER_SIZE + 0; // Testar escrita logo após o buffer "antes"
    const test_val32 = 0x12345678;
    const test_val64 = new AdvancedInt64("0xAABBCCDDEEFF0011");

    try {
        log(`Escrevendo ${toHexS1(test_val32)} em offset relativo ${test_rel_offset}`, "info", FNAME_TEST);
        oob_write_relative(test_rel_offset, test_val32, 4);
        const read_val32 = oob_read_relative(test_rel_offset, 4);
        if (read_val32 === test_val32) {
            log(`SUCESSO: Lido ${toHexS1(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            log(`FALHA: Lido ${toHexS1(read_val32)}, esperado ${toHexS1(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_rel_offset + 4;
        log(`Escrevendo ${test_val64.toString(true)} em offset relativo ${next_offset}`, "info", FNAME_TEST);
        oob_write_relative(next_offset, test_val64, 8);
        const read_val64 = oob_read_relative(next_offset, 8);
        if (read_val64 && read_val64.low() === test_val64.low() && read_val64.high() === test_val64.high()) {
            log(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            log(`FALHA: Lido ${read_val64 ? read_val64.toString(true) : 'ERRO_LEITURA'}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
        }
    } catch (e) {
        log(`ERRO durante o teste do módulo CoreExploit: ${e.message}`, "error", FNAME_TEST);
    }
    log(`--- Teste CoreExploit Concluído ---`, "test", FNAME_TEST);
    log = oldLog; // Restaura o log original
}
