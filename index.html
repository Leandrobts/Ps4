<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v15.7 - Corrigindo Execução Fase 1</title>
    <style>/* ... Estilos ... */</style>
</head>
<body>
    <h1>PoC v15.7 - Corrigindo Execução Fase 1</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
    <p>Fase 1: PoC Original (Debug). Fase 2: Aprofundamento.</p>
    <button id="runBtn" onclick="runEverythingSequentially()">Iniciar Teste Completo (Debug Fase 1)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        // ... (globals: outputDiv, runBtn, fingerprintCanvas, coordStatusDiv, pauses, OOB var, listeners, xss flag, finalResults) ...
        let rectArea = { x: 10, y: 10, w: 30, h: 30 }; // Global
        let linkArea = { x: 150, y: 100, w: 60, h: 30 }; // Global
        // ... (Resto dos globals) ...
        const log = (message, type = 'info') => { /* ... (implementação anterior) ... */ };
        const toHex = (val, bits = 32) => { /* ... (implementação anterior) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (heurística) ... */ };
        const isPotentialData32 = (val) => { /* ... (heurística) ... */ };
        const logFinalSummary = () => { /* ... (implementação anterior - pode imprecisa) ... */ };


        // ==================================================
        // --- FASE 1: Testes Originais (Com Debug Interno) ---
        // ==================================================
        log("Definindo Testes da Fase 1 (Originais)", "info");

        // Teste Original 1: XSS (SEM ALERT)
        const originalTestCSPBypass = async () => {
            log("--- [Fase 1] T1: XSS Iniciando (Sem Alert) ---", 'test');
            xssRanFlag = false;
            try { // Data URI Payload
                const payloadJS = `try { log("[Payload Data/F1:] Executado!", "vuln"); window.xssRanFlag = true; } catch(e) { log("[Payload Data/F1:] Bloqueado: " + e.message, "good"); }`;
                /* ... (criação e adição do script tag) ... */
            } catch (e) { log(`[F1] Erro data URI: ${e.message}`, 'error'); }
            await new Promise(r=>setTimeout(r,SHORT_PAUSE*2));
            try { // Onerror Payload
                const imgTag = document.createElement('img'); imgTag.src = 'invalid_' + Date.now();
                const onerrorPayload = `
                    try {
                        log("[F1] Payload onerror iniciado!", "info");
                        const target = document.getElementById('xss-target-div');
                        if (target) { target.innerHTML = '<h2 class="log-vuln">[F1] XSS DOM ONERROR!</h2>'; }
                        window.xssRanFlag = true; // Define a flag
                        log("[F1] XSS DOM via onerror realizado no log! Flag setada.", "vuln");
                    } catch(e) { log("[F1] Erro payload onerror: " + e.message, "warn"); }`;
                imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); log("[F1] Tag img onerror adicionada.", 'info');
            } catch (e) { log(`[F1] Erro img onerror: ${e.message}`, 'error'); }
            await new Promise(r => setTimeout(r, MEDIUM_PAUSE)); // Pausa para onerror
            finalResults.phase1_xss_flag = xssRanFlag;
            log(`--- [Fase 1] T1: XSS Concluído (Flag=${xssRanFlag}) ---`, 'test');
        };

        // Teste Original 2: OOB (Lógica Original)
        const originalTestOOBReadInfoLeak = async () => {
             log("--- [Fase 1] T2: OOB Iniciando ---", 'test');
             // ... (Código EXATO do Teste 2 da PRIMEIRA mensagem) ...
             // incluindo a lógica original de armazenamento em leakedValueFromOOB
             // e a contagem original de potentialLeakFoundCount
             // ...
             finalResults.phase1_oob_stored = !!leakedValueFromOOB; // Atualiza resumo
             log(`--- [Fase 1] T2: OOB Concluído (...) ---`, 'test');
             // Precisa retornar um valor para o await funcionar corretamente, mesmo que seja true genérico
             // A função original não tinha return explícito, o que pode ser um problema para async/await
             return true;
        };

        // Teste Original 3: PP Básica (Lógica Original + return)
        const originalTestBasicPP = async () => {
            log("--- [Fase 1] T3: PP Básica Iniciando ---", 'test');
            const testProp = '__pp_basic_test_orig__'; const testValue = 'PollutedOrig!'; let success = false;
             try {
                 Object.prototype[testProp] = testValue;
                 const obj = {}; // Cria obj DEPOIS de poluir
                 if (obj[testProp] === testValue) {
                     log(`[Fase 1] VULN: PP Básica confirmada!`, 'vuln'); success = true;
                 } else { log(`[Fase 1] FALHA/BLOQ PP Básica.`,'good'); }
             } catch (e) { log(`[Fase 1] Erro PP Básico: ${e.message}`, 'error'); success = false; } // Garante false em erro
             finally { try { delete Object.prototype[testProp]; log(`[Fase 1] Limpeza PP Básica ok.`,'info');} catch(e){} }
             finalResults.phase1_pp_basic = success;
             log(`--- [Fase 1] T3: PP Básica Concluído (Success=${success}) ---`, 'test');
             return success; // Retorna o status
        };

        // Teste Original 4: PP Hijack (Lógica Original + return)
        const originalTestPPJsonHijack = async () => {
            log("--- [Fase 1] T4: PP Hijack Iniciando ---", 'test');
            const oS = JSON.stringify; let hS = false; let iS = false; let hijackReturnedCorrectly = false;
            try {
                JSON.stringify = function hJSO(v,r,s){ /* ... (lógica original do hijack, lendo leakedValueFromOOB) ... */ return `{"hijacked_phase1":true,"leak_read":${iS}}`; };
                const res = JSON.stringify({x:1});
                if (res?.includes('"hijacked_phase1":true')) {
                     log("[F1] VULN: Retorno hijack ok!",'vuln'); hijackReturnedCorrectly = true;
                 } else { /*...*/ }
            } catch (e) { log(`[F1] Erro PP Hijack: ${e.message}`,'error'); hijackReturnedCorrectly = false; } // Garante false
            finally { /* ... (restauração) ... */ }
            finalResults.phase1_pp_hijack = hijackReturnedCorrectly;
            log(`--- [Fase 1] T4: PP Hijack Concluído (Success=${hijackReturnedCorrectly}) ---`, 'test');
            return hijackReturnedCorrectly; // Retorna o status
        };

        // Função para rodar a Fase 1 COM TRY/CATCH INDIVIDUAL
        const runOriginalTests = async () => {
             log("==== [Fase 1] INICIANDO runOriginalTests (com try/catch interno) ====", 'critical');
             let testName = ""; // Para saber qual teste falhou
             try {
                 testName = "T1: XSS";
                 log(`[Fase 1] Executando ${testName}...`, 'info'); await originalTestCSPBypass();
                 log(`[Fase 1] ${testName} Concluído (aparentemente).`, 'info'); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));

                 testName = "T2: OOB";
                 log(`[Fase 1] Executando ${testName}...`, 'info'); await originalTestOOBReadInfoLeak();
                 log(`[Fase 1] ${testName} Concluído (aparentemente).`, 'info'); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));

                 testName = "T3: PP Básica";
                 log(`[Fase 1] Executando ${testName}...`, 'info'); await originalTestBasicPP();
                 log(`[Fase 1] ${testName} Concluído (aparentemente).`, 'info'); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));

                 testName = "T4: PP Hijack";
                 log(`[Fase 1] Executando ${testName}...`, 'info'); await originalTestPPJsonHijack();
                 log(`[Fase 1] ${testName} Concluído (aparentemente).`, 'info'); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));

                 log("==== [Fase 1] runOriginalTests CONCLUÍDA (sem erro capturado aqui) ====", 'critical');
                 return true; // Indica sucesso geral da fase

             } catch (error) {
                 log(`==== [Fase 1] ERRO DURANTE ${testName} em runOriginalTests: ${error.name} - ${error.message} ====`,'error');
                 log(error.stack || '[Sem Stack Trace]', 'error');
                 return false; // Indica falha na fase
             }
        }

        // ==========================================================
        // --- FASE 2: Testes Adicionais (Definições Mantidas) ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");
        // Testes A, B, C, F, J, K, D/E Combinado (Definições como na v15.5)
        const testBasicDataCollection = async () => { /* ... */ };
        const testEnvironmentProbing = async () => { /* ... */ };
        const testAdvancedFingerprinting = async () => { /* ... */ };
        const testErrorObservation = async () => { /* ... */ };
        const testAdvancedPP = async () => { /* ... */ };
        const testPPGadgetAttempts = async () => { /* ... */ };
        const testComprehensiveCanvas = async () => { /* ... (usa globais rectArea/linkArea, lê xssRanFlag e leakedValueFromOOB) ... */ };

        // Função para rodar a Fase 2
        const runNewTests = async () => { /* ... (código v15.5) ... */ };


        // --- Função Principal ---
        const runEverythingSequentially = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v15.7 (Debug Interno Fase 1) ====", 'critical');
            finalResults = {}; // Reseta

            log(">>> Chamando runOriginalTests <<<", 'warn');
            const phase1Success = await runOriginalTests(); // Roda Fase 1 e captura status
            log(`>>> runOriginalTests finalizado (Status Sucesso: ${phase1Success}) <<<`, phase1Success ? 'good' : 'error');

            if (!phase1Success) {
                 log("AVISO: Fase 1 falhou ou foi interrompida. A Fase 2 pode ter resultados inesperados ou não rodar dependendo do erro.", "warn");
                 // Decide se quer parar ou continuar. Vamos continuar por enquanto.
            }

            log("\n>>> Pausa Entre Fases <<<\n", "warn");
            await new Promise(r => setTimeout(r, MEDIUM_PAUSE));

            log(">>> Chamando runNewTests <<<", 'warn');
            try {
                await runNewTests(); // Roda Fase 2
                log(">>> runNewTests CONCLUÍDO <<<", 'warn');
            } catch (error) {
                 log(`>>> ERRO CAPTURADO DURANTE runNewTests: ${error.name} - ${error.message} <<<`, 'error');
                 log(error.stack || '(sem stack trace)', 'error');
            }

            log("\n==== PoC Final v15.7 CONCLUÍDA ====", 'critical');
            try { logFinalSummary(); } catch(e) { log("Erro ao gerar resumo final", "error"); }
            log("Listeners podem continuar ativos.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza listeners, etc.
        window.addEventListener('unload', () => { /* ... */ });
        // document.addEventListener('DOMContentLoaded', runEverythingSequentially);

    </script>

</body>
</html>
