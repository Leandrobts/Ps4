<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v21 - Base 100% Original + Canvas Isolado Pós-Load</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>PoC v21 - Base 100% Original + Canvas Isolado Pós-Load</h1>
    <canvas id="interactive-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
    <p>Botão inicia testes originais (Fase 1). Teste de Canvas (Fase 2) inicia ~15s após carregar a página.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes Originais (Fase 1)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup (Originais) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak

        // --- Função de Log (Original) ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){ // Limite Original
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex (Original)
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples Ponteiros (Original) ---
        const isPotentialPointer64 = (high, low) => { /* ... (lógica original) ... */ };

         // --- Heurística Simples Dados U32 (Original) ---
         const isPotentialData32 = (val) => { /* ... (lógica original) ... */ };

        // --- Teste 1: CSP Bypass / XSS (Original com alert) ---
        const testCSPBypass = async () => { /* ... (Código EXATO Teste 1 original) ... */ };

        // --- Teste 2: OOB Write/Read Extensivo (Original) ---
        const testOOBReadInfoLeakEnhancedStore = async () => { /* ... (Código EXATO Teste 2 original) ... */ };

        // --- Teste 3: Prototype Pollution (Básica) (Original) ---
        const testBasicPP = async () => { /* ... (Código EXATO Teste 3 original) ... */ };

        // --- Teste 4: PP Hijack (JSON.stringify com Interação) (Original) ---
        const testPPJsonHijack = async () => { /* ... (Código EXATO Teste 4 original) ... */ };

        // --- Função Principal para Rodar Todos os Testes (Original) ---
        const runAllTests = async () => {
            // Código EXATO de runAllTests do script original
            if (runBtn) runBtn.disabled = true;
            log("==== [F1 Orig] INICIANDO PoC Final v9 (runAllTests) ====", 'critical');
            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPJsonHijack(); // Teste 4
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            log("\n==== [F1 Orig] PoC Final v9 CONCLUÍDA (runAllTests) ====", 'critical');
            if (runBtn) runBtn.disabled = false; // Reabilita o botão ao final
        };

        // document.addEventListener('DOMContentLoaded', runAllTests); // Original comentado
    </script>

    <script>
        // Usa as variáveis globais já definidas no HTML se necessário
        // (canvasElement, coordStatusDivCanvas, etc.)
        // Note que 'log' e 'toHex' definidos no script anterior estarão disponíveis globalmente.
        // Se houver conflito de nomes, precisaríamos de namespaces ou redefinição.

        // Setup para Fase 2 - Canvas
        const canvasElementF2 = document.getElementById('interactive-canvas');
        const coordStatusDivF2 = document.getElementById('canvas-coord-status');
        const CANVAS_SHORT_PAUSE = 50; // Pausas específicas do canvas
        let canvasClickListenerF2 = null;
        let canvasMoveListenerF2 = null;
        // Áreas definidas aqui para o teste isolado
        const rectAreaF2 = { x: 10, y: 10, w: 50, h: 50 };
        const linkAreaF2 = { x: 150, y: 100, w: 80, h: 30 };

        // Função de Log específica para Fase 2 (opcional, pode usar a global 'log')
        const logF2 = (message, type = 'info') => {
            log(`[Fase 2 Canvas] ${message}`, type); // Adiciona prefixo
        }

        // Teste Isolado de Canvas
        const runIsolatedCanvasTest = async () => {
            logF2("--- Iniciando Teste Isolado de Canvas ---", 'test');
            let ctx = null;
            try {
                if (!canvasElementF2 || !canvasElementF2.getContext) throw new Error('Elemento Canvas não encontrado/suportado');
                ctx = canvasElementF2.getContext('2d');
                if (!ctx) throw new Error('Contexto 2D não disponível');
                logF2("Contexto 2D obtido.", 'info');
                ctx.clearRect(0, 0, canvasElementF2.width, canvasElementF2.height);
                ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElementF2.width, canvasElementF2.height);
            } catch(e) { logF2(`Falha no setup: ${e.message}`, 'error'); return; }

            // 1. Desenho
            logF2("Desenhando formas...", 'subtest'); await new Promise(r=>setTimeout(r,CANVAS_SHORT_PAUSE));
            try { /* ... (Código de desenho usando rectAreaF2, linkAreaF2) ... */ } catch(e) { /*...*/ }

            // 2. API Checks/Quirks
            logF2("Verificando APIs/Quirks...", 'subtest'); await new Promise(r=>setTimeout(r,CANVAS_SHORT_PAUSE));
            try { /* ... (Código de verificação de filter, toDataURL, etc.) ... */ } catch(e) { /*...*/ }

            // 3. Interatividade
            logF2("Adicionando listeners 'click' e 'mousemove'...", 'subtest'); await new Promise(r=>setTimeout(r,CANVAS_SHORT_PAUSE));
            if(canvasClickListenerF2 && canvasElementF2) { try { canvasElementF2.removeEventListener('click', canvasClickListenerF2); } catch(e){} }
            if(canvasMoveListenerF2 && canvasElementF2) { try { canvasElementF2.removeEventListener('mousemove', canvasMoveListenerF2); } catch(e){} }
            canvasClickListenerF2 = (event) => { /* ... (Lógica do click handler usando rectAreaF2/linkAreaF2 e tentando window.open) ... */ };
            canvasMoveListenerF2 = (event) => { /* ... (Lógica do move handler atualizando coordStatusDivF2) ... */ };
            try { canvasElementF2.addEventListener('click', canvasClickListenerF2); canvasElementF2.addEventListener('mousemove', canvasMoveListenerF2); logF2("Listeners adicionados.", 'good'); }
            catch (e) { logF2(`Erro add listeners: ${e.message}`, 'error'); }

            logF2("--- Teste Isolado de Canvas Concluído ---", 'test');
        };

        // Agendar início da Fase 2 (Canvas) após X segundos do load da página
        const delayFase2 = 15000; // 15 segundos
        log(`[Sistema] Teste de Canvas (Fase 2) agendado para ${delayFase2/1000}s após o load.`, 'warn');
        window.addEventListener('load', () => {
            log(`[Sistema] Página carregada. Iniciando timer de ${delayFase2/1000}s para Fase 2 (Canvas)...`, 'warn');
            setTimeout(() => {
                log("[Sistema] Timer finalizado. Chamando teste de Canvas (Fase 2)...", 'warn');
                if (runBtn && !runBtn.disabled) runBtn.disabled = true; // Desabilita botão se Fase 2 começar
                runIsolatedCanvasTest().finally(() => {
                     if (runBtn && runBtn.disabled) runBtn.disabled = false; // Reabilita ao final da fase 2
                });
            }, delayFase2);
        });

         // Limpeza listeners Fase 2
        window.addEventListener('unload', () => { if(canvasClickListenerF2 && canvasElementF2) canvasElementF2.removeEventListener('click',canvasClickListenerF2); if(canvasMoveListenerF2 && canvasElementF2) canvasElementF2.removeEventListener('mousemove',canvasMoveListenerF2); });

    </script>

</body>
</html>
