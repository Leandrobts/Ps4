<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Teste de Canvas v21.1 (Isolado - Debug)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 40vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-good { color: #4CAF50; } .log-vuln { color: #ff4444; font-weight: bold; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>Teste de Canvas v21.1 (Isolado - Debug)</h1>
    <p>Teste isolado de Canvas 2D com mais logs e verifica√ß√µes.</p>
    <canvas id="interactive-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ‚Üë</div>
    <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste de Canvas</button>
    <div id="output-canvas"></div> <script>
        // --- Setup Canvas Test ---
        // Vari√°veis globais para elementos, inicializadas como null
        let canvasOutputDiv = null;
        let canvasRunBtn = null;
        let canvasElement = null;
        let coordStatusDivCanvas = null;
        let ctx = null; // Contexto global para f√°cil acesso

        const SHORT_PAUSE_CANVAS = 50;
        const MEDIUM_PAUSE_CANVAS = 300;
        let canvasClickListenerCanvas = null;
        let canvasMoveListenerCanvas = null;
        const rectAreaCanvas = { x: 10, y: 10, w: 50, h: 50 };
        const linkAreaCanvas = { x: 150, y: 100, w: 80, h: 30 };

        // --- Fun√ß√£o de Log (Mais Robusta) ---
        const logCanvas = (message, type = 'info') => {
             // Log no console sempre, para o caso do DIV falhar
             console.log(`[${type.toUpperCase()}] ${message}`);
             if (!canvasOutputDiv) {
                 console.error("logCanvas ERRO: output-canvas DIV n√£o encontrado!");
                 return;
             }
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 // Limite de log
                 if(canvasOutputDiv.innerHTML.length > 500000){
                     canvasOutputDiv.innerHTML = canvasOutputDiv.innerHTML.substring(canvasOutputDiv.innerHTML.length - 250000);
                     canvasOutputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + canvasOutputDiv.innerHTML;
                 }
                 canvasOutputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 canvasOutputDiv.scrollTop = canvasOutputDiv.scrollHeight;
             } catch(e) {
                 // Loga erro no console se falhar em escrever no DIV
                 console.error("logCanvas ERRO ao escrever no DIV:", e);
             }
        };

         // --- Helper toHex (Opcional, mas pode ser √∫til) ---
         const toHex = (val, bits = 32) => { try { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); } catch { return 'Error'; } };

        // --- Fun√ß√£o Principal do Teste de Canvas ---
        const testComprehensiveCanvasIsolated = async () => {
            logCanvas("--- Iniciando Teste Isolado de Canvas ---", 'test');
            try {
                // Verifica se o contexto j√° foi obtido (evita erro se chamado m√∫ltiplas vezes)
                if (!ctx) {
                    if (!canvasElement) throw new Error('Elemento Canvas √© null');
                    ctx = canvasElement.getContext('2d');
                    if (!ctx) throw new Error('Contexto 2D n√£o dispon√≠vel');
                    logCanvas("Contexto Canvas 2D obtido pela primeira vez.", 'info');
                } else {
                    logCanvas("Contexto Canvas 2D j√° existente.", 'info');
                }

                // Limpa e desenha fundo
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.fillStyle = "#334"; // Fundo diferente
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                logCanvas("Canvas limpo e fundo desenhado.", 'info');

            } catch(e) {
                logCanvas(`Falha CR√çTICA no setup do Canvas: ${e.message}`, 'error');
                logCanvas("--- Teste de Canvas Isolado ABORTADO (Setup) ---", 'test');
                if (canvasRunBtn) canvasRunBtn.disabled = false; // Reabilita bot√£o se falhar aqui
                return; // Aborta o resto do teste
            }

            // 1. Desenho
            logCanvas("Desenhando formas...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE_CANVAS));
            try {
                ctx.fillStyle="#FF5733"; ctx.fillRect(rectAreaCanvas.x, rectAreaCanvas.y, rectAreaCanvas.w, rectAreaCanvas.h); // Laranja
                ctx.fillStyle="#33FF57"; ctx.beginPath(); ctx.arc(120, 50, 30, 0, 2*Math.PI); ctx.fill(); // Verde
                ctx.fillStyle="rgba(50, 150, 255, 0.7)"; ctx.fillRect(linkAreaCanvas.x, linkAreaCanvas.y, linkAreaCanvas.w, linkAreaCanvas.h); // Azul Transp
                ctx.fillStyle="#FFFFFF"; ctx.font="bold 14px monospace"; ctx.textAlign="center";
                ctx.fillText("Abrir Link", linkAreaCanvas.x + linkAreaCanvas.w / 2, linkAreaCanvas.y + linkAreaCanvas.h / 2 + 5);
                ctx.textAlign="start";
                logCanvas("Formas desenhadas.", 'good');
            } catch(e) { logCanvas(`Erro durante desenho: ${e.message}`, 'error'); }

            // 2. Teste de APIs e Quirks
            logCanvas("Verificando APIs e Quirks...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE_CANVAS));
            try {
                const filterSupported = typeof ctx.filter !== 'undefined';
                logCanvas(` API Filter Suportado: ${filterSupported}`, filterSupported ? 'info' : 'warn');
                const pngURL = canvasElement.toDataURL('image/png');
                const jpegURL = canvasElement.toDataURL('image/jpeg');
                const urlQuirk = pngURL.length === jpegURL.length || pngURL.substring(30,70) === jpegURL.substring(30,70);
                logCanvas(` toDataURL PNG(len ${pngURL.length}) / JPEG(len ${jpegURL.length}). Quirk: ${urlQuirk}`, urlQuirk ? 'warn' : 'info');
                logCanvas(` API ellipse: ${typeof ctx.ellipse==='function'}`, 'info');
                logCanvas(` API measureText: ${typeof ctx.measureText==='function'}`, 'info');
                if (typeof ctx.measureText==='function') { logCanvas(`  measureText('Testüòä'): width ${ctx.measureText('Testüòä').width.toFixed(1)}`, 'info');}
            } catch(e) { logCanvas(` Erro API Check: ${e.message}`, 'error'); }

            // 3. Interatividade
            logCanvas("Adicionando listeners 'click' e 'mousemove'...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE_CANVAS));
            if(canvasClickListenerCanvas && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListenerCanvas); } catch(e){} }
            if(canvasMoveListenerCanvas && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListenerCanvas); } catch(e){} }

            canvasClickListenerCanvas = (event) => { /* ... (l√≥gica click v19, usando logCanvas) ... */ try{const r=canvasElement.getBoundingClientRect();const x=event.clientX-r.left; const y=event.clientY-r.top; let area='fora';if(x>=rectAreaCanvas.x&&x<=rectAreaCanvas.x+rectAreaCanvas.w&&y>=rectAreaCanvas.y&&y<=rectAreaCanvas.y+rectAreaCanvas.h)area='Rect Laranja'; else if(x>=linkAreaCanvas.x&&x<=linkAreaCanvas.x+linkAreaCanvas.w&&y>=linkAreaCanvas.y&&y<=linkAreaCanvas.y+linkAreaCanvas.h)area='√Årea Link'; logCanvas(`--> Click! Area: ${area}. Coords: x=${x.toFixed(0)}, y=${y.toFixed(0)}`,'warn'); if(area==='√Årea Link'){logCanvas("--> A√ß√£o LINK: Tentando abrir google.com...",'vuln'); try{window.open('https://google.com','_blank');}catch(e){logCanvas('Erro ao abrir link (bloqueado?): '+e.message,'error');}}}catch(e){logCanvas(`Erro click handler: ${e.message}`,'error');} };
            canvasMoveListenerCanvas = (event) => { /* ... (l√≥gica move v19, usando coordStatusDivCanvas) ... */ try{const r=canvasElement.getBoundingClientRect();const x=event.clientX-r.left; const y=event.clientY-r.top; if(coordStatusDivCanvas) coordStatusDivCanvas.textContent = `Canvas Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`;}catch(e){} };

            try { canvasElement.addEventListener('click', canvasClickListenerCanvas); canvasElement.addEventListener('mousemove', canvasMoveListenerCanvas); logCanvas("Listeners adicionados. TESTE CLICANDO E MOVENDO O MOUSE NO CANVAS!", 'good'); }
            catch (e) { logCanvas(`Erro add listeners: ${e.message}`, 'error'); }

            logCanvas("--- Teste de Canvas Isolado Conclu√≠do ---", 'test');
            if (canvasRunBtn) canvasRunBtn.disabled = false; // Reabilita bot√£o no final
        };

        // --- Fun√ß√£o chamada pelo bot√£o ---
        const runCanvasTest = async () => {
            logCanvas("Bot√£o 'Iniciar Teste de Canvas' clicado.", "info");
            if (canvasRunBtn) canvasRunBtn.disabled = true;
            // Garante que os elementos globais foram pegos antes de rodar
             if (!canvasOutputDiv || !canvasRunBtn || !canvasElement || !coordStatusDivCanvas) {
                 logCanvas("ERRO FATAL: Elementos HTML essenciais n√£o encontrados no carregamento.", "error");
                 if (canvasRunBtn) canvasRunBtn.disabled = false;
                 return;
             }
            await testComprehensiveCanvasIsolated();
            // O bot√£o √© reabilitado dentro do testComprehensiveCanvasIsolated se ele completar
        };

         // --- Inicializa√ß√£o e Limpeza ---
         // Pega refer√™ncias aos elementos assim que o script carrega
         try {
             canvasOutputDiv = document.getElementById('output-canvas');
             canvasRunBtn = document.getElementById('runCanvasBtn');
             canvasElement = document.getElementById('interactive-canvas');
             coordStatusDivCanvas = document.getElementById('canvas-coord-status');
             if (!canvasOutputDiv || !canvasRunBtn || !canvasElement || !coordStatusDivCanvas) {
                console.error("Falha ao obter todos os elementos HTML necess√°rios na carga inicial!");
                // Logar no body se o outputDiv falhar?
                if (!outputDiv) document.body.innerHTML += '<p style="color:red;">ERRO: Falha ao obter DIV de output!</p>';
             } else {
                 console.log("Elementos HTML para Teste de Canvas encontrados.");
             }
         } catch (e) {
             console.error("Erro cr√≠tico durante setup inicial:", e);
             alert("Erro cr√≠tico no setup inicial, veja o console (F12).");
         }

         // Limpeza listeners ao sair
         window.addEventListener('unload', () => { if(canvasClickListenerCanvas && canvasElement) canvasElement.removeEventListener('click',canvasClickListenerCanvas); if(canvasMoveListenerCanvas && canvasElement) canvasElement.removeEventListener('mousemove',canvasMoveListenerCanvas); });
         // document.addEventListener('DOMContentLoaded', runCanvasTest); // Para rodar auto

    </script>

</body>
</html>
