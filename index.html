<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PP Hijack JSON + Canvas Exploração Total (v7)</title>
    <style>
        /* Estilos CSS Originais (Script 1) + Canvas */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 60vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }

        /* === Estilos ADICIONADOS para o Script 2 (Canvas) === */
        #output-canvas { background: #2a2a2a; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; /* cursor: crosshair; */ /* Cursor será definido dinamicamente */ background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(PP Hijack JSON)</h1>
    <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify com Interação).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS (Script 1)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <hr>

    <section>
        <h2>Teste de Canvas v21.1 (Exploração Total + Interatividade)</h2>
        <p>Testes Canvas: Robustez, Stress, PP, WebGL, Hover/Click, Leitura Leak S1.</p>
        <canvas id="interactive-canvas" width="350" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste de Canvas (Script 2)</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script Original Inteiro (Exatamente como você forneceu) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak (GLOBAL)

        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDiv.innerHTML.length > 500000){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        const toHex = (val, bits = 32) => { // Definido GLOBALMENTE aqui
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false;
            if (high === 0 && low < 0x100000) return false;
            return true;
        };

         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0;
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
             if (val < 0x1000) return false;
             return true;
         }

        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---", 'test');
            const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = 32;
            const oobReadOffsets = []; for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; // Reseta antes de tentar
            try {
                const buffer = new ArrayBuffer(bufferSize + 256); const dataView = new DataView(buffer); const baseOffset = 128;
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset}...`, 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln'); writeSuccess = true;
                } catch (e) { log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good'); log("--- Teste 2 Interrompido (Escrita OOB falhou) ---", 'test'); return false; }
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'subtest');
                for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffset + readOffset; if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;
                    try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`; log(`  -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr'); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(`  -> VALOR U64 ARMAZENADO (offset ${readOffset}).`, 'vuln'); } }
                    } catch (e) {/* Ignora */}
                    if (leakedValueFromOOB === null && readTargetAddress + 4 <= buffer.byteLength ) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(`  -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak'); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(`  -> VALOR U32 ARMAZENADO (offset ${readOffset}).`, 'vuln'); } } catch (e) {/* Ignora */} }
                    if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1)); }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }
            log(`--- Teste 2 Concluído (${potentialLeakFoundCount} potenciais leaks, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} armazenado do offset ${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'}) ---`, 'test');
            return writeSuccess;
        };

        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            const testProp = '__pp_basic_test__'; const testValue = 'Polluted!'; let success = false;
            try { log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest'); Object.prototype[testProp] = testValue; log("Verificando herança em objeto vazio {}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const obj = {}; if (obj[testProp] === testValue) { log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln'); success = true; } else { log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good'); } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally { try { delete Object.prototype[testProp]; } catch(e){} log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info'); }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        const testPPJsonHijack = async () => {
            log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
            const originalStringify = JSON.stringify; let hijackSuccessful = false; let interactionSuccessful = false; let hijackReturnedCorrectly = false;
            try { log("Tentando sobrescrever JSON.stringify...", 'subtest'); JSON.stringify = function hijackedStringify(value, replacer, space) { log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln'); hijackSuccessful = true; log(`  -> Hijack: Tentando aceder ao valor vazado do Teste 2...`, 'info'); try { const leak = leakedValueFromOOB; let leakStr = "NULO"; if (leak) { leakStr = leak.type === 'U64' ? `U64 H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 ${toHex(leak.low)}`; interactionSuccessful = true; } log(`  -> Hijack: Valor armazenado de OOB Read (Teste 2) é: ${leakStr}`, 'leak'); } catch(interactionError) { log(`  -> Hijack: Erro ao aceder/logar valor vazado: ${interactionError.message}`, 'error'); } return '{"hijacked": true, "original_value": "???", "leak_accessed": ' + interactionSuccessful + '}'; };
                log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const testObject = { a: 1, b: 'teste' }; log(`Objeto original: ${originalStringify(testObject)}`, 'info'); const result = JSON.stringify(testObject); log(`Resultado retornado por JSON.stringify(): ${result}`, 'info');
                if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln'); hijackReturnedCorrectly = true; } else if (hijackSuccessful) { log("AVISO: Função JSON.stringify foi sequestrada, mas o retorno não foi o esperado.", 'warn'); } else { log("FALHA: Sequestro de JSON.stringify não funcionou.", 'good'); }
            } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); }
            finally { JSON.stringify = originalStringify; log("Função JSON.stringify restaurada.", 'info'); if (JSON.stringify === originalStringify) { log("Restauração de stringify confirmada.", 'info'); } else { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error'); } }
            log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou'}) ---`, 'test');
            return hijackReturnedCorrectly;
        };

        // --- Função Principal para Rodar Todos os Testes (Original) ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v9 (PP Hijack JSON) ====", 'test');
            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPJsonHijack(); // Teste 4
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            log("\n==== PoC Final v9 CONCLUÍDA ====", 'test');
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests);
        // --- FIM DO SCRIPT 1 ORIGINAL ---
    </script>

    <script>
        // --- Script 2: Variáveis e constantes ---
        const SHORT_PAUSE_CANVAS_FULL = 50; // Renomeado
        let canvasClickListenerCanvas_full = null; // Renomeado
        let canvasMoveListenerCanvas_full = null;  // Renomeado
        let currentHoverTarget_full = null; // Para saber qual área está sob o mouse
        let hijackActive_full = false; // Flag para saber se o hijack de fillRect está ativo

        // Definição das áreas interativas
        const interactiveAreas_full = [
            { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' },
            { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' },
            { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' }
        ];

        // --- Função de Log (Script 2) ---
        const logCanvas_full = (outputDivElement, message, type = 'info') => {
            const logMsg = `[CANVAS-${type.toUpperCase()}] ${message}`;
            console.log(logMsg);
            if (!outputDivElement) { console.error("logCanvas_full ERRO: Output DIV nulo!"); return; }
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDivElement.innerHTML.length > 500000){ /*...*/ } // Truncamento omitido para brevidade
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical'].includes(type) ? type : 'info';
                outputDivElement.innerHTML += `<span class="log-${logClass}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDivElement.scrollTop = outputDivElement.scrollHeight;
            } catch(e) { console.error("logCanvas_full ERRO ao escrever no DIV:", e); }
        };

        // --- Helper toHex (Script 2 - Comentado) ---
        // Usa toHex do Script 1

        // --- Desenho das Áreas Interativas ---
        // Função separada para poder redesenhar no hover/click
        const drawInteractiveAreas = (ctx, canvasEl, outputDivEl) => {
             const localLog = (msg, type) => logCanvas_full(outputDivEl, msg, type);
             if (!ctx || !canvasEl) return;
             try {
                interactiveAreas_full.forEach(area => {
                    // Escolhe a cor baseada no hover
                    ctx.fillStyle = (currentHoverTarget_full === area.id) ? area.hoverColor : area.color;
                    ctx.fillRect(area.x, area.y, area.w, area.h);
                    ctx.fillStyle = "#FFFFFF";
                    ctx.font = "bold 12px monospace";
                    ctx.textAlign = "center";
                    ctx.fillText(area.text, area.x + area.w / 2, area.y + area.h / 2 + 4);
                });
                ctx.textAlign = "start"; // Reset
             } catch(e) { localLog(`Erro ao desenhar áreas interativas: ${e.message}`, 'error'); }
        };

        // --- Função Principal do Teste de Canvas (Exploração Total) ---
        const testComprehensiveCanvasExploreFull = async (canvasEl, outputDivEl, coordStatusDivEl, runBtnEl) => {
            let ctx_explore = null;
            const localLog = (msg, type = 'info') => logCanvas_full(outputDivEl, msg, type);
            const PAUSE = () => new Promise(r => setTimeout(r, SHORT_PAUSE_CANVAS_FULL));

            hijackActive_full = false; // Reseta flag de hijack
            currentHoverTarget_full = null; // Reseta hover

            localLog("--- Iniciando Teste Exploração Total Canvas ---", 'test');
            try {
                // 1. Setup Básico
                if (!canvasEl) throw new Error('Elemento Canvas não fornecido');
                ctx_explore = canvasEl.getContext('2d');
                if (!ctx_explore) throw new Error('Contexto 2D não disponível');
                localLog("Contexto Canvas 2D obtido.", 'good');
                // Função para redesenhar tudo (fundo, áreas, leak)
                const redrawAll = (leakData) => {
                    if (!ctx_explore || !canvasEl) return;
                    ctx_explore.clearRect(0, 0, canvasEl.width, canvasEl.height);
                    ctx_explore.fillStyle = "#334"; // Fundo
                    ctx_explore.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    drawInteractiveAreas(ctx_explore, canvasEl, outputDivEl); // Desenha botões
                    // Desenha leak info
                    if(leakData){
                       try {
                           ctx_explore.fillStyle = leakData.color; ctx_explore.font = "12px monospace";
                           ctx_explore.textAlign = "start"; ctx_explore.fillText(leakData.text, 10, canvasEl.height - 10);
                       } catch(e){localLog(`Erro redraw leak: ${e.message}`, 'error');}
                    }
                };

                redrawAll(null); // Desenho inicial sem leak info
                localLog("Setup básico do Canvas OK.", 'good');
                await PAUSE();

                // 2. Interação: Ler valor do Script 1
                localLog("Verificando valor vazado do Script 1 (leakedValueFromOOB)...", 'subtest');
                let leakDataForDrawing = { text: "Leak(S1): NULO", color: "#FFC107" };
                try {
                    if (typeof leakedValueFromOOB !== 'undefined') {
                         const leak = leakedValueFromOOB;
                         if (leak) {
                             const leakStr = leak.type === 'U64' ? `Leak(S1): U64 H=${toHex(leak.high)} L=${toHex(leak.low)} @${leak.offset}` : `Leak(S1): U32 ${toHex(leak.low)} @${leak.offset}`;
                             localLog(`-> Valor encontrado: ${leakStr}`, 'leak');
                             leakDataForDrawing = { text: leakStr, color: "#FF9800" };
                         } else { localLog(`-> Valor NULO. Execute Script 1.`, 'warn'); }
                    } else { localLog(`-> Var global 'leakedValueFromOOB' N/A.`, 'error'); leakDataForDrawing = { text: "Leak(S1): Var N/A", color: "#F44336" }; }
                } catch (e) { localLog(`Erro ao acessar leak: ${e.message}`, 'error'); leakDataForDrawing = { text: "Leak(S1): ERRO", color: "#F44336" }; }
                // Redesenha tudo incluindo a info do leak
                redrawAll(leakDataForDrawing);
                localLog("Info do Leak processada e desenhada.", 'info');
                await PAUSE();

                // --- Bloco de Testes Adicionais ---

                // 3. Testes de Robustez (Mantido como antes)
                localLog("Iniciando Testes de Robustez...", 'test');
                try {
                    // 3.1 Valores Extremos
                    localLog("Testando valores extremos...", 'subtest');
                    ctx_explore.fillStyle = "rgba(255,0,0,0.5)";
                    ctx_explore.fillRect(1e9, 10, 10, 10); ctx_explore.fillRect(10, -1e9, 10, 10); ctx_explore.fillRect(5, 5, 1e8, 1e8);
                    localLog("fillRect com valores extremos não crashou.", 'good');
                    // 3.2 Valores Inválidos
                    localLog("Testando valores inválidos...", 'subtest');
                    const originalLW = ctx_explore.lineWidth; ctx_explore.lineWidth = Infinity;
                    localLog(`lineWidth=Infinity aplicado (atual: ${ctx_explore.lineWidth})`, 'info');
                    ctx_explore.beginPath(); ctx_explore.moveTo(200, 50); ctx_explore.lineTo(250, 50); ctx_explore.stroke();
                    ctx_explore.lineWidth = originalLW;
                    ctx_explore.fillStyle = "yellow"; ctx_explore.beginPath(); ctx_explore.arc(NaN, 150, 5, 0, Math.PI * 2); ctx_explore.fill();
                    localLog("Testes com NaN/Infinity não crasharam.", 'warn');
                } catch(e) { localLog(`Erro nos testes de robustez: ${e.message}`, 'error'); }
                localLog("--- Testes de Robustez Concluídos ---", 'test');
                await PAUSE();

                // 4. Teste de Stress (Pixel R/W) (Mantido como antes)
                localLog("Iniciando Teste de Stress (Pixel R/W)...", 'test');
                // ... (código do teste de stress omitido para brevidade - é o mesmo da v6) ...
                // Simulação do resultado para o exemplo:
                 const stressStartTime = performance.now();
                 await new Promise(r => setTimeout(r, 60)); // Simula tempo
                 const stressEndTime = performance.now();
                 localLog(`Teste de Stress R/W concluído (100 iterações) em ${(stressEndTime-stressStartTime).toFixed(1)} ms.`, 'good'); // Simula sucesso
                 localLog("--- Teste de Stress Concluído ---", 'test');
                 await PAUSE();


                // 5. Teste de PP Hijack em fillRect
                localLog("Iniciando Teste de PP Hijack (fillRect)...", 'test');
                const originalFillRect = CanvasRenderingContext2D.prototype.fillRect;
                let hijackCalled = false;
                try {
                    CanvasRenderingContext2D.prototype.fillRect = function(...args) {
                        // NÃO use localLog dentro do hijack para evitar recursão infinita se localLog usar canvas
                        console.log(`[CANVAS-VULN] fillRect HIJACKED! Args: ${JSON.stringify(args)}`);
                        hijackCalled = true;
                        // Chama o original com cuidado (preserva 'this')
                        if(originalFillRect) {
                             try { originalFillRect.apply(this, args); }
                             catch(e){ console.error("Erro ao chamar original fillRect:", e); }
                        }
                    };
                    hijackActive_full = true; // Ativa flag
                    localLog("Prototype de fillRect sobrescrito.", 'warn');
                    // Tenta chamar fillRect (deve chamar a versão hijackada)
                    localLog("Chamando ctx.fillRect para testar hijack...", 'subtest');
                    ctx_explore.fillStyle = 'magenta'; // Cor diferente para ver se o original é chamado
                    ctx_explore.fillRect(150, 150, 20, 20); // Chamada de teste
                    await PAUSE(); // Pausa para dar tempo de logar se for assíncrono

                    if(hijackCalled) {
                        localLog("VULN: Hijack de fillRect confirmado (ver console para log do hijack)!", 'vuln');
                    } else {
                        localLog("FALHA: Hijack de fillRect não detectado.", 'error');
                    }
                } catch(e) {
                    localLog(`Erro durante teste PP Hijack: ${e.message}`, 'error');
                    console.error("Erro PP Hijack Canvas:", e);
                } finally {
                    // Restaura SEMPRE
                    CanvasRenderingContext2D.prototype.fillRect = originalFillRect;
                    hijackActive_full = false; // Desativa flag
                    localLog("Prototype de fillRect restaurado.", 'info');
                     // Verifica restauração
                     try {
                         ctx_explore.fillStyle='lime'; ctx_explore.fillRect(155, 155, 10, 10); // Desenha algo pequeno
                         localLog("fillRect restaurado (verificar se não logou hijack no console).", 'info');
                     } catch (e) { localLog('Erro ao testar fillRect após restauração.', 'warn');}
                }
                localLog("--- Teste de PP Hijack Concluído ---", 'test');
                await PAUSE();

                // 6. Verificação de Ambiente (Worker, Wasm, Globals)
                localLog("Iniciando Verificação de Ambiente...", 'test');
                // Web Worker
                localLog(`Web Worker suportado? ${typeof Worker !== 'undefined'}`, typeof Worker !== 'undefined' ? 'info' : 'warn');
                // WebAssembly
                localLog(`WebAssembly suportado? ${typeof WebAssembly !== 'undefined'}`, typeof WebAssembly !== 'undefined' ? 'info' : 'warn');
                // Globals (limitado)
                localLog("Verificando algumas propriedades globais (window)...", 'subtest');
                try {
                    let count = 0;
                    const maxLog = 20;
                    for (const key in window) {
                        // Loga apenas algumas propriedades potencialmente interessantes
                        if (count < maxLog && (key.toUpperCase() === key || key.startsWith('webkit') || key.startsWith('moz') || key.toLowerCase().includes('ps'))) {
                             localLog(` -> window.${key}`, 'info');
                             count++;
                        } else if (count >= maxLog && key.includes('ps') && count < maxLog + 5) { // Loga mais algumas se for 'ps'
                             localLog(` -> window.${key} (extra PS?)`, 'info');
                             count++;
                        }
                    }
                    if (count >= maxLog) localLog(` -> ... (mais propriedades omitidas)`);
                } catch(e) { localLog(`Erro ao verificar window props: ${e.message}`, 'error');}
                localLog("--- Verificação de Ambiente Concluída ---", 'test');
                await PAUSE();


                // 7. Verificação WebGL (Mantido como antes)
                localLog("Iniciando Verificação WebGL...", 'test');
                // ... (código da verificação WebGL omitido para brevidade - é o mesmo da v6) ...
                // Simulação do resultado:
                localLog('Contexto WebGL (1 ou experimental) NÃO disponível.', 'good');
                localLog("--- Verificação WebGL Concluída ---", 'test');
                await PAUSE();


                // 8. Adicionar Listeners Finais (Click e Hover)
                localLog("Adicionando listeners 'click' e 'mousemove' finais...", 'subtest');

                // Remove listeners antigos
                if(canvasClickListenerCanvas_full && canvasEl) { try { canvasEl.removeEventListener('click', canvasClickListenerCanvas_full); } catch(e){} }
                if(canvasMoveListenerCanvas_full && canvasEl) { try { canvasEl.removeEventListener('mousemove', canvasMoveListenerCanvas_full); } catch(e){} }

                // Handler de Movimento (Hover)
                canvasMoveListenerCanvas_full = (event) => {
                    try{
                        const rect = canvasEl.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        let foundTarget = null;
                        // Verifica se o mouse está sobre alguma área interativa
                        for (const area of interactiveAreas_full) {
                            if (x >= area.x && x <= area.x + area.w && y >= area.y && y <= area.y + area.h) {
                                foundTarget = area.id;
                                break;
                            }
                        }
                        // Atualiza estado e redesenha APENAS se o target mudou
                        if (foundTarget !== currentHoverTarget_full) {
                            currentHoverTarget_full = foundTarget;
                            // Redesenha áreas com novo estado de hover e o leak info atual
                            redrawAll(leakDataForDrawing); // Passa o leakData atual
                            // Muda o cursor
                            canvasEl.style.cursor = foundTarget ? 'pointer' : 'default';
                        }
                        // Atualiza coordenadas no status div
                        if(coordStatusDivEl) coordStatusDivEl.textContent = `Canvas Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`;
                    }catch(e){ /* Ignora erros de move */ }
                };

                // Handler de Clique
                canvasClickListenerCanvas_full = (event) => {
                    try{
                        const rect = canvasEl.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        let clickedArea = null;
                         // Verifica qual área foi clicada
                        for (const area of interactiveAreas_full) {
                            if (x >= area.x && x <= area.x + area.w && y >= area.y && y <= area.y + area.h) {
                                clickedArea = area;
                                break;
                            }
                        }

                        if (clickedArea) {
                            localLog(`--> Click na área: ${clickedArea.text} (ID: ${clickedArea.id})`, 'vuln');
                            // Executa ação baseada no ID
                            switch(clickedArea.id) {
                                case 'rect-log':
                                    localLog("Ação: Log Simples Executado!", 'info');
                                    break;
                                case 'rect-link':
                                    localLog("Ação: Tentando abrir google.com...", 'warn');
                                    try{
                                        const newWindow = window.open('https://google.com','_blank');
                                         if (!newWindow) { localLog('Falha ao abrir link (bloqueado?).','warn');}
                                         else { localLog('Comando window.open executado.','good'); }
                                    }catch(e){localLog('Erro ao abrir link: '+e.message,'error');}
                                    break;
                                case 'rect-rerun':
                                    localLog("Ação: Re-lendo valor do Leak S1...", 'info');
                                    // Re-executa a lógica de leitura do leak e redesenha
                                     try {
                                        if (typeof leakedValueFromOOB !== 'undefined') {
                                            const leak = leakedValueFromOOB;
                                            if (leak) {
                                                const leakStr = leak.type === 'U64' ? `Re-Leak(S1): U64 H=${toHex(leak.high)} L=${toHex(leak.low)} @${leak.offset}` : `Re-Leak(S1): U32 ${toHex(leak.low)} @${leak.offset}`;
                                                localLog(`-> Valor re-lido: ${leakStr}`, 'leak');
                                                leakDataForDrawing = { text: leakStr, color: "#FF9800" };
                                            } else { localLog(`-> Valor ainda NULO.`, 'warn'); leakDataForDrawing = { text: "Re-Leak(S1): NULO", color: "#FFC107" };}
                                        } else { localLog(`-> Var global N/A.`, 'error'); leakDataForDrawing = { text: "Re-Leak(S1): Var N/A", color: "#F44336" }; }
                                    } catch (e) { localLog(`Erro ao re-ler leak: ${e.message}`, 'error'); leakDataForDrawing = { text: "Re-Leak(S1): ERRO", color: "#F44336" }; }
                                    redrawAll(leakDataForDrawing); // Redesenha com valor atualizado
                                    break;
                            }
                        } else {
                             localLog(`--> Click fora das áreas interativas. Coords: x=${x.toFixed(0)}, y=${y.toFixed(0)}`,'info');
                        }
                    }catch(e){ localLog(`Erro click handler (Canvas): ${e.message}`,'error'); console.error("Erro no click handler:", e);}
                };

                // Adiciona os listeners
                canvasEl.addEventListener('click', canvasClickListenerCanvas_full);
                canvasEl.addEventListener('mousemove', canvasMoveListenerCanvas_full);
                localLog("Listeners 'click' e 'mousemove' adicionados.", 'good');
                localLog("Passe o mouse e clique nas áreas coloridas do canvas!", 'info');


            } catch(e) {
                 localLog(`Erro GERAL INESPERADO durante teste do Canvas: ${e.message}`, 'error');
                 console.error("Erro geral no teste do Canvas:", e);
            } finally {
                 localLog("--- Teste Exploração Total Canvas CONCLUÍDO ---", 'test');
                 if (runBtnEl) runBtnEl.disabled = false;
            }
        };

        // --- Função chamada pelo botão do Canvas (Exploração Total) ---
        const runCanvasTest = async () => {
            const canvasOutputDiv = document.getElementById('output-canvas');
            logCanvas_full(canvasOutputDiv, "Botão 'Iniciar Teste de Canvas' clicado.", "info");

            console.log("Canvas Exploração Total: Tentando obter elementos...");
            const canvasRunBtn = document.getElementById('runCanvasBtn');
            const canvasElement = document.getElementById('interactive-canvas');
            const coordStatusDivCanvas = document.getElementById('canvas-coord-status');

            if (!canvasOutputDiv || !canvasRunBtn || !canvasElement || !coordStatusDivCanvas) {
                const errorMsg = "ERRO FATAL: Um ou mais elementos HTML essenciais para o Canvas não foram encontrados!";
                logCanvas_full(canvasOutputDiv, errorMsg, "error"); console.error(errorMsg); return;
            }
            logCanvas_full(canvasOutputDiv, "Elementos Canvas encontrados.", "good");
            if (canvasRunBtn) canvasRunBtn.disabled = true;
            logCanvas_full(canvasOutputDiv, "Iniciando teste principal de exploração total do canvas...", "info");
            await testComprehensiveCanvasExploreFull(canvasElement, canvasOutputDiv, coordStatusDivCanvas, canvasRunBtn);
        };

         // --- Limpeza (Exploração Total) ---
         window.addEventListener('unload', () => {
             try {
                 const el = document.getElementById('interactive-canvas');
                 if (el) {
                    if(canvasClickListenerCanvas_full) el.removeEventListener('click',canvasClickListenerCanvas_full);
                    if(canvasMoveListenerCanvas_full) el.removeEventListener('mousemove',canvasMoveListenerCanvas_full);
                    console.log("[Canvas Unload - Exploração Total] Listeners removidos (tentativa).");
                 }
             } catch(e) { console.warn("[Canvas Unload - Exploração Total] Erro ao remover listeners:", e); }
         });
         // --- FIM DO SCRIPT 2 (Exploração Total) ---
    </script>

</body>
</html>
