<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Vulnerabilidades Avançada</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas, #output-advanced {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh; /* Aumentado para mais logs */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        .log-tool { color: #7FFF00; font-weight: bold; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
        .tool-section { margin-top: 20px; padding: 10px; border: 1px solid #555; background-color: #1a1a1a; }
        .tool-section h3 { margin-top: 0; color: #00FFFF; }
        .tool-section input[type="text"], .tool-section textarea { background-color: #333; color: #eee; border: 1px solid #555; padding: 5px; margin-right: 5px; width: 200px; }
        .tool-section button { background-color: #007bff; color: white; border: none; padding: 5px 10px; cursor: pointer; }
        .tool-section button:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <h1>Testes de Vulnerabilidade - Script Principal</h1>
    <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTestsS1()">Iniciar Testes S1</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Suite de Vulnerabilidades - Canvas e APIs Avançadas</h2>
        <p>Foco: PP Avançado++, OOB R/W (Metadata/ImageData), API Checks (GL/GPU/FS), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="300" height="100"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Testes Canvas S2</button>
        <div id="output-canvas"></div>
    </section>

    <hr>

    <section class="tool-section">
        <h2>Ferramentas e Testes Avançados - Script 3</h2>
        <p>Testes adicionais, ferramentas conceituais e primitivas de baixo nível (simuladas/educacionais).</p>
        <button id="runAdvancedBtn" onclick="runAllAdvancedTests()">Iniciar Testes Avançados S3</button>

        <div id="rop-builder" class="tool-section" style="margin-top:15px;">
            <h3>Construtor de Cadeia ROP (Conceitual)</h3>
            <textarea id="rop-gadgets-input" rows="5" placeholder="EndereçoGadget1=Nome (ex: 0x41414141=pop_rax_ret)&#10;EndereçoGadget2=Nome"></textarea><br>
            <textarea id="rop-chain-input" rows="5" placeholder="NomeGadget1&#10;ValorParaRDI (se pop rdi)&#10;NomeGadget2..."></textarea><br>
            <button onclick="buildRopChain()">Construir Cadeia</button>
        </div>

        <div id="memory-viewer" class="tool-section" style="margin-top:15px;">
            <h3>Visualizador de Memória (Conceitual - Requer Primitiva de Leitura)</h3>
            <input type="text" id="mem-view-addr" placeholder="Endereço (ex: 0x12345000)">
            <input type="text" id="mem-view-size" placeholder="Tamanho (bytes, ex: 64)">
            <button onclick="viewMemory()">Visualizar Memória</button>
            <p style="font-size:0.8em;">Nota: Isso simula a leitura. Nenhuma leitura real de memória arbitrária ocorre sem um exploit.</p>
        </div>
        <div id="output-advanced"></div>
    </section>


    <script>
        // --- Utilitários e Constantes Globais (v19.0) ---
        const KB = 1024;
        const MB = KB * KB;
        const GB = KB * KB * KB;

        // Adaptado de int64.mjs
        class AdvancedInt64 {
            constructor(low, high) {
                let buffer = new Uint32Array(2);
                let bytes = new Uint8Array(buffer.buffer);

                if (arguments.length > 2) { throw TypeError('AdvancedInt64 takes at most 2 args'); }
                if (arguments.length === 0) { throw TypeError('AdvancedInt64 takes at min 1 args'); }
                let is_one = false;
                if (arguments.length === 1) { is_one = true; }

                if (!is_one) {
                    if (typeof (low) !== 'number' && typeof (high) !== 'number') {
                        throw TypeError('low/high must be numbers');
                    }
                }
                const check_range = (x) => (-0x80000000 <= x) && (x <= 0xffffffff);

                if (typeof low === 'number') {
                    if (!check_range(low)) { throw TypeError('low not a valid value: ' + low); }
                    if (is_one) {
                        high = 0;
                        if (low < 0) { high = -1; }
                    } else {
                        if (!check_range(high)) { throw TypeError('high not a valid value: ' + high); }
                    }
                    buffer[0] = low;
                    buffer[1] = high;
                } else if (typeof low === 'string') { // Hex string
                    let hexstr = low;
                    if (hexstr.substring(0, 2) === "0x") { hexstr = hexstr.substring(2); }
                    if (hexstr.length % 2 === 1) { hexstr = '0' + hexstr; }
                    if (hexstr.length > 16) { hexstr = hexstr.substring(hexstr.length - 16); } // Max 16 hex chars (8 bytes)
                    else { hexstr = hexstr.padStart(16, '0');}


                    for (let i = 0; i < 8; i++) { // Read 8 bytes for a 64-bit number
                        bytes[i] = parseInt(hexstr.slice(14 - i*2, 16 - i*2), 16);
                    }

                } else if (typeof low === 'object') {
                    if (low instanceof AdvancedInt64) {
                        bytes.set(low.bytes);
                    } else if (low.length === 8) { // Assuming byte array
                        bytes.set(low);
                    } else { throw TypeError("Array must have exactly 8 elements."); }
                } else {
                    throw TypeError('AdvancedInt64 does not support your object for conversion');
                }

                this.buffer = buffer;
                this.bytes = bytes;
            }

            low() { return this.buffer[0]; }
            high() { return this.buffer[1]; }

            toString(is_pretty) {
                let lowStr = this.low().toString(16).padStart(8, '0');
                let highStr = this.high().toString(16).padStart(8, '0');
                if (is_pretty) {
                    highStr = highStr.substring(0, 4) + '_' + highStr.substring(4);
                    lowStr = lowStr.substring(0, 4) + '_' + lowStr.substring(4);
                    return '0x' + highStr + '_' + lowStr;
                }
                return '0x' + highStr + lowStr;
            }

            add(other) {
                if (!(other instanceof AdvancedInt64)) { other = new AdvancedInt64(other); }
                let newLow = (this.low() + other.low()) >>> 0;
                let carry = (this.low() & 0xFFFFFFFF) + (other.low() & 0xFFFFFFFF) > 0xFFFFFFFF ? 1 : 0;
                let newHigh = (this.high() + other.high() + carry) >>> 0;
                return new AdvancedInt64(newLow, newHigh);
            }

            sub(other) {
                if (!(other instanceof AdvancedInt64)) { other = new AdvancedInt64(other); }
                const negOther = other.neg();
                return this.add(negOther);
            }

            neg() {
                const low = ~this.low();
                const high = ~this.high();
                const one = new AdvancedInt64(1,0);
                const res = new AdvancedInt64(low, high);
                return res.add(one);
            }

            eq(other) {
                if (!(other instanceof AdvancedInt64)) { other = new AdvancedInt64(other); }
                return this.low() === other.low() && this.high() === other.high();
            }

            static Zero = new AdvancedInt64(0,0);
            static One = new AdvancedInt64(1,0);
        }

        // Adaptado de rw.mjs
        const readWriteUtils = {
            readBytes: (u8_view, offset, size) => {
                let res = 0;
                for (let i = 0; i < size; i++) {
                    res += u8_view[offset + i] << (i * 8);
                }
                return res >>> 0;
            },
            read16: (u8_view, offset) => readWriteUtils.readBytes(u8_view, offset, 2),
            read32: (u8_view, offset) => readWriteUtils.readBytes(u8_view, offset, 4),
            read64: (u8_view, offset) => {
                let resBytes = [];
                for (let i = 0; i < 8; i++) {
                    resBytes.push(u8_view[offset + i]);
                }
                return new AdvancedInt64(resBytes);
            },
            writeBytes: (u8_view, offset, value, size) => {
                for (let i = 0; i < size; i++) {
                    u8_view[offset + i] = (value >>> (i * 8)) & 0xff;
                }
            },
            write16: (u8_view, offset, value) => readWriteUtils.writeBytes(u8_view, offset, value, 2),
            write32: (u8_view, offset, value) => readWriteUtils.writeBytes(u8_view, offset, value, 4),
            write64: (u8_view, offset, value) => {
                if (!(value instanceof AdvancedInt64)) { throw TypeError('write64 value must be an AdvancedInt64'); }
                let low = value.low();
                let high = value.high();
                for (let i = 0; i < 4; i++) { u8_view[offset + i] = (low >>> (i * 8)) & 0xff; }
                for (let i = 0; i < 4; i++) { u8_view[offset + 4 + i] = (high >>> (i * 8)) & 0xff; }
            }
        };

        // Adaptado de utils.mjs
        const generalUtils = {
            align: (addrOrInt, alignment) => {
                let a = (addrOrInt instanceof AdvancedInt64) ? addrOrInt : new AdvancedInt64(addrOrInt);
                const mask = new AdvancedInt64(-alignment & 0xffffffff, ((-alignment & 0xffffffff) < 0 && alignment !== 0) ? 0xffffffff : 0); // Simplified alignment mask handling for JS
                // This alignment logic is tricky for 64-bit in JS without true 64-bit bitwise ops.
                // A simpler approach for positive numbers, assuming alignment is power of 2:
                let low = a.low();
                let high = a.high(); // High part alignment is more complex
                low = (low + alignment -1) & (~(alignment-1)); // Align low part up
                // For full 64-bit alignment, one would typically do: (val + (align-1)) & ~(align-1)
                // This simplified version primarily aligns the lower 32 bits.
                return new AdvancedInt64(low, high);

            },
            str2array: (str, length, offset = 0) => {
                let a = new Array(length);
                for (let i = 0; i < length; i++) {
                    a[i] = str.charCodeAt(i + offset);
                }
                return a;
            },
            // For logging within the HTML
            logToDiv: (divId, message, type = 'info', funcName = '') => {
                const outputDiv = document.getElementById(divId);
                if (!outputDiv) return;
                try {
                    const timestamp = `[${new Date().toLocaleTimeString()}]`;
                    const prefix = funcName ? `[${funcName}] ` : '';
                    const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation', 'tool'].includes(type) ? type : 'info';

                    if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; }

                    outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                    outputDiv.scrollTop = outputDiv.scrollHeight;
                } catch(e) { console.error(`Erro no log para ${divId}:`, e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
            }
        };


        // Offsets (para referência em testes avançados, não usados diretamente aqui sem primitivas)
        // Originalmente de offset.mjs
        const jscOffsets = {
            js_butterfly: 0x8,
            view_m_vector: 0x10,
            view_m_length: 0x18,
            view_m_mode: 0x1c,
            size_view: 0x20,
            // strimpl_strlen: 4, // StringImpl offsets, menos relevantes para os testes aqui
            // strimpl_m_data: 8,
            // strimpl_inline_str: 0x14,
            // size_strimpl: 0x18
        };
    </script>

    <script>
        // --- Script 1 (v19.0 - Arsenal Expandido) ---
        const outputDivS1 = document.getElementById('output');
        const runBtnS1 = document.getElementById('runBtn');
        const SHORT_PAUSE_S1 = 50;
        const MEDIUM_PAUSE_S1 = 500;
        let leakedValueFromOOB_S1 = null; // Renomeado para evitar conflito

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const logS1 = (message, type = 'info', funcName = '') => {
            generalUtils.logToDiv('output', message, type, funcName); // Usa o logger geral
        };


        const PAUSE_S1_FUNC = (ms = SHORT_PAUSE_S1) => new Promise(r => setTimeout(r, ms)); // Renomeado
        const toHexS1 = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const isPotentialPointer64S1 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32S1 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };

        const testCSPBypassS1 = async () => {
            const FNAME = 'testCSPBypassS1'; logS1("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME);
            try { const payloadJS = `try { logS1("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); alert('XSS S1 via Data URI!'); } catch(e) { logS1("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = (e) => { logS1(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME); }; document.body.appendChild(scriptTag); await PAUSE_S1_FUNC(SHORT_PAUSE_S1 * 2); document.body.removeChild(scriptTag); } catch (e) { logS1(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME); }
            await PAUSE_S1_FUNC();
            try { const imgTag = document.createElement('img'); const imgSrc = 'invalid_img_' + Date.now(); imgTag.src = imgSrc; const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; logS1("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { logS1("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { logS1("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); await PAUSE_S1_FUNC(SHORT_PAUSE_S1 * 2); document.body.removeChild(imgTag); } catch (e) { logS1(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME); }
            await PAUSE_S1_FUNC();
            try { const link = document.createElement('a'); link.href = "javascript:try{logS1('[Payload JS Href:] Executado!', 'vuln', 'XSS Payload JS Href'); alert('XSS S1 via JS Href!');}catch(e){logS1('[Payload JS Href:] Bloqueado: '+e.message,'good','XSS Payload JS Href');}"; link.textContent = "[Test Link JS Href - Clique Manual]"; link.style.display = 'block'; link.style.color = 'cyan'; document.getElementById('xss-target-div').appendChild(link); logS1("Adicionado link javascript: href para teste manual.", 'info', FNAME); } catch(e) { logS1(`Erro ao criar link js: href: ${e.message}`, 'error', FNAME); }
            logS1("--- Teste 1 Concluído ---", 'test', FNAME);
        };

        const testOOBReadInfoLeakEnhancedStoreS1 = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStoreS1'; logS1("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize; const readRangeStart = -64; const readRangeEnd = bufferSize + 64; const allocationSize = bufferSize + 256; const baseOffsetInBuffer = 128; const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB_S1 = null; try { const buffer = new ArrayBuffer(allocationSize); const dataView = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await PAUSE_S1_FUNC(); try { dataView.setUint8(writeTargetAddress, writeValue); logS1(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHexS1(writeValue, 8)}`, 'vuln', FNAME); logS1(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME); writeSuccess = true; } catch (e) { logS1(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); logS1(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME); return false; } await PAUSE_S1_FUNC(); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffsetInBuffer + readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) { try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64S1(high, low)) { const vStr = `H=${toHexS1(high)} L=${toHexS1(low)}`; logS1(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME); potentialLeakFoundCount++; if (leakedValueFromOOB_S1 === null) { leakedValueFromOOB_S1 = { high, low, type: 'U64', offset: readOffset }; logS1(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); logS1(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); logS1(` ---> INSIGHT: O valor vazado ${vStr} (tipo ${leakedValueFromOOB_S1.type}) em ${relOffsetStr} é um candidato a ponteiro. Para contornar o ASLR, seria necessário analisar este valor e a memória ao redor dele (usando uma primitiva de leitura arbitrária mais poderosa, se disponível, para dereferenciar este ponteiro caso ele aponte para fora deste buffer) para identificar um endereço base de um módulo carregado ou uma estrutura de dados conhecida.`, 'info', FNAME); } } } catch (e) {} } if (leakedValueFromOOB_S1 === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32S1(val32)) { logS1(` -> Leak U32? ${relOffsetStr}: ${toHexS1(val32)}`, 'leak', FNAME); potentialLeakFoundCount++; leakedValueFromOOB_S1 = { high: 0, low: val32, type: 'U32', offset: readOffset }; logS1(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); logS1(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { logS1(` -> Leu valor OOB escrito (${toHexS1(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME); } } catch (e) {} } if (readOffset % 32 === 0) await PAUSE_S1_FUNC(1); } } catch (e) { logS1(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); } finally { const leakStatus = leakedValueFromOOB_S1 ? `1 valor ${leakedValueFromOOB_S1.type} @${leakedValueFromOOB_S1.offset}` : 'nenhum valor armazenado'; logS1(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME); /* Comentário de Contexto para Exploração: Uma primitiva de leitura OOB confiável que vaza ponteiros válidos é o primeiro passo para contornar o ASLR. A exploração normalmente envolveria: 1. Identificar a qual módulo/região o ponteiro vazado pertence. 2. Calcular o endereço base desse módulo. 3. Com o endereço base, calcular os endereços de funções/gadgets ROP dentro desse módulo. Isso requer conhecimento da arquitetura do processo e dos módulos carregados. */ } return writeSuccess;
        };

        const testOOBUAFPatternS1 = async () => { /* ...código v18... */ // Mantendo a lógica interna igual por ora
            const FNAME = 'testOOBUAFPatternS1'; logS1("--- Iniciando Teste 3: OOB Write -> UAF Pattern ---", 'test', FNAME); const buffer1Size = 64; const buffer2Size = 128; const oobWriteOffset = buffer1Size; const corruptedValue = 0xDEADBEEF; const allocationSize1 = buffer1Size + 128; const baseOffset1 = 64; let buffer1 = null, buffer2 = null; let dv1 = null; let writeOK = false; let uafTriggered = false; try { buffer1 = new ArrayBuffer(allocationSize1); dv1 = new DataView(buffer1); for (let i = 0; i < buffer1.byteLength; i++) dv1.setUint8(i, 0xBB); buffer2 = new ArrayBuffer(buffer2Size); const dv2_init = new DataView(buffer2); for (let i = 0; i < buffer2.byteLength; i++) dv2_init.setUint8(i, 0xCC); await PAUSE_S1_FUNC(); const targetWriteAddr = baseOffset1 + oobWriteOffset; try { if (targetWriteAddr >= 0 && targetWriteAddr + 4 <= buffer1.byteLength) { dv1.setUint32(targetWriteAddr, corruptedValue, true); logS1(`VULN: Escrita OOB U32 @${oobWriteOffset} (addr ${targetWriteAddr}) parece OK.`, 'vuln', FNAME); logS1(`---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeOK = true; } else { logS1(`Offset de escrita OOB (${targetWriteAddr}) fora do buffer1.`, 'warn', FNAME); } } catch (e) { logS1(`Escrita OOB U32 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeOK) { await PAUSE_S1_FUNC(); try { const slicedBuffer2 = buffer2.slice(0, 10); const dv2_check = new DataView(buffer2); const lengthCheck = buffer2.byteLength; logS1(`Uso do buffer 2 após escrita OOB parece OK (tamanho: ${lengthCheck}). Nenhuma UAF óbvia detectada.`, 'good', FNAME); } catch (e) { logS1(`---> VULN? ERRO ao usar buffer 2 após escrita OOB: ${e.message}`, 'critical', FNAME); logS1(`---> *** ALERTA: Potencial UAF ou Corrupção de Metadados detectada! O erro ao usar buffer2 PODE indicar sucesso na corrupção. ***`, 'escalation', FNAME); uafTriggered = true; console.error("Erro UAF Pattern:", e); } } } catch (e) { logS1(`Erro fatal no Teste 3 (OOB UAF): ${e.message}`, 'error', FNAME); console.error(e); } finally { buffer1 = null; buffer2 = null; dv1 = null; logS1(`--- Teste 3 Concluído (Escrita OOB: ${writeOK}, Potencial UAF/Erro: ${uafTriggered}) ---`, 'test', FNAME); /* Comentário de Contexto para Exploração: Se uma escrita OOB leva a uma UAF ou corrupção de metadados que pode ser controlada, isso pode ser usado para obter controle do fluxo de execução, por exemplo, sobrescrevendo um ponteiro de função de um objeto liberado antes que ele seja reutilizado. */ } return writeOK && uafTriggered;
        };
        const testOOBOtherTypesS1 = async () => { /* ...código v18... */ // Mantendo lógica interna
            const FNAME = 'testOOBOtherTypesS1'; logS1("--- Iniciando Teste 4: OOB Write/Read (Float64/BigInt64) ---", 'test', FNAME); const bufferSize = 64; const oobWriteOffset = bufferSize; const allocationSize = bufferSize + 128; const baseOffset = 64; let buffer = null; let dv = null; let writeF64OK = false; let writeB64OK = false; let readF64OK = false; let readB64OK = false; try { buffer = new ArrayBuffer(allocationSize); dv = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) dv.setUint8(i, 0xDD); const targetAddr = baseOffset + oobWriteOffset; const writeValF64 = Math.PI; const writeValB64 = BigInt("0x1122334455667788"); logS1(`Tentando escrita OOB Float64 @${oobWriteOffset} (addr ${targetAddr})`, 'info', FNAME); try { if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) { dv.setFloat64(targetAddr, writeValF64, true); logS1(`Escrita OOB Float64 parece OK.`, 'vuln', FNAME); writeF64OK = true; } else { logS1(`Offset F64 OOB (${targetAddr}) fora do buffer.`, 'warn', FNAME);} } catch(e) { logS1(`Escrita OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeF64OK) { try { const readVal = dv.getFloat64(targetAddr, true); if (readVal === writeValF64) { logS1(`Leitura OOB Float64 CONFIRMADA (${readVal}). R/W OK.`, 'vuln', FNAME); logS1(`---> *** ALERTA: Primitivo R/W OOB Float64 confirmado ***`, 'escalation', FNAME); readF64OK = true; } else { logS1(`Leitura OOB Float64 retornou valor inesperado: ${readVal}`, 'warn', FNAME); } } catch(e) { logS1(`Leitura OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } } await PAUSE_S1_FUNC(); if (typeof DataView.prototype.setBigInt64 !== 'undefined') { logS1(`Tentando escrita OOB BigInt64 @${oobWriteOffset} (addr ${targetAddr})`, 'info', FNAME); try { if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) { dv.setBigInt64(targetAddr, writeValB64, true); logS1(`Escrita OOB BigInt64 parece OK.`, 'vuln', FNAME); writeB64OK = true; } else { logS1(`Offset B64 OOB (${targetAddr}) fora do buffer.`, 'warn', FNAME);} } catch(e) { logS1(`Escrita OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeB64OK) { try { const readVal = dv.getBigInt64(targetAddr, true); if (readVal === writeValB64) { logS1(`Leitura OOB BigInt64 CONFIRMADA (0x${readVal.toString(16)}). R/W OK.`, 'vuln', FNAME); logS1(`---> *** ALERTA: Primitivo R/W OOB BigInt64 confirmado ***`, 'escalation', FNAME); readB64OK = true; } else { logS1(`Leitura OOB BigInt64 retornou valor inesperado: 0x${readVal.toString(16)}`, 'warn', FNAME); } } catch(e) { logS1(`Leitura OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } } } else { logS1("BigInt64 em DataView não suportado neste navegador.", 'warn', FNAME); } } catch(e) { logS1(`Erro fatal no Teste 4 (OOB Types): ${e.message}`, 'error', FNAME); console.error(e); } finally { buffer = null; dv = null; logS1(`--- Teste 4 Concluído (F64 R/W: ${readF64OK}, B64 R/W: ${readB64OK}) ---`, 'test', FNAME); /* Comentário de Contexto para Exploração: Primitivas de Leitura/Escrita OOB estáveis para diferentes tipos de dados são versáteis. Elas podem ser usadas para vazar informações (ler ponteiros, dados sensíveis) ou corromper memória (escrever sobre ponteiros de função, metadados de objetos, etc.) como parte de uma cadeia de exploração maior. */ }
        };
        const testBasicPPS1 = async () => { /* ...código v18... */
            const FNAME = 'testBasicPPS1'; logS1("--- Iniciando Teste 5: PP (Básica) ---", 'test', FNAME); const prop = '__pp_basic__'; const val = 'Polluted!'; let ok = false; let testObj = null; try { Object.prototype[prop] = val; await PAUSE_S1_FUNC(); testObj = {}; const inheritedValue = testObj[prop]; if (inheritedValue === val) { logS1(`VULN: PP Básica OK! Objeto herdou a propriedade poluída.`, 'vuln', FNAME); ok = true; } else { logS1(`PP Básica falhou ou não detectada.`, 'good', FNAME); } } catch (e) { logS1(`Erro durante teste PP Básico: ${e.message}`, 'error', FNAME); console.error(e); } finally { try { delete Object.prototype[prop]; } catch(e){ logS1(`Erro ao limpar Object.prototype.${prop}: ${e.message}`, 'error', FNAME); } } logS1(`--- Teste 5 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test', FNAME); return ok;
        };
        const testPPJsonHijackS1 = async () => { /* ...código v18... */
            const FNAME = 'testPPJsonHijackS1'; logS1("--- Iniciando Teste 6: PP Hijack (JSON.stringify) ---", 'test', FNAME); const orig = JSON.stringify; let okH = false; let okL = false; let okR = false; try { JSON.stringify = function hijacked(v, r, s) { logS1("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln', FNAME); okH = true; try { const l = leakedValueFromOOB_S1; let lStr = "NULO ou Indefinido"; if (l) { lStr = l.type === 'U64' ? `U64 H=${toHexS1(l.high)} L=${toHexS1(l.low)} @${l.offset}` : `U32 ${toHexS1(l.low)} @${l.offset}`; okL = true; logS1(` ---> INFO: Interação Hijack + OOB Read Leak OK.`, 'escalation', FNAME); } logS1(` -> Valor OOB lido: ${lStr}`, okL ? 'leak' : 'warn', FNAME); } catch(ie) { logS1(` -> Erro ao tentar ler leak OOB: ${ie.message}`, 'error', FNAME); console.error(ie); } const hijackReturnValue = '{"hijacked": true, "leak_read_success": ' + okL + '}'; return hijackReturnValue; }; await PAUSE_S1_FUNC(); const testObject = {a:1, b: 'test'}; const result = JSON.stringify(testObject); if (result && result.includes('"hijacked": true')) { logS1("VULN: Retorno da função JSON.stringify sequestrada verificado!", 'vuln', FNAME); okR = true; } else if (okH) { logS1("AVISO: JSON.stringify sequestrado, mas retorno inesperado.", 'warn', FNAME); } else { logS1("JSON.stringify não foi sequestrado.", 'good', FNAME); } } catch (e) { logS1(`Erro fatal durante Teste 6: ${e.message}`, 'error', FNAME); console.error(e); } finally { const currentStringify = JSON.stringify; JSON.stringify = orig; if (currentStringify !== orig && JSON.stringify !== orig) { logS1("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'critical', FNAME); } else { logS1("JSON.stringify restaurado.", 'good', 'Cleanup');} } logS1(`--- Teste 6 Concluído (Hijack: ${okH}, Retorno: ${okR}, Leitura Leak: ${okL}) ---`, 'test', FNAME); return okR && okL;
        };
        const testWebSocketsS1 = async () => { /* ...código v18... */
            const FNAME = 'testWebSocketsS1'; logS1("--- Iniciando Teste 7: WebSockets ---", 'test', FNAME); const wsUrl = "wss://websocket-echo.com/"; let ws = null; let connected = false; let messageReceived = false; let errorOccurred = false; const ppProp = '__ws_polluted__'; Object.prototype[ppProp] = 'WS Polluted!'; let ppDetected = false; const connectionPromise = new Promise((resolve, reject) => { try { ws = new WebSocket(wsUrl); try { if (ws && ws[ppProp] === 'WS Polluted!') { logS1(`VULN: PP afetou instância WebSocket ('${ppProp}')!`, 'vuln', FNAME); ppDetected = true; } delete Object.prototype[ppProp]; } catch(e){} ws.onopen = (event) => { logS1("WebSocket Conectado!", 'good', FNAME); connected = true; try { const testMsg = "Hello WebSocket Test " + Date.now(); ws.send(testMsg); try { ws.send(new Blob(["blob data"])); } catch(e) {} try { ws.send(new ArrayBuffer(16)); } catch(e) {} try { const largeSize = 1 * 1024 * 1024; const largeBuffer = new Uint8Array(largeSize).fill(0x41); ws.send(largeBuffer); } catch(e) {} } catch (e) { logS1(`Erro ao enviar mensagem: ${e.message}`, 'error', FNAME); errorOccurred = true; reject(e); } }; ws.onmessage = (event) => { logS1(`Mensagem recebida: ${String(event.data).substring(0, 100)}${String(event.data).length > 100 ? '...' : ''}`, 'good', FNAME); messageReceived = true; if (ws && ws.readyState === WebSocket.OPEN) { ws.close(1000, "Test Completed"); } resolve(); }; ws.onerror = (event) => { logS1(`Erro no WebSocket: ${event.type}`, 'error', FNAME); errorOccurred = true; reject(new Error("WebSocket onerror triggered")); }; ws.onclose = (event) => { logS1(`WebSocket Fechado. Code: ${event.code}, Reason: "${event.reason}", Clean: ${event.wasClean}`, event.wasClean ? 'good' : 'warn', FNAME); if (!connected && !errorOccurred) reject(new Error("WS fechado antes de conectar/msg.")); else resolve(); }; setTimeout(() => { if (!connected || !messageReceived) { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1001, "Timeout"); } catch(e){} reject(new Error("WebSocket timeout")); } }, 10000); } catch (e) { logS1(`Erro CRÍTICO ao criar WebSocket: ${e.message}`, 'critical', FNAME); errorOccurred = true; console.error(e); reject(e); } }); try { await connectionPromise; } catch(e) { } finally { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1000, "Cleanup"); } catch (e) {} ws = null; delete Object.prototype[ppProp]; logS1(`--- Teste 7 Concluído (Conectado: ${connected}, Msg OK: ${messageReceived}, Erro: ${errorOccurred}, PP Detect: ${ppDetected}) ---`, 'test', FNAME); }
        };
        const testWebWorkersS1 = async () => { /* ...código v18... */
            const FNAME = 'testWebWorkersS1'; logS1("--- Iniciando Teste 8: Web Workers ---", 'test', FNAME); let worker = null; let workerReplied = false; let workerError = false; let ppDetectedWorker = false; const ppPropWorker = '__worker_polluted__'; Object.prototype[ppPropWorker] = 'Worker Polluted!'; const workerCode = ` self.onmessage = function(e) { let response = 'Worker received: ' + e.data; try { if (self.${ppPropWorker} === 'Worker Polluted!') { response += ' [PP Detected In Worker!]'; } } catch(err) {} self.postMessage(response); }; try { if (self.${ppPropWorker} === 'Worker Polluted!') { self.postMessage('PP Detected on Worker Self!'); } } catch(e){} `; const workerPromise = new Promise((resolve, reject) => { try { const blob = new Blob([workerCode], { type: 'application/javascript' }); const blobUrl = URL.createObjectURL(blob); worker = new Worker(blobUrl); try { if (worker && worker[ppPropWorker] === 'Worker Polluted!') { logS1(`VULN: PP afetou instância Worker main thread ('${ppPropWorker}')!`, 'vuln', FNAME); ppDetectedWorker = true; } } catch(e){} worker.onmessage = (event) => { logS1(`Mensagem do Worker: "${event.data}"`, 'good', FNAME); if (event.data.includes('Worker Polluted!')) { logS1(`VULN: PP detectada DENTRO worker/comunicação!`, 'vuln', FNAME); ppDetectedWorker = true; } workerReplied = true; resolve(); }; worker.onerror = (event) => { logS1(`Erro no Worker: ${event.message} em ${event.filename}:${event.lineno}`, 'error', FNAME); workerError = true; reject(event.error || new Error(event.message)); }; worker.postMessage("Hello Worker " + Date.now()); setTimeout(() => { if (!workerReplied) { workerError = true; reject(new Error("Worker timeout")); } }, 5000); URL.revokeObjectURL(blobUrl); } catch (e) { logS1(`Erro CRÍTICO criar/comunicar Worker: ${e.message}`, 'critical', FNAME); workerError = true; console.error(e); reject(e); } finally { delete Object.prototype[ppPropWorker]; } }); try { await workerPromise; } catch(e) { } finally { try { if (worker) worker.terminate(); } catch(e) {} worker = null; delete Object.prototype[ppPropWorker]; logS1(`--- Teste 8 Concluído (Resposta OK: ${workerReplied}, Erro: ${workerError}, PP Detect: ${ppDetectedWorker}) ---`, 'test', FNAME); }
        };
        const testIndexedDBS1 = async () => { /* ...código v18... */
            const FNAME = 'testIndexedDBS1'; logS1("--- Iniciando Teste 9: IndexedDB ---", 'test', FNAME); const dbName = "TestDB_v19"; const storeName = "TestStore"; let db = null; let errorMsg = null; let addOK = false; let getOK = false; let deleteOK = false; let addComplexOK = false;
            try { await new Promise((resolve, reject) => { logS1("Tentando deletar DB antigo (se existir)...", 'info', FNAME); const deleteRequest = indexedDB.deleteDatabase(dbName); deleteRequest.onsuccess = () => { logS1("DB antigo deletado ou não existia.", 'good', FNAME); resolve(); }; deleteRequest.onerror = (e) => { logS1(`Erro ao deletar DB antigo: ${e.target.error}`, 'warn', FNAME); resolve(); }; deleteRequest.onblocked = () => { logS1("Deleção do DB bloqueada (conexões abertas?).", 'warn', FNAME); resolve(); }; setTimeout(() => reject(new Error("Timeout deletando DB")), 3000); }).catch(e => logS1(`Timeout/Erro na deleção prévia: ${e.message}`, 'warn', FNAME)); } catch(e) {logS1("Erro inesperado na deleção prévia.", 'warn', FNAME);}
            await PAUSE_S1_FUNC();
            try { logS1("Abrindo/Criando IndexedDB...", 'info', FNAME); db = await new Promise((resolve, reject) => { const request = indexedDB.open(dbName, 1); request.onupgradeneeded = (event) => { logS1("Evento onupgradeneeded disparado.", 'info', FNAME); try { const dbInstance = event.target.result; if (!dbInstance.objectStoreNames.contains(storeName)) { logS1(`Criando object store: ${storeName}`, 'info', FNAME); dbInstance.createObjectStore(storeName, { keyPath: "id" }); } } catch (e) { logS1(`Erro durante onupgradeneeded: ${e.message}`, 'error', FNAME); errorMsg = `Upgrade error: ${e.message}`; reject(e); } }; request.onsuccess = (event) => { logS1("IndexedDB aberto com sucesso.", 'good', FNAME); resolve(event.target.result); }; request.onerror = (event) => { logS1(`Erro ao abrir IndexedDB: ${event.target.error}`, 'error', FNAME); errorMsg = `Open error: ${event.target.error}`; reject(event.target.error); }; setTimeout(() => reject(new Error("Timeout abrindo DB")), 5000); });
                if (db) { logS1("Testando adicionar registro simples...", 'info', FNAME); const addData = { id: "simple_" + Date.now(), name: "TestData", value: Math.random() }; const addResult = await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readwrite"); const store = transaction.objectStore(storeName); const request = store.add(addData); request.onsuccess = (event) => { addOK = true; resolve(addData.id); }; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Add Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout add simples")), 3000); } catch (e) { reject(e); } }); logS1(`Adicionar registro simples ${addOK ? 'OK' : 'FALHOU'}. ID: ${addResult}`, addOK ? 'good' : 'error', FNAME);
                    if (addOK && addResult) { logS1("Testando ler registro simples...", 'info', FNAME); const getResult = await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readonly"); const store = transaction.objectStore(storeName); const request = store.get(addResult); request.onsuccess = (event) => { getOK = (event.target.result != null); resolve(event.target.result); }; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Get Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout get simples")), 3000); } catch (e) { reject(e); } }); logS1(`Ler registro simples ${getOK ? 'OK' : 'FALHOU'}.`, getOK ? 'good' : 'error', FNAME);
                        if (getOK) { logS1("Testando deletar registro simples...", 'info', FNAME); await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readwrite"); const store = transaction.objectStore(storeName); const request = store.delete(addResult); request.onsuccess = () => { deleteOK = true; }; transaction.oncomplete = resolve; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Delete Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout delete simples")), 3000); } catch (e) { reject(e); } }); logS1(`Deletar registro simples ${deleteOK ? 'OK' : 'FALHOU'}.`, deleteOK ? 'good' : 'error', FNAME); } }
                    logS1("Testando adicionar Blob e ArrayBuffer...", 'info', FNAME); const blobData = new Blob(['Test Blob Data S1 - ' + Date.now()], {type: 'text/plain'}); const bufferData = new Uint8Array([10, 20, 30, 40, Date.now() % 256]).buffer;
                    try { await new Promise(async (resolve, reject) => { const transaction = db.transaction([storeName], "readwrite"); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Add Complex: ${event.target.error}`)); transaction.oncomplete = resolve; const store = transaction.objectStore(storeName); store.put({ id: 'blob_test', data: blobData }); store.put({ id: 'buffer_test', data: bufferData }); setTimeout(() => reject(new Error("Timeout add complex")), 4000); }); addComplexOK = true; logS1("Adicionar/Put Blob e ArrayBuffer parece OK.", 'good', FNAME); } catch(e) { logS1(`Erro ao adicionar/put Blob/ArrayBuffer: ${e?.message || String(e)}`, 'error', FNAME); errorMsg = errorMsg || `Add complex failed: ${e?.message || String(e)}`; } }
            } catch (e) { logS1(`Erro GERAL no teste IndexedDB: ${e?.message || String(e)}`, 'error', FNAME); if (!errorMsg) errorMsg = e?.message || String(e); console.error("IndexedDB Error:", e); } finally { logS1("Fechando conexão IndexedDB (se aberta)...", 'info', FNAME); try { if (db) db.close(); } catch (e) {} db = null; logS1(`--- Teste 9 Concluído (Add Simples: ${addOK}, Get: ${getOK}, Del: ${deleteOK}, Add Complex: ${addComplexOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME); }
        };
        const testDOMStressS1 = async () => { /* ...código v18... */
            const FNAME = 'testDOMStressS1'; logS1("--- Iniciando Teste 10: DOM Stress ---", 'test', FNAME); const container = document.body; const elementCount = 200; const cycles = 5; let errors = 0; logS1(`Iniciando ${cycles} ciclos de stress com ${elementCount} elementos...`, 'info', FNAME); try { for (let c = 0; c < cycles; c++) { logS1(`Ciclo ${c + 1}/${cycles}...`, 'info', FNAME); const elements = []; for (let i = 0; i < elementCount; i++) { try { const el = document.createElement('div'); el.textContent = `Stress-${c}-${i}`; el.style.position = 'absolute'; el.style.left = `${(i * 5) % 300}px`; el.style.top = `-${10 + (c*2)}px`; el.style.color = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`; container.appendChild(el); elements.push(el); } catch (e) { errors++; logS1(`Erro ao criar/adicionar el ${i}: ${e.message}`, 'warn', FNAME); } } await PAUSE_S1_FUNC(50); elements.forEach(el => { try { container.removeChild(el); } catch(e) { errors++; } }); await PAUSE_S1_FUNC(10); } logS1("Ciclos de stress concluídos.", 'good', FNAME); } catch (e) { logS1(`Erro GERAL durante DOM Stress: ${e.message}`, 'error', FNAME); errors++; console.error("DOM Stress Error:", e); } finally { logS1(`--- Teste 10 Concluído (Erros reportados: ${errors}) ---`, 'test', FNAME); }
        };

        const runAllTestsS1 = async () => {
            const FNAME = 'runAllTestsS1';
            if (runBtnS1) runBtnS1.disabled = true;
            outputDivS1.innerHTML = '';
            logS1("==== INICIANDO Script 1 (v19.0 - Arsenal Expandido) ====", 'test', FNAME);
            await testCSPBypassS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testOOBReadInfoLeakEnhancedStoreS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testOOBUAFPatternS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testOOBOtherTypesS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testBasicPPS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testPPJsonHijackS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testWebSocketsS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testWebWorkersS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testIndexedDBS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            await testDOMStressS1(); await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            logS1("\n==== Script 1 CONCLUÍDO (v19.0) ====", 'test', FNAME);
            if (runBtnS1) runBtnS1.disabled = false;
        };
    </script>

    <script>
        // --- Script 2: Canvas (v19.0 - Arsenal Expandido) ---
        const SHORT_PAUSE_CANVAS_S2 = 50;
        const MEDIUM_PAUSE_S2 = 500; // Adicionado para consistência
        let canvasClickListenerS2 = null;
        let canvasMoveListenerS2 = null;
        let currentHoverTargetS2 = null;
        
        // Mantendo estrutura similar ao original para áreas e quadrados
        const interactiveAreasS2 = [
            { id: 'rect-log-s2', x: 10, y: 10, w: 70, h: 25, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Clk' },
            { id: 'rect-link-s2', x: 90, y: 10, w: 80, h: 25, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' },
            { id: 'rect-rerun-s2', x: 180, y: 10, w: 100, h: 25, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' }
        ];
        
        const imgSquareSizeS2 = 28;
        const imgSquareSpacingS2 = 5;
        const imgSquaresS2 = []; // Será populado em runCanvasTestSequenceS2
        const imgSquaresStartYS2 = 45;

        let currentLeakDataS2 = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvasS2 = null;
        let coordStatusDivS2 = null;
        let canvasElementS2 = null;
        let ctxS2 = null;
        let glContextS2 = null;
        let isWebGL2S2 = false;
        let gpuAdapterS2 = null;
        let gpuDeviceS2 = null;

        const logCanvasS2 = (message, type = 'info', funcName = '') => {
            generalUtils.logToDiv('output-canvas', message, type, funcName);
        };

        const PAUSE_S2_FUNC = (ms = SHORT_PAUSE_CANVAS_S2) => new Promise(r => setTimeout(r, ms));
        const toHexCanvasS2 = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let n = Number(val);
            if (bits <= 32) { n >>>= 0; }
            const p = Math.ceil(bits / 4);
            return '0x' + n.toString(16).toUpperCase().padStart(p, '0');
        };
        // Funções de checagem de ponteiro/dado (podem ser as mesmas do S1 ou específicas)
        const isPotentialPointer64_S2_FUNC = (high, low) => isPotentialPointer64S1(high,low);
        const isPotentialData32_S2_FUNC = (val) => isPotentialData32S1(val);

        const drawInteractiveAreasS2 = () => {
            if (!ctxS2) return;
            try {
                interactiveAreasS2.forEach(a => {
                    ctxS2.fillStyle = (currentHoverTargetS2 === a.id) ? a.hoverColor : a.color;
                    ctxS2.fillRect(a.x, a.y, a.w, a.h);
                    ctxS2.fillStyle = "#FFF";
                    ctxS2.font = "bold 10px mono";
                    ctxS2.textAlign = "center";
                    ctxS2.textBaseline = "middle";
                    ctxS2.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 1);
                });
                ctxS2.textAlign = "start";
                ctxS2.textBaseline = "alphabetic";
            } catch (e) { logCanvasS2(`Erro drawAreasS2: ${e.message}`, 'error', 'drawInteractiveAreasS2'); }
        };

        const drawImageSquaresS2 = () => {
            if (!ctxS2) return;
            try {
                imgSquaresS2.forEach(sq => {
                    ctxS2.fillStyle = sq.hover ? '#FFFF88' : sq.color;
                    ctxS2.fillRect(sq.x, sq.y, sq.size, sq.size);
                    ctxS2.strokeStyle = '#AAA';
                    ctxS2.lineWidth = 1;
                    ctxS2.strokeRect(sq.x, sq.y, sq.size, sq.size);
                    if (sq.text) {
                        ctxS2.fillStyle = "#FFF";
                        ctxS2.font = "bold 9px mono";
                        ctxS2.textAlign = "center";
                        ctxS2.textBaseline = "middle";
                        ctxS2.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2);
                    }
                    if (sq.url) { // Se houver URL, pode indicar de forma diferente
                        ctxS2.fillStyle = "#6cf";
                        ctxS2.font = "bold 8px mono";
                        ctxS2.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - 6);
                    }
                });
                ctxS2.textAlign = "start";
                ctxS2.textBaseline = "alphabetic";
            } catch (e) { logCanvasS2(`Erro drawImageSquaresS2: ${e.message}`, 'error', 'drawImageSquaresS2'); }
        };

        const redrawAllS2 = () => {
            if (!ctxS2 || !canvasElementS2) return;
            try {
                ctxS2.save();
                ctxS2.clearRect(0, 0, canvasElementS2.width, canvasElementS2.height);
                ctxS2.fillStyle = "#334"; // Fundo do canvas
                ctxS2.fillRect(0, 0, canvasElementS2.width, canvasElementS2.height);
                drawInteractiveAreasS2();
                drawImageSquaresS2();
                ctxS2.fillStyle = currentLeakDataS2.color;
                ctxS2.font = "10px mono";
                ctxS2.textAlign = "start";
                ctxS2.fillText(currentLeakDataS2.text, 10, canvasElementS2.height - 5);
                ctxS2.restore();
            } catch (e) { logCanvasS2(`Erro redrawAllS2: ${e.message}`, 'error', 'redrawAllS2'); }
        };

        // --- Funções de Teste do Script 2 (Adaptadas do original) ---

        const testWebGLCheckS2 = async () => {
            const FNAME = 'testWebGLCheckS2'; logCanvasS2("--- Teste: Verificação WebGL ---",'test', FNAME); glContextS2=null; isWebGL2S2=false; try { glContextS2=canvasElementS2.getContext('webgl')||canvasElementS2.getContext('experimental-webgl'); if(glContextS2){ const glVersion = glContextS2.getParameter(glContextS2.VERSION); logCanvasS2(`WebGL OK! V:${glVersion.substring(0,30)}`, 'good', FNAME); try{ let gl2=canvasElementS2.getContext('webgl2'); if(gl2){ const gl2Version = gl2.getParameter(gl2.VERSION); logCanvasS2(`WebGL2 OK! V:${gl2Version.substring(0,30)}`, 'good', FNAME); isWebGL2S2=true; glContextS2 = gl2; /* Prioritize WebGL2 if available for other tests */ } else { logCanvasS2("WebGL2 não disponível.", 'good', FNAME); } }catch(e2){ logCanvasS2("WebGL2 não disponível (erro check).", 'good', FNAME); } }else{ logCanvasS2('WebGL N/A.', 'good', FNAME); } }catch(e){ logCanvasS2(`Erro ao verificar WebGL: ${e.message}`, 'error', FNAME); console.error(e); glContextS2=null; } logCanvasS2(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContextS2}, WebGL2: ${isWebGL2S2}) ---`, 'test', FNAME); await PAUSE_S2_FUNC();
        };

        const testAdvancedPPS2 = async () => {
            const FNAME = 'testAdvancedPPS2'; logCanvasS2("--- Teste: PP Avançado (Gadgets++) ---", 'test', FNAME);
            const propsToPollute = [ { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' }, { name: 'hasOwnProperty', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => { try{({}).hasOwnProperty('a'); return null;} catch(e){ return `Object.hasOwnProperty quebrou! ${e.message}`;} } }, { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'outerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'textContent', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div') }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'onload', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onload === v ? 'PP afetou handler `onload`!' : null, createTarget: () => document.createElement('img') }, { name: 'appendChild', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.appendChild(document.createElement('span')); return null; } catch(e){ return `Node.appendChild quebrou! ${e.message}`;} } }, { name: 'addEventListener', proto: EventTarget.prototype, protoName: 'EventTarget', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.addEventListener('test', ()=>{}); return null; } catch(e){ return `EventTarget.addEventListener quebrou! ${e.message}`;} } }, { name: 'value', proto: HTMLInputElement.prototype, protoName: 'HTMLInputElement', createTarget: () => document.createElement('input'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou input.value!' : null }, { name: 'value', proto: HTMLTextAreaElement.prototype, protoName: 'HTMLTextAreaElement', createTarget: () => document.createElement('textarea'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou textarea.value!' : null }, { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'filter', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].filter(()=>{}); return null;} catch(e){ return `Array.filter quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'forEach', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].forEach(()=>{}); return null;} catch(e){ return `Array.forEach quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'join', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[1,2].join(); return null;} catch(e){ return `Array.join quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} }, ];
            const testValue = "PP_Adv_Polluted_" + Date.now(); let successCount = 0; let gadgetCount = 0; let gadgetMessages = [];
            for (const item of propsToPollute) { if (!item.proto) { continue; } const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName; let inherited = false; let gadgetMsg = null; let errorMsg = null; let originalValue = undefined; let wasDefined = false; try { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } catch (e) { logCanvasS2(`AVISO: Erro check/get original ${targetProtoName}.${prop}: ${e.message}`, 'warn', FNAME); continue; } try { targetProto[prop] = testValue; let obj; if (item.createTarget) { try { obj = item.createTarget(); } catch (e) { obj = {}; } } else { obj = {}; } let inheritedValue = undefined; try { inheritedValue = obj[prop]; } catch (e) {} if (inheritedValue === testValue) { logCanvasS2(`-> VULN: Herança PP para '${targetProtoName}.${prop}' OK.`, 'vuln', FNAME); inherited = true; successCount++; if (item.gadgetCheck) { try { gadgetMsg = item.gadgetCheck(obj, testValue); } catch(e){} if (gadgetMsg) { logCanvasS2(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME); gadgetMessages.push(prop + ": " + gadgetMsg); gadgetCount++; if (['innerHTML', 'outerHTML', 'src', 'href', 'onclick', 'onerror', 'onload', 'value', 'postMessage', 'send', 'call', 'apply', 'map', 'filter', 'forEach', 'appendChild', 'addEventListener', 'hasOwnProperty', 'join'].includes(prop)) { logCanvasS2(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para '${prop}'! ***`, 'escalation', FNAME); } } } } else { if (prop === '__proto__') { logCanvasS2(`-> FAIL: Herança de '__proto__' não OK (Esperado).`, 'good', FNAME); } } } catch (e) { logCanvasS2(`Erro ao poluir/testar '${targetProtoName}.${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; } finally { try { let cleanupOK = true; if (wasDefined) { targetProto[prop] = originalValue; try { if (targetProto[prop] !== originalValue) cleanupOK = false; } catch(e){ cleanupOK = false; } } else { delete targetProto[prop]; if (Object.prototype.hasOwnProperty.call(targetProto, prop)) cleanupOK = false; } if (!cleanupOK) { logCanvasS2(`---> CRITICAL: FALHA ao limpar/restaurar ${targetProtoName}.${prop}! Estado pode estar inconsistente. <---`, 'critical', FNAME); } } catch (e) { logCanvasS2(`AVISO CRÍTICO: Erro INESPERADO ao limpar/restaurar ${targetProtoName}.${prop}: ${e.message}`, 'critical', FNAME); } } await PAUSE_S2_FUNC(15); }
            logCanvasS2(`--- Teste PP Avançado Concluído (${successCount} OK, ${gadgetCount} gadgets encontrados) ---`, 'test', FNAME); if (gadgetCount > 0) { logCanvasS2(`Gadgets detectados: ${gadgetMessages.join('; ')}`, 'critical', FNAME); } await PAUSE_S2_FUNC();
        };

        const testOOBReadEnhancedS2 = async () => {
            const FNAME = 'testOOBReadEnhancedS2'; logCanvasS2("--- Teste: OOB Read Enhanced Scan ---",'test', FNAME); const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128; const allocationSize = bufferSize + 512; const baseOffsetInBuffer = 256; let potentialLeakFoundCount=0; const foundPointers=[]; try{ const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer); for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); } for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){ const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){ try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue; if(isPotentialPointer64_S2_FUNC(high,low)){ const valueStr=`H=${toHexCanvasS2(high,32)} L=${toHexCanvasS2(low,32)}`; logCanvasS2(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U64', high, low, hex:valueStr}; foundPointers.push(leakInfo); logCanvasS2(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); logCanvasS2(` ---> INSIGHT: O valor vazado ${valueStr} (U64) em ${relOffsetStr} é um candidato a ponteiro. (...)`, 'info', FNAME); } }catch(e){} } else if(readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){ try{ const val32=dataView.getUint32(readTargetAddress,true); if (val32 === 0xCCCCCCCC) continue; let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64'); if(!alreadyLoggedAsPtr64 && isPotentialData32_S2_FUNC(val32) && !isPotentialPointer64_S2_FUNC(0,val32)){ logCanvasS2(` -> Leak U32? ${relOffsetStr}: ${toHexCanvasS2(val32,32)}`,'leak', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U32', value:val32, hex:toHexCanvasS2(val32)}; foundPointers.push(leakInfo); logCanvasS2(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } }catch(e){} } if(readOffset % 64 === 0) await PAUSE_S2_FUNC(1); } }catch(e){ logCanvasS2(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); } finally { logCanvasS2(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais encontrados) ---`,'test', FNAME); if(foundPointers.length === 0){ logCanvasS2("Nenhum leak potencial óbvio encontrado.", 'good', FNAME); } else { console.log("Potenciais Leaks (OOB Read Enhanced S2):", foundPointers); } } await PAUSE_S2_FUNC(); return foundPointers;
        };

        const testOOBWriteMetadataS2 = async () => {
            const FNAME = 'testOOBWriteMetadataS2'; logCanvasS2("--- Teste: OOB Write -> Metadata (ArrayBuffer.byteLength) ---",'test', FNAME); const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE; const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false; const allocationSize = controlBufferSize + 256; const baseOffsetInBuffer = 128; let foundOffset=-1; let finalResultLog = `AVISO: Escrita OOB realizada (${writeSuccessCount}x), mas nenhuma corrupção de byteLength detectada.`; try{ controlBuffer=new ArrayBuffer(allocationSize); dv=new DataView(controlBuffer); for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvasS2(`Erro fatal alocar buffer ctrl: ${e.message}`, 'error', FNAME); return; } logCanvasS2(`Alocando ${sprayCount} buffers alvo de ${targetBufferSize} bytes...`, 'info', FNAME); for(let i=0; i<sprayCount; i++){ try{ targetBuffers.push(new ArrayBuffer(targetBufferSize)); }catch(e){}} await PAUSE_S2_FUNC(); const metadataOffsetsToTry=[-8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32]; for(const tryOffset of metadataOffsetsToTry){ const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset; const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`; logCanvasS2(`Tentando offset OOB metadata: ${tryOffset}... Addr: ${targetWriteAddr}`, 'info', FNAME); let currentWriteOK=false; try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, targetValue, true); writeSuccessCount++; currentWriteOK=true; logCanvasS2(` -> Escrita OOB U32 em ${relOffsetStr} parece OK.`, 'info', FNAME); } else { logCanvasS2(` -> Offset OOB ${relOffsetStr} fora dos limites.`, 'warn', FNAME); } }catch(e){ logCanvasS2(` -> Escrita OOB U32 falhou/bloqueada em ${relOffsetStr}: ${e.message}`, 'good', FNAME); }
                if(currentWriteOK){ logCanvasS2(` -> Verificando ${targetBuffers.length} buffers alvo...`, 'info', FNAME); await PAUSE_S2_FUNC(5); for(let j=0; j<targetBuffers.length; j++){ try { const currentLength = targetBuffers[j]?.byteLength; if(currentLength === targetValue){ logCanvasS2(`---> VULN: ArrayBuffer alvo ${j} teve byteLength CORROMPIDO para ${toHexCanvasS2(targetValue)} com escrita OOB em ${relOffsetStr}!`, 'critical', FNAME); corruptionSuccess=true; foundOffset=tryOffset; finalResultLog = `SUCESSO! byteLength corrompido usando offset relativo ctrlEnd+${foundOffset}.`;
                    try { const corruptedTargetBuffer = targetBuffers[j]; const corruptedDv = new DataView(corruptedTargetBuffer); const originalTargetSize = targetBufferSize; const readWriteOffset = originalTargetSize + 4; if (readWriteOffset < corruptedTargetBuffer.byteLength - 4) { const testPattern = 0x12345678; logCanvasS2(` -> Tentando R/W (${toHexCanvasS2(testPattern)}) via buffer corrompido ${j} @ offset ${readWriteOffset}...`, 'info', FNAME); corruptedDv.setUint32(readWriteOffset, testPattern, true); const readBack = corruptedDv.getUint32(readWriteOffset, true); if (readBack === testPattern) { logCanvasS2(` ---> SUCESSO DEMO: R/W além dos limites originais do ArrayBuffer ${j} CONFIRMADA! (Leu ${toHexCanvasS2(readBack)})`, 'vuln', FNAME); logCanvasS2(` ---> *** ALERTA: Primitiva de R/W Arbitrária (limitada ao novo tamanho ${toHexCanvasS2(corruptedTargetBuffer.byteLength)}) obtida! ***`, 'escalation', FNAME); } else { logCanvasS2(` -> AVISO DEMO: Escrita no buffer ${j} corrompido @ ${readWriteOffset} falhou na verificação (leu ${toHexCanvasS2(readBack)}).`, 'warn', FNAME); } } else { logCanvasS2(` -> INFO DEMO: Offset de teste ${readWriteOffset} fora do novo tamanho ${corruptedTargetBuffer.byteLength}.`, 'info', FNAME); } } catch (eDemo) { logCanvasS2(` -> ERRO DEMO: Erro R/W estendido no buffer ${j} corrompido: ${eDemo.message}`, 'error', FNAME); } break; } } catch(eCheck) { logCanvasS2(`Erro ao verificar buffer alvo ${j}: ${eCheck.message}`, 'error', FNAME); } } try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); /* Restore original pattern */ } }catch(eRestore){} } if(corruptionSuccess) break; await PAUSE_S2_FUNC(10); }
            if (!corruptionSuccess && writeSuccessCount === 0) { finalResultLog = `Escrita OOB falhou/bloqueada.`; logCanvasS2(finalResultLog, 'good', FNAME); } else { logCanvasS2(finalResultLog, corruptionSuccess ? 'vuln' : 'warn', FNAME); } logCanvasS2("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME); await PAUSE_S2_FUNC();
        };

        const testWebGLDeeperPlusS2 = async () => {
            const FNAME = 'testWebGLDeeperPlusS2'; if(!glContextS2){ logCanvasS2("--- Teste: WebGL Deep Plus Pulado (WebGL N/A) ---",'test', FNAME); return; } logCanvasS2(`--- Teste: WebGL Deep Plus c/ Checks (${isWebGL2S2?'WebGL2':'WebGL1'}) ---`,'test', FNAME); let gl=glContextS2; let pgm=null, buf=null, vs=null, fs=null, tex=null; let step='init'; let glError=gl.NO_ERROR; const errors=[]; const checkGLError=(s)=>{ let found=false; while((glError=gl.getError())!==gl.NO_ERROR){ let errorString = glError; for(let key in gl) { try{if(gl[key] === glError) { errorString = key; break; }}catch(e){} } const eStr=`GL Err ${errorString} (0x${glError.toString(16)}) after ${s}`; logCanvasS2(eStr,'error', FNAME); errors.push(eStr); found=true; } return !found; }; try{ checkGLError('getParam(VERSION)'); step='compileShaders'; const vsSrc=`attribute vec4 p; void main(){ gl_Position = vec4(p.xy * 0.5, 0.0, 1.0); }`; const fsSrc=`precision mediump float; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, vec2(0.5, 0.5)) * vec4(1.0, ${isWebGL2S2 ? '0.5' : '0.0'}, 0.0, 1.0); }`; vs=gl.createShader(gl.VERTEX_SHADER); if(!vs || !checkGLError('createShader(VS)')) throw new Error('Falha criar VS'); gl.shaderSource(vs,vsSrc); if(!checkGLError('shaderSource(VS)')) throw new Error('Falha source VS'); gl.compileShader(vs); if(!checkGLError('compileShader(VS)')) throw new Error('Falha compile VS'); if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(vs); logCanvasS2(`Erro Compilar VS: ${infoLog}`, 'error', FNAME); throw new Error(`VS Compile: ${infoLog}`); } fs=gl.createShader(gl.FRAGMENT_SHADER); if(!fs || !checkGLError('createShader(FS)')) throw new Error('Falha criar FS'); gl.shaderSource(fs,fsSrc); if(!checkGLError('shaderSource(FS)')) throw new Error('Falha source FS'); gl.compileShader(fs); if(!checkGLError('compileShader(FS)')) throw new Error('Falha compile FS'); if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(fs); logCanvasS2(`Erro Compilar FS: ${infoLog}`, 'error', FNAME); throw new Error(`FS Compile: ${infoLog}`); } step='linkProgram'; pgm=gl.createProgram(); if(!pgm || !checkGLError('createProgram')) throw new Error('Falha createProgram'); gl.attachShader(pgm,vs); if(!checkGLError('attachVS')) throw new Error('Falha attachVS'); gl.attachShader(pgm,fs); if(!checkGLError('attachFS')) throw new Error('Falha attachFS'); gl.linkProgram(pgm); if(!checkGLError('linkProgram')) throw new Error('Falha linkProgram'); if(!gl.getProgramParameter(pgm,gl.LINK_STATUS)){ const infoLog = gl.getProgramInfoLog(pgm); logCanvasS2(`Erro Linkar Programa: ${infoLog}`, 'error', FNAME); throw new Error(`Link: ${infoLog}`); } gl.useProgram(pgm); if(!checkGLError('useProgram')) throw new Error('Falha useProgram'); step='textureSetup'; tex=gl.createTexture(); if(!tex || !checkGLError('createTexture')) throw new Error('Falha createTexture'); gl.bindTexture(gl.TEXTURE_2D,tex); if(!checkGLError('bindTexture')) throw new Error('Falha bindTexture'); if(ctxS2){ ctxS2.save(); ctxS2.fillStyle='lime'; ctxS2.fillRect(50,150,40,40); ctxS2.fillStyle='black'; ctxS2.font='bold 12px mono'; ctxS2.fillText('TEX',55,175); ctxS2.restore(); } await PAUSE_S2_FUNC(20); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasElementS2); if(!checkGLError('texImage2D')) throw new Error('Falha texImage2D'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST); if(!checkGLError('texParamMag')) throw new Error('Falha texParamMag'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST); if(!checkGLError('texParamMin')) throw new Error('Falha texParamMin'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapS')) throw new Error('Falha texParamWrapS'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapT')) throw new Error('Falha texParamWrapT'); step='uniformTex'; const texLoc = gl.getUniformLocation(pgm, 'u_tex'); if(!checkGLError('getUniLocTex')) throw new Error('Falha getUniLocTex'); if(texLoc){ gl.uniform1i(texLoc, 0); if(!checkGLError('uniform1i')) throw new Error('Falha uniform1i'); } step='createBufferDraw'; buf=gl.createBuffer(); if(!buf || !checkGLError('createBuf')) throw new Error('Falha createBuf'); gl.bindBuffer(gl.ARRAY_BUFFER,buf); if(!checkGLError('bindBuf')) throw new Error('Falha bindBuf'); const pos=new Float32Array([-1,-1, 1,-1, -1, 1]); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW); if(!checkGLError('bufData')) throw new Error('Falha bufData'); step='vertexAttrib'; const loc=gl.getAttribLocation(pgm,"p"); if (loc < 0) { checkGLError('getAttribLoc(p)'); throw new Error("Atributo 'p' não encontrado no shader."); } if(!checkGLError('getAttribLoc(p)')) throw new Error('Falha getAttribLoc'); gl.enableVertexAttribArray(loc); if(!checkGLError('enableVA')) throw new Error('Falha enableVA'); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); if(!checkGLError('vertexAttribPtr')) throw new Error('Falha vertexAttribPtr'); step='draw'; const glViewportX = 0; const glViewportY = canvasElementS2.height - 50; const glViewportW = 50; const glViewportH = 50; gl.viewport(glViewportX, glViewportY, glViewportW, glViewportH); if(!checkGLError('viewport')) throw new Error('Falha viewport'); gl.clearColor(0.1, 0.1, 0.2, 1.0); if(!checkGLError('clearColor')) throw new Error('Falha clearColor'); gl.clear(gl.COLOR_BUFFER_BIT); if(!checkGLError('clear')) throw new Error('Falha clear'); gl.activeTexture(gl.TEXTURE0); if(!checkGLError('activeTex')) throw new Error('Falha activeTex'); gl.bindTexture(gl.TEXTURE_2D, tex); if(!checkGLError('bindTexDraw')) throw new Error('Falha bindTexDraw'); gl.drawArrays(gl.TRIANGLES, 0, 3); if(!checkGLError('drawArrays')) { logCanvasS2("drawArrays executado sem erros GL imediatos.", 'good', FNAME); } else { throw new Error('Erro GL após drawArrays'); } if(errors.length === 0){ logCanvasS2("Sequência WebGL básica concluída sem erros GL.", 'good', FNAME); } }catch(e){ logCanvasS2(`Erro fatal WebGL Deep Plus (etapa ${step}): ${e.message}`,'error', FNAME); console.error(e); checkGLError(`error_catch_${step}`); }finally{ if(gl){ try{gl.bindBuffer(gl.ARRAY_BUFFER,null);}catch(e){} try{gl.bindTexture(gl.TEXTURE_2D,null);}catch(e){} try{gl.useProgram(null);}catch(e){} if(pgm && vs){try{gl.detachShader(pgm, vs);}catch(e){}} if(pgm && fs){try{gl.detachShader(pgm, fs);}catch(e){}} if(vs){try{gl.deleteShader(vs);}catch(e){}} if(fs){try{gl.deleteShader(fs);}catch(e){}} if(pgm){try{gl.deleteProgram(pgm);}catch(e){}} if(buf){try{gl.deleteBuffer(buf);}catch(e){}} if(tex){try{gl.deleteTexture(tex);}catch(e){}} } } logCanvasS2("--- Teste WebGL Deep Plus Concluído ---",'test', FNAME); await PAUSE_S2_FUNC();
        };

        const testOOBWriteToImageDataCheckS2 = async () => {
            const FNAME = 'testOOBWriteToImageDataCheckS2'; logCanvasS2("--- Teste: OOB Write -> ImageData Check ---",'test', FNAME); const spraySize=30; const imgDataWidth=10; const imgDataHeight=10; const bufferOOBSize=64; const writeValue1=0x42424242; const writeValue2=0x43434343; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; const sprayedImagesData = []; let bufferOOB=null; let dv=null; let oobWritePerformed = false; let potentialCorruptionDetected = false; let patternMatched = false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); }catch(e){ logCanvasS2(`Erro fatal alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return; } const totalPixels = imgDataWidth * imgDataHeight; const initialByteArray = new Uint8ClampedArray(totalPixels * 4); for (let j = 0; j < initialByteArray.length; j++) { initialByteArray[j] = 255; } for(let i=0; i<spraySize; i++){ try{ let imgData = new ImageData(initialByteArray, imgDataWidth, imgDataHeight); sprayedImagesData.push(imgData); }catch(e){ logCanvasS2(`Aviso: Falha ao alocar ImageData ${i}: ${e.message}`, 'warn', FNAME); break; } } await PAUSE_S2_FUNC(); const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvasS2(`Escrita OOB U32x2 @ ${relOffsetStr} OK (Val=${toHexCanvasS2(writeValue1)}/${toHexCanvasS2(writeValue2)}).`, 'vuln', FNAME); logCanvasS2(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); oobWritePerformed = true; } else { logCanvasS2(`Offset OOB ${relOffsetStr} fora do buffer.`, 'error', FNAME); } }catch(e){ logCanvasS2(`AVISO: Escrita OOB U32x2 falhou/bloqueada @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } await PAUSE_S2_FUNC(); if(!ctxS2){ logCanvasS2("Contexto 2D (ctxS2) não disponível para put/getImageData.", 'warn', FNAME); return; } ctxS2.fillStyle="#111"; ctxS2.fillRect(0, 50, canvasElementS2.width, canvasElementS2.height - 80); const cols = Math.floor((canvasElementS2.width - 10) / (imgDataWidth + 1)); const startY = 60; for(let i=0; i<sprayedImagesData.length; i++){ const gridX = 10 + (i % cols) * (imgDataWidth + 1); const gridY = startY + Math.floor(i / cols) * (imgDataHeight + 1); if (gridY + imgDataHeight > canvasElementS2.height - 15) { continue; } try{ const currentImageData = sprayedImagesData[i]; if (!currentImageData) continue; ctxS2.putImageData(currentImageData, gridX, gridY); const readbackImageData = ctxS2.getImageData(gridX, gridY, imgDataWidth, imgDataHeight); const readbackData = readbackImageData.data; for(let k=0; k < readbackData.length; k += 4){ const r = readbackData[k]; const g = readbackData[k+1]; const b = readbackData[k+2]; const a = readbackData[k+3]; if(r !== 255 || g !== 255 || b !== 255 || a !== 255){ const pixelIndex = k / 4; logCanvasS2(`---> CORRUPÇÃO DETECTADA em ImageData ${i} @ pixel ${pixelIndex}! RGBA=(${r},${g},${b},${a})`, 'critical', FNAME); potentialCorruptionDetected = true; const byte1 = writeValue1 & 0xFF; const byte2 = (writeValue1 >> 8) & 0xFF; const byte3 = (writeValue1 >> 16) & 0xFF; const byte4 = (writeValue1 >> 24) & 0xFF; let matchesPattern = false; if (r === byte1 && g === byte2 && b === byte3 && a === byte4) { matchesPattern = true; logCanvasS2(`     -> Padrão OOB 1 (0x${writeValue1.toString(16)}) detectado!`, 'vuln', FNAME); } if (matchesPattern) { patternMatched = true; logCanvasS2(` ---> *** ALERTA: Padrão OOB Write lido de volta do ImageData! Corrupção Controlada! ***`, 'escalation', FNAME); } break; } } }catch(e){ logCanvasS2(`Erro put/getImageData para ImageData ${i}: ${e.message}`, 'error', FNAME); console.error(`Erro ImgData ${i}:`, e); potentialCorruptionDetected = true; } if(i % 5 === 0) await PAUSE_S2_FUNC(5); } if (patternMatched) { logCanvasS2(`SUCESSO: Corrupção E padrão OOB lido de volta de um ImageData!`, 'vuln', FNAME); } else if (potentialCorruptionDetected) { logCanvasS2(`AVISO: Corrupção/Erro detectado em ImageData, mas padrão OOB não confirmado.`, 'warn', FNAME); logCanvasS2(` ---> *** ALERTA: Corrupção de memória instável afetando ImageData! Investigar. ***`, 'escalation', FNAME); } else if (oobWritePerformed) { logCanvasS2(`Escrita OOB realizada, mas nenhuma corrupção detectada nos ImageDatas.`, 'good', FNAME); } else { logCanvasS2(`Escrita OOB não realizada/falhou e nenhuma corrupção detectada.`, 'good', FNAME); } logCanvasS2("--- Teste OOB Write -> ImageData Check Concluído ---",'test', FNAME); await PAUSE_S2_FUNC();
        };

        const testOOBWriteOnlyS2 = async () => {
            const FNAME = 'testOOBWriteOnlyS2'; logCanvasS2("--- Teste: OOB Write Only (Trigger) ---",'test', FNAME); const bufferOOBSize=64; const writeValue1=0xDEADBEEF; const writeValue2=0xCAFEBABE; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; let bufferOOB=null; let dv=null; let writeSuccess=false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvasS2(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return false; } const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvasS2(`Escrita OOB U32x2 @ ${relOffsetStr} OK.`, 'vuln', FNAME); logCanvasS2(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeSuccess=true; } else { logCanvasS2(`Offset OOB ${relOffsetStr} fora do buffer.`, 'error', FNAME); } }catch(e){ logCanvasS2(`AVISO: Escrita OOB U32x2 falhou/bloqueada @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } logCanvasS2("--- Teste OOB Write Only Concluído ---",'test', FNAME); await PAUSE_S2_FUNC(); return writeSuccess;
        };
        
        const testFileSystemAccessS2 = async () => {
            const FNAME = 'testFileSystemAccessS2'; logCanvasS2("--- Teste: File System Access API Check ---", 'test', FNAME); let apiAvailable = false; let openFilePickerCalled = false; let saveFilePickerCalled = false; let dirPickerCalled = false; let errorMsg = null; if (window.showOpenFilePicker) { logCanvasS2("API showOpenFilePicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showOpenFilePicker().then(handles => { logCanvasS2("showOpenFilePicker resolvido (provavelmente cancelado pelo usuário).", 'vuln', FNAME); }).catch(err => { logCanvasS2(`showOpenFilePicker rejeitado: ${err.name} - ${err.message}`, err.name === 'AbortError' ? 'good' : 'warn', FNAME); }); openFilePickerCalled = true; await PAUSE_S2_FUNC(100); } catch (e) { logCanvasS2(`Erro síncrono showOpenFilePicker: ${e.message}`, 'error', FNAME); errorMsg = e.message; } } else { logCanvasS2("API showOpenFilePicker NÃO disponível.", 'good', FNAME); } await PAUSE_S2_FUNC(MEDIUM_PAUSE_S2); if (window.showSaveFilePicker) { logCanvasS2("API showSaveFilePicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showSaveFilePicker().then(handle => { logCanvasS2("showSaveFilePicker resolvido (provavelmente cancelado pelo usuário).", 'vuln', FNAME); }).catch(err => { logCanvasS2(`showSaveFilePicker rejeitado: ${err.name} - ${err.message}`, err.name === 'AbortError' ? 'good' : 'warn', FNAME); }); saveFilePickerCalled = true; await PAUSE_S2_FUNC(100); } catch (e) { logCanvasS2(`Erro síncrono showSaveFilePicker: ${e.message}`, 'error', FNAME); if (!errorMsg) errorMsg = e.message; } } else { logCanvasS2("API showSaveFilePicker NÃO disponível.", 'good', FNAME); } await PAUSE_S2_FUNC(MEDIUM_PAUSE_S2); if (window.showDirectoryPicker) { logCanvasS2("API showDirectoryPicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showDirectoryPicker().then(handle => { logCanvasS2("showDirectoryPicker resolvido (provavelmente cancelado pelo usuário).", 'vuln', FNAME); }).catch(err => { logCanvasS2(`showDirectoryPicker rejeitado: ${err.name} - ${err.message}`, err.name === 'AbortError' ? 'good' : 'warn', FNAME); }); dirPickerCalled = true; await PAUSE_S2_FUNC(100); } catch (e) { logCanvasS2(`Erro síncrono showDirectoryPicker: ${e.message}`, 'error', FNAME); if (!errorMsg) errorMsg = e.message; } } else { logCanvasS2("API showDirectoryPicker NÃO disponível.", 'good', FNAME); } if (!apiAvailable) { logCanvasS2("API File System Access não disponível.", 'good', FNAME); } else if (errorMsg) { logCanvasS2(`Erro encontrado ao chamar APIs File System Access: ${errorMsg}`, 'error', FNAME); } else { logCanvasS2("Chamadas APIs File System Access OK (rejeições são normais se o usuário cancelar).", 'good', FNAME); } logCanvasS2(`--- Teste File System Access Concluído (Disp: ${apiAvailable}, Chamadas: ${openFilePickerCalled}/${saveFilePickerCalled}/${dirPickerCalled}) ---`, 'test', FNAME); await PAUSE_S2_FUNC();
        };

        const testWebGPUCheckS2 = async () => {
            const FNAME = 'testWebGPUCheckS2'; logCanvasS2("--- Teste: WebGPU Check ---", 'test', FNAME); let adapterOK = false; let deviceOK = false; let errorMsg = null; gpuAdapterS2 = null; gpuDeviceS2 = null; if (!navigator.gpu) { logCanvasS2("WebGPU API (navigator.gpu) NÃO disponível.", 'good', FNAME); logCanvasS2(`--- Teste WebGPU Concluído (API Não Disponível) ---`, 'test', FNAME); await PAUSE_S2_FUNC(); return; } logCanvasS2("WebGPU API (navigator.gpu) disponível.", 'good', FNAME); try { gpuAdapterS2 = await navigator.gpu.requestAdapter(); if (gpuAdapterS2) { logCanvasS2(`Adaptador GPU obtido: ${gpuAdapterS2.name || 'N/A'}`, 'good', FNAME); adapterOK = true; try { gpuDeviceS2 = await gpuAdapterS2.requestDevice(); if (gpuDeviceS2) { logCanvasS2("Dispositivo GPU obtido.", 'good', FNAME); deviceOK = true; gpuDeviceS2.addEventListener('uncapturederror', (event) => { logCanvasS2(`--> ERRO WebGPU: ${event.error.message}`, 'critical', FNAME); console.error("WebGPU Error:", event.error); }); gpuDeviceS2.lost.then((info) => { logCanvasS2(`--> Dispositivo WebGPU PERDIDO! R: ${info.reason}. M: ${info.message}`, 'critical', FNAME); gpuDeviceS2 = null; }); try { const buffer = gpuDeviceS2.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }); logCanvasS2("Buffer WebGPU criado.", 'good', FNAME); buffer.destroy(); } catch(bufferError) { logCanvasS2(`Erro criar buffer WebGPU: ${bufferError.message}`, 'error', FNAME); } } else { logCanvasS2("Falha obter dispositivo GPU (null).", 'error', FNAME); errorMsg = "requestDevice null"; } } catch (deviceError) { logCanvasS2(`Erro requisitar dispositivo GPU: ${deviceError.message}`, 'error', FNAME); errorMsg = deviceError.message; console.error(deviceError); } } else { logCanvasS2("Falha obter adaptador GPU (null).", 'warn', FNAME); errorMsg = "requestAdapter null"; } } catch (adapterError) { logCanvasS2(`Erro requisitar adaptador GPU: ${adapterError.message}`, 'error', FNAME); errorMsg = adapterError.message; console.error(adapterError); } logCanvasS2(`--- Teste WebGPU Concluído (Adaptador: ${adapterOK}, Disp: ${deviceOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME); await PAUSE_S2_FUNC();
        };

        const runCanvasTestSequenceS2 = async () => {
            const FNAME = 'runCanvasTestSequenceS2';
            outputDivCanvasS2 = document.getElementById('output-canvas');
            coordStatusDivS2 = document.getElementById('canvas-coord-status');
            canvasElementS2 = document.getElementById('interactive-canvas');
            const runBtnCanvas = document.getElementById('runCanvasBtn');

            if (!outputDivCanvasS2 || !runBtnCanvas || !canvasElementS2 || !coordStatusDivS2) {
                console.error("FATAL: Elementos essenciais S2 não encontrados!");
                return;
            }

            if (runBtnCanvas) runBtnCanvas.disabled = true;
            outputDivCanvasS2.innerHTML = '';
            logCanvasS2("Iniciando sequência focada do Script 2 (v19.0)...", "test", FNAME);

            imgSquaresS2.length = 0;
            let sqX = 10;
            let sqY = imgSquaresStartYS2;
            
            // Definir squareDefsS2 com ações adaptadas para S2
            // As ações devem ser as funções de teste adaptadas para S2
            const squareDefsS2Config = [
                { id: 's2-sq-meta', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadataS2 },
                { id: 's2-sq-pp', text: 'PP++', color: '#C70039', action: testAdvancedPPS2 },
                { id: 's2-sq-oobrd', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhancedS2 },
                { id: 's2-sq-imgdt', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheckS2 },
                { id: 's2-sq-file', text: 'File', color: '#581845', action: testFileSystemAccessS2 },
                { id: 's2-sq-gpu', text: 'WebGPU', color: '#337BFF', action: testWebGPUCheckS2 },
                 { id: 's2-sq-webgl', text: 'WebGL+', color: '#2ECC71', action: testWebGLDeeperPlusS2 },
            ];

            squareDefsS2Config.forEach(def => {
                if (sqX + imgSquareSizeS2 + imgSquareSpacingS2 > canvasElementS2.width - 5 && sqX > 10) {
                    sqX = 10;
                    sqY += imgSquareSizeS2 + imgSquareSpacingS2;
                }
                if (sqY + imgSquareSizeS2 > canvasElementS2.height - 15) { // Verifica se cabe no canvas
                    logCanvasS2(`AVISO: Não há espaço para o quadrado ${def.id} no canvas (Y: ${sqY}). Pulando.`, 'warn', FNAME);
                    return;
                }
                imgSquaresS2.push({
                    id: def.id,
                    x: sqX, y: sqY,
                    size: imgSquareSizeS2,
                    color: def.color,
                    text: def.text,
                    hover: false,
                    url: def.url, // se houver
                    action: def.action
                });
                sqX += imgSquareSizeS2 + imgSquareSpacingS2;
            });


            try {
                try {
                    ctxS2 = canvasElementS2.getContext('2d');
                    if (!ctxS2) throw new Error("Falha ao obter Ctx 2D para S2.");
                } catch (e) {
                    logCanvasS2(`Falha Ctx 2D (S2): ${e.message}`, 'critical', FNAME);
                    throw e; // Interrompe se não puder desenhar
                }
                
                redrawAllS2(); // Desenha o estado inicial
                await PAUSE_S2_FUNC();

                try {
                    const l = leakedValueFromOOB_S1; // Lê o valor do Script 1
                    if (l) {
                        const ls = l.type === 'U64' ? `L(S1):U64 H=${toHexCanvasS2(l.high)} L=${toHexCanvasS2(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvasS2(l.low)}@${l.offset}`;
                        logCanvasS2(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME);
                        currentLeakDataS2 = { text: ls, color: "#FF9800" };
                    } else {
                        logCanvasS2(`-> Leak S1 (leakedValueFromOOB_S1) nulo/não encontrado.`, 'warn', FNAME);
                        currentLeakDataS2 = { text: "L(S1):NULO", color: "#FFC107" };
                    }
                } catch (e) {
                    logCanvasS2(`Erro ao acessar leak S1: ${e.message}`, 'error', FNAME);
                    currentLeakDataS2 = { text: "L(S1):ERRO", color: "#F44336" };
                    console.error("Erro S2 lendo leak S1:", e);
                }
                redrawAllS2(); // Redesenha com info do leak
                await PAUSE_S2_FUNC();

                // Executa a sequência de testes automáticos do canvas
                await testWebGLCheckS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                await testAdvancedPPS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                await testOOBReadEnhancedS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                await testOOBWriteMetadataS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                
                logCanvasS2("--- Iniciando Teste de Interação OOB Write -> WebGL (S2) ---", 'test', FNAME);
                const oobWriteInteractionOK_S2 = await testOOBWriteOnlyS2();
                await testWebGLDeeperPlusS2(); // Este desenha no canvas
                if (oobWriteInteractionOK_S2 && glContextS2) {
                    logCanvasS2(` ---> *** ALERTA POTENCIAL S2: WebGL funcionou após OOB Write. Investigar. ***`, 'escalation', FNAME);
                }
                logCanvasS2("--- Teste Interação OOB Write -> WebGL (S2) Concluído ---", 'test', FNAME);
                await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                
                await testOOBWriteToImageDataCheckS2(); // Este desenha no canvas
                await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                
                await testFileSystemAccessS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);
                await testWebGPUCheckS2(); await PAUSE_S2_FUNC(SHORT_PAUSE_CANVAS_S2);

                logCanvasS2("--- Sequência principal de testes S2 focados concluída ---", 'test', FNAME);
                await PAUSE_S2_FUNC(100);

                // Configura listeners de mouse
                if (canvasClickListenerS2 && canvasElementS2) { try { canvasElementS2.removeEventListener('click', canvasClickListenerS2); } catch (e) {} }
                if (canvasMoveListenerS2 && canvasElementS2) { try { canvasElementS2.removeEventListener('mousemove', canvasMoveListenerS2); } catch (e) {} }

                canvasMoveListenerS2 = (event) => {
                    const rect = canvasElementS2.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    let needsRedraw = false;
                    let newHoverTarget = null;
                    let cursorStyle = 'default';

                    interactiveAreasS2.forEach(a => {
                        if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) {
                            newHoverTarget = a.id;
                            cursorStyle = 'pointer';
                        }
                    });
                    imgSquaresS2.forEach(sq => {
                        let oldHover = sq.hover;
                        sq.hover = false;
                        if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) {
                            newHoverTarget = sq.id;
                            cursorStyle = sq.action ? 'crosshair' : (sq.url ? 'pointer' : 'default');
                            sq.hover = true;
                        }
                        if (oldHover !== sq.hover) needsRedraw = true;
                    });

                    if (newHoverTarget !== currentHoverTargetS2) {
                        currentHoverTargetS2 = newHoverTarget;
                        needsRedraw = true;
                    }
                    try {
                        if (needsRedraw) { redrawAllS2(); }
                        canvasElementS2.style.cursor = cursorStyle;
                        if (coordStatusDivS2) coordStatusDivS2.textContent = `Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`;
                    } catch (e) { logCanvasS2(`Erro mousemove S2: ${e.message}`, 'error', 'MouseMoveS2'); console.error(e); }
                };

                canvasClickListenerS2 = async (event) => {
                    const FNAME_CLICK = 'CanvasClickS2';
                    try {
                        const rect = canvasElementS2.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        let clickedArea = null;
                        interactiveAreasS2.forEach(a => {
                            if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; }
                        });
                        let clickedSquare = null;
                        imgSquaresS2.forEach((sq) => {
                            if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquare = sq; }
                        });

                        if (clickedArea) {
                            logCanvasS2(`Click Área S2: ${clickedArea.text} (ID: ${clickedArea.id})`, 'info', FNAME_CLICK);
                            switch (clickedArea.id) {
                                case 'rect-log-s2': logCanvasS2('Click no botão de log (S2).', 'info', FNAME_CLICK); break;
                                case 'rect-link-s2': logCanvasS2('Abrindo link externo (google.com)...', 'info', FNAME_CLICK); try { window.open('https://google.com', '_blank'); } catch (e) { logCanvasS2('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } break;
                                case 'rect-rerun-s2':
                                    logCanvasS2('Re-lendo leak S1...', 'info', FNAME_CLICK);
                                    try {
                                        const l = leakedValueFromOOB_S1; // Re-lê do S1
                                        if (l) { const ls = l.type === 'U64' ? `L(S1):U64 H=${toHexCanvasS2(l.high)} L=${toHexCanvasS2(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvasS2(l.low)}@${l.offset}`; logCanvasS2(`-> Re-read Leak S1: ${ls}`, 'leak', FNAME_CLICK); currentLeakDataS2 = { text: ls, color: "#FF9800" }; }
                                        else { logCanvasS2(`-> Re-read Leak S1: Nulo`, 'warn', FNAME_CLICK); currentLeakDataS2 = { text: "L(S1):NULO", color: "#FFC107" }; }
                                    } catch (e) { logCanvasS2(`Erro re-ler leak S1: ${e.message}`, 'error', FNAME_CLICK); }
                                    redrawAllS2();
                                    break;
                            }
                        } else if (clickedSquare) {
                            logCanvasS2(`Click Quadrado S2 ID: ${clickedSquare.id} (Texto: ${clickedSquare.text})`, 'vuln', FNAME_CLICK);
                            if (clickedSquare.url) {
                                logCanvasS2(`Abrindo URL: ${clickedSquare.url}`, 'info', FNAME_CLICK);
                                try { window.open(clickedSquare.url, '_blank'); } catch (e) { logCanvasS2('Erro window.open: ' + e.message, 'error', FNAME_CLICK); }
                            } else if (clickedSquare.action && typeof clickedSquare.action === 'function') {
                                let actionError = null;
                                if (runBtnCanvas) runBtnCanvas.disabled = true;
                                logCanvasS2(`Executando re-run S2 ${clickedSquare.id} (${clickedSquare.action.name || 'anon_action'})...`, 'test', FNAME_CLICK);
                                try {
                                    await clickedSquare.action();
                                    logCanvasS2(`Re-run S2 ${clickedSquare.id} concluído.`, 'good', FNAME_CLICK);
                                } catch (e) {
                                    logCanvasS2(`Erro durante re-run S2 ${clickedSquare.id}: ${e.message}`, 'error', FNAME_CLICK);
                                    console.error(`Erro ação S2 ${clickedSquare.id}:`, e);
                                    actionError = e;
                                } finally {
                                    clickedSquare.color = actionError ? '#FFA500' : '#8A2BE2'; // Muda cor após clique/execução
                                    redrawAllS2();
                                    if (runBtnCanvas) runBtnCanvas.disabled = false;
                                    logCanvasS2(`Re-run S2 ${clickedSquare.id} finalizado.`, 'test', FNAME_CLICK);
                                }
                            } else {
                                logCanvasS2(`Nenhuma ação definida para o quadrado S2 ${clickedSquare.id}.`, 'info', FNAME_CLICK);
                                clickedSquare.text += "*"; redrawAllS2();
                            }
                        }
                    } catch (e) {
                        logCanvasS2(`Erro GERAL listener clique S2: ${e.message}`, 'error', FNAME_CLICK);
                        console.error("Erro Clique S2:", e);
                        if (runBtnCanvas) runBtnCanvas.disabled = false;
                    }
                };

                canvasElementS2.addEventListener('click', canvasClickListenerS2);
                canvasElementS2.addEventListener('mousemove', canvasMoveListenerS2);
                redrawAllS2(); // Garante que tudo está desenhado após configurar os listeners

            } catch (e) {
                logCanvasS2(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME);
                console.error("Erro GERAL SCRIPT 2:", e);
                if (e.stack) console.error(e.stack);
            } finally {
                logCanvasS2("--- Fim da execução Script 2 (v19.0) ---", 'test', FNAME);
                if (runBtnCanvas) runBtnCanvas.disabled = false;
            }
        };

        const runCanvasTest = async () => { // Esta é a função chamada pelo botão "Iniciar Testes Canvas S2"
            await runCanvasTestSequenceS2();
        };

        // Limpeza no unload
        window.addEventListener('unload', () => {
            try {
                if (canvasClickListenerS2 && canvasElementS2) canvasElementS2.removeEventListener('click', canvasClickListenerS2);
                if (canvasMoveListenerS2 && canvasElementS2) canvasElementS2.removeEventListener('mousemove', canvasMoveListenerS2);
                // Limpar outros recursos do S2 se necessário (ex: gpuDeviceS2.destroy() se existir e for apropriado)
                if (gpuDeviceS2 && typeof gpuDeviceS2.destroy === 'function') {
                    //gpuDeviceS2.destroy(); // A API de WebGPU lida com 'lost' de forma diferente, destroy pode não ser sempre necessário aqui.
                }
                gpuDeviceS2 = null;
                gpuAdapterS2 = null;
            } catch (e) {
                // Silencioso no unload
            }
            console.log("[Canvas Unload S2] Limpeza tentada.");
        });
    </script>







    <script>
        // --- Script 3: Ferramentas e Testes Avançados (v19.0) ---
        const outputDivS3 = document.getElementById('output-advanced');
        const runBtnAdvancedS3 = document.getElementById('runAdvancedBtn');
        const SHORT_PAUSE_S3 = 50;
        const MEDIUM_PAUSE_S3 = 500;

        const logS3 = (message, type = 'info', funcName = '') => {
            generalUtils.logToDiv('output-advanced', message, type, funcName);
        };
        const PAUSE_S3_FUNC = (ms = SHORT_PAUSE_S3) => new Promise(r => setTimeout(r, ms));


        const testWebAssemblyInterface = async () => {
            const FNAME = "testWebAssemblyInterface";
            logS3("--- Iniciando Teste de Interface WebAssembly ---", "test", FNAME);
            if (typeof WebAssembly !== 'object') {
                logS3("WebAssembly API não suportada.", "warn", FNAME);
                logS3("--- Teste WebAssembly Concluído (Não Suportado) ---", "test", FNAME);
                return;
            }
            logS3("WebAssembly API disponível.", "good", FNAME);
            try {
                // Um módulo Wasm mínimo (faz um add)
                const wasmBytes = new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60,
                    0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01,
                    0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20,
                    0x00, 0x20, 0x01, 0x6a, 0x0b
                ]);
                const module = await WebAssembly.compile(wasmBytes);
                const instance = await WebAssembly.instantiate(module);
                const result = instance.exports.add(5, 3);
                if (result === 8) {
                    logS3(`Instanciação e chamada de Wasm OK. add(5,3) = ${result}`, "good", FNAME);
                } else {
                    logS3(`Chamada Wasm retornou valor inesperado: ${result}`, "warn", FNAME);
                }
            } catch (e) {
                logS3(`Erro durante teste WebAssembly: ${e.message}`, "error", FNAME);
                console.error("Wasm Error:", e);
            }
            logS3("--- Teste WebAssembly Concluído ---", "test", FNAME);
        };

        const testSharedArrayBufferSupport = async () => {
            const FNAME = "testSharedArrayBufferSupport";
            logS3("--- Iniciando Teste de SharedArrayBuffer ---", "test", FNAME);
            if (typeof SharedArrayBuffer === 'undefined') {
                logS3("SharedArrayBuffer não suportado ou desabilitado (requer COOP/COEP).", "warn", FNAME);
                logS3("Verifique os cabeçalhos Cross-Origin-Opener-Policy (COOP) e Cross-Origin-Embedder-Policy (COEP).", "info", FNAME);
            } else {
                logS3("SharedArrayBuffer suportado.", "good", FNAME);
                try {
                    const sab = new SharedArrayBuffer(16);
                    logS3(`SharedArrayBuffer de ${sab.byteLength} bytes criado com sucesso.`, "good", FNAME);
                    const i32a = new Int32Array(sab);
                    Atomics.store(i32a, 0, 123);
                    const loadedVal = Atomics.load(i32a, 0);
                    if (loadedVal === 123) {
                        logS3(`Atomics.store/load em SharedArrayBuffer OK. (${loadedVal})`, "good", FNAME);
                    } else {
                        logS3(`Atomics.store/load em SharedArrayBuffer falhou. Leu: ${loadedVal}`, "error", FNAME);
                    }
                } catch (e) {
                    logS3(`Erro ao usar SharedArrayBuffer/Atomics: ${e.message}`, "error", FNAME);
                     if (e.name === 'ReferenceError' && e.message.includes("Atomics")) {
                        logS3("Atomics API parece não estar disponível, mesmo com SharedArrayBuffer presente.", "warn", FNAME);
                    }
                }
            }
            logS3("--- Teste SharedArrayBuffer Concluído ---", "test", FNAME);
        };

        const explainMemoryPrimitives = () => {
            const FNAME = "explainMemoryPrimitives";
            logS3("--- Explicação: Primitivas de Memória (addrof, fakeobj) ---", "tool", FNAME);
            logS3("Estas são primitivas comuns em exploração de navegadores, tipicamente obtidas após explorar uma vulnerabilidade inicial (ex: OOB R/W).", "info", FNAME);
            logS3("`addrof(object)`: Retornaria o endereço de memória do objeto JavaScript fornecido.", "info", FNAME);
            logS3("`fakeobj(address)`: Criaria um objeto JavaScript 'falso' que aponta para o endereço de memória fornecido, permitindo tratar dados arbitrários na memória como se fossem um objeto JS.", "info", FNAME);
            logS3("Para implementar `addrof` real, você precisaria de uma forma de ler a memória onde as estruturas de objetos JS são armazenadas. Frequentemente, isso envolve corromper um ArrayBuffer ou DataView para apontar seu buffer interno para o objeto desejado e então ler seus metadados/ponteiros.", "info", FNAME);
            logS3("Para `fakeobj` real, seria o inverso: corromper um objeto JS (ou o buffer de um ArrayBuffer que depois é tratado como objeto) para que seus ponteiros internos apontem para um endereço arbitrário.", "info", FNAME);
            logS3("Offsets úteis (JSC): js_butterfly (0x8), view_m_vector (0x10 de um JSArrayBufferView).", "info", FNAME);
            logS3("Esta suíte usa AdvancedInt64 para manipulação de endereços de 64 bits: new AdvancedInt64('0x...', '0x...') ou new AdvancedInt64(byteArray).", "info", FNAME);
            logS3("Funções de Leitura/Escrita (simuladas aqui, mas mostram a ideia): readWriteUtils.read64(view, offset), readWriteUtils.write64(view, offset, int64Value).", "info", FNAME);
        };

        const buildRopChain = () => {
            const FNAME = "buildRopChain";
            logS3("--- Construtor de Cadeia ROP (Conceitual) ---", "tool", FNAME);
            const gadgetsInput = document.getElementById('rop-gadgets-input').value.trim();
            const chainInput = document.getElementById('rop-chain-input').value.trim();

            if (!gadgetsInput || !chainInput) {
                logS3("Entrada de gadgets ou cadeia ROP está vazia.", "warn", FNAME);
                return;
            }

            const gadgetMap = new Map();
            try {
                gadgetsInput.split('\n').forEach(line => {
                    if (line.trim()) {
                        const parts = line.split('=');
                        if (parts.length === 2) {
                            const addr = new AdvancedInt64(parts[0].trim());
                            gadgetMap.set(parts[1].trim(), addr);
                        }
                    }
                });
                logS3(`Gadgets carregados: ${gadgetMap.size}`, "info", FNAME);
                gadgetMap.forEach((addr, name) => logS3(`  ${name} : ${addr.toString(true)}`, "info"));

            } catch (e) {
                logS3(`Erro ao processar gadgets: ${e.message}`, "error", FNAME);
                return;
            }

            const ropChain = [];
            const chainSteps = chainInput.split('\n');
            let validChain = true;

            logS3("Construindo cadeia ROP:", "info", FNAME);
            for (const step of chainSteps) {
                const trimmedStep = step.trim();
                if (!trimmedStep) continue;

                if (gadgetMap.has(trimmedStep)) { // É um gadget
                    const gadgetAddr = gadgetMap.get(trimmedStep);
                    ropChain.push(gadgetAddr);
                    logS3(`  [GADGET] ${trimmedStep} -> ${gadgetAddr.toString(true)}`, "info", FNAME);
                } else { // É um valor/constante
                    try {
                        const value = trimmedStep.toLowerCase().startsWith("0x") ? new AdvancedInt64(trimmedStep) : new AdvancedInt64(parseInt(trimmedStep));
                        ropChain.push(value);
                        logS3(`  [VALOR]  ${trimmedStep} -> ${value.toString(true)}`, "info", FNAME);
                    } catch (e) {
                        logS3(`AVISO: '${trimmedStep}' não é um gadget conhecido nem um valor numérico válido. Tratando como string (endereço simbólico ou erro).`, "warn", FNAME);
                        // Poderia adicionar lógica para tratar como string literal ou endereço simbólico se necessário.
                        // Por ora, apenas loga e continua, a "execução" é conceitual.
                        ropChain.push(trimmedStep); // Adiciona como string
                    }
                }
            }

            if (validChain && ropChain.length > 0) {
                logS3("Cadeia ROP construída (endereços/valores):", "good", FNAME);
                ropChain.forEach((item, index) => {
                    logS3(`    ${index}: ${(item instanceof AdvancedInt64) ? item.toString(true) : item}`, "info");
                });
                logS3("Nota: Esta é uma representação. A execução real requereria controle do ponteiro de stack (RSP) e um 'ret' inicial.", "info", FNAME);
            } else if (!validChain) {
                logS3("Cadeia ROP inválida devido a erros.", "error", FNAME);
            } else {
                logS3("Nenhuma cadeia ROP construída.", "warn", FNAME);
            }
        };


        const viewMemory = () => {
            const FNAME = "viewMemory";
            logS3("--- Visualizador de Memória (Conceitual) ---", "tool", FNAME);
            const addrStr = document.getElementById('mem-view-addr').value;
            const sizeStr = document.getElementById('mem-view-size').value;

            if (!addrStr || !sizeStr) {
                logS3("Endereço ou tamanho não fornecido.", "warn", FNAME);
                return;
            }
            try {
                const startAddr = new AdvancedInt64(addrStr);
                const size = parseInt(sizeStr);

                if (isNaN(size) || size <= 0 || size > 1024) { // Limita o tamanho para exibição
                    logS3("Tamanho inválido ou muito grande (max 1024).", "error", FNAME);
                    return;
                }

                logS3(`Simulando leitura de ${size} bytes a partir de ${startAddr.toString(true)}:`, "info", FNAME);
                logS3("Conteúdo simulado (exemplo):", "info", FNAME);

                let hexString = "";
                for (let i = 0; i < size; i++) {
                    // Simula bytes aleatórios para demonstração
                    const randomByte = Math.floor(Math.random() * 256);
                    hexString += randomByte.toString(16).padStart(2, '0') + " ";
                    if ((i + 1) % 16 === 0) { // Nova linha a cada 16 bytes
                        logS3(hexString, "info", FNAME);
                        hexString = "";
                    }
                }
                if (hexString) logS3(hexString, "info", FNAME); // Loga o restante

                logS3("Nota: Uma primitiva de leitura real (ex: DataView sobre um ArrayBuffer corrompido) seria necessária para ler memória real.", "info", FNAME);

            } catch (e) {
                logS3(`Erro ao processar entrada: ${e.message}`, "error", FNAME);
            }
        };


        const runAllAdvancedTests = async () => {
            const FNAME = 'runAllAdvancedTestsS3';
            if (runBtnAdvancedS3) runBtnAdvancedS3.disabled = true;
            outputDivS3.innerHTML = ''; // Limpa o log específico do S3
            logS3("==== INICIANDO Script 3: Ferramentas e Testes Avançados (v19.0) ====", 'test', FNAME);

            await testWebAssemblyInterface(); await PAUSE_S3_FUNC(MEDIUM_PAUSE_S3);
            await testSharedArrayBufferSupport(); await PAUSE_S3_FUNC(MEDIUM_PAUSE_S3);
            explainMemoryPrimitives(); await PAUSE_S3_FUNC(SHORT_PAUSE_S3);
            // As ferramentas de ROP e Memory Viewer são interativas, não executadas automaticamente aqui.

            logS3("\n==== Script 3 CONCLUÍDO (Testes Automáticos) ====", 'test', FNAME);
            if (runBtnAdvancedS3) runBtnAdvancedS3.disabled = false;
        };
    </script>

</body>
</html>
