<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Exploração Direcionada v3</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Exploração Direcionada v3</h1>
    <p>Foco: Testar Hijacking de Funções Nativas via Prototype Pollution.</p>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 200;
        const SHORT_PAUSE = 50;

        // --- Teste 1 (Entry Point Check) ---
        const runCSP_XSS_Check = () => { /* ... código igual ao v9 ... */ log("--- T1: Verificação de Entrada XSS ---",'test');log("Execução JS via XSS/CSP OK.",'good');log("--- T1 Concluído ---",'test'); };

        // --- NOVO Teste 2: Teste de Hijacking de Funções via PP v3 ---
        const runPPHijackTest_v3 = async () => {
            log("--- T2: Teste de Hijacking de Funções via PP v3 ---", 'test');
            log("Objetivo: Poluir protótipos de funções comuns e verificar se a chamada é interceptada.", 'warn');

            // Lista de alvos: [Protótipo, Nome da Função, Ação para Chamar]
            const targets = [
                { proto: Array.prototype,   key: 'map',      action: () => [1, 2].map(x => x) },
                { proto: Array.prototype,   key: 'push',     action: () => [].push(1) },
                { proto: Array.prototype,   key: 'join',     action: () => [1, 2].join(',') },
                { proto: String.prototype,  key: 'includes', action: () => "".includes("a") },
                { proto: String.prototype,  key: 'slice',    action: () => "".slice(0) },
                { proto: Function.prototype,key: 'call',     action: () => function(){}.call(null) },
                { proto: Function.prototype,key: 'apply',    action: () => function(){}.apply(null) },
                { proto: Object.prototype,  key: 'toString', action: () => ({}).toString() },
                { proto: Object.prototype,  key: 'hasOwnProperty', action: () => ({}).hasOwnProperty('test') },
                // Adicionar mais alvos se desejar...
            ];

            for (const target of targets) {
                const { proto, key, action } = target;
                // Validar se a chave existe no protótipo
                if (typeof proto[key] !== 'function') {
                    log(`INFO: Propriedade '${key}' não é uma função no protótipo alvo. Pulando.`, 'info');
                    continue;
                }

                log(`Testando Hijack de: ${proto.constructor.name}.prototype.${key}`, 'subtest');
                const originalFunction = proto[key];
                let pollutionSuccess = false;
                let hijackDetected = false;

                try {
                    // Função espiã que será injetada
                    const spyFunction = function(...args) {
                        hijackDetected = true; // Marcar que fomos chamados
                        log(`>> HIJACK DETECTADO! Chamada para ${key} interceptada! <<`, "vuln");
                        // Opcional: Chamar a função original para manter a funcionalidade (CUIDADO!)
                        // try {
                        //     return originalFunction.apply(this, args);
                        // } catch(e) {
                        //     log(`Erro ao chamar função original ${key} de dentro da espiã: ${e.message}`, 'error');
                        //     return undefined; // ou lançar erro?
                        // }
                        return `HIJACKED_${key}`; // Retornar valor fixo
                    };

                    // Poluir
                    log(`  Poluindo ${proto.constructor.name}.prototype.${key}...`, 'info');
                    proto[key] = spyFunction;

                    // Verificar se a poluição funcionou (simples)
                    if (proto[key] === spyFunction) {
                         log("  Poluição parece OK. Executando ação de gatilho...", 'info');
                         pollutionSuccess = true; // Marcar que precisamos restaurar

                         // Executar a ação que deveria chamar a função original
                         try {
                            let result = action();
                            log(`  Ação executada. Resultado: ${typeof result ==='string' || typeof result === 'number' || typeof result === 'boolean' ? result : JSON.stringify(result)}`, 'info');
                            if(hijackDetected) {
                                log(`  CONFIRMADO: Função espiã foi executada para '${key}'.`, 'vuln');
                            } else {
                                log(`  AVISO: Ação executada, mas função espiã NÃO foi chamada para '${key}'. Poluição ineficaz?`, 'warn');
                            }
                         } catch (e) {
                              log(`  ERRO ao executar ação para '${key}' (efeito PP?): ${e.message}`, 'leak');
                              // Mesmo com erro, a função espiã pode ter sido chamada antes
                               if(hijackDetected) {
                                   log(`  CONFIRMADO: Função espiã foi executada para '${key}' (antes do erro).`, 'vuln');
                               }
                         }

                    } else {
                        log("  Falha ao poluir/verificar poluição.", 'error');
                    }

                } catch (e) {
                    log(`  Erro GERAL no teste de hijack para '${key}': ${e.message}`, 'error');
                } finally {
                    // Restaurar SEMPRE
                    if (proto && key && originalFunction && proto[key] !== originalFunction) { // Restaurar apenas se realmente mudou
                        log(`  Restaurando ${proto.constructor.name}.prototype.${key} original...`, 'info');
                        proto[key] = originalFunction;
                        if (proto[key] === originalFunction) {
                           log("  Restauração OK.", 'good');
                        } else {
                           log(`  FALHA AO RESTAURAR '${key}'! Isso pode causar problemas!`, 'error');
                        }
                    } else if (pollutionSuccess) {
                        log(`  WARN: Poluição tinha sucedido mas estado atual de '${key}' parece já restaurado?`, 'warn');
                    }
                }
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));
            } // Fim loop targets
            log("--- T2 Concluído ---", 'test');
        };

        // --- Teste 3: OOB Write Confirm (Mantido - Base) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v8 ... */ log("--- T3: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T3: ${e.message}`,'error');} log("--- T3 Concluído ---",'test'); };

        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (EXPLORAÇÃO DIRECIONADA v3 - PP HIJACK)...");
            const tests = [ // Sequência atualizada
                runCSP_XSS_Check,           // T1: Check XSS/Entrada
                runPPHijackTest_v3,         // T2: Teste Hijack Funções PP (NOVO)
                runOOBTestU8_Confirm,       // T3: OOB Confirm Base
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v8 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes EXPLORAÇÃO DIRECIONADA v3 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS_Check()">Rodar T1 (Check XSS)</button>
            <button onclick="runPPHijackTest_v3()">Rodar T2 (PP Hijack Test)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T3 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
        `;

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
