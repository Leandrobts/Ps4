<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection</title>
    <style>
        /* Estilos CSS Id√™nticos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; }
        .extended-test { color: #03A9F4; } /* Classe para novos tipos de teste */
    </style>
</head>
<body>
    <h1>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_tests">Run All Tests (Incl. Extended Detection)</option>
            <option value="oob_write_aggressive">Aggressive OOB Write (Info Leak Demo)</option>
            <option value="oob_impact_tests">OOB Impact (Metadata/Crash)</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass (Direct Impact)</option>
            <option value="uaf_basic">Basic Use-After-Free Tests</option>
            <option value="type_confusion_basic">Basic Type Confusion Tests</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// CONFIGURA√á√ÉO E FUN√á√ïES B√ÅSICAS (Id√™nticas)
// ======================
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!
document.addEventListener('DOMContentLoaded', function() { /*...*/ });
function log(message, type = '') { /*...*/ }
function clearLog() { /*...*/ }
var potentialVulnsFound = { oobWrite: false };
async function sendVulnerabilityNotification(payload) { /*...*/ }
function demonstrateCookieRead() { /*...*/ }
function demonstrateDomManipulation() { /*...*/ }
function demonstrateNetworkRequest() { /*...*/ }

// ======================
// Fun√ß√µes de Teste de Vulnerabilidade Atualizadas e Novas
// ======================
const aggressiveTests = {

    "oob_write_aggressive": async function() { // Agora inclui Info Leak Demo
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write (Info Leak Demo)...", "info section");
        potentialVulnsFound.oobWrite = false;
        try {
            const bufferSize = 32;
            const buffer = new ArrayBuffer(bufferSize);
            const view = new Uint8Array(buffer);
            const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10]; // Reduzido para focar
            const readOffsets = [-5, 0, 5, bufferSize - 1, bufferSize, bufferSize + 5, bufferSize + 8, bufferSize + 16]; // Adicionado leitura OOB maior

            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info");
                let oobWriteSuccess = false;
                try {
                    view[writeOffset] = writeValue;
                    log(`‚ö†Ô∏è OOB write at offset ${writeOffset} successful (no error).`, "warning");
                    potentialVulnsFound.oobWrite = true;
                    oobWriteSuccess = true; // Marcar sucesso localmente

                } catch (writeError) {
                    log(`‚úÖ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success");
                }

                // Apenas tenta ler se a escrita OOB (ou escrita normal) n√£o deu erro
                if(oobWriteSuccess || (writeOffset >= 0 && writeOffset < bufferSize)) {
                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const readValue = view[readOffset];
                            const readValueHex = (readValue !== undefined ? `0x${readValue.toString(16)}` : 'undefined');
                            log(`[OOB-AGG] Read ${readValueHex} at offset ${readOffset} after write at ${writeOffset}.`, "info");

                            // Detec√ß√£o de Corrup√ß√£o
                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                                const detailMsg = `Wrote at ${writeOffset}, read ${readValueHex} at IN-BOUNDS offset ${readOffset}.`;
                                log(`<span class="poc-potential defense-bypass privilege-escalation">üö© Potential OOB Write Corruption: ${detailMsg}</span>`, "danger");
                                sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg });
                            }

                            // << DEMONSTRA√á√ÉO DE INFO LEAK CONTROLADO >>
                            // Se conseguimos ler OOB com sucesso (offset >= bufferSize),
                            // vamos tentar logar/notificar os pr√≥ximos bytes como info leak.
                            if (readOffset >= bufferSize && readValue !== undefined) {
                                let leakedBytes = [];
                                const bytesToRead = 8; // Ler 8 bytes adjacentes
                                for (let i = 0; i < bytesToRead; i++) {
                                    try {
                                        const leakOffset = readOffset + i;
                                        // √â crucial que a leitura OOB funcione aqui. Se view[leakOffset] der erro, n√£o vaza.
                                        leakedBytes.push(view[leakOffset]?.toString(16).padStart(2, '0') ?? '??');
                                    } catch (leakReadError) {
                                        leakedBytes.push('ERR'); // Indicar erro na leitura do byte espec√≠fico
                                        break; // Parar se um erro ocorrer
                                    }
                                }
                                const leakHex = leakedBytes.join(' ');
                                const detailMsg = `Read ${readValueHex} at OOB offset ${readOffset}. Following bytes: ${leakHex}`;
                                log(`<span class="poc-potential impact">üíß Potential Info Leak: ${detailMsg}</span>`, "warning impact");
                                // Notificar apenas a primeira vez que um leak for detectado para n√£o spammar
                                if(!this.infoLeakNotified) {
                                     sendVulnerabilityNotification({ vulnerability: 'OOB_INFO_LEAK_ADJACENT', details: detailMsg });
                                     this.infoLeakNotified = true; // Evitar m√∫ltiplas notifica√ß√µes de leak
                                }
                            }

                        } catch (readError) {
                             log(`‚ö†Ô∏è Error reading at offset ${readOffset}: ${readError.message}`, "warning");
                        }
                    } // end read loop
                } // end if write success
                await new Promise(resolve => setTimeout(resolve, 100));
            } // end write loop
             this.infoLeakNotified = false; // Resetar flag de notifica√ß√£o de leak para pr√≥xima execu√ß√£o
            log("[OOB-AGG] Completed OOB write / info leak testing.", "info");
        } catch (e) {
            log(`‚ùå Test error (OOB Write/Leak): ${e.message}`, "danger"); console.error(e);
             this.infoLeakNotified = false;
        }
    },

    "test_oob_metadata": async function() { /* ... c√≥digo id√™ntico ... */ },
    "test_oob_crash_probe": async function() { /* ... c√≥digo id√™ntico ... */ },
    "csp_bypass_aggressive": async function() { /* ... c√≥digo id√™ntico com impacto direto e notifica√ß√£o ... */ },


    // --- NOVOS TESTES DE DETEC√á√ÉO ---

    "uaf_basic": async function() {
        log("[UAF-BASIC] Attempting basic Use-After-Free scenarios...", "section extended-test");
        log("INFO: These tests are generic and may not trigger UAFs without specific engine knowledge.", "info");

        // Cen√°rio 1: DOM Node reference after removal (Garbage Collection dependent)
        try {
            log("[UAF-BASIC] Scenario 1: DOM Node Reference After Removal", "extended-test");
            let parent = document.createElement('div');
            let child = document.createElement('span');
            parent.appendChild(child);
            document.body.appendChild(parent); // Add to DOM

            let childRef = child; // Keep reference

            parent.removeChild(child); // Remove from parent
            document.body.removeChild(parent); // Remove parent from DOM

            // Force GC? N√£o h√° API padr√£o, mas tentar alocar mem√≥ria pode ajudar
            try { new ArrayBuffer(10 * 1024 * 1024); } catch(e) {} // Allocate 10MB

            await new Promise(resolve => setTimeout(resolve, 500)); // Wait briefly

            log(`[UAF-BASIC] Accessing childRef.tagName after removal...`, "info");
            // Accessing property after potential free. Crash ou valor inesperado √© o alvo.
            let tagName = childRef.tagName;
            log(`[UAF-BASIC] childRef.tagName = ${tagName}. No immediate crash/error.`, "success"); // N√£o necessariamente bom

            // Tentar chamar um m√©todo
             log(`[UAF-BASIC] Calling childRef.getBoundingClientRect() after removal...`, "info");
             let rect = childRef.getBoundingClientRect();
             log(`[UAF-BASIC] getBoundingClientRect OK. No immediate crash/error.`, "success");

             childRef = null; // Release reference explicitly

        } catch (e) {
            // Um erro aqui PODE ser um UAF, mas pode ser erro normal. Precisa de an√°lise.
            log(`‚ùå Error in UAF Scenario 1: ${e.message}. Potential UAF or expected error? Needs investigation.`, "danger extended-test");
            sendVulnerabilityNotification({ vulnerability: 'UAF_BASIC_SCENARIO1_ERROR', details: e.message });
        }

        // Cen√°rio 2: ArrayBuffer/TypedArray (Mais complexo, requereria APIs espec√≠ficas ou bugs)
        // Implementar um teste UAF gen√©rico confi√°vel para Buffers √© muito dif√≠cil sem um bug conhecido.
        log("[UAF-BASIC] Scenario 2: ArrayBuffer/TypedArray (Placeholder - complex)", "extended-test info");
        log("INFO: Reliable UAF tests for buffers usually require specific engine bugs/APIs.", "info");

        log("[UAF-BASIC] Completed basic UAF tests.", "extended-test info");
    },

    "type_confusion_basic": async function() {
        log("[TYPE-CONFUSION] Attempting basic Type Confusion scenarios...", "section extended-test");
        log("INFO: These tests are generic and may not trigger type confusion without specific engine knowledge.", "info");

        // Cen√°rio 1: Passar tipo errado para API que espera objeto espec√≠fico
        try {
            log("[TYPE-CONFUSION] Scenario 1: Incorrect type to DOM API", "extended-test");
            // Exemplo: postMessage espera uma estrutura serializ√°vel. Tentar passar algo n√£o serializ√°vel
            // ou um objeto com estrutura manipulada.
             log(`[TYPE-CONFUSION] Sending self non-serializable data via postMessage...`, "info");
             try {
                 window.postMessage(window, "*"); // Enviar 'window' que n√£o √© serializ√°vel
                 log(`[TYPE-CONFUSION] postMessage(window) did not throw immediate error.`, "success"); // Browser pode s√≥ recusar silenciosamente
             } catch(e_pm1) {
                 log(`[TYPE-CONFUSION] postMessage(window) threw: ${e_pm1.message} (Likely expected)`, "success");
             }

            // Tentar com um objeto que *parece* com outro? (Dif√≠cil sem conhecer estruturas internas)
            let fakeEvent = { target: document.body, type: "click", bubbles: false };
             log(`[TYPE-CONFUSION] Dispatching fake event object...`, "info");
             try {
                 document.dispatchEvent(fakeEvent); // Isso n√£o √© um Event real.
                 log(`[TYPE-CONFUSION] dispatchEvent(fakeEvent) did not throw immediate error.`, "success");
             } catch(e_de1) {
                  log(`[TYPE-CONFUSION] dispatchEvent(fakeEvent) threw: ${e_de1.message} (Likely expected)`, "success");
             }

        } catch (e) {
             // Erros inesperados aqui poderiam indicar type confusion, mas √© raro ser √≥bvio.
            log(`‚ùå Error in Type Confusion Scenario 1: ${e.message}. Needs investigation.`, "danger extended-test");
             sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO1_ERROR', details: e.message });
        }

         // Cen√°rio 2: Confus√£o entre Primitivos e Objetos (Ex: Number vs Number object)
         try {
            log("[TYPE-CONFUSION] Scenario 2: Primitive vs Object", "extended-test");
             // APIs que esperam um objeto Number, mas recebem um primitivo, ou vice-versa.
             // Exemplo: toFixed √© do Number.prototype
             let numPrimitive = 5;
             let numObject = new Number(5);
             log(`[TYPE-CONFUSION] Calling numPrimitive.toFixed(numObject)...`, "info");
             try {
                 let result = numPrimitive.toFixed(numObject); // Argumento deveria ser primitivo
                 log(`[TYPE-CONFUSION] numPrimitive.toFixed(numObject) = ${result}. No error.`, "success");
             } catch(e_tf1) {
                  log(`[TYPE-CONFUSION] numPrimitive.toFixed(numObject) threw: ${e_tf1.message}`, "danger"); // Erro aqui √© mais prov√°vel
             }

         } catch(e) {
             log(`‚ùå Error in Type Confusion Scenario 2: ${e.message}. Needs investigation.`, "danger extended-test");
              sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: e.message });
         }

        log("[TYPE-CONFUSION] Completed basic Type Confusion tests.", "extended-test info");
    },

    // --- Executor Principal Atualizado ---
    "all_tests": async function() { // Renomeado de 'all_aggressive'
        log("=== Running All Tests (OOB, CSP, UAF Basic, Type Confusion Basic) ===", "section");

        await aggressiveTests["oob_write_aggressive"]();
        log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));

        if (potentialVulnsFound.oobWrite) {
             await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000));
             await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));
        } else { log("Skipping OOB impact tests.", "warning"); }

        await aggressiveTests["csp_bypass_aggressive"]();
        log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));

        await aggressiveTests["uaf_basic"]();
         log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));

         await aggressiveTests["type_confusion_basic"]();

        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },

    // Mant√©m executor s√≥ para OOB Impact
    "oob_impact_tests": async function() { /* ... c√≥digo id√™ntico ... */ }
    // O executor s√≥ para CSP foi removido pois impacto est√° integrado
    // Adiciona os executores para os novos testes individuais
};

// ======================
// Test Runner (Atualizado)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;

    // Aviso para testes de impacto OOB se OOB principal n√£o rodou
    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) {
        log("Warning: Running OOB Impact tests, but main OOB test success wasn't recorded. Run 'All Tests' or 'OOB Write Investigation' first for best results.", "warning");
    }

    clearLog(); log(`=== Starting Test: ${selectedTest} ===`, "section");
    if (aggressiveTests[selectedTest]) {
        await aggressiveTests[selectedTest](); // Chama a fun√ß√£o de teste selecionada
        log(`\n=== Test Execution for "${selectedTest}" Completed. Review logs & endpoint. ===`, "section");
    } else {
        log(`Error: Test "${selectedTest}" not found.`, "danger");
    }
}
</script>
</body>
</html>
