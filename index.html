<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Focado</title>
    <style>
        /* Estilos CSS (Log Vulnerável Atualizado) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; /* Vermelho mais vivo */ font-weight: bold; /* Sem fundo */ }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Demonstração Focada</h1>
    <p>Script refinado mostrando apenas vulnerabilidades confirmadas (OOB Write, CSP Bypass, Prototype Pollution). Teste CSP inclui link que requer clique manual.</p>
    <div id="poc-output"></div>

    <script>
        const outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => {
            // Função log (igual aos scripts anteriores)
            if (outputDiv) {
                const timestamp = `[${new Date().toLocaleTimeString()}] `;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight; // Reativar scroll sempre
            } else { console.error("Elemento #poc-output não encontrado!"); }
        };

        const PAUSE_DURATION = 500; // Pausa

        // --- Funções de Teste Mantidas ---

        // Teste 1: OOB Write (Uint8) Simplificado
        const runOOBTestU8 = async () => {
            log("--- Iniciando Teste 1: OOB Write (Uint8) ---", 'test');
            try {
                const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
                const writeValue = 0xEE;
                const writeOffsets = [-1, bufferSize, bufferSize + 10]; // Offsets chave
                for (const writeOffset of writeOffsets) {
                    log(`Tentando escrita OOB U8 no offset ${writeOffset}...`, 'subtest');
                    try {
                        view[writeOffset] = writeValue;
                        log(`VULNERÁVEL: Escrita OOB U8 no offset ${writeOffset} bem-sucedida!`, 'vuln');
                    } catch (writeError) { log(`✅ Escrita OOB U8 bloqueada/erro: ${writeError.message}`, 'good'); }
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            } catch (e) { log(`Erro GERAL no teste OOB U8: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };

        // Teste 2: OOB Write com Outros Tipos (Uint32)
        const runOOBOtherTypes = async () => {
            log("--- Iniciando Teste 2: OOB Write (Uint32) ---", 'test');
             try {
                const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize);
                const view = new Uint32Array(buffer); const numElements = bufferSize / 4;
                const writeValue = 0xDEADBEEF;
                const writeOffsets = [-1, numElements, numElements + 2]; // Offsets de elemento

                 for (const writeOffset of writeOffsets) {
                    log(`Tentando escrita OOB U32 no offset de elemento ${writeOffset}...`, 'subtest');
                    try {
                        view[writeOffset] = writeValue;
                        log(`VULNERÁVEL: Escrita OOB U32 no offset ${writeOffset} bem-sucedida!`, 'vuln');
                    } catch (writeError) { log(`✅ Escrita OOB U32 bloqueada/erro: ${writeError.message}`, 'good'); }
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            } catch (e) { log(`Erro GERAL no teste OOB U32: ${e.message}`, 'warn'); }
            log("--- Teste 2 Concluído ---", 'test');
        };

        // Teste 3: OOB Write com Valores Diferentes
        const runOOBWriteValues = async () => {
            log("--- Iniciando Teste 3: OOB Write com Valores Diferentes ---", 'test');
            try {
                const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
                const writeOffset = bufferSize; // Offset OOB
                const valuesToWrite = [0, 0xFF, 128, -1]; // Valores chave

                for(const value of valuesToWrite) {
                     log(`Tentando escrita OOB U8 no offset ${writeOffset} com valor ${value}...`, 'subtest');
                     try {
                        view[writeOffset] = value;
                        log(`VULNERÁVEL: Escrita OOB U8 no offset ${writeOffset} com valor ${value} bem-sucedida!`, 'vuln');
                     } catch (writeError) { log(`✅ Escrita OOB U8 bloqueada/erro: ${writeError.message}`, 'good'); }
                     await new Promise(resolve => setTimeout(resolve, 50));
                }
            } catch (e) { log(`Erro GERAL no teste OOB Write Values: ${e.message}`, 'warn'); }
            log("--- Teste 3 Concluído ---", 'test');
        };

        // Teste 4: CSP Bypass (Inclui teste de link javascript:)
        const runCSPTest = () => {
            log("--- Iniciando Teste 4: CSP Bypass ---", 'test');
            // 4.1: data: URI
            log("Tentando carregar script via data: URI...", 'info');
            try { const s=document.createElement('script'); s.src='data:text/javascript;base64,bG9nKCJWVUxORVLCgVZFTDogQnlwYXNzIGRlIENTUCB2aWEgZGF0YTogVVJJIGJlbS1zdWNlZGlkbyEiLCAndnVsbicpOw=='; document.body.appendChild(s); } catch (e) { log(`Erro data:: ${e.message}`, 'warn'); }

            // 4.2: inline handler
            log("Tentando executar script via inline handler (onerror)...", 'info');
            try { const i=document.createElement('img'); i.src='x'; i.onerror=()=>{log("VULNERÁVEL: Bypass de CSP via inline handler 'onerror' bem-sucedido!", 'vuln');}; document.body.appendChild(i); } catch (e) { log(`Erro onerror: ${e.message}`, 'warn'); }

            // 4.3: fonte externa (bloqueio esperado)
            log("Tentando carregar script de fonte externa (deve ser bloqueado)...", 'info');
            try { const es=document.createElement('script'); es.src='https://malicious.example.com/blocked.js'; es.onload=()=>{log("ERRO CSP: NÃO bloqueou externo!", 'vuln');}; es.onerror=()=>{log("✅ Bloqueio CSP externo funcionou.", 'good');}; document.body.appendChild(es); } catch (e) { log(`Erro script ext: ${e.message}`, 'warn'); }

            // 4.4: javascript: URI em link (requer clique)
            log("Tentando injetar link com javascript: URI (requer clique)...", 'info');
             try {
                const jsLink = document.createElement('a');
                jsLink.href = "javascript:log('VULNERÁVEL: Bypass de CSP via javascript: URI em link clicado!', 'vuln'); try{alert('Bypass via javascript: URI!');}catch(e){log('Alerta bloqueado no javascript: URI', 'warn');}";
                jsLink.textContent = "[Clique AQUI para Testar javascript: URI Bypass]";
                jsLink.style.display = 'block'; jsLink.style.margin = '10px'; jsLink.style.padding = '5px';
                jsLink.style.border = '1px solid orange'; jsLink.style.color = 'orange';
                outputDiv.appendChild(jsLink); // Adicionar perto dos logs
                log("Link com javascript: URI adicionado. Teste requer clique manual.", 'warn');
            } catch (e) { log(`Erro ao criar link javascript:: ${e.message}`, 'warn'); }

            log("--- Teste 4 Concluído (Verifique logs e clique no link) ---", 'test');
        };

        // Teste 5: Prototype Pollution
        const runPrototypePollutionTest = () => {
             log("--- Iniciando Teste 5: Prototype Pollution ---", 'test');
            const k='poc_inj', v='Polluted!'; try { log(`Tentando poluir Object.prototype['${k}']...`, 'info'); Object.prototype[k]=v; const t={'w':window,'d':document,'n':{}}; let c=0; for(const n in t){ try { if(t[n] && t[n][k]===v){log(`VULNERÁVEL: PP detectada! ${n}.${k}=${t[n][k]}`, 'vuln'); c++;}} catch(e){} } if(c>0){log(`Confirmado: ${c} objeto(s) poluído(s).`, 'vuln');} else {log(`Aviso: Não confirmou poluição.`, 'warn');} try{delete Object.prototype[k];log("Limpou poluição.",'info');}catch(e){log(`Erro limpar PP: ${e.message}`,'warn');} } catch(e){log(`Erro GERAL PP: ${e.message}`,'warn');}
             log("--- Teste 5 Concluído ---", 'test');
        };


        // --- Função Principal de Execução ---
        const runAllTests = async () => {
            log("Iniciando testes de PoC (VERSÃO FOCADA)...");
            const tests = [
                runOOBTestU8,             // Teste 1 - OOB U8
                runOOBOtherTypes,         // Teste 2 - OOB U32
                runOOBWriteValues,        // Teste 3 - OOB Valores
                runCSPTest,               // Teste 4 - CSP Bypass
                runPrototypePollutionTest // Teste 5 - Prototype Pollution
            ];

            for(let i=0; i < tests.length; i++){
                if (!document.getElementById('poc-output')) {
                     console.error("Output div sumiu, provável crash/problema.");
                     break;
                }
                 try {
                    await tests[i]();
                 } catch(testError) {
                    log(`ERRO INESPERADO DURANTE TESTE ${i+1}: ${testError.message}`, 'error');
                 }

                 if (i < tests.length - 1) {
                    log(`Pausa ${PAUSE_DURATION}ms...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION));
                 }
            }

            log("\n\nTodos os testes PoC FOCADOS foram concluídos. Revise o log acima.", 'test');
        };

        // Executar ao carregar a página
        document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
