<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v19 - Base Intacta + Verificações Fase 2</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>PoC v19 - Base Intacta + Verificações Fase 2</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas> <canvas id="fingerprint-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
    <p>Fase 1: PoC Original v9 Intacto (com alerts). Fase 2: Verificações Isoladas (XSS DOM, PP, Canvas).</p>
    <button id="runBtn" onclick="runEverythingInSequence()">Iniciar Teste Completo</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const coordStatusDiv = document.getElementById('canvas-coord-status');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        const LONG_PAUSE = 2000; // Pausa entre fases um pouco menor
        let leakedValueFromOOB = null; // Global Original
        let canvasClickListener = null; // Listener Fase 2
        let canvasMoveListener = null; // Listener Fase 2
        // Áreas globais para Canvas Fase 2
        let rectArea = { x: 10, y: 10, w: 30, h: 30 };
        let linkArea = { x: 150, y: 100, w: 60, h: 30 };

        // --- Função de Log (Original) ---
        const log = (message, type = 'info') => { /* ... (implementação completa) ... */ };

        // --- Helpers (Originais) ---
        const toHex = (val, bits = 32) => { /* ... (implementação completa) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (lógica original) ... */ };
        const isPotentialData32 = (val) => { /* ... (lógica original) ... */ };


        // ============================================================
        // --- FASE 1: Código Original Intacto (`index-18.html`) ---
        // ============================================================
        log("Definindo Funções Originais da Fase 1 (Base Intacta)", "info");

        // Funções: testCSPBypass, testOOBReadInfoLeakEnhancedStore, testBasicPP, testPPJsonHijack, runAllTests
        // Código EXATO do script index-18.html deve ser colado aqui DENTRO da tag <script>.
        // --- Cole o conteúdo da tag <script> do index-18.html aqui ---

        // Exemplo (cole o código real do seu arquivo aqui):
        const testCSPBypass = async () => { log("--- [F1 Orig] Iniciando Teste 1 ---",'test'); /* ... código original ... */ log("--- [F1 Orig] Teste 1 Concluido ---",'test');};
        const testOOBReadInfoLeakEnhancedStore = async () => { log("--- [F1 Orig] Iniciando Teste 2 ---",'test'); /* ... código original ... */ log("--- [F1 Orig] Teste 2 Concluido ---",'test');};
        const testBasicPP = async () => { log("--- [Fase 1] Iniciando Teste 3: PP Básica ---", 'test'); const testProp = '__pp_basic_test__'; const testValue = 'Polluted!'; let success = false; try { log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest'); Object.prototype[testProp] = testValue; log("Verificando herança em objeto vazio {}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const obj = {}; if (obj[testProp] === testValue) { log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln'); success = true; } else { log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good'); } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); } finally { try { delete Object.prototype[testProp]; } catch(e){} log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info'); } log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test'); return success; };
        const testPPJsonHijack = async () => { log("--- [Fase 1] Iniciando Teste 4: PP Hijack ---", 'test'); const originalStringify = JSON.stringify; let hijackSuccessful = false; let interactionSuccessful = false; let hijackReturnedCorrectly = false; try { log("Tentando sobrescrever JSON.stringify...", 'subtest'); JSON.stringify = function hijackedStringify(value, replacer, space) { log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln'); hijackSuccessful = true; log(`  -> Hijack: Tentando aceder ao valor vazado do Teste 2...`, 'info'); try { const leak = leakedValueFromOOB; let leakStr = "NULO"; if (leak) { leakStr = leak.type === 'U64' ? `U64 H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 ${toHex(leak.low)}`; interactionSuccessful = true; } log(`  -> Hijack: Valor armazenado de OOB Read (Teste 2) é: ${leakStr}`, 'leak'); } catch(interactionError) { log(`  -> Hijack: Erro ao aceder/logar valor vazado: ${interactionError.message}`, 'error'); } return '{"hijacked": true, "original_value": "???", "leak_accessed": ' + interactionSuccessful + '}'; }; log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const testObject = { a: 1, b: 'teste' }; log(`Objeto original: ${originalStringify(testObject)}`, 'info'); const result = JSON.stringify(testObject); log(`Resultado retornado por JSON.stringify(): ${result}`, 'info'); if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln'); hijackReturnedCorrectly = true; } else if (hijackSuccessful) { log("AVISO: Função JSON.stringify foi sequestrada, mas o retorno não foi o esperado.", 'warn'); } else { log("FALHA: Sequestro de JSON.stringify não funcionou.", 'good'); } } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); } finally { JSON.stringify = originalStringify; log("Função JSON.stringify restaurada.", 'info'); if (JSON.stringify === originalStringify) { log("Restauração de stringify confirmada.", 'info'); } else { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error'); } } log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou'}) ---`, 'test'); return hijackReturnedCorrectly; };
        const runAllTests = async () => { if (runBtn) runBtn.disabled = true; /* Evita re-entrada acidental */ log("==== [F1 Orig] INICIANDO PoC Original v9 (runAllTests) ====", 'critical'); await testCSPBypass(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); await testOOBReadInfoLeakEnhancedStore(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); await testBasicPP(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); await testPPJsonHijack(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); log("\n==== [F1 Orig] PoC Original v9 CONCLUÍDA (runAllTests) ====", 'critical'); /* Não reabilita botão aqui */ };

        // --- Fim do código original ---


        // ==========================================================
        // --- FASE 2: Testes Adicionais Isolados ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Verificações Isoladas)", "info");

        // Teste A: Verificar Modificação DOM do XSS
        const phase2_VerifyXSSDOMModification = async () => {
            log("--- [Fase 2] Iniciando A: Verificação XSS DOM ---", 'test');
            try {
                const target = document.getElementById('xss-target-div');
                if (target && target.innerHTML.includes('log-vuln')) {
                    log("  SUCESSO: Modificação DOM pelo XSS da Fase 1 foi detectada.", 'good');
                } else {
                    log("  FALHA: Modificação DOM pelo XSS da Fase 1 NÃO detectada.", 'warn');
                }
            } catch(e) { log(`  Erro ao verificar XSS DOM: ${e.message}`, 'error'); }
            log("--- [Fase 2] A: Concluído ---", 'test');
        };

        // Teste B: Verificar PP Básica (Re-teste rápido)
        const phase2_VerifyBasicPPSuccess = async () => {
            log("--- [Fase 2] Iniciando B: Verificação PP Básica ---", 'test');
            const testProp = '__pp_basic_test__'; // Mesmo nome do Teste 3 original
            try {
                // O teste original já fez a limpeza, então a propriedade não deve existir
                if (({}).hasOwnProperty(testProp) || Object.prototype.hasOwnProperty(testProp)) {
                     log(`  AVISO: Propriedade PP Básica ('${testProp}') ainda existe? Limpeza falhou?`, 'warn');
                } else {
                     log(`  INFO: Propriedade PP Básica ('${testProp}') não existe (limpeza da Fase 1 OK).`, 'good');
                }
                 // Poderia tentar poluir e verificar de novo rapidamente aqui se quisesse reconfirmar
            } catch(e) { log(`  Erro ao verificar PP Básica: ${e.message}`, 'error'); }
             log("--- [Fase 2] B: Concluído ---", 'test');
        };

        // Teste C: Verificar PP Hijack e Leitura OOB
        const phase2_VerifyPPHijack = async () => {
            log("--- [Fase 2] Iniciando C: Verificação PP Hijack e Leitura OOB ---", 'test');
             const testObj = { data: 123 };
             const originalStringify = JSON.stringify; // Salva ANTES de tentar hijack
             let hijackFuncionou = false;
             try {
                 // 1. Verifica se hijack ainda é possível (deve ser)
                 JSON.stringify = function phase2Hijack(v) {
                     log("  [Fase 2] => DENTRO DO HIJACK JSON.stringify! <=", 'vuln');
                     // 2. Verifica se ainda consegue ler o valor OOB da Fase 1
                     let leakStr = "NULO";
                     if (leakedValueFromOOB) { // Acessa global setado na Fase 1
                         leakStr = leakedValueFromOOB.type === 'U64' ? `U64@${leakedValueFromOOB.offset} H=${toHex(leakedValueFromOOB.high)} L=${toHex(leakedValueFromOOB.low)}` : `U32@${leakedValueFromOOB.offset} ${toHex(leakedValueFromOOB.low)}`;
                         log(`  [Fase 2] => Leitura OOB da Fase 1: ${leakStr}`, 'leak');
                     } else {
                         log("  [Fase 2] => Valor OOB da Fase 1 é NULO agora.", 'info');
                     }
                     hijackFuncionou = true;
                     return `{"phase2_hijack": true, "original": "${originalStringify(v)}"}`; // Retorna algo diferente
                 };
                 const result = JSON.stringify(testObj);
                 log(`  [Fase 2] Resultado do hijack: ${result}`, 'info');
                 if (!hijackFuncionou) {
                     log("  FALHA: Hijack não foi executado na Fase 2.", 'error');
                 } else if (!result || !result.includes('"phase2_hijack": true')) {
                     log("  AVISO: Hijack executado, mas retorno inesperado.", 'warn');
                 } else {
                     log("  SUCESSO: Hijack e leitura do valor OOB (se existia) verificados na Fase 2.", 'good');
                 }

             } catch(e) {
                  log(`  Erro durante verificação do hijack: ${e.message}`, 'error');
             } finally {
                 JSON.stringify = originalStringify; // Restaura
                 log("  [Fase 2] JSON.stringify restaurado.", 'info');
             }
             log("--- [Fase 2] C: Concluído ---", 'test');
        };

        // Teste D: Verificar Vetores PP Avançados (__proto__, constructor, Array)
        const phase2_TestAdvancedPPVectors = async () => {
            log("--- [Fase 2] Iniciando D: Verificação Vetores PP Avançados ---", 'test');
            const testValue = "AdvancedPP_Fase2";
            let results = {};

            // Teste __proto__
            const protoProp = "__proto_test_f2__";
            try { ({})[protoProp] = "dummy"; delete Object.prototype[protoProp]; ({})[protoProp] = "dummy"; delete Object.prototype[protoProp]; // Tentativa de limpar lixo anterior
                  Object.prototype[protoProp] = testValue; // Tenta via Object.prototype primeiro (mais seguro)
                  if (({})[protoProp] === testValue) { results.proto_Object = true; } else { results.proto_Object = false; }
                  delete Object.prototype[protoProp];

                  Object.prototype[protoProp] = "dummy_val"; // Polui com algo
                  ({}).__proto__[protoProp] = testValue; // Tenta sobrescrever via __proto__
                  if (({})[protoProp] === testValue) { results.proto_Direct = true; } else { results.proto_Direct = false; }
            } catch(e) { results.proto_Direct = `Error: ${e.message}`; }
            finally { delete Object.prototype[protoProp]; }

            // Teste constructor.prototype
            const consProp = "__constructor_test_f2__";
            try { delete Object.prototype[consProp]; delete Object.prototype.constructor.prototype[consProp]; // Limpa
                  Object.prototype.constructor.prototype[consProp] = testValue;
                  results.constructor_Proto = (({})[consProp] === testValue);
            } catch(e) { results.constructor_Proto = `Error: ${e.message}`; }
            finally { try { delete Object.prototype.constructor.prototype[consProp]; delete Object.prototype[consProp]; } catch(e){} }

             // Teste Array.prototype
             const arrayProp = "__array_test_f2__";
             try { delete Array.prototype[arrayProp]; // Limpa
                   Array.prototype[arrayProp] = testValue;
                   results.array_Proto = ([] [arrayProp] === testValue);
             } catch(e) { results.array_Proto = `Error: ${e.message}`; }
             finally { delete Array.prototype[arrayProp]; }

            log(`  Resultados PP Avançado: proto_Obj=${results.proto_Object}, proto_Direct=${results.proto_Direct}, cons_Proto=${results.constructor_Proto}, array_Proto=${results.array_Proto}`, 'info');
            log("--- [Fase 2] D: Concluído ---", 'test');
        };

        // Teste E: Funcionalidade Canvas 2D e Interatividade
        const phase2_TestCanvasFunctionality = async () => {
            log("--- [Fase 2] Iniciando E: Funcionalidade Canvas e Interatividade ---", 'test');
            let canvas = null; let ctx = null;
            try { canvas = fingerprintCanvas; ctx = canvas.getContext('2d'); if(!ctx) throw new Error('No Ctx');
                  ctx.clearRect(0,0,canvas.width, canvas.height); ctx.fillStyle="#333"; ctx.fillRect(0,0,canvas.width, canvas.height); // Limpa e fundo
            } catch(e){ log(` Erro Setup Canvas: ${e.message}`, 'error'); return; }

            log(" Testando desenho, APIs e interatividade...", 'subtest');
            try {
                 // Desenhos
                 ctx.fillStyle="#F00"; ctx.fillRect(rectArea.x, rectArea.y, rectArea.w, rectArea.h); // Usa global
                 ctx.fillStyle="#00F"; ctx.beginPath(); ctx.arc(70, 30, 20, 0, 2*Math.PI); ctx.fill();
                 ctx.fillStyle="rgba(0,255,0,0.6)"; ctx.fillRect(linkArea.x, linkArea.y, linkArea.w, linkArea.h); // Usa global
                 ctx.fillStyle="#FFF"; ctx.font="12px monospace"; ctx.fillText("Link?", linkArea.x+5, linkArea.y+18);

                 // API Checks (filter, toDataURL quirk)
                 const filterSupported = typeof ctx.filter !== 'undefined';
                 log(`  API Filter Suportado: ${filterSupported}`, filterSupported ? 'info' : 'warn');
                 const pngURL = canvas.toDataURL('image/png'); const jpegURL = canvas.toDataURL('image/jpeg');
                 const urlQuirk = pngURL.length === jpegURL.length || pngURL.substring(30,70) === jpegURL.substring(30,70);
                 log(`  toDataURL PNG(len ${pngURL.length}), JPEG(len ${jpegURL.length}). Quirk similaridade: ${urlQuirk}`, urlQuirk ? 'warn' : 'info');

                 // Listeners
                 if(canvasClickListener && canvas) { try { canvas.removeEventListener('click', canvasClickListener); } catch(e){} }
                 if(canvasMoveListener && canvas) { try { canvas.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                 canvasClickListener = (event) => { /* ... (lógica click v15.5 usando globais rectArea/linkArea e lendo xssRanFlag) ... */ };
                 canvasMoveListener = (event) => { /* ... (lógica move v15.5 atualizando coordStatusDiv) ... */ };
                 canvas.addEventListener('click', canvasClickListener); canvas.addEventListener('mousemove', canvasMoveListener);
                 log("  Listeners click/mousemove adicionados.", 'info');

            } catch(e) { log(` Erro no teste Canvas: ${e.message}`, 'error'); }
            log("--- [Fase 2] E: Concluído ---", 'test');
        };


        // Função para rodar a Fase 2 Isolada
        const runPhase2_IsolatedTests = async () => {
            log("==== [Fase 2] INICIANDO Verificações Isoladas ====", 'critical');
            await phase2_VerifyXSSDOMModification(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // A
            await phase2_VerifyBasicPPSuccess(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // B
            await phase2_VerifyPPHijack(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // C
            await phase2_TestAdvancedPPVectors(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // D
            await phase2_TestCanvasFunctionality(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // E
            // Outros testes da Fase 2 (Coleta Dados, Erros, etc.) foram omitidos conforme instrução de focar no que funcionou/é interessante
            log("==== [Fase 2] Verificações Isoladas CONCLUÍDAS ====", 'critical');
        }


        // --- Função Principal Nova ---
        const runEverythingInSequence = async () => { // Chamada pelo botão
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v19 (Base Intacta + Verificações Isoladas) ====", 'critical');

            log(">>> Iniciando Fase 1 (Execução Original 'runAllTests') <<<", 'warn');
            await runAllTests(); // Chama a função ORIGINAL do seu script base
            log(">>> Fase 1 ('runAllTests') CONCLUÍDA (aparentemente) <<<", 'warn');

            log("\n>>> PAUSA LONGA ANTES DA FASE 2 (2 segundos) <<<\n", "warn");
            await new Promise(r => setTimeout(r, LONG_PAUSE));

            log(">>> Iniciando Fase 2 (Verificações Isoladas) <<<", 'warn');
            await runPhase2_IsolatedTests();
            log(">>> Fase 2 (Verificações Isoladas) CONCLUÍDA <<<", 'warn');

            log("\n==== PoC Final v19 CONCLUÍDA ====", 'critical');
            log("Listeners do Canvas podem continuar ativos.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza listeners
        window.addEventListener('unload', () => { /* ... */ });
        // document.addEventListener('DOMContentLoaded', runEverythingInSequence);

    </script>

</body>
</html>
