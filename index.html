<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OOB 64 + Data Collector v12</title> <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho para vulnerabilidade confirmada */
        .log-good { color: #4CAF50; } /* Verde para bloqueio esperado / falha */
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px;} /* Tornar canvas visível para depuração */
    </style>
</head>
<body>
    <h1>Info Leak Finder & Data Collector v12</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas> <canvas id="fingerprint-canvas" width="300" height="150"></canvas> <p>Testa: XSS, OOB R/W, PP (Básica, Avançada, Hijack, Gadgets?), Coleta de Dados (Fingerprinting Básico/Avançado), Sondagem Ambiente, Obs. Erros, Canvas Avançado.</p> <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak

        // --- Função de Log ---
        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDiv.innerHTML.length > 900000){ // Aumentado limite
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 450000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex (sem alterações)
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val); if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }
        // Heurísticas de Ponteiro/Dado (sem alterações)
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false;
            if (high === 0 && low < 0x100000) return false; return true;
        };
        const isPotentialData32 = (val) => {
            if (val === null || typeof val !== 'number') return false; val = val >>> 0;
            if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false;
             if (val < 0x1000) return false; return true;
        }

        // --- Testes 1 a 5 (sem alterações lógicas internas, apenas mantidos) ---
        const testCSPBypass = async () => { /* ... código Teste 1 ... */ log("--- Teste 1 Concluído ---", 'test'); };
        const testOOBReadInfoLeakEnhancedStore = async () => { /* ... código Teste 2 ... */ log(`--- Teste 2 Concluído (...) ---`, 'test'); return true;};
        const testBasicPP = async () => { /* ... código Teste 3 ... */ log(`--- Teste 3 Concluído (...) ---`, 'test'); return true; };
        const testPPJsonHijack = async () => { /* ... código Teste 4 ... */ log(`--- Teste 4 Concluído (...) ---`, 'test'); return true; };
        const testDataCollection = async () => { /* ... código Teste 5 ... */ log("--- Teste 5 Concluído ---", 'test'); };

        // --- Teste 6: Prototype Pollution Avançado --- (sem alterações lógicas internas)
        const testAdvancedPP = async () => { /* ... código Teste 6 ... */ log(`--- Teste 6 Concluído (...) ---`, 'test'); };

        // --- Teste 7: Fingerprinting Avançado (Audio/Canvas) --- (sem alterações lógicas internas)
        const testAdvancedFingerprinting = async () => { /* ... código Teste 7 ... */ log("--- Teste 7 Concluído ---", 'test'); };

        // --- Teste 8: Observação de Erros --- (sem alterações lógicas internas)
        const testErrorObservation = async () => { /* ... código Teste 8 ... */ log("--- Teste 8 Concluído ---", 'test'); };

        // --- NOVO: Teste 9: Tentativas de PP Gadget ---
        const testPPGadgetAttempts = async () => {
            log("--- Iniciando Teste 9: Tentativas de PP Gadget (Especulativo) ---", 'test');
            log("AVISO: Estes testes tentam poluir propriedades que *poderiam* ser gadgets. A eficácia depende do ambiente e de pesquisa externa.", 'warn');
            const gadgetValue = "GadgetPolluted";
            let constructorPolluted = false;
            let toStringPolluted = false;

            // 9.1 Tentar poluir via constructor.prototype
            const constructorProp = "__pp_constructor_gadget__";
            log(`Tentando poluir Object.prototype.constructor.prototype.${constructorProp}...`, 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                // Evita erro se constructor for undefined/null em algum protótipo estranho
                 if (Object.prototype.constructor && Object.prototype.constructor.prototype) {
                    Object.prototype.constructor.prototype[constructorProp] = gadgetValue;
                    if (({})[constructorProp] === gadgetValue) {
                        log(`VULN?: Poluição via constructor.prototype.${constructorProp} parece ter funcionado!`, 'vuln');
                        constructorPolluted = true;
                    } else {
                        log(`INFO: Poluição via constructor.prototype.${constructorProp} não afetou {}.`, 'info');
                    }
                 } else {
                     log(`INFO: Object.prototype.constructor.prototype não acessível.`, 'info');
                 }
            } catch(e) {
                 log(`ERRO/BLOQUEADO: Poluição via constructor.prototype falhou: ${e.message}`, 'good');
            } finally {
                 try { delete Object.prototype[constructorProp]; } catch(e){} // Tenta limpar Object.prototype
                 try { if (Object.prototype.constructor && Object.prototype.constructor.prototype) delete Object.prototype.constructor.prototype[constructorProp]; } catch(e) {} // Tenta limpar o alvo
            }

             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // 9.2 Tentar poluir propriedade em toString
            const toStringProp = "__pp_toString_gadget__";
            log(`Tentando poluir Object.prototype.toString.${toStringProp}...`, 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             let originalToStringDesc = null;
             try {
                 // Verifica se toString é gravável (pode não ser)
                 originalToStringDesc = Object.getOwnPropertyDescriptor(Object.prototype, 'toString');
                 if (!originalToStringDesc || originalToStringDesc.writable || originalToStringDesc.configurable) {
                    Object.prototype.toString[toStringProp] = gadgetValue; // Adiciona prop à função
                    if (({}).toString[toStringProp] === gadgetValue) {
                        log(`INFO: Adicionada propriedade ${toStringProp} a Object.prototype.toString herdada.`, 'info');
                        toStringPolluted = true; // Indica que a propriedade foi adicionada, não que um gadget foi ativado
                    } else {
                        log(`INFO: Propriedade ${toStringProp} não parece ter sido herdada em ({}).toString.`, 'info');
                    }
                 } else {
                      log(`INFO: Object.prototype.toString não é gravável/configurável.`, 'good');
                 }
             } catch (e) {
                  log(`ERRO/BLOQUEADO: Poluição em toString falhou: ${e.message}`, 'good');
             } finally {
                   // Tenta limpar a propriedade da função, se ela foi adicionada
                   try { delete Object.prototype.toString[toStringProp]; } catch(e) {}
             }

            log(`--- Teste 9 Concluído (Constructor ${constructorPolluted ? 'Funcionou?' : 'Falhou/Bloqueado'}, toString ${toStringPolluted ? 'Prop Adicionada' : 'Falhou/Bloqueado'}) ---`, 'test');
        };

        // --- NOVO: Teste 10: Sondagem do Ambiente (WebView) ---
        const testEnvironmentProbing = async () => {
             log("--- Iniciando Teste 10: Sondagem do Ambiente (WebView/PWA) ---", 'test');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

             log("Verificando interfaces comuns de WebView/PWA...", 'subtest');
             let isWebViewLikely = false;

             // iOS WKWebView
             try {
                 if (window.webkit && window.webkit.messageHandlers) {
                     const handlers = Object.keys(window.webkit.messageHandlers).join(', ') || 'Nenhum';
                     log(`  window.webkit.messageHandlers encontrado! Handlers: ${handlers}`, 'warn');
                     isWebViewLikely = true;
                 } else {
                     log(`  window.webkit.messageHandlers: Não encontrado.`, 'info');
                 }
             } catch(e) { log(`  Erro verificando window.webkit: ${e.message}`, 'warn'); }

             // Android WebView (genérico - nomes podem variar muito)
             try {
                 let androidBridgeFound = null;
                 if (typeof window.Android !== "undefined") androidBridgeFound = "window.Android";
                 else if (typeof window.JSBridge !== "undefined") androidBridgeFound = "window.JSBridge";
                 else if (typeof window.AppInterface !== "undefined") androidBridgeFound = "window.AppInterface";
                 // Adicionar outros nomes comuns se conhecido

                 if (androidBridgeFound) {
                     log(`  Possível interface Android WebView encontrada: ${androidBridgeFound}`, 'warn');
                     isWebViewLikely = true;
                 } else {
                     log(`  Interfaces comuns Android WebView: Não encontradas.`, 'info');
                 }
             } catch(e) { log(`  Erro verificando interfaces Android: ${e.message}`, 'warn'); }

            // Edge WebView2
             try {
                 if (window.chrome && window.chrome.webview) {
                    log(`  window.chrome.webview encontrado! (Edge WebView2?)`, 'warn');
                    isWebViewLikely = true;
                 } else {
                     log(`  window.chrome.webview: Não encontrado.`, 'info');
                 }
             } catch(e) { log(`  Erro verificando window.chrome.webview: ${e.message}`, 'warn'); }

             // iOS PWA/Standalone
              try {
                 if (navigator.standalone === true) {
                    log(`  navigator.standalone é true (iOS PWA/Standalone?)`, 'warn');
                    isWebViewLikely = true; // Ou PWA
                 } else if (navigator.standalone === false) {
                     log(`  navigator.standalone é false.`, 'info');
                 } else {
                     log(`  navigator.standalone: Não suportado/Indefinido.`, 'info');
                 }
             } catch(e) { log(`  Erro verificando navigator.standalone: ${e.message}`, 'warn'); }

             // Re-verificar platform/vendor (podem ter mudado?)
             try { log(`  navigator.platform (recheck): ${navigator.platform}`, 'info'); } catch(e) {}
             try { log(`  navigator.vendor (recheck): ${navigator.vendor}`, 'info'); } catch(e) {}


             if (isWebViewLikely) {
                  log("CONCLUSÃO PARCIAL: Detecção de uma ou mais interfaces comuns de WebView/PWA/Standalone.", 'warn');
             } else {
                  log("CONCLUSÃO PARCIAL: Nenhuma interface comum de WebView detectada.", 'info');
             }

             log("--- Teste 10 Concluído ---", 'test');
        };

        // --- NOVO: Teste 11: Testes Avançados de Canvas 2D ---
        const testAdvancedCanvas = async () => {
            log("--- Iniciando Teste 11: Testes Avançados de Canvas 2D ---", 'test');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            let canvas = null;
            let ctx = null;
            try {
                canvas = document.getElementById('fingerprint-canvas');
                if (!canvas || !canvas.getContext) throw new Error('Canvas 2D element not found or not supported');
                ctx = canvas.getContext('2d');
                if (!ctx) throw new Error('Canvas 2D context not available');
                log("Contexto Canvas 2D obtido.", 'info');
            } catch(e) {
                log(` Falha ao obter contexto Canvas 2D: ${e.message}`, 'error');
                log("--- Teste 11 Abortado ---", 'test');
                return;
            }

            // 11.1 Desenho Complexo e Checksum
            log("Desenhando formas complexas e calculando checksum...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const startDraw = performance.now();
                ctx.fillStyle = "#f0f"; // Fundo Magenta para diferenciar
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#000"; // Cor de desenho

                // Desenhos variados
                ctx.fillRect(10, 10, 50, 50); // Retângulo
                ctx.beginPath(); // Círculo
                ctx.arc(100, 35, 25, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath(); // Linha
                ctx.moveTo(10, 70); ctx.lineTo(120, 120); ctx.stroke();
                ctx.font = "16px sans-serif"; // Texto com fonte diferente
                ctx.fillText("Canvas Test @ 123", 130, 30);
                // Curva
                ctx.beginPath(); ctx.moveTo(150, 70); ctx.bezierCurveTo(170, 10, 230, 130, 250, 100); ctx.stroke();
                // Gradiente
                const gradient = ctx.createLinearGradient(200, 10, 280, 10);
                gradient.addColorStop(0, "red"); gradient.addColorStop(1, "blue");
                ctx.fillStyle = gradient; ctx.fillRect(200, 10, 80, 50);

                 const endDraw = performance.now();
                 const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                 let checksum = 0;
                 for (let i = 0; i < imageData.data.length; i++) { checksum = (checksum + imageData.data[i]) % 1000000007; } // Checksum modular simples
                 log(`  Desenho complexo concluído em ${(endDraw - startDraw).toFixed(2)} ms.`, 'info');
                 log(`  Checksum da imagem resultante: ${checksum}`, 'info');

             } catch(e) {
                  log(`  Erro durante desenho/checksum: ${e.message}`, 'error');
             }

             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // 11.2 Teste de APIs específicas
            log("Verificando suporte a APIs Canvas 2D específicas...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                 log(`  ctx.ellipse suportado: ${typeof ctx.ellipse === 'function'}`, 'info');
                 log(`  ctx.filter suportado: ${typeof ctx.filter !== 'undefined'}`, 'info'); // Filter é propriedade, não função
                 log(`  ctx.resetTransform suportado: ${typeof ctx.resetTransform === 'function'}`, 'info');
                 log(`  ctx.imageSmoothingQuality suportado: ${typeof ctx.imageSmoothingQuality !== 'undefined'}`, 'info');
                 try { ctx.imageSmoothingQuality = 'high'; log(`    ctx.imageSmoothingQuality='high' atribuído. Valor atual: ${ctx.imageSmoothingQuality}`, 'info'); } catch(e) { log(`    ctx.imageSmoothingQuality='high' falhou: ${e.message}`, 'warn');}
             } catch (e) {
                 log(`  Erro ao verificar APIs específicas: ${e.message}`, 'error');
             }

             // 11.3 Teste toDataURL (pode falhar com canvas 'tainted', mas não é o caso aqui)
             log("Testando toDataURL...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
              try {
                 const dataUrlPng = canvas.toDataURL('image/png');
                 log(`  toDataURL('image/png') funcionou. Início: ${dataUrlPng.substring(0, 70)}... (Tamanho: ${dataUrlPng.length})`, 'info');
                 try {
                    const dataUrlJpeg = canvas.toDataURL('image/jpeg', 0.8); // Com qualidade
                    log(`  toDataURL('image/jpeg', 0.8) funcionou. Início: ${dataUrlJpeg.substring(0, 70)}... (Tamanho: ${dataUrlJpeg.length})`, 'info');
                 } catch(e) { log(`  toDataURL('image/jpeg') falhou: ${e.message}`, 'warn');}
              } catch (e) {
                  log(`  Erro ao testar toDataURL: ${e.message}`, 'error');
              }

            log("--- Teste 11 Concluído ---", 'test');
        };

        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v12 (Mais Exploração) ====", 'critical'); // Versão atualizada

            // Coleta de Dados e Fingerprinting Básico/Avançado
            await testDataCollection(); // Teste 5
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedFingerprinting(); // Teste 7
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Sondagem do Ambiente Específico
            await testEnvironmentProbing(); // Teste 10 (Novo)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

             // Testes de Canvas Avançado
            await testAdvancedCanvas(); // Teste 11 (Novo)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Testes de Vulnerabilidade Clássicos
            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Testes de Prototype Pollution
            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedPP(); // Teste 6
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPGadgetAttempts(); // Teste 9 (Novo)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPJsonHijack(); // Teste 4
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Observação de Comportamento Esperado
            await testErrorObservation(); // Teste 8
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("\n==== PoC Final v12 CONCLUÍDA ====", 'critical'); // Versão atualizada
            if (runBtn) runBtn.disabled = false;
        };

        // Carregar todos os scripts e HTML antes de rodar
        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
