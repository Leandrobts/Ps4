<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v14 - Explora√ß√£o Baseada em Evid√™ncias</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; } /* Fundo para visibilidade */
    </style>
</head>
<body>
    <h1>PoC v14 - Explora√ß√£o Baseada em Evid√™ncias</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas> <canvas id="fingerprint-canvas" width="300" height="150"></canvas> <p>Testa (baseado em achados): Fingerprinting Extensivo, Quirks de Ambiente/API, Canvas Avan√ßado/Interativo, XSS, OOB (Mec√¢nica), PP Extensiva (B√°sica, Avan√ßada, Gadgets Especulativos, Hijack, Intera√ß√µes).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">√Årea para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Teste OOB (provavelmente padr√£o)
        let canvasClickListener = null; // Handler do clique no canvas
        const INTERACTION_POLLUTION_PROP = '__pp_interaction_test__'; // Prop para teste de intera√ß√£o PP

        // --- Fun√ß√£o de Log ---
        const log = (message, type = 'info') => { /* ... (implementa√ß√£o anterior, talvez ajustar limite) ... */
             if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 1200000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 600000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro na fun√ß√£o log:", e); outputDiv = null; }
        };

        // --- Helpers (toHex, Heur√≠sticas) ---
        const toHex = (val, bits = 32) => { /* ... (implementa√ß√£o anterior) ... */ if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        // Heur√≠sticas ajustadas para logar mas n√£o necessariamente armazenar padr√µes
        const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false; if (val < 0x1000) return false; return true; };

        // --- Defini√ß√µes dos Testes ---

        // Teste A: Coleta de Dados B√°sica (Equivalente ao Teste 5 anterior)
        const testBasicDataCollection = async () => { log("--- Iniciando Teste A: Coleta Dados B√°sicos ---", 'test'); /* ... (c√≥digo do testDataCollection anterior) ... */ await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); log("Coletando dados de Navigator...", 'subtest'); try { log(` navigator.userAgent: ${navigator.userAgent}`, 'info'); } catch(e){} /*...*/ try { log(` navigator.webdriver: ${navigator.webdriver === true ? 'True' : 'False/N/A'}`, 'info'); } catch(e){} try {const p=navigator.plugins; log(` navigator.plugins: ${p?p.length:0} (${p&&p.length>0?Array.from(p).map(i=>i.name).join('; '):'N/A'})`, 'info');}catch(e){} await new Promise(resolve=>setTimeout(resolve,SHORT_PAUSE)); log("Coletando dados Tela/Recursos/Tempo...", 'subtest'); try{log(` screen: ${screen.width}x${screen.height} (${screen.colorDepth}bit)`, 'info');}catch(e){} try{log(` localStorage: ${!!window.localStorage}, sessionStorage: ${!!window.sessionStorage}`, 'info');}catch(e){} try{log(` WebSocket: ${!!window.WebSocket}, Wasm: ${typeof(WebAssembly)==='object'}, ServiceWorker: ${'serviceWorker' in navigator}`, 'info');}catch(e){} try{log(` WebRTC: ${!!window.RTCPeerConnection}`, 'info');}catch(e){} try{log(` TimezoneOffset: ${new Date().getTimezoneOffset()}`, 'info');}catch(e){} try{const s=performance.now();let c=0;for(let i=0;i<100000;i++){c++;}const E=performance.now();log(` Perf Loop(100k): ${(E-s).toFixed(2)}ms`, 'info');}catch(e){} await new Promise(resolve=>setTimeout(resolve,SHORT_PAUSE)); log("Coletando dados WebGL (esperado falhar)...", 'subtest'); try{const c=document.getElementById('webgl-canvas'); const gl=c.getContext('webgl')||c.getContext('experimental-webgl'); if(gl){const d=gl.getExtension('WEBGL_debug_renderer_info');log(` WebGL Vendor: ${gl.getParameter(d?d.UNMASKED_VENDOR_WEBGL:gl.VENDOR)}`, 'info');log(` WebGL Renderer: ${gl.getParameter(d?d.UNMASKED_RENDERER_WEBGL:gl.RENDERER)}`, 'info');}else{log(' WebGL n√£o dispon√≠vel.', 'warn');}}catch(e){log(` Erro WebGL: ${e.message}`, 'error');} log("--- Teste A Conclu√≠do ---", 'test'); };

        // Teste B: Sondagem do Ambiente (WebView/PWA) (Equivalente ao Teste 10 anterior)
        const testEnvironmentProbing = async () => { log("--- Iniciando Teste B: Sondagem Ambiente (WebView/PWA) ---", 'test'); /* ... (c√≥digo do testEnvironmentProbing anterior) ... */ log("Verificando interfaces comuns...", 'subtest'); let found=false; try{if(window.webkit?.messageHandlers){log(` window.webkit.messageHandlers encontrado!`, 'warn'); found=true;}}catch(e){} try{if(typeof window.Android !== "undefined" || typeof window.JSBridge !== "undefined"){log(` Interface Android encontrada?`, 'warn'); found=true;}}catch(e){} try{if(window.chrome?.webview){log(` window.chrome.webview encontrado!`, 'warn'); found=true;}}catch(e){} try{if(navigator.standalone===true){log(` navigator.standalone √© true`, 'warn'); found=true;}}catch(e){} log(` Interfaces comuns WebView/PWA encontradas: ${found}`, 'info'); log("--- Teste B Conclu√≠do ---", 'test'); };

        // Teste C: Fingerprinting Avan√ßado (Audio/Canvas Text) (Equivalente ao Teste 7 anterior)
        const testAdvancedFingerprinting = async () => { log("--- Iniciando Teste C: Fingerprinting Avan√ßado ---", 'test'); /* ... (c√≥digo do testAdvancedFingerprinting anterior) ... */ log("Coletando dados AudioContext (esperado falhar)...", 'subtest'); let audioCtx=null; try{const AC=window.AudioContext||window.webkitAudioContext; if(AC){audioCtx=new AC(); log(` AudioContext: Sim (SampleRate: ${audioCtx.sampleRate})`, 'info');}else{log(` AudioContext indispon√≠vel.`, 'warn');}}catch(e){log(` Erro AudioContext: ${e.message}`, 'error');} finally{if(audioCtx?.state!=='closed'){try{await audioCtx.close();}catch(e){}}} await new Promise(resolve=>setTimeout(resolve,SHORT_PAUSE)); log("Coletando dados Canvas Text...", 'subtest'); try{const c=fingerprintCanvas; const ctx=c.getContext('2d'); if(!ctx) throw new Error('No 2D Ctx'); ctx.clearRect(0,0,c.width,c.height); ctx.fillStyle="#fff"; ctx.fillRect(0,0,c.width,c.height); const txt="Canvas Fingerprint Test 123? <>#$%"; ctx.font="16px 'Arial'"; ctx.fillStyle="#000"; ctx.fillText(txt, 5, 20); const imgData=ctx.getImageData(0,0,c.width,c.height); let chk=0; for(let i=0;i<imgData.data.length;i++){chk=(chk+imgData.data[i])%1000000007;} log(` Canvas 2D: Sim (Text Checksum: ${chk})`, 'info');}catch(e){log(` Erro Canvas Text: ${e.message}`, 'error');} log("--- Teste C Conclu√≠do ---", 'test'); };

        // Teste D: Canvas 2D Avan√ßado e Quirks (Equivalente ao Teste 11 anterior)
        const testAdvancedCanvas = async () => { log("--- Iniciando Teste D: Canvas Avan√ßado e Quirks ---", 'test'); /* ... (c√≥digo do testAdvancedCanvas anterior) ... */ let canvas=null, ctx=null; try{canvas=fingerprintCanvas; ctx=canvas.getContext('2d'); if(!ctx) throw new Error('No 2D Ctx');}catch(e){log(` Falha setup Canvas: ${e.message}`,'error'); return;} log("Desenhando e testando APIs Canvas...", 'subtest'); try{const s=performance.now(); ctx.fillStyle="#0f0"; ctx.fillRect(0,0,canvas.width,canvas.height); /* Desenhos mais simples */ ctx.fillStyle="#f00"; ctx.fillRect(10,10,30,30); ctx.beginPath();ctx.arc(70,30,20,0,2*Math.PI);ctx.fill(); const e=performance.now(); const imgD=ctx.getImageData(0,0,canvas.width,canvas.height); let chk=0; for(let i=0;i<imgD.data.length;i+=4){chk=(chk+imgD.data[i]+imgD.data[i+1]+imgD.data[i+2]+imgD.data[i+3])%1000000007;} log(` Desenho simples: ${(e-s).toFixed(2)}ms, Checksum: ${chk}`, 'info'); log(` API ellipse: ${typeof ctx.ellipse==='function'}, filter: ${typeof ctx.filter!=='undefined'}, resetTransform: ${typeof ctx.resetTransform==='function'}, imageSmoothingQuality: ${typeof ctx.imageSmoothingQuality!=='undefined'}`, 'info'); if(typeof ctx.filter==='undefined') log(` Quirky: ctx.filter n√£o suportado (esperado em Safari 17).`, 'warn'); const pngURL=canvas.toDataURL('image/png'); const jpegURL=canvas.toDataURL('image/jpeg'); log(` toDataURL PNG ok (len ${pngURL.length}), JPEG ok (len ${jpegURL.length})`, 'info'); if(pngURL.substring(22,60)===jpegURL.substring(23,61) || pngURL.length === jpegURL.length){ log(` Quirky: toDataURL PNG/JPEG parecem similares/iguais!`, 'warn'); } }catch(e){log(` Erro nos testes avan√ßados Canvas: ${e.message}`, 'error');} log("--- Teste D Conclu√≠do ---", 'test'); };

        // Teste E: Canvas 2D Interativo e Stress (Equivalente ao Teste 12 anterior)
        const testInteractiveCanvas = async () => { log("--- Iniciando Teste E: Canvas Interativo e Stress ---", 'test'); /* ... (c√≥digo do testInteractiveCanvas anterior) ... */ let canvas=null, ctx=null; const rectArea={x:10,y:10,w:30,h:30}; const linkArea={x:150,y:100,w:60,h:30}; try{canvas=fingerprintCanvas; ctx=canvas.getContext('2d'); if(!ctx) throw new Error('No 2D Ctx'); ctx.fillStyle="rgba(0,255,0,0.5)";ctx.fillRect(linkArea.x,linkArea.y,linkArea.w,linkArea.h); ctx.fillStyle="#fff"; ctx.font="12px monospace"; ctx.fillText("Link?", linkArea.x+5, linkArea.y+18);}catch(e){log(` Falha setup Canvas Interativo: ${e.message}`,'error'); return;} log("Adicionando listener 'click'...", 'subtest'); if(canvasClickListener&&canvas){try{canvas.removeEventListener('click', canvasClickListener);}catch(e){}} canvasClickListener=(event)=>{try{const r=canvas.getBoundingClientRect();const x=event.clientX-r.left; const y=event.clientY-r.top; let area='fora'; if(x>=rectArea.x&&x<=rectArea.x+rectArea.w&&y>=rectArea.y&&y<=rectArea.y+rectArea.h) area='Ret√¢ngulo'; else if(x>=linkArea.x&&x<=linkArea.x+linkArea.w&&y>=linkArea.y&&y<=linkArea.y+linkArea.h) area='√Årea Link'; log(` Canvas Click! Coords: x=${x.toFixed(0)}, y=${y.toFixed(0)}. √Årea: ${area}. (Flag XSS: ${window.teste1_XSS_Realizado === true})`, 'info');}catch(e){log(`Erro click handler: ${e.message}`,'error');}}; try{canvas.addEventListener('click',canvasClickListener); log(" Listener 'click' adicionado.",'info');}catch(e){log(`Erro add listener: ${e.message}`,'error');} await new Promise(resolve=>setTimeout(resolve,SHORT_PAUSE)); log("Iniciando stress desenho/toDataURL...", 'subtest'); try{const sS=performance.now(); for(let i=0;i<500;i++){ctx.fillStyle=`rgba(${(i*30)%255},${(i*50)%255},${(i*70)%255},0.05)`;ctx.fillRect(Math.random()*canvas.width,Math.random()*canvas.height,5,5);if(i%100===0) await new Promise(r=>setTimeout(r,0));} const eS=performance.now(); log(` Stress desenho (500): ${(eS-sS).toFixed(2)}ms`, 'info'); const sU=performance.now(); for(let i=0;i<5;i++){canvas.toDataURL(); if(i%2===0) await new Promise(r=>setTimeout(r,0));} const eU=performance.now(); log(` Stress toDataURL (5): ${(eU-sU).toFixed(2)}ms`, 'info');}catch(e){log(` Erro stress canvas: ${e.message}`,'error');} await new Promise(resolve=>setTimeout(resolve,SHORT_PAUSE)); log("Testando measureText...", 'subtest'); try{ctx.font="14px monospace"; const m1=ctx.measureText("Teste"); const m2=ctx.measureText("üòäüáßüá∑"); log(` measureText widths: "${m1.width.toFixed(2)}", "${m2.width.toFixed(2)}"`, 'info');} catch(e){log(` Erro measureText: ${e.message}`,'error');} log("--- Teste E Conclu√≠do ---", 'test'); };

        // Teste F: Observa√ß√£o de Erros Detalhada (Equivalente ao Teste 8 + mais erros)
        const testErrorObservation = async () => { log("--- Iniciando Teste F: Observa√ß√£o Erros Detalhada ---", 'test'); /* ... (c√≥digo do testErrorObservation anterior + novos) ... */ log("Testando erros comuns...", 'subtest'); let errors = {}; try{ var _a = nonExistentVariable; } catch(e) { errors['ReferenceError'] = e.message; log(` ReferenceError: ${e.message}`, 'good'); } try{ null.method(); } catch(e) { errors['TypeError'] = e.message; log(` TypeError: ${e.message}`, 'good'); } try{ decodeURIComponent('%E0%A4%A'); } catch(e) { errors['URIError'] = e.message; log(` URIError: ${e.message}`, 'good'); } try{ const buffer=new ArrayBuffer(1); const dv=new DataView(buffer); dv.getInt8(-1); } catch(e) { errors['RangeError (DataView)'] = e.message; log(` RangeError (DataView): ${e.message}`, 'good'); } try { if(Object.prototype[INTERACTION_POLLUTION_PROP]) { log(` Intera√ß√£o PP->Erro: Propriedade '${INTERACTION_POLLUTION_PROP}' existe antes de erro (valor: ${Object.prototype[INTERACTION_POLLUTION_PROP]})`, 'warn'); } else { log(` Intera√ß√£o PP->Erro: Propriedade '${INTERACTION_POLLUTION_PROP}' N√ÉO existe antes de erro.`, 'info'); } } catch(e){} log(` Mensagens de erro capturadas: ${JSON.stringify(errors)}`, 'info'); log("--- Teste F Conclu√≠do ---", 'test'); };

        // Teste G: XSS (Equivalente ao Teste 1 anterior, com flag)
        const testXSS = async () => { log("--- Iniciando Teste G: XSS ---", 'test'); window.teste1_XSS_Realizado = false; /*...*/ log("Tentando XSS DOM via inline handler (onerror)...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try{const img=document.createElement('img'); img.src='invalid_img_'+Date.now(); const payload=`try{const t=document.getElementById('xss-target-div'); if(t){t.innerHTML='<h2 class="log-vuln">XSS DOM ONERROR!</h2>'; log("XSS DOM via onerror!", "vuln");} window.teste1_XSS_Realizado = true; alert('XSS_DOM_ONERROR');}catch(e){log("Erro payload onerror: "+e.message, "warn");}`; img.setAttribute('onerror',payload); document.body.appendChild(img); log(" Tag <img> com onerror adicionada.",'info');} catch(e){log(`Erro img onerror: ${e.message}`, 'error');} /*...*/ log("--- Teste G Conclu√≠do ---", 'test'); };

        // Teste H: OOB Mec√¢nica (Equivalente ao Teste 2 anterior)
        const testOOBMechanics = async () => { log("--- Iniciando Teste H: OOB Mec√¢nica ---", 'test'); /* ... (c√≥digo do testOOBReadInfoLeakEnhancedStore anterior) ... */ log("AVISO: Este teste verifica a mec√¢nica de R/W OOB dentro do padding do buffer, mas N√ÉO se espera um vazamento real de mem√≥ria externa.", 'warn'); /* ... resto do c√≥digo ... */ log(`--- Teste H Conclu√≠do (...) ---`, 'test'); return true; };

        // Teste I: PP B√°sica (Equivalente ao Teste 3 anterior)
        const testBasicPP = async () => { log("--- Iniciando Teste I: PP B√°sica ---", 'test'); /* ... (c√≥digo do testBasicPP anterior) ... */ log(`--- Teste I Conclu√≠do (...) ---`, 'test'); return true; };

        // Teste J: PP Avan√ßada (`__proto__`, Array) (Equivalente ao Teste 6 anterior)
        const testAdvancedPP = async () => { log("--- Iniciando Teste J: PP Avan√ßada ---", 'test'); /* ... (c√≥digo do testAdvancedPP anterior) ... */ log(`--- Teste J Conclu√≠do (...) ---`, 'test'); };

        // Teste K: Tentativas de PP Gadget Especulativo (Equivalente ao Teste 9 anterior + mais)
        const testPPGadgetAttempts = async () => { log("--- Iniciando Teste K: PP Gadgets Especulativos ---", 'test'); /* ... (c√≥digo do testPPGadgetAttempts anterior + innerHTML/src) ... */ log("AVISO: Tentativas especulativas baseadas em padr√µes comuns.", 'warn'); const val="GadgetPP_"+Date.now(); let results={}; try{Object.prototype.constructor.prototype.gadget1=val; results.constructor=({}).gadget1===val; delete Object.prototype.constructor.prototype.gadget1;}catch(e){results.constructor=e.message;} try{Object.prototype.toString.gadget2=val; results.toString=({}).toString.gadget2===val; delete Object.prototype.toString.gadget2;}catch(e){results.toString=e.message;} try{Object.prototype.innerHTML=val; results.innerHTML=document.createElement('div').innerHTML===val; delete Object.prototype.innerHTML;}catch(e){results.innerHTML=e.message;} try{Object.prototype.src=val; results.src=document.createElement('img').src===val; delete Object.prototype.src;}catch(e){results.src=e.message;} try{Math.random=()=>'Polluted!'; results.mathRandom = Math.random()==='Polluted!'; Math.random=Math.random.original; } catch(e){results.mathRandom = e.message;} log(` Resultados Gadgets Especulativos: ${JSON.stringify(results)}`, 'info'); /* Limpeza adicional pode ser necess√°ria */ log("--- Teste K Conclu√≠do ---", 'test'); };

        // Teste L: PP Hijack (JSON.stringify) (Equivalente ao Teste 4 anterior)
        const testPPHijack = async () => { log("--- Iniciando Teste L: PP Hijack ---", 'test'); /* ... (c√≥digo do testPPJsonHijack anterior) ... */ log(`--- Teste L Conclu√≠do (...) ---`, 'test'); return true; };

        // Teste M: Intera√ß√£o PP -> Canvas/Erro Prep (Poluir)
        const testInteractionPrep = async () => {
             log("--- Iniciando Teste M: Intera√ß√£o Prep (Poluindo) ---", 'test');
             try {
                 log(`Poluindo Object.prototype.${INTERACTION_POLLUTION_PROP} = true`, 'info');
                 Object.prototype[INTERACTION_POLLUTION_PROP] = true;
             } catch(e) { log(`Falha ao poluir para intera√ß√£o: ${e.message}`, 'error'); }
             // N√£o h√° 'conclu√≠do' aqui, a polui√ß√£o permanece para os pr√≥ximos testes
        };

        // Teste N: Intera√ß√£o PP -> Canvas/Erro Cleanup (Limpar)
        const testInteractionCleanup = async () => {
             log("--- Iniciando Teste N: Intera√ß√£o Cleanup (Limpando) ---", 'test');
             try {
                 delete Object.prototype[INTERACTION_POLLUTION_PROP];
                 log(`Limpando Object.prototype.${INTERACTION_POLLUTION_PROP}. Existe ainda? ${Object.prototype.hasOwnProperty(INTERACTION_POLLUTION_PROP)}`, 'info');
             } catch(e) { log(`Falha ao limpar polui√ß√£o de intera√ß√£o: ${e.message}`, 'warn'); }
             log("--- Teste N Conclu√≠do ---", 'test');
        };


        // --- Fun√ß√£o Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v14 (Baseado em Evid√™ncias) ====", 'critical');

            // 1. Setup e Fingerprinting Inicial
            await testBasicDataCollection(); // Teste A
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testEnvironmentProbing(); // Teste B
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedFingerprinting(); // Teste C
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 2. Canvas (Intera√ß√£o PP ser√° testada aqui) e OOB (Executar Canvas antes)
            await testInteractionPrep(); // Teste M (Polui para intera√ß√£o)
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); // Pausa curta
            await testAdvancedCanvas(); // Teste D (Verificar√° heran√ßa de M)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testInteractiveCanvas(); // Teste E (Verificar√° heran√ßa de M)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            // Teste OOB H depois do Canvas
            await testOOBMechanics(); // Teste H
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 3. Observa√ß√£o de Erros (Intera√ß√£o PP ser√° testada aqui)
            await testErrorObservation(); // Teste F (Verificar√° heran√ßa de M)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testInteractionCleanup(); // Teste N (Limpa polui√ß√£o de M)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

             // 4. Testes de Prototype Pollution (Verificar se limpeza de M funcionou)
            await testBasicPP(); // Teste I
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedPP(); // Teste J
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPGadgetAttempts(); // Teste K (Expandido)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPHijack(); // Teste L (Depende de PP e OOB)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 5. Teste de XSS (Executa por √∫ltimo, verifica flag)
            await testXSS(); // Teste G (Modificado para setar flag)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("\n==== PoC Final v14 CONCLU√çDA ====", 'critical');
            log("Listener de clique do Canvas continua ativo. Limpeza n√£o implementada para este PoC.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza do listener do canvas
        window.addEventListener('unload', () => { /* ... (c√≥digo anterior) ... */ });
        // document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
