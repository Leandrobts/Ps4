<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v17 - Primitive Refine + APIs + Canvas Interact)</title>
    <style>
        /* Estilos CSS (Idênticos v14/v15/v16) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(Refined + APIs + Interact) - Script 1 (v17)</h1>
    <p>Testa: XSS, OOB R/W, PP Básica, PP Hijack, OOB UAF/OtherTypes, WebSockets, Web Workers, IndexedDB, DOM Stress.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1 (v17)</button> <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v17) - Script 2</h2>
        <p>Foco: PP Avançado++, OOB Read++, OOB Write->Metadata/ImageData, WebGL(N/A), FileSystem(N/A), WebGPU(N/A), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="350" height="250"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v17</button> <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 (v17 - Refined Primitives + More APIs) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null;

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
             if (!keepLog && type === 'good') {
                 const lowerMsg = String(message).toLowerCase();
                 if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('completo') || lowerMsg.includes('ok') || lowerMsg.includes('recebida')) { keepLog = true; }
            }
            if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; }
            if (!keepLog) return;

            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; }
                 outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms)); // Alias for Script 1 pauses
        const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };

        // --- Testes Script 1 ---

        // Teste 1: XSS (Inalterado)
        const testCSPBypass = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testCSPBypass'; log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME); try { const payloadJS = `try { log("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); alert('XSS S1 via Data URI!'); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = (e) => { log(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME); }; document.body.appendChild(scriptTag); await PAUSE_S1(SHORT_PAUSE * 2); document.body.removeChild(scriptTag); } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME); } await PAUSE_S1(); try { const imgTag = document.createElement('img'); const imgSrc = 'invalid_img_' + Date.now(); imgTag.src = imgSrc; const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { log("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); await PAUSE_S1(SHORT_PAUSE * 2); document.body.removeChild(imgTag); } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME); } log("--- Teste 1 Concluído ---", 'test', FNAME);
        };

        // Teste 2: OOB Read/Write (Inalterado)
        const testOOBReadInfoLeakEnhancedStore = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize; const readRangeStart = -64; const readRangeEnd = bufferSize + 64; const allocationSize = bufferSize + 256; const baseOffsetInBuffer = 128; const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; try { const buffer = new ArrayBuffer(allocationSize); const dataView = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await PAUSE_S1(); try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME); writeSuccess = true; } catch (e) { log(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); log(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME); return false; } await PAUSE_S1(); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffsetInBuffer + readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) { try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const vStr = `H=${toHex(high)} L=${toHex(low)}`; log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); } } } catch (e) {} } if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { log(` -> Leu valor OOB escrito (${toHex(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME); } } catch (e) {} } if (readOffset % 32 === 0) await PAUSE_S1(1); } } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); } finally { const leakStatus = leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'; log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME); } return writeSuccess;
        };

        // Teste 3: OOB UAF Pattern (Inalterado)
        const testOOBUAFPattern = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testOOBUAFPattern'; log("--- Iniciando Teste 3: OOB Write -> UAF Pattern ---", 'test', FNAME); const buffer1Size = 64; const buffer2Size = 128; const oobWriteOffset = buffer1Size; const corruptedValue = 0xDEADBEEF; const allocationSize1 = buffer1Size + 128; const baseOffset1 = 64; let buffer1 = null, buffer2 = null; let dv1 = null; let writeOK = false; let uafTriggered = false; try { buffer1 = new ArrayBuffer(allocationSize1); dv1 = new DataView(buffer1); for (let i = 0; i < buffer1.byteLength; i++) dv1.setUint8(i, 0xBB); buffer2 = new ArrayBuffer(buffer2Size); const dv2_init = new DataView(buffer2); for (let i = 0; i < buffer2.byteLength; i++) dv2_init.setUint8(i, 0xCC); await PAUSE_S1(); const targetWriteAddr = baseOffset1 + oobWriteOffset; try { if (targetWriteAddr >= 0 && targetWriteAddr + 4 <= buffer1.byteLength) { dv1.setUint32(targetWriteAddr, corruptedValue, true); log(`VULN: Escrita OOB U32 @${oobWriteOffset} (addr ${targetWriteAddr}) parece OK.`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeOK = true; } else { log(`Offset de escrita OOB (${targetWriteAddr}) fora do buffer1.`, 'warn', FNAME); } } catch (e) { log(`Escrita OOB U32 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeOK) { await PAUSE_S1(); try { const slicedBuffer2 = buffer2.slice(0, 10); const dv2_check = new DataView(buffer2); const lengthCheck = buffer2.byteLength; log(`Uso do buffer 2 após escrita OOB parece OK (tamanho: ${lengthCheck}). Nenhuma UAF óbvia detectada.`, 'good', FNAME); } catch (e) { log(`---> VULN? ERRO ao usar buffer 2 após escrita OOB: ${e.message}`, 'critical', FNAME); log(`---> *** ALERTA: Potencial UAF ou Corrupção de Metadados detectada! O erro ao usar buffer2 PODE indicar sucesso na corrupção. ***`, 'escalation', FNAME); uafTriggered = true; console.error("Erro UAF Pattern:", e); } } } catch (e) { log(`Erro fatal no Teste 3 (OOB UAF): ${e.message}`, 'error', FNAME); console.error(e); } finally { buffer1 = null; buffer2 = null; dv1 = null; log(`--- Teste 3 Concluído (Escrita OOB: ${writeOK}, Potencial UAF/Erro: ${uafTriggered}) ---`, 'test', FNAME); } return writeOK && uafTriggered;
        };

        // *** ADICIONADO v17: Teste OOB Outros Tipos ***
        const testOOBOtherTypes = async () => {
            const FNAME = 'testOOBOtherTypes';
            log("--- Iniciando Teste 4: OOB Write/Read (Float64/BigInt64) ---", 'test', FNAME);
            const bufferSize = 64;
            const oobWriteOffset = bufferSize; // Escrever logo após o buffer
            const allocationSize = bufferSize + 128;
            const baseOffset = 64;
            let buffer = null;
            let dv = null;
            let writeF64OK = false;
            let writeB64OK = false;
            let readF64OK = false;
            let readB64OK = false;

            try {
                buffer = new ArrayBuffer(allocationSize);
                dv = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) dv.setUint8(i, 0xDD); // Preencher com padrão

                const targetAddr = baseOffset + oobWriteOffset;
                const writeValF64 = Math.PI; // Valor Float64
                const writeValB64 = BigInt("0x1122334455667788"); // Valor BigInt64

                // Teste Float64
                log(`Tentando escrita OOB Float64 @${oobWriteOffset} (addr ${targetAddr})`, 'info', FNAME);
                try {
                     if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) {
                        dv.setFloat64(targetAddr, writeValF64, true); // Little endian
                        log(`Escrita OOB Float64 parece OK.`, 'vuln', FNAME);
                        writeF64OK = true;
                     } else { log(`Offset F64 OOB (${targetAddr}) fora do buffer.`, 'warn', FNAME);}
                } catch(e) { log(`Escrita OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); }

                if (writeF64OK) {
                    try {
                        const readVal = dv.getFloat64(targetAddr, true);
                        if (readVal === writeValF64) {
                            log(`Leitura OOB Float64 CONFIRMADA (${readVal}). R/W OK.`, 'vuln', FNAME);
                             log(`---> *** ALERTA: Primitivo R/W OOB Float64 confirmado ***`, 'escalation', FNAME);
                            readF64OK = true;
                        } else { log(`Leitura OOB Float64 retornou valor inesperado: ${readVal}`, 'warn', FNAME); }
                    } catch(e) { log(`Leitura OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); }
                }

                await PAUSE_S1(); // Pausa antes do próximo tipo

                // Teste BigInt64 (requer suporte do navegador)
                if (typeof DataView.prototype.setBigInt64 !== 'undefined') {
                     log(`Tentando escrita OOB BigInt64 @${oobWriteOffset} (addr ${targetAddr})`, 'info', FNAME);
                     try {
                         if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) {
                            dv.setBigInt64(targetAddr, writeValB64, true); // Little endian
                            log(`Escrita OOB BigInt64 parece OK.`, 'vuln', FNAME);
                            writeB64OK = true;
                         } else { log(`Offset B64 OOB (${targetAddr}) fora do buffer.`, 'warn', FNAME);}
                     } catch(e) { log(`Escrita OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); }

                     if (writeB64OK) {
                         try {
                            const readVal = dv.getBigInt64(targetAddr, true);
                            if (readVal === writeValB64) {
                                log(`Leitura OOB BigInt64 CONFIRMADA (0x${readVal.toString(16)}). R/W OK.`, 'vuln', FNAME);
                                log(`---> *** ALERTA: Primitivo R/W OOB BigInt64 confirmado ***`, 'escalation', FNAME);
                                readB64OK = true;
                            } else { log(`Leitura OOB BigInt64 retornou valor inesperado: 0x${readVal.toString(16)}`, 'warn', FNAME); }
                         } catch(e) { log(`Leitura OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); }
                     }
                } else {
                    log("BigInt64 em DataView não suportado neste navegador.", 'warn', FNAME);
                }

            } catch(e) {
                 log(`Erro fatal no Teste 4 (OOB Types): ${e.message}`, 'error', FNAME);
                 console.error(e);
            } finally {
                 buffer = null; dv = null;
                 log(`--- Teste 4 Concluído (F64 R/W: ${readF64OK}, B64 R/W: ${readB64OK}) ---`, 'test', FNAME);
            }
        };

        // Teste 5: PP Básica (Inalterado) - Reordenado
        const testBasicPP = async () => { /* ...código v16 inalterado... */
            const FNAME = 'testBasicPP'; log("--- Iniciando Teste 5: PP (Básica) ---", 'test', FNAME); const prop = '__pp_basic__'; const val = 'Polluted!'; let ok = false; let testObj = null; try { Object.prototype[prop] = val; await PAUSE_S1(); testObj = {}; const inheritedValue = testObj[prop]; if (inheritedValue === val) { log(`VULN: PP Básica OK! Objeto herdou a propriedade poluída.`, 'vuln', FNAME); ok = true; } else { log(`PP Básica falhou ou não detectada.`, 'good', FNAME); } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error', FNAME); console.error(e); } finally { try { delete Object.prototype[prop]; } catch(e){ log(`Erro ao limpar Object.prototype.${prop}: ${e.message}`, 'error', FNAME); } } log(`--- Teste 5 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test', FNAME); return ok;
        };

        // Teste 6: PP Hijack (Inalterado) - Reordenado
        const testPPJsonHijack = async () => { /* ...código v16 inalterado... */
            const FNAME = 'testPPJsonHijack'; log("--- Iniciando Teste 6: PP Hijack (JSON.stringify) ---", 'test', FNAME); const orig = JSON.stringify; let okH = false; let okL = false; let okR = false; try { JSON.stringify = function hijacked(v, r, s) { log("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln', FNAME); okH = true; try { const l = leakedValueFromOOB; let lStr = "NULO ou Indefinido"; if (l) { lStr = l.type === 'U64' ? `U64 H=${toHex(l.high)} L=${toHex(l.low)} @${l.offset}` : `U32 ${toHex(l.low)} @${l.offset}`; okL = true; log(` ---> INFO: Interação Hijack + OOB Read Leak OK.`, 'escalation', FNAME); } log(` -> Valor OOB lido: ${lStr}`, okL ? 'leak' : 'warn', FNAME); } catch(ie) { log(` -> Erro ao tentar ler leak OOB: ${ie.message}`, 'error', FNAME); console.error(ie); } const hijackReturnValue = '{"hijacked": true, "leak_read_success": ' + okL + '}'; return hijackReturnValue; }; await PAUSE_S1(); const testObject = {a:1, b: 'test'}; const result = JSON.stringify(testObject); if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada verificado!", 'vuln', FNAME); okR = true; } else if (okH) { log("AVISO: JSON.stringify sequestrado, mas retorno inesperado.", 'warn', FNAME); } else { log("JSON.stringify não foi sequestrado.", 'good', FNAME); } } catch (e) { log(`Erro fatal durante Teste 6: ${e.message}`, 'error', FNAME); console.error(e); } finally { const currentStringify = JSON.stringify; JSON.stringify = orig; if (currentStringify !== orig && JSON.stringify !== orig) { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'critical', FNAME); } } log(`--- Teste 6 Concluído (Hijack: ${okH}, Retorno: ${okR}, Leitura Leak: ${okL}) ---`, 'test', FNAME); return okR && okL;
        };

        // Teste 7: WebSockets (Inalterado) - Reordenado
        const testWebSockets = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testWebSockets'; log("--- Iniciando Teste 7: WebSockets ---", 'test', FNAME); const wsUrl = "wss://websocket-echo.com/"; let ws = null; let connected = false; let messageReceived = false; let errorOccurred = false; const ppProp = '__ws_polluted__'; Object.prototype[ppProp] = 'WS Polluted!'; let ppDetected = false; const connectionPromise = new Promise((resolve, reject) => { try { ws = new WebSocket(wsUrl); try { if (ws && ws[ppProp] === 'WS Polluted!') { log(`VULN: PP afetou instância WebSocket ('${ppProp}')!`, 'vuln', FNAME); ppDetected = true; } delete Object.prototype[ppProp]; } catch(e){} ws.onopen = (event) => { log("WebSocket Conectado!", 'good', FNAME); connected = true; try { const testMsg = "Hello WebSocket Test " + Date.now(); ws.send(testMsg); try { ws.send(new Blob(["blob data"])); } catch(e) {} try { ws.send(new ArrayBuffer(16)); } catch(e) {} try { const largeSize = 1 * 1024 * 1024; const largeBuffer = new Uint8Array(largeSize).fill(0x41); ws.send(largeBuffer); } catch(e) {} } catch (e) { log(`Erro ao enviar mensagem: ${e.message}`, 'error', FNAME); errorOccurred = true; reject(e); } }; ws.onmessage = (event) => { log(`Mensagem recebida: ${String(event.data).substring(0, 100)}${String(event.data).length > 100 ? '...' : ''}`, 'good', FNAME); messageReceived = true; if (ws && ws.readyState === WebSocket.OPEN) { ws.close(1000, "Test Completed"); } resolve(); }; ws.onerror = (event) => { log(`Erro no WebSocket: ${event.type}`, 'error', FNAME); errorOccurred = true; reject(new Error("WebSocket onerror triggered")); }; ws.onclose = (event) => { log(`WebSocket Fechado. Code: ${event.code}, Reason: "${event.reason}", Clean: ${event.wasClean}`, event.wasClean ? 'good' : 'warn', FNAME); if (!connected && !errorOccurred) reject(new Error("WS fechado antes de conectar/msg.")); else resolve(); }; setTimeout(() => { if (!connected || !messageReceived) { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1001, "Timeout"); } catch(e){} reject(new Error("WebSocket timeout")); } }, 10000); } catch (e) { log(`Erro CRÍTICO ao criar WebSocket: ${e.message}`, 'critical', FNAME); errorOccurred = true; console.error(e); reject(e); } }); try { await connectionPromise; } catch(e) { } finally { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1000, "Cleanup"); } catch (e) {} ws = null; delete Object.prototype[ppProp]; log(`--- Teste 7 Concluído (Conectado: ${connected}, Msg OK: ${messageReceived}, Erro: ${errorOccurred}, PP Detect: ${ppDetected}) ---`, 'test', FNAME); }
        };

        // Teste 8: Web Workers (Inalterado) - Reordenado
        const testWebWorkers = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testWebWorkers'; log("--- Iniciando Teste 8: Web Workers ---", 'test', FNAME); let worker = null; let workerReplied = false; let workerError = false; let ppDetectedWorker = false; const ppPropWorker = '__worker_polluted__'; Object.prototype[ppPropWorker] = 'Worker Polluted!'; const workerCode = ` self.onmessage = function(e) { let response = 'Worker received: ' + e.data; try { if (self.${ppPropWorker} === 'Worker Polluted!') { response += ' [PP Detected In Worker!]'; } } catch(err) {} self.postMessage(response); }; try { if (self.${ppPropWorker} === 'Worker Polluted!') { self.postMessage('PP Detected on Worker Self!'); } } catch(e){} `; const workerPromise = new Promise((resolve, reject) => { try { const blob = new Blob([workerCode], { type: 'application/javascript' }); const blobUrl = URL.createObjectURL(blob); worker = new Worker(blobUrl); try { if (worker && worker[ppPropWorker] === 'Worker Polluted!') { log(`VULN: PP afetou instância Worker main thread ('${ppPropWorker}')!`, 'vuln', FNAME); ppDetectedWorker = true; } } catch(e){} worker.onmessage = (event) => { log(`Mensagem do Worker: "${event.data}"`, 'good', FNAME); if (event.data.includes('Worker Polluted!')) { log(`VULN: PP detectada DENTRO worker/comunicação!`, 'vuln', FNAME); ppDetectedWorker = true; } workerReplied = true; resolve(); }; worker.onerror = (event) => { log(`Erro no Worker: ${event.message} em ${event.filename}:${event.lineno}`, 'error', FNAME); workerError = true; reject(event.error || new Error(event.message)); }; worker.postMessage("Hello Worker " + Date.now()); setTimeout(() => { if (!workerReplied) { workerError = true; reject(new Error("Worker timeout")); } }, 5000); URL.revokeObjectURL(blobUrl); } catch (e) { log(`Erro CRÍTICO criar/comunicar Worker: ${e.message}`, 'critical', FNAME); workerError = true; console.error(e); reject(e); } finally { delete Object.prototype[ppPropWorker]; } }); try { await workerPromise; } catch(e) { } finally { try { if (worker) worker.terminate(); } catch(e) {} worker = null; delete Object.prototype[ppPropWorker]; log(`--- Teste 8 Concluído (Resposta OK: ${workerReplied}, Erro: ${workerError}, PP Detect: ${ppDetectedWorker}) ---`, 'test', FNAME); }
        };

        // *** ADICIONADO v17: Teste IndexedDB ***
        const testIndexedDB = async () => {
            const FNAME = 'testIndexedDB';
            log("--- Iniciando Teste 9: IndexedDB ---", 'test', FNAME);
            const dbName = "TestDB_v17";
            const storeName = "TestStore";
            let db = null;
            let errorMsg = null;
            let addOK = false;
            let getOK = false;
            let deleteOK = false;

            // Limpar DB antigo (se existir) - Melhor esforço
            try {
                 await new Promise((resolve, reject) => {
                    log("Tentando deletar DB antigo (se existir)...", 'info', FNAME);
                    const deleteRequest = indexedDB.deleteDatabase(dbName);
                    deleteRequest.onsuccess = () => { log("DB antigo deletado ou não existia.", 'good', FNAME); resolve(); };
                    deleteRequest.onerror = (e) => { log(`Erro ao deletar DB antigo: ${e.target.error}`, 'warn', FNAME); resolve(); /* Continua mesmo com erro */ };
                    deleteRequest.onblocked = () => { log("Deleção do DB bloqueada (conexões abertas?).", 'warn', FNAME); resolve(); };
                     setTimeout(() => reject(new Error("Timeout deletando DB")), 3000); // Timeout curto
                 }).catch(e => log(`Timeout/Erro na deleção prévia: ${e.message}`, 'warn', FNAME));
            } catch(e) {log("Erro inesperado na deleção prévia.", 'warn', FNAME);}

             await PAUSE_S1();

            try {
                log("Abrindo/Criando IndexedDB...", 'info', FNAME);
                db = await new Promise((resolve, reject) => {
                    const request = indexedDB.open(dbName, 1);

                    request.onupgradeneeded = (event) => {
                        log("Evento onupgradeneeded disparado.", 'info', FNAME);
                        try {
                            const dbInstance = event.target.result;
                             if (!dbInstance.objectStoreNames.contains(storeName)) {
                                log(`Criando object store: ${storeName}`, 'info', FNAME);
                                dbInstance.createObjectStore(storeName, { keyPath: "id", autoIncrement: true });
                             }
                        } catch (e) {
                             log(`Erro durante onupgradeneeded: ${e.message}`, 'error', FNAME);
                             errorMsg = `Upgrade error: ${e.message}`;
                             reject(e); // Rejeita a promise principal
                        }
                    };

                    request.onsuccess = (event) => {
                        log("IndexedDB aberto com sucesso.", 'good', FNAME);
                        resolve(event.target.result);
                    };

                    request.onerror = (event) => {
                        log(`Erro ao abrir IndexedDB: ${event.target.error}`, 'error', FNAME);
                        errorMsg = `Open error: ${event.target.error}`;
                        reject(event.target.error);
                    };
                     setTimeout(() => reject(new Error("Timeout abrindo DB")), 5000); // Timeout
                });

                if (db) {
                    // Teste Add
                    log("Testando adicionar registro...", 'info', FNAME);
                    const addData = { name: "TestData", value: Math.random(), largeData: "A".repeat(1024) };
                    const addResult = await new Promise((resolve, reject) => {
                        try {
                            const transaction = db.transaction([storeName], "readwrite");
                            const store = transaction.objectStore(storeName);
                            const request = store.add(addData);
                            request.onsuccess = (event) => { addOK = true; resolve(event.target.result); };
                            request.onerror = (event) => reject(event.target.error);
                             transaction.onerror = (event) => reject(event.target.error);
                             transaction.onabort = (event) => reject(new Error(`Transação abortada: ${event.target.error}`));
                        } catch (e) { reject(e); }
                         setTimeout(() => reject(new Error("Timeout add")), 3000);
                    });
                    log(`Adicionar registro ${addOK ? 'OK' : 'FALHOU'}. ID: ${addResult}`, addOK ? 'good' : 'error', FNAME);

                    // Teste Get (se add funcionou)
                    if (addOK && addResult) {
                         log("Testando ler registro...", 'info', FNAME);
                         const getResult = await new Promise((resolve, reject) => {
                            try {
                                const transaction = db.transaction([storeName], "readonly");
                                const store = transaction.objectStore(storeName);
                                const request = store.get(addResult); // Pega pelo ID retornado
                                request.onsuccess = (event) => { getOK = (event.target.result != null); resolve(event.target.result); };
                                request.onerror = (event) => reject(event.target.error);
                                 transaction.onerror = (event) => reject(event.target.error);
                                 transaction.onabort = (event) => reject(new Error(`Transação abortada: ${event.target.error}`));
                            } catch (e) { reject(e); }
                             setTimeout(() => reject(new Error("Timeout get")), 3000);
                         });
                         log(`Ler registro ${getOK ? 'OK' : 'FALHOU'}.`, getOK ? 'good' : 'error', FNAME);
                         // log(` -> Dado lido: ${JSON.stringify(getResult).substring(0,100)}...`, 'info', FNAME);

                         // Teste Delete (se get funcionou)
                         if (getOK) {
                             log("Testando deletar registro...", 'info', FNAME);
                              const deleteResult = await new Promise((resolve, reject) => {
                                try {
                                    const transaction = db.transaction([storeName], "readwrite");
                                    const store = transaction.objectStore(storeName);
                                    const request = store.delete(addResult);
                                    request.onsuccess = (event) => { deleteOK = true; resolve(true); };
                                    request.onerror = (event) => reject(event.target.error);
                                     transaction.onerror = (event) => reject(event.target.error);
                                     transaction.onabort = (event) => reject(new Error(`Transação abortada: ${event.target.error}`));
                                } catch (e) { reject(e); }
                                 setTimeout(() => reject(new Error("Timeout delete")), 3000);
                              });
                              log(`Deletar registro ${deleteOK ? 'OK' : 'FALHOU'}.`, deleteOK ? 'good' : 'error', FNAME);
                         }
                    }
                }

            } catch (e) {
                 log(`Erro GERAL no teste IndexedDB: ${e?.message || String(e)}`, 'error', FNAME);
                 if (!errorMsg) errorMsg = e?.message || String(e);
                 console.error("IndexedDB Error:", e);
            } finally {
                log("Fechando conexão IndexedDB (se aberta)...", 'info', FNAME);
                try { if (db) db.close(); } catch (e) {}
                db = null;
                 log(`--- Teste 9 Concluído (Add: ${addOK}, Get: ${getOK}, Delete: ${deleteOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME);
            }
        };

         // *** ADICIONADO v17: Teste DOM Stress ***
         const testDOMStress = async () => {
            const FNAME = 'testDOMStress';
            log("--- Iniciando Teste 10: DOM Stress ---", 'test', FNAME);
            const container = document.body; // Ou um div específico
            const elementCount = 200; // Número de elementos a criar/manipular
            const cycles = 5; // Quantas vezes repetir o ciclo add/remove
            let errors = 0;

            log(`Iniciando ${cycles} ciclos de stress com ${elementCount} elementos...`, 'info', FNAME);

            try {
                 for (let c = 0; c < cycles; c++) {
                    log(`Ciclo ${c + 1}/${cycles}...`, 'info', FNAME);
                    const elements = [];
                    // Criação e Adição
                    for (let i = 0; i < elementCount; i++) {
                        try {
                            const el = document.createElement('div');
                            el.textContent = `Stress-${c}-${i}`;
                            el.style.position = 'absolute'; // Evitar reflow pesado
                            el.style.left = `${(i * 5) % 300}px`;
                            el.style.top = `-${10 + (c*2)}px`; // Manter fora da vista
                             el.style.color = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
                             container.appendChild(el);
                            elements.push(el);
                        } catch (e) { errors++; log(`Erro ao criar/adicionar el ${i}: ${e.message}`, 'warn', FNAME); }
                    }
                     await PAUSE_S1(50); // Pequena pausa após adicionar

                    // Remoção
                     elements.forEach(el => {
                        try {
                            container.removeChild(el);
                        } catch(e) { errors++; /* Ignorar erro se já removido? */ }
                     });
                     await PAUSE_S1(10); // Pequena pausa após remover
                 }
                 log("Ciclos de stress concluídos.", 'good', FNAME);

            } catch (e) {
                 log(`Erro GERAL durante DOM Stress: ${e.message}`, 'error', FNAME);
                 errors++;
                 console.error("DOM Stress Error:", e);
            } finally {
                 log(`--- Teste 10 Concluído (Erros reportados: ${errors}) ---`, 'test', FNAME);
            }
        };


        // Função principal Script 1 (v17)
        const runAllTests = async () => {
             const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO Script 1 (v17 - Refined + APIs) ====", 'test', FNAME);
            await testCSPBypass(); // Teste 1
            await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBUAFPattern(); // Teste 3
            await PAUSE_S1(MEDIUM_PAUSE);
             await testOOBOtherTypes(); // Teste 4 *** NOVO v17 ***
             await PAUSE_S1(MEDIUM_PAUSE);
            await testBasicPP(); // Teste 5
            await PAUSE_S1(MEDIUM_PAUSE);
            await testPPJsonHijack(); // Teste 6
            await PAUSE_S1(MEDIUM_PAUSE);
             await testWebSockets(); // Teste 7
             await PAUSE_S1(MEDIUM_PAUSE);
             await testWebWorkers(); // Teste 8
             await PAUSE_S1(MEDIUM_PAUSE);
             await testIndexedDB(); // Teste 9 *** NOVO v17 ***
             await PAUSE_S1(MEDIUM_PAUSE);
             await testDOMStress(); // Teste 10 *** NOVO v17 ***
            await PAUSE_S1(MEDIUM_PAUSE);
            log("\n==== Script 1 CONCLUÍDO ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        // --- Script 2: Canvas (v17 - Refined Logging + Canvas Interact) ---

        // --- Variáveis Globais ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
         // *** MODIFICADO v17: Adicionar texto e URL aos quadrados ***
         const interactiveAreas = [
             { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' },
             { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' },
             { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' }
         ];
         const imgSquareSize = 45; // Aumentar tamanho para caber texto
         const imgSquareSpacing = 10;
         const imgSquares = []; // Será populado em runCanvasTestSequence
         const imgSquaresStartY = 180; // Ajustar posição
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;
         let gpuAdapter = null; let gpuDevice = null;

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const logCanvas = (message, type = 'info', funcName = '') => {
             // *** MODIFICADO v17: Refinar logs 'good' a manter ***
             let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type);
             if (!keepLog && type === 'good') {
                 const lowerMsg = String(message).toLowerCase();
                  // Manter mais logs de sucesso/falha controlada
                  if (lowerMsg.includes('n/a') || lowerMsg.includes('não suportad') || lowerMsg.includes('não disponível') || lowerMsg.includes('fail:') || lowerMsg.includes('não afetou') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('ok') || lowerMsg.includes('aberto') || lowerMsg.includes('concluído') || lowerMsg.includes('restaurado') || lowerMsg.includes('limpeza') || lowerMsg.includes('pulado') || lowerMsg.includes('resolvido') || lowerMsg.includes('sem erro') || lowerMsg.includes('finalizado')) {
                     keepLog = true;
                 }
             }
             // Manter erros específicos importantes
              if (!keepLog && type === 'error' && (String(message).includes('Element.innerHTML setter') || String(message).includes('webgl') || String(message).includes('gpu') || String(message).includes('file system') || String(message).includes('indexeddb') || String(message).includes('fatal') || String(message).includes('critical'))) {
                  keepLog = true;
              }
              // Manter logs de cliques interativos
              if (!keepLog && funcName === 'CanvasClick') {
                  keepLog = true;
              }

            if (!keepLog) return;

            if (!outputDivCanvas) return;
            const logPrefix = `[CANVAS-${type.toUpperCase()}]`;
            const funcPrefix = funcName ? `[${funcName}] ` : '';
            const logMsg = `${logPrefix} ${funcPrefix}${message}`;
             console.log(logMsg);
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if(outputDivCanvas.innerHTML.length > 800000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 400000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; }
                outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`;
                outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight;
            } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        // Funções PAUSE, toHexCanvas, isPotentialPointer64_S2, isPotentialData32_S2, drawInteractiveAreas permanecem iguais
         const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
         const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); };
         const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
         const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };
         const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }};

         // *** MODIFICADO v17: Desenhar texto nos quadrados ***
         const drawImageSquares = () => {
            if (!ctx) return;
            try {
                 imgSquares.forEach(sq => {
                    ctx.fillStyle = sq.hover ? '#FFFF88' : sq.color; // Amarelo claro no hover
                    ctx.fillRect(sq.x, sq.y, sq.size, sq.size);
                    ctx.strokeStyle = '#AAA'; // Borda mais clara
                    ctx.lineWidth = 1;
                    ctx.strokeRect(sq.x, sq.y, sq.size, sq.size);

                    // Desenhar texto se existir
                     if (sq.text) {
                        ctx.fillStyle = "#FFF"; // Texto branco
                        ctx.font = "bold 11px mono";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2);
                     }
                      // Indicar se é link (opcional)
                      if (sq.url) {
                         ctx.fillStyle = "#6cf"; // Azul claro
                         ctx.font = "bold 10px mono";
                         ctx.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - 8);
                      }
                 });
                 ctx.textAlign = "start"; // Resetar alinhamento
                 ctx.textBaseline = "alphabetic"; // Resetar baseline
            } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); }
         };

         // redrawAll (Inalterado, mas usará a nova drawImageSquares)
         const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};


        // --- Testes Script 2 ---

        // WebGL Check (Inalterado)
        const testWebGLCheck = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testWebGLCheck'; logCanvas("--- Teste: Verificação WebGL ---",'test', FNAME); glContext=null; isWebGL2=false; try { glContext=canvasElement.getContext('webgl')||canvasElement.getContext('experimental-webgl'); if(glContext){ const glVersion = glContext.getParameter(glContext.VERSION); logCanvas(`WebGL OK! V:${glVersion.substring(0,30)}`, 'good', FNAME); try{ let gl2=canvasElement.getContext('webgl2'); if(gl2){ const gl2Version = gl2.getParameter(gl2.VERSION); logCanvas(`WebGL2 OK! V:${gl2Version.substring(0,30)}`, 'good', FNAME); isWebGL2=true; } else { logCanvas("WebGL2 não disponível.", 'good', FNAME); } }catch(e2){ logCanvas("WebGL2 não disponível (erro check).", 'good', FNAME); } }else{ logCanvas('WebGL N/A.', 'good', FNAME); } }catch(e){ logCanvas(`Erro ao verificar WebGL: ${e.message}`, 'error', FNAME); console.error(e); glContext=null; } logCanvas(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContext}, WebGL2: ${isWebGL2}) ---`, 'test', FNAME); await PAUSE();
        };

        // PP Avançado
        const testAdvancedPP = async () => {
            const FNAME = 'testAdvancedPP';
            logCanvas("--- Teste: PP Avançado (Gadgets++) ---", 'test', FNAME);
             // *** MODIFICADO v17: Adicionar mais propriedades ***
            const propsToPollute = [
                // Core Object
                { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' },
                // DOM Elements & Nodes & Events
                { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'outerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'textContent', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div') }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'onload', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onload === v ? 'PP afetou handler `onload`!' : null, createTarget: () => document.createElement('img') },
                { name: 'appendChild', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.appendChild(document.createElement('span')); return null; } catch(e){ return `Node.appendChild quebrou! ${e.message}`;} } }, // *** NOVO v17 ***
                { name: 'addEventListener', proto: EventTarget.prototype, protoName: 'EventTarget', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.addEventListener('test', ()=>{}); return null; } catch(e){ return `EventTarget.addEventListener quebrou! ${e.message}`;} } }, // *** NOVO v17 ***
                // Input/Textarea specific
                { name: 'value', proto: HTMLInputElement.prototype, protoName: 'HTMLInputElement', createTarget: () => document.createElement('input'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou input.value!' : null }, { name: 'value', proto: HTMLTextAreaElement.prototype, protoName: 'HTMLTextAreaElement', createTarget: () => document.createElement('textarea'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou textarea.value!' : null },
                // Arrays
                { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'filter', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].filter(()=>{}); return null;} catch(e){ return `Array.filter quebrou! ${e.message}`;} }, createTarget: () => [] },
                 { name: 'forEach', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].forEach(()=>{}); return null;} catch(e){ return `Array.forEach quebrou! ${e.message}`;} }, createTarget: () => [] }, // *** NOVO v17 ***
                // Functions
                { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} },
                 // Globais / Speculativos (MUITO CUIDADO - podem quebrar a página)
                  //{ name: 'cookie', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => { try{ return document.cookie.includes('PP_Adv_Polluted') ? 'PP Afetou document.cookie!' : null; } catch(e){return null;} }, createTarget: () => document }, // *** NOVO v17 - Requer teste cuidadoso ***
                  //{ name: 'href', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => { try { if(location.href.includes('PP_Adv_Polluted')) return 'PP Afetou location.href!'; } catch(e){} return null; }, createTarget: () => location }, // *** NOVO v17 - Altamente especulativo / improvável ***
            ];
            const testValue = "PP_Adv_Polluted_" + Date.now();
            let successCount = 0; let gadgetCount = 0; let gadgetMessages = []; // *** NOVO v17: Coletar mensagens ***

            for (const item of propsToPollute) {
                // ... (Lógica interna de poluição, verificação, limpeza igual a v16) ...
                 if (!item.proto) { continue; } const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName; let inherited = false; let gadgetMsg = null; let errorMsg = null; let originalValue = undefined; let wasDefined = false; try { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } catch (e) { logCanvas(`AVISO: Erro check/get original ${targetProtoName}.${prop}: ${e.message}`, 'warn', FNAME); continue; } try { targetProto[prop] = testValue; let obj; if (item.createTarget) { try { obj = item.createTarget(); } catch (e) { obj = {}; } } else { obj = {}; } let inheritedValue = undefined; try { inheritedValue = obj[prop]; } catch (e) {} if (inheritedValue === testValue) { logCanvas(`-> VULN: Herança PP para '${targetProtoName}.${prop}' OK.`, 'vuln', FNAME); inherited = true; successCount++; if (item.gadgetCheck) { try { gadgetMsg = item.gadgetCheck(obj, testValue); } catch(e){} if (gadgetMsg) { logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME); gadgetMessages.push(prop + ": " + gadgetMsg); gadgetCount++; if (['innerHTML', 'outerHTML', 'src', 'href', 'onclick', 'onerror', 'onload', 'value', 'postMessage', 'send', 'call', 'apply', 'map', 'filter', 'forEach', 'appendChild', 'addEventListener', 'cookie'].includes(prop)) { logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para '${prop}'! ***`, 'escalation', FNAME); } } } } else { if (prop === '__proto__') { logCanvas(`-> FAIL: Herança de '__proto__' não OK (Esperado).`, 'good', FNAME); } } } catch (e) { logCanvas(`Erro ao poluir/testar '${targetProtoName}.${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; } finally { try { if (wasDefined) { targetProto[prop] = originalValue; } else { delete targetProto[prop]; } } catch (e) { logCanvas(`AVISO: Erro ao limpar ${targetProtoName}.${prop}: ${e.message}`, 'warn', FNAME); } } await PAUSE(20);
            }

            // *** MODIFICADO v17: Usar a lista coletada ***
            logCanvas(`--- Teste PP Avançado Concluído (${successCount} OK, ${gadgetCount} gadgets encontrados) ---`, 'test', FNAME);
             if (gadgetCount > 0) {
                 logCanvas(`Gadgets detectados: ${gadgetMessages.join('; ')}`, 'critical', FNAME);
             }
            await PAUSE();
        };


        // OOB Read Enhanced (Inalterado)
         const testOOBReadEnhanced = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste: OOB Read Enhanced Scan ---",'test', FNAME); const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128; const allocationSize = bufferSize + 512; const baseOffsetInBuffer = 256; let potentialLeakFoundCount=0; const foundPointers=[]; try{ const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer); for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); } for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){ const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){ try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue; if(isPotentialPointer64_S2(high,low)){ const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U64', high, low, hex:valueStr}; foundPointers.push(leakInfo); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); } }catch(e){} } else if(readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){ try{ const val32=dataView.getUint32(readTargetAddress,true); if (val32 === 0xCCCCCCCC) continue; let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64'); if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){ logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)}; foundPointers.push(leakInfo); logCanvas(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } }catch(e){} } if(readOffset % 64 === 0) await PAUSE(1); } }catch(e){ logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); } finally { logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais encontrados) ---`,'test', FNAME); if(foundPointers.length === 0){ logCanvas("Nenhum leak potencial óbvio encontrado nesta varredura.", 'good', FNAME); } else { console.log("Potenciais Leaks Encontrados (OOB Read Enhanced):", foundPointers); } } await PAUSE(); return foundPointers;
         };

        // OOB Write Metadata
        const testOOBWriteMetadata = async () => {
            const FNAME = 'testOOBWriteMetadata';
            logCanvas("--- Teste: OOB Write -> Metadata (ArrayBuffer.byteLength) ---",'test', FNAME);
            const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE;
            const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false;
            const allocationSize = controlBufferSize + 256; const baseOffsetInBuffer = 128; let foundOffset=-1;
            let finalResultLog = `AVISO: Escrita OOB realizada (${writeSuccessCount}x), mas nenhuma corrupção de byteLength detectada.`; // *** Default log v17 ***

            try{
                controlBuffer=new ArrayBuffer(allocationSize); dv=new DataView(controlBuffer);
                for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD);
            }catch(e){ logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`, 'error', FNAME); return; }

            for(let i=0; i<sprayCount; i++){ try{ targetBuffers.push(new ArrayBuffer(targetBufferSize)); }catch(e){}}
            await PAUSE();

            const metadataOffsetsToTry=[-8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32];
            for(const tryOffset of metadataOffsetsToTry){
                 const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset;
                 const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`;
                 logCanvas(`Tentando offset OOB metadata: ${tryOffset}... Addr: ${targetWriteAddr}`, 'info', FNAME); // *** Log v17 ***
                 let currentWriteOK=false;
                 try{
                     if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){
                         dv.setUint32(targetWriteAddr, targetValue, true);
                         writeSuccessCount++; currentWriteOK=true;
                         logCanvas(` -> Escrita OOB U32 em ${relOffsetStr} parece OK.`, 'info', FNAME); // *** Log v17 ***
                     } else { logCanvas(` -> Offset OOB ${relOffsetStr} fora dos limites.`, 'warn', FNAME); }
                 }catch(e){ logCanvas(` -> Escrita OOB U32 falhou/bloqueada em ${relOffsetStr}: ${e.message}`, 'good', FNAME); }

                 if(currentWriteOK){
                     logCanvas(` -> Verificando ${targetBuffers.length} buffers alvo...`, 'info', FNAME); // *** Log v17 ***
                     await PAUSE(5); // *** Pausa v17 ***
                     for(let j=0; j<targetBuffers.length; j++){
                         try {
                              const currentLength = targetBuffers[j]?.byteLength; // *** Log v17 ***
                              // logCanvas(`  -> Verificando buffer ${j}, tamanho atual: ${currentLength}`, 'info', FNAME); // Log verboso opcional
                             if(currentLength === targetValue){
                                 logCanvas(`---> VULN: ArrayBuffer alvo ${j} teve byteLength CORROMPIDO para ${toHexCanvas(targetValue)} com escrita OOB em ${relOffsetStr}! <---`, 'critical', FNAME);
                                 logCanvas(` ---> *** ALERTA: Primitivo Relevante (Corrupção Metadados OOB Write -> R/W Poderoso) ***`, 'escalation', FNAME);
                                 corruptionSuccess=true; foundOffset=tryOffset;
                                 finalResultLog = `SUCESSO! byteLength corrompido usando offset relativo ctrlEnd+${foundOffset}.`; // *** Update log v17 ***
                                 try{
                                     const corruptedView=new DataView(targetBuffers[j]);
                                     const readOOBAddr = targetBufferSize + 4;
                                     const readOOBValue = corruptedView.getUint32(readOOBAddr, true);
                                     logCanvas(`  -> Leitura OOB via AB ${j} corrompido @ offset ${readOOBAddr}: ${toHexCanvas(readOOBValue)}`, 'leak', FNAME);
                                      logCanvas(` ---> *** ALERTA: Leitura OOB confirmada usando buffer corrompido! ***`, 'escalation', FNAME);
                                 }catch(eRead){ logCanvas(`  -> Erro ao tentar leitura OOB via AB ${j} corrompido: ${eRead.message}`, 'warn', FNAME); }
                                 break; // Sai do loop interno se achou
                             }
                         } catch(eCheck) { logCanvas(`Erro ao verificar buffer alvo ${j}: ${eCheck.message}`, 'error', FNAME); }
                     }
                     // Limpar a escrita OOB antes de tentar o próximo offset
                     try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); } }catch(eRestore){}
                 }
                 if(corruptionSuccess) break; // Sai do loop externo se achou
                 await PAUSE(10);
            } // Fim do loop de offsets

            // *** Log Final Explícito v17 ***
            if (!corruptionSuccess && writeSuccessCount === 0) {
                finalResultLog = `Escrita OOB falhou/bloqueada em todos os offsets testados.`;
                 logCanvas(finalResultLog, 'good', FNAME);
            } else {
                 logCanvas(finalResultLog, corruptionSuccess ? 'vuln' : 'warn', FNAME);
            }

            logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME);
            await PAUSE();
        };


        // WebGL Deep Plus (Inalterado, será pulado)
        const testWebGLDeeperPlus = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testWebGLDeeperPlus'; if(!glContext){ logCanvas("--- Teste: WebGL Deep Plus Pulado (WebGL N/A) ---",'test', FNAME); return; } logCanvas(`--- Teste: WebGL Deep Plus c/ Checks (${isWebGL2?'WebGL2':'WebGL1'}) ---`,'test', FNAME); let gl=glContext; let pgm=null, buf=null, vs=null, fs=null, tex=null; let step='init'; let glError=gl.NO_ERROR; const errors=[]; const checkGLError=(s)=>{ let found=false; while((glError=gl.getError())!==gl.NO_ERROR){ let errorString = glError; for(let key in gl) { try{if(gl[key] === glError) { errorString = key; break; }}catch(e){} } const eStr=`GL Err ${errorString} (0x${glError.toString(16)}) after ${s}`; logCanvas(eStr,'error', FNAME); errors.push(eStr); found=true; } return !found; }; try{ checkGLError('getParam(VERSION)'); step='compileShaders'; const vsSrc=`attribute vec4 p; void main(){ gl_Position = vec4(p.xy * 0.5, 0.0, 1.0); }`; const fsSrc=`precision mediump float; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, vec2(0.5, 0.5)) * vec4(1.0, ${isWebGL2 ? '0.5' : '0.0'}, 0.0, 1.0); }`; vs=gl.createShader(gl.VERTEX_SHADER); if(!vs || !checkGLError('createShader(VS)')) throw new Error('Falha criar VS'); gl.shaderSource(vs,vsSrc); if(!checkGLError('shaderSource(VS)')) throw new Error('Falha source VS'); gl.compileShader(vs); if(!checkGLError('compileShader(VS)')) throw new Error('Falha compile VS'); if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(vs); logCanvas(`Erro Compilar VS: ${infoLog}`, 'error', FNAME); throw new Error(`VS Compile: ${infoLog}`); } fs=gl.createShader(gl.FRAGMENT_SHADER); if(!fs || !checkGLError('createShader(FS)')) throw new Error('Falha criar FS'); gl.shaderSource(fs,fsSrc); if(!checkGLError('shaderSource(FS)')) throw new Error('Falha source FS'); gl.compileShader(fs); if(!checkGLError('compileShader(FS)')) throw new Error('Falha compile FS'); if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(fs); logCanvas(`Erro Compilar FS: ${infoLog}`, 'error', FNAME); throw new Error(`FS Compile: ${infoLog}`); } step='linkProgram'; pgm=gl.createProgram(); if(!pgm || !checkGLError('createProgram')) throw new Error('Falha createProgram'); gl.attachShader(pgm,vs); if(!checkGLError('attachVS')) throw new Error('Falha attachVS'); gl.attachShader(pgm,fs); if(!checkGLError('attachFS')) throw new Error('Falha attachFS'); gl.linkProgram(pgm); if(!checkGLError('linkProgram')) throw new Error('Falha linkProgram'); if(!gl.getProgramParameter(pgm,gl.LINK_STATUS)){ const infoLog = gl.getProgramInfoLog(pgm); logCanvas(`Erro Linkar Programa: ${infoLog}`, 'error', FNAME); throw new Error(`Link: ${infoLog}`); } gl.useProgram(pgm); if(!checkGLError('useProgram')) throw new Error('Falha useProgram'); step='textureSetup'; tex=gl.createTexture(); if(!tex || !checkGLError('createTexture')) throw new Error('Falha createTexture'); gl.bindTexture(gl.TEXTURE_2D,tex); if(!checkGLError('bindTexture')) throw new Error('Falha bindTexture'); if(ctx){ ctx.save(); ctx.fillStyle='lime'; ctx.fillRect(50,150,40,40); ctx.fillStyle='black'; ctx.font='bold 12px mono'; ctx.fillText('TEX',55,175); ctx.restore(); } await PAUSE(20); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasElement); if(!checkGLError('texImage2D')) throw new Error('Falha texImage2D'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST); if(!checkGLError('texParamMag')) throw new Error('Falha texParamMag'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST); if(!checkGLError('texParamMin')) throw new Error('Falha texParamMin'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapS')) throw new Error('Falha texParamWrapS'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapT')) throw new Error('Falha texParamWrapT'); step='uniformTex'; const texLoc = gl.getUniformLocation(pgm, 'u_tex'); if(!checkGLError('getUniLocTex')) throw new Error('Falha getUniLocTex'); if(texLoc){ gl.uniform1i(texLoc, 0); if(!checkGLError('uniform1i')) throw new Error('Falha uniform1i'); } step='createBufferDraw'; buf=gl.createBuffer(); if(!buf || !checkGLError('createBuf')) throw new Error('Falha createBuf'); gl.bindBuffer(gl.ARRAY_BUFFER,buf); if(!checkGLError('bindBuf')) throw new Error('Falha bindBuf'); const pos=new Float32Array([-1,-1, 1,-1, -1, 1]); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW); if(!checkGLError('bufData')) throw new Error('Falha bufData'); step='vertexAttrib'; const loc=gl.getAttribLocation(pgm,"p"); if (loc < 0) { checkGLError('getAttribLoc(p)'); throw new Error("Atributo 'p' não encontrado no shader."); } if(!checkGLError('getAttribLoc(p)')) throw new Error('Falha getAttribLoc'); gl.enableVertexAttribArray(loc); if(!checkGLError('enableVA')) throw new Error('Falha enableVA'); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); if(!checkGLError('vertexAttribPtr')) throw new Error('Falha vertexAttribPtr'); step='draw'; const glViewportX = 250; const glViewportY = 50; const glViewportW = 90; const glViewportH = 90; gl.viewport(glViewportX, glViewportY, glViewportW, glViewportH); if(!checkGLError('viewport')) throw new Error('Falha viewport'); gl.clearColor(0.1, 0.1, 0.2, 1.0); if(!checkGLError('clearColor')) throw new Error('Falha clearColor'); gl.clear(gl.COLOR_BUFFER_BIT); if(!checkGLError('clear')) throw new Error('Falha clear'); gl.activeTexture(gl.TEXTURE0); if(!checkGLError('activeTex')) throw new Error('Falha activeTex'); gl.bindTexture(gl.TEXTURE_2D, tex); if(!checkGLError('bindTexDraw')) throw new Error('Falha bindTexDraw'); gl.drawArrays(gl.TRIANGLES, 0, 3); if(!checkGLError('drawArrays')) { logCanvas("drawArrays executado sem erros GL imediatos.", 'good', FNAME); } else { throw new Error('Erro GL após drawArrays'); } if(errors.length === 0){ logCanvas("Sequência WebGL básica concluída sem erros GL.", 'good', FNAME); } }catch(e){ logCanvas(`Erro fatal durante Teste WebGL Deep Plus (etapa ${step}): ${e.message}`,'error', FNAME); console.error(e); checkGLError(`error_catch_${step}`); }finally{ if(gl){ try{gl.bindBuffer(gl.ARRAY_BUFFER,null);}catch(e){} try{gl.bindTexture(gl.TEXTURE_2D,null);}catch(e){} try{gl.useProgram(null);}catch(e){} if(pgm && vs){try{gl.detachShader(pgm, vs);}catch(e){}} if(pgm && fs){try{gl.detachShader(pgm, fs);}catch(e){}} if(vs){try{gl.deleteShader(vs);}catch(e){}} if(fs){try{gl.deleteShader(fs);}catch(e){}} if(pgm){try{gl.deleteProgram(pgm);}catch(e){}} if(buf){try{gl.deleteBuffer(buf);}catch(e){}} if(tex){try{gl.deleteTexture(tex);}catch(e){}} } } logCanvas("--- Teste WebGL Deep Plus Concluído ---",'test', FNAME); await PAUSE();
        };

        // OOB Write -> ImageData (Inalterado)
        const testOOBWriteToImageDataCheck = async () => { /* ...código v16 inalterado... */
            const FNAME = 'testOOBWriteToImageDataCheck'; logCanvas("--- Teste: OOB Write -> ImageData Check ---",'test', FNAME); const spraySize=30; const imgDataWidth=10; const imgDataHeight=10; const bufferOOBSize=64; const writeValue1=0x42424242; const writeValue2=0x43434343; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; const sprayedImagesData = []; let bufferOOB=null; let dv=null; let oobWritePerformed = false; let potentialCorruptionDetected = false; let patternMatched = false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); }catch(e){ logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return; } const totalPixels = imgDataWidth * imgDataHeight; const initialByteArray = new Uint8ClampedArray(totalPixels * 4); for (let j = 0; j < initialByteArray.length; j++) { initialByteArray[j] = 255; } for(let i=0; i<spraySize; i++){ try{ let imgData = new ImageData(initialByteArray, imgDataWidth, imgDataHeight); sprayedImagesData.push(imgData); }catch(e){ logCanvas(`Aviso: Falha ao alocar ImageData ${i}: ${e.message}`, 'warn', FNAME); break; } } await PAUSE(); const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); oobWritePerformed = true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora do buffer de controle alocado.`, 'error', FNAME); } }catch(e){ logCanvas(`AVISO: Escrita OOB U32x2 falhou/bloqueada @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } await PAUSE(); if(!ctx){ logCanvas("Contexto 2D não disponível para put/getImageData.", 'warn', FNAME); return; } ctx.fillStyle="#111"; ctx.fillRect(0, 50, canvasElement.width, canvasElement.height - 80); const cols = Math.floor((canvasElement.width - 10) / (imgDataWidth + 1)); const startY = 60; for(let i=0; i<sprayedImagesData.length; i++){ const gridX = 10 + (i % cols) * (imgDataWidth + 1); const gridY = startY + Math.floor(i / cols) * (imgDataHeight + 1); if (gridY + imgDataHeight > canvasElement.height - 15) { continue; } try{ const currentImageData = sprayedImagesData[i]; if (!currentImageData) continue; ctx.putImageData(currentImageData, gridX, gridY); const readbackImageData = ctx.getImageData(gridX, gridY, imgDataWidth, imgDataHeight); const readbackData = readbackImageData.data; for(let k=0; k < readbackData.length; k += 4){ const r = readbackData[k]; const g = readbackData[k+1]; const b = readbackData[k+2]; const a = readbackData[k+3]; if(r !== 255 || g !== 255 || b !== 255 || a !== 255){ const pixelIndex = k / 4; logCanvas(`---> CORRUPÇÃO DETECTADA em ImageData ${i} @ pixel ${pixelIndex}! RGBA=(${r},${g},${b},${a})`, 'critical', FNAME); potentialCorruptionDetected = true; const byte1 = writeValue1 & 0xFF; const byte2 = (writeValue1 >> 8) & 0xFF; const byte3 = (writeValue1 >> 16) & 0xFF; const byte4 = (writeValue1 >> 24) & 0xFF; let matchesPattern = false; if (r === byte1 && g === byte2 && b === byte3 && a === byte4) { matchesPattern = true; logCanvas(`    -> Padrão OOB 1 (0x${writeValue1.toString(16)}) detectado!`, 'vuln', FNAME); } /* else check pattern 2 */ if (matchesPattern) { patternMatched = true; logCanvas(` ---> *** ALERTA: Padrão OOB Write lido de volta do ImageData! Corrupção Controlada! ***`, 'escalation', FNAME); } break; } } }catch(e){ logCanvas(`Erro durante put/getImageData para ImageData ${i}: ${e.message}`, 'error', FNAME); console.error(`Erro ImgData ${i}:`, e); potentialCorruptionDetected = true; } if(i % 5 === 0) await PAUSE(5); } if (patternMatched) { logCanvas(`SUCESSO: Corrupção detectada E padrão OOB lido de volta de um ImageData!`, 'vuln', FNAME); } else if (potentialCorruptionDetected) { logCanvas(`AVISO: Corrupção/Erro detectado em ImageData, mas padrão OOB específico não confirmado.`, 'warn', FNAME); logCanvas(` ---> *** ALERTA: Corrupção de memória instável detectada afetando ImageData! Investigar. ***`, 'escalation', FNAME); } else if (oobWritePerformed) { logCanvas(`Escrita OOB realizada, mas nenhuma corrupção detectada nos ImageDatas.`, 'good', FNAME); } else { logCanvas(`Escrita OOB não realizada/falhou e nenhuma corrupção detectada.`, 'good', FNAME); } logCanvas("--- Teste OOB Write -> ImageData Check Concluído ---",'test', FNAME); await PAUSE();
        };

        // OOB Write Only (Inalterado)
        const testOOBWriteOnly = async () => { /* ...código v16 inalterado... */
            const FNAME = 'testOOBWriteOnly'; logCanvas("--- Teste: OOB Write Only (Trigger) ---",'test', FNAME); const bufferOOBSize=64; const writeValue1=0xDEADBEEF; const writeValue2=0xCAFEBABE; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; let bufferOOB=null; let dv=null; let writeSuccess=false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return false; } const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK.`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeSuccess=true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora do buffer alocado.`, 'error', FNAME); } }catch(e){ logCanvas(`AVISO: Escrita OOB U32x2 falhou/bloqueada @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } logCanvas("--- Teste OOB Write Only Concluído ---",'test', FNAME); await PAUSE(); return writeSuccess;
        };

        // File System Access (Inalterado, reportará N/A)
         const testFileSystemAccess = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testFileSystemAccess'; logCanvas("--- Teste: File System Access API Check ---", 'test', FNAME); let apiAvailable = false; let openFilePickerCalled = false; let saveFilePickerCalled = false; let dirPickerCalled = false; let errorMsg = null; if (window.showOpenFilePicker) { logCanvas("API showOpenFilePicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showOpenFilePicker().then(handles => { logCanvas("showOpenFilePicker resolvido.", 'vuln', FNAME); }).catch(err => { logCanvas(`showOpenFilePicker rejeitado: ${err.name}`, 'warn', FNAME); }); openFilePickerCalled = true; await PAUSE(100); } catch (e) { logCanvas(`Erro síncrono showOpenFilePicker: ${e.message}`, 'error', FNAME); errorMsg = e.message; } } else { logCanvas("API showOpenFilePicker NÃO disponível.", 'good', FNAME); } await PAUSE(MEDIUM_PAUSE); if (window.showSaveFilePicker) { logCanvas("API showSaveFilePicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showSaveFilePicker().then(handle => { logCanvas("showSaveFilePicker resolvido.", 'vuln', FNAME); }).catch(err => { logCanvas(`showSaveFilePicker rejeitado: ${err.name}`, 'warn', FNAME); }); saveFilePickerCalled = true; await PAUSE(100); } catch (e) { logCanvas(`Erro síncrono showSaveFilePicker: ${e.message}`, 'error', FNAME); if (!errorMsg) errorMsg = e.message; } } else { logCanvas("API showSaveFilePicker NÃO disponível.", 'good', FNAME); } await PAUSE(MEDIUM_PAUSE); if (window.showDirectoryPicker) { logCanvas("API showDirectoryPicker disponível.", 'good', FNAME); apiAvailable = true; try { window.showDirectoryPicker().then(handle => { logCanvas("showDirectoryPicker resolvido.", 'vuln', FNAME); }).catch(err => { logCanvas(`showDirectoryPicker rejeitado: ${err.name}`, 'warn', FNAME); }); dirPickerCalled = true; await PAUSE(100); } catch (e) { logCanvas(`Erro síncrono showDirectoryPicker: ${e.message}`, 'error', FNAME); if (!errorMsg) errorMsg = e.message; } } else { logCanvas("API showDirectoryPicker NÃO disponível.", 'good', FNAME); } if (!apiAvailable) { logCanvas("API File System Access não disponível neste navegador/contexto.", 'good', FNAME); } else if (errorMsg) { logCanvas(`Erro encontrado ao chamar APIs File System Access: ${errorMsg}`, 'error', FNAME); } else { logCanvas("Chamadas iniciais APIs File System Access OK.", 'good', FNAME); } logCanvas(`--- Teste File System Access Concluído (Disp: ${apiAvailable}, Chamadas OK: ${openFilePickerCalled}/${saveFilePickerCalled}/${dirPickerCalled}, Erro Sync: ${!!errorMsg}) ---`, 'test', FNAME); await PAUSE();
         };

        // WebGPU Check (Inalterado, reportará N/A)
         const testWebGPUCheck = async () => { /* ...código v16 inalterado... */
             const FNAME = 'testWebGPUCheck'; logCanvas("--- Teste: WebGPU Check ---", 'test', FNAME); let adapterOK = false; let deviceOK = false; let errorMsg = null; gpuAdapter = null; gpuDevice = null; if (!navigator.gpu) { logCanvas("WebGPU API (navigator.gpu) NÃO disponível.", 'good', FNAME); logCanvas(`--- Teste WebGPU Concluído (API Não Disponível) ---`, 'test', FNAME); await PAUSE(); return; } logCanvas("WebGPU API (navigator.gpu) disponível.", 'good', FNAME); try { gpuAdapter = await navigator.gpu.requestAdapter(); if (gpuAdapter) { logCanvas(`Adaptador GPU obtido: ${gpuAdapter.name || 'N/A'}`, 'good', FNAME); adapterOK = true; try { gpuDevice = await gpuAdapter.requestDevice(); if (gpuDevice) { logCanvas("Dispositivo GPU obtido.", 'good', FNAME); deviceOK = true; gpuDevice.addEventListener('uncapturederror', (event) => { logCanvas(`--> ERRO WebGPU: ${event.error.message}`, 'critical', FNAME); console.error("WebGPU Error:", event.error); }); gpuDevice.lost.then((info) => { logCanvas(`--> Dispositivo WebGPU PERDIDO! R: ${info.reason}. M: ${info.message}`, 'critical', FNAME); gpuDevice = null; }); try { const buffer = gpuDevice.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }); logCanvas("Buffer WebGPU criado.", 'good', FNAME); buffer.destroy(); } catch(bufferError) { logCanvas(`Erro criar buffer WebGPU: ${bufferError.message}`, 'error', FNAME); } } else { logCanvas("Falha obter dispositivo GPU (null).", 'error', FNAME); errorMsg = "requestDevice null"; } } catch (deviceError) { logCanvas(`Erro requisitar dispositivo GPU: ${deviceError.message}`, 'error', FNAME); errorMsg = deviceError.message; console.error(deviceError); } } else { logCanvas("Falha obter adaptador GPU (null).", 'warn', FNAME); errorMsg = "requestAdapter null"; } } catch (adapterError) { logCanvas(`Erro requisitar adaptador GPU: ${adapterError.message}`, 'error', FNAME); errorMsg = adapterError.message; console.error(adapterError); } logCanvas(`--- Teste WebGPU Concluído (Adaptador: ${adapterOK}, Disp: ${deviceOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME); await PAUSE();
         };


        // --- Função Principal Canvas (v17) ---
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { /* ... erro fatal ... */ return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true; outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência focada do Script 2 (v17)...", "test", FNAME);

             // *** MODIFICADO v17: Definir quadrados interativos aqui ***
             imgSquares.length = 0; // Limpar array
             let sqX = 10; let sqY = imgSquaresStartY;
             const squareDefs = [
                 { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, // Laranja: Roda teste Metadata
                 { id: 'imgSq1', text: 'WebGL', color: '#C70039', action: testWebGLDeeperPlus }, // Vermelho: Roda teste WebGL
                 { id: 'imgSq2', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, // Roxo: Roda teste ImageData
                 { id: 'imgSq3', text: 'File', color: '#581845', action: testFileSystemAccess }, // Roxo escuro: Roda teste File
                 { id: 'imgSq4', text: 'GPU', color: '#337BFF', url: 'https://github.com/' } // Azul: Abre Link GitHub
             ];
            squareDefs.forEach(def => {
                 imgSquares.push({
                     id: def.id, x: sqX, y: sqY, size: imgSquareSize,
                     color: def.color, text: def.text, hover: false,
                     url: def.url, // Adiciona URL se definido
                     action: def.action // Adiciona ação se definido
                 });
                 sqX += imgSquareSize + imgSquareSpacing;
                 if (sqX + imgSquareSize > canvasElement.width - 10) { // Quebra de linha simples
                     sqX = 10; sqY += imgSquareSize + imgSquareSpacing;
                 }
             });


            try {
                try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                redrawAll(); await PAUSE();

                 // Ler leak S1
                 try { /* ...código v16 inalterado... */ if (typeof leakedValueFromOOB !== 'undefined') { const l = leakedValueFromOOB; if(l){ const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 nulo/não encontrado.`, 'warn', FNAME); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } else { logCanvas(`-> Var 'leakedValueFromOOB' S1 N/A.`, 'error', FNAME); currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; console.error(e); }
                 redrawAll(); await PAUSE();

                // Sequência de Testes S2 Automáticos
                await testWebGLCheck();
                await PAUSE(SHORT_PAUSE_CANVAS);
                 await testAdvancedPP(); // *** Adicionar mais PP aqui ***
                 await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced();
                 await PAUSE(SHORT_PAUSE_CANVAS);
                 await testOOBWriteMetadata(); // *** Adicionar logs aqui ***
                 await PAUSE(SHORT_PAUSE_CANVAS);
                logCanvas("--- Iniciando Teste de Interação OOB Write -> WebGL (Pulado se WebGL N/A) ---", 'test', FNAME);
                 const oobWriteInteractionOK = await testOOBWriteOnly();
                 await testWebGLDeeperPlus(); // Será pulado se WebGL N/A
                 if (oobWriteInteractionOK && glContext) { logCanvas(` ---> *** ALERTA POTENCIAL: WebGL funcionou após OOB Write. Investigar. ***`, 'escalation', FNAME); }
                 logCanvas("--- Teste Interação OOB Write -> WebGL Concluído ---", 'test', FNAME);
                 await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteToImageDataCheck();
                 await PAUSE(SHORT_PAUSE_CANVAS);
                 await testFileSystemAccess(); // Reportará N/A
                 await PAUSE(SHORT_PAUSE_CANVAS);
                 await testWebGPUCheck(); // Reportará N/A
                 await PAUSE(SHORT_PAUSE_CANVAS);

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME);
                await PAUSE(100);

                // Listeners Interativos
                if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} }
                if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                // Listener MouseMove (inalterado)
                canvasMoveListener = (event) => { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let needsRedraw = false; let newHoverTarget = null; let cursorStyle = 'default'; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { newHoverTarget = a.id; cursorStyle = 'pointer'; } }); imgSquares.forEach(sq => { let oldHover = sq.hover; sq.hover = false; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { newHoverTarget = sq.id; cursorStyle = sq.url ? 'pointer' : 'crosshair'; sq.hover = true; } if(oldHover !== sq.hover) needsRedraw = true; }); if (newHoverTarget !== currentHoverTarget) { currentHoverTarget = newHoverTarget; needsRedraw = true; } try { if(needsRedraw){ redrawAll(); } canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e){ logCanvas(`Erro mousemove: ${e.message}`, 'error', 'MouseMove'); console.error(e); } };

                 // *** MODIFICADO v17: Listener Click com novas ações ***
                 canvasClickListener = async (event) => {
                    const FNAME_CLICK = 'CanvasClick';
                    try {
                        const rect = canvasElement.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        let clickedArea = null;
                        interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; } });
                        let clickedSquare = null;
                         imgSquares.forEach((sq) => { if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquare = sq; } });

                        if (clickedArea) {
                            logCanvas(`Click Área: ${clickedArea.text} (ID: ${clickedArea.id})`, 'info', FNAME_CLICK);
                            switch (clickedArea.id) {
                                case 'rect-log': logCanvas('Click no botão de log.', 'info', FNAME_CLICK); break;
                                case 'rect-link': logCanvas('Abrindo link externo...', 'info', FNAME_CLICK); try { window.open('https://google.com', '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } break;
                                case 'rect-rerun': logCanvas('Re-lendo leak S1...', 'info', FNAME_CLICK); /* ...código re-read leak v16... */ try { if(typeof leakedValueFromOOB !== 'undefined'){ const l=leakedValueFromOOB; if(l){const ls=l.type==='U64'?`L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Re-read Leak S1: ${ls}`,'leak', FNAME_CLICK); currentLeakData={text:ls, color:"#FF9800"};} else { logCanvas(`-> Re-read Leak S1: Nulo`, 'warn', FNAME_CLICK); currentLeakData={text:"L(S1):NULO", color:"#FFC107"};} } else { logCanvas(`-> Re-read Leak S1: Var N/A`, 'error', FNAME_CLICK); currentLeakData={text:"L(S1):Var N/A", color:"#F44336"};}}catch(e){ logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK);} redrawAll(); break;
                            }
                        } else if (clickedSquare) {
                            logCanvas(`Click Quadrado ID: ${clickedSquare.id} (Texto: ${clickedSquare.text})`, 'vuln', FNAME_CLICK);

                             // Ação 1: Abrir URL se existir
                             if (clickedSquare.url) {
                                logCanvas(`Abrindo URL: ${clickedSquare.url}`, 'info', FNAME_CLICK);
                                try { window.open(clickedSquare.url, '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); }
                             }
                             // Ação 2: Executar re-run se existir
                             else if (clickedSquare.action && typeof clickedSquare.action === 'function') {
                                 let actionError = null;
                                 if (runBtnCanvas) runBtnCanvas.disabled = true;
                                 logCanvas(`Executando re-run ${clickedSquare.id} (${clickedSquare.action.name})...`, 'test', FNAME_CLICK);
                                 try {
                                     await clickedSquare.action(); // Executa a função de teste associada
                                     logCanvas(`Re-run ${clickedSquare.id} concluído sem erro aparente.`, 'good', FNAME_CLICK);
                                 } catch (e) {
                                     logCanvas(`Erro durante re-run ${clickedSquare.id}: ${e.message}`, 'error', FNAME_CLICK);
                                     console.error(`Erro ação ${clickedSquare.id}:`, e); actionError = e;
                                 } finally {
                                     clickedSquare.color = actionError ? 'orange' : 'purple'; // Muda cor após execução
                                     redrawAll();
                                     if (runBtnCanvas) runBtnCanvas.disabled = false;
                                     logCanvas(`Re-run ${clickedSquare.id} finalizado.`, 'test', FNAME_CLICK);
                                 }
                             } else {
                                 logCanvas(`Nenhuma ação definida para o quadrado ${clickedSquare.id}.`, 'info', FNAME_CLICK);
                                 // Poderia adicionar lógica para modificar texto aqui se desejado
                                 // clickedSquare.text += "*"; redrawAll();
                             }
                        } else {
                           // Click fora das áreas interativas (omitir log)
                        }
                    } catch (e) {
                        logCanvas(`Erro GERAL listener clique: ${e.message}`, 'error', FNAME_CLICK);
                        console.error(e);
                        if (runBtnCanvas) runBtnCanvas.disabled = false;
                    }
                 }; // Fim canvasClickListener


                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                redrawAll();

            } catch(e) {
                 logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack);
             }
             finally {
                 logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME);
                 if (runBtnCanvas) runBtnCanvas.disabled = false;
             }
        };

        // Wrapper e Unload (Inalterados)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); gpuDevice = null; gpuAdapter = null; } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
