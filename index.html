<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v20 - Base Original + Canvas Isolado</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; } /* Renomeado ID do canvas */
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>PoC v20 - Base Original + Canvas Isolado</h1>
    <canvas id="interactive-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ‚Üë</div>
    <p>Fase 1: PoC Original v9 Intacto (do seu arquivo). Fase 2: Apenas Teste de Canvas Isolado.</p>
    <button id="runBtn" onclick="runEverythingInSequence_v20()">Iniciar Teste Completo</button>
    <div id="output"></div>
    <div id="xss-target-div">√Årea para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const canvasElement = document.getElementById('interactive-canvas'); // Refer√™ncia correta
        const coordStatusDiv = document.getElementById('canvas-coord-status');
        const SHORT_PAUSE = 50; // Usado pelo c√≥digo original
        const MEDIUM_PAUSE = 500; // Usado pelo c√≥digo original
        const LONG_PAUSE = 10000; // Pausa longa (10s) entre fases
        let leakedValueFromOOB = null; // Global Original (setado por Fase 1)
        // Globais para Canvas Fase 2
        let canvasClickListener = null;
        let canvasMoveListener = null;
        let rectArea = { x: 10, y: 10, w: 50, h: 50 }; // √Årea 1 para clique
        let linkArea = { x: 150, y: 100, w: 80, h: 30 }; // √Årea 2 (link)

        // --- Fun√ß√£o de Log (Original) ---
        const log = (message, type = 'info') => { /* ... (implementa√ß√£o completa) ... */ };

        // --- Helpers (Originais) ---
        const toHex = (val, bits = 32) => { /* ... (implementa√ß√£o completa) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (l√≥gica original) ... */ };
        const isPotentialData32 = (val) => { /* ... (l√≥gica original) ... */ };


        // ============================================================
        // --- FASE 1: C√≥digo Original Intacto (`index-18.html`) ---
        // ============================================================
        log("Definindo Fun√ß√µes Originais da Fase 1 (Base Intacta)", "info");

        // --- Teste 1 Original: ---
        const testCSPBypass = async () => { /* ... C√≥digo EXATO do Teste 1 original (com alerts) ... */ };
        // --- Teste 2 Original: ---
        const testOOBReadInfoLeakEnhancedStore = async () => { /* ... C√≥digo EXATO do Teste 2 original ... */ };
        // --- Teste 3 Original: ---
        const testBasicPP = async () => { /* ... C√≥digo EXATO do Teste 3 original ... */ };
        // --- Teste 4 Original: ---
        const testPPJsonHijack = async () => { /* ... C√≥digo EXATO do Teste 4 original ... */ };
        // --- Fun√ß√£o Principal Original (`runAllTests`) ---
        const runAllTests = async () => { /* ... C√≥digo EXATO de runAllTests original ... */ };

        // --- FIM DO C√ìDIGO ORIGINAL ---


        // ==========================================================
        // --- FASE 2: Teste de Canvas Isolado ---
        // ==========================================================
        log("Definindo Teste Isolado da Fase 2 (Canvas)", "info");

        const runIsolatedCanvasTest = async () => {
            log("--- [Fase 2] Iniciando Teste Isolado de Canvas ---", 'test');
            let ctx = null;
            try {
                if (!canvasElement || !canvasElement.getContext) throw new Error('Elemento Canvas n√£o encontrado/suportado');
                ctx = canvasElement.getContext('2d');
                if (!ctx) throw new Error('Contexto 2D n√£o dispon√≠vel');
                log("[F2 Canvas] Contexto 2D obtido.", 'info');
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.fillStyle = "#334"; // Fundo diferente para F2
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            } catch(e) { log(`[F2 Canvas] Falha no setup: ${e.message}`, 'error'); return; }

            // 1. Desenho
            log("Desenhando formas...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE));
            try {
                // Atualiza √°reas globais com as posi√ß√µes usadas aqui
                rectArea = { x: 10, y: 10, w: 50, h: 50 };
                linkArea = { x: 150, y: 100, w: 80, h: 30 };

                ctx.fillStyle="#FF5733"; ctx.fillRect(rectArea.x, rectArea.y, rectArea.w, rectArea.h); // Laranja
                ctx.fillStyle="#33FF57"; ctx.beginPath(); ctx.arc(120, 50, 30, 0, 2*Math.PI); ctx.fill(); // Verde
                ctx.fillStyle="rgba(50, 150, 255, 0.7)"; ctx.fillRect(linkArea.x, linkArea.y, linkArea.w, linkArea.h); // Azul Transp
                ctx.fillStyle="#FFFFFF"; ctx.font="bold 14px monospace"; ctx.textAlign="center";
                ctx.fillText("Abrir Link", linkArea.x + linkArea.w / 2, linkArea.y + linkArea.h / 2 + 5);
                ctx.textAlign="start";
                log("[F2 Canvas] Formas desenhadas.", 'info');
            } catch(e) { log(`[F2 Canvas] Erro durante desenho: ${e.message}`, 'error'); }

            // 2. Teste de APIs e Quirks
            log("Verificando APIs e Quirks...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE));
            try {
                const filterSupported = typeof ctx.filter !== 'undefined';
                log(`[F2 Canvas] API Filter Suportado: ${filterSupported}`, filterSupported ? 'info' : 'warn');
                const pngURL = canvasElement.toDataURL('image/png');
                const jpegURL = canvasElement.toDataURL('image/jpeg');
                const urlQuirk = pngURL.length === jpegURL.length || pngURL.substring(30,70) === jpegURL.substring(30,70);
                log(`[F2 Canvas] toDataURL PNG(len ${pngURL.length}) / JPEG(len ${jpegURL.length}). Quirk: ${urlQuirk}`, urlQuirk ? 'warn' : 'info');
                log(`[F2 Canvas] API ellipse: ${typeof ctx.ellipse==='function'}`, 'info');
                log(`[F2 Canvas] API measureText: ${typeof ctx.measureText==='function'}`, 'info');
                if (typeof ctx.measureText==='function') { log(`  measureText('Testüòä'): width ${ctx.measureText('Testüòä').width.toFixed(1)}`, 'info'); }
            } catch(e) { log(`[F2 Canvas] Erro API Check: ${e.message}`, 'error'); }

            // 3. Interatividade
            log("Adicionando listeners 'click' e 'mousemove'...", 'subtest');
            await new Promise(r => setTimeout(r, SHORT_PAUSE));
            if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} }
            if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }

            canvasClickListener = (event) => {
                try{ const r=canvasElement.getBoundingClientRect();const x=event.clientX-r.left; const y=event.clientY-r.top; let area='fora';
                     // Usa as vari√°veis globais atualizadas
                     if(x>=rectArea.x&&x<=rectArea.x+rectArea.w&&y>=rectArea.y&&y<=rectArea.y+rectArea.h) area='Rect Laranja';
                     else if(x>=linkArea.x&&x<=linkArea.x+linkArea.w&&y>=linkArea.y&&y<=linkArea.y+linkArea.h) area='√Årea Link';
                     log(`[F2 Canvas] Click! Area: ${area}. Coords: x=${x.toFixed(0)}, y=${y.toFixed(0)}`, 'warn'); // Warn p/ destacar
                     if(area==='√Årea Link'){
                         log("--> A√ß√£o LINK: Tentando abrir google.com...", 'vuln'); // Vuln p/ destacar
                         try{ window.open('https://google.com','_blank'); } catch(e){logCanvas('Erro ao abrir link (bloqueado?): '+e.message,'error');}
                     }
                }catch(e){logCanvas(`Erro click handler: ${e.message}`,'error');} // Usa logCanvas aqui? N√£o, usar log normal
            };
            canvasMoveListener = (event) => {
                 try { const r=canvasElement.getBoundingClientRect();const x=event.clientX-r.left; const y=event.clientY-r.top; if(coordStatusDiv) coordStatusDiv.textContent = `Canvas Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e) {}
            };

            try { canvasElement.addEventListener('click', canvasClickListener); canvasElement.addEventListener('mousemove', canvasMoveListener); log("[F2 Canvas] Listeners adicionados.", 'good'); }
            catch (e) { log(`[F2 Canvas] Erro add listeners: ${e.message}`, 'error'); }

            log("--- [Fase 2] Teste Isolado de Canvas Conclu√≠do ---", 'test');
        };


        // --- Fun√ß√£o Principal Nova ---
        const runEverythingInSequence_v19 = async () => { // Renomear para v20? Mantendo v19 por enquanto
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v19 (Base Intacta + Canvas Isolado) ====", 'critical');

            log(">>> Iniciando Fase 1 (Execu√ß√£o Original 'runAllTests') <<<", 'warn');
            // Chama a fun√ß√£o original SEM await para n√£o depender de sua conclus√£o correta
            runAllTests();
            log(">>> Fase 1 ('runAllTests') INICIADA. Aguardando tempo fixo... <<<", 'warn');


            log(`\n>>> PAUSA LONGA ANTES DA FASE 2 (${LONG_PAUSE/1000} segundos) <<<\n`, "warn");
            await new Promise(r => setTimeout(r, LONG_PAUSE));


            log(">>> Iniciando Fase 2 (Teste de Canvas Isolado) <<<", 'warn');
            // Chama APENAS o teste de canvas isolado
            await runIsolatedCanvasTest();
            log(">>> Fase 2 (Teste de Canvas Isolado) CONCLU√çDA <<<", 'warn');


            log("\n==== PoC Final v19 CONCLU√çDA ====", 'critical');
            log("Listeners do Canvas podem continuar ativos.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza listeners
        window.addEventListener('unload', () => { if(canvasClickListener && canvasElement) canvasElement.removeEventListener('click',canvasClickListener); if(canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove',canvasMoveListener); });
        // O bot√£o chama runEverythingInSequence_v19
        // document.addEventListener('DOMContentLoaded', runEverythingInSequence_v19);

    </script>

</body>
</html>
