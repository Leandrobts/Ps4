<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - Teste v12 (PP Agressivo 2)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div, #iframe-target-div { border: 2px dotted orange; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        iframe { width: 90%; height: 50px; border: 1px solid #555; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - Teste v12 (PP Agressivo 2)</h1>
    <p>Testa: XSS, OOB R/W (Info Leak), PP Gadget (srcdoc), PP Hijack (createElement).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>
    <div id="iframe-target-div">
        Área para teste do iframe (srcdoc):<br>
        <iframe id="test-iframe"></iframe>
    </div>


    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms

        // --- Função de Log ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false;
            if (high === 0 && low < 0x100000) return false;
            return true;
        };

         // --- Heurística Simples para Detetar Potenciais Dados U32 ---
         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0;
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
             if (val < 0x1000) return false;
             return true;
         }

        // --- Teste 1: CSP Bypass / XSS ---
        // (Função testCSPBypass igual à versão anterior)
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // ... (código igual ao script v9) ...
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        // --- Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---
        // (Função igual à v7/v9 - focada em info leak)
        const testOOBReadInfoLeakEnhanced = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---", 'test');
            // ... (código igual ao script v9) ...
            const bufferSize = 32;
            const writeValue = 0xEE;
            const oobWriteOffset = 32;
            const oobReadOffsets = [];
            for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false;
            let potentialLeakFoundCount = 0;

            try {
                const buffer = new ArrayBuffer(bufferSize + 256);
                const dataView = new DataView(buffer);
                const baseOffset = 128;
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }

                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset}...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                    writeSuccess = true;
                } catch (e) {
                    log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good');
                    log("--- Teste 2 Interrompido (Escrita OOB falhou) ---", 'test');
                    return false;
                }

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;
                    if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;

                    try {
                        const low = dataView.getUint32(readTargetAddress, true);
                        const high = dataView.getUint32(readTargetAddress + 4, true);
                        if (isPotentialPointer64(high, low)) {
                            const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                            log(`  -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr');
                            potentialLeakFoundCount++;
                        } else {
                            const val32 = low;
                            if (isPotentialData32(val32)) {
                                log(`  -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak');
                                potentialLeakFoundCount++;
                            }
                        }
                    } catch (e) {/* Ignora */}
                    if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }

            log(`--- Teste 2 Concluído (${potentialLeakFoundCount} potenciais leaks encontrados) ---`, 'test');
            return writeSuccess;
        };

        // --- Teste 3: Prototype Pollution (Básica) ---
        // (Função testBasicPP igual à versão anterior)
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            // ... (código igual ao script v9) ...
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: PP Gadget (srcdoc) ---
        // NOVO: Tenta poluir srcdoc e aplicá-lo a um iframe
        const testPPSrcdocGadget = async () => {
            log("--- Iniciando Teste 4: PP Gadget (srcdoc) ---", 'test');
            const testProp = 'srcdoc';
            // Conteúdo HTML a ser injetado no iframe
            const testValue = '<!DOCTYPE html><html><body style="background:red; color:white;"><h1>PP Gadget srcdoc Funcionou!</h1></body></html>';
            let pollutionDone = false;
            let gadgetWorked = false;
            const iframeId = 'test-iframe';

            try {
                log(`Poluindo Object.prototype.${testProp}...`, 'subtest');
                 // Verifica se já existe para segurança
                if (Object.prototype.hasOwnProperty(testProp)) {
                     log(`Aviso: Object.prototype já possui ${testProp}. Teste abortado.`, 'warn');
                     log(`--- Teste 4 Concluído (Abortado) ---`, 'test');
                     return false;
                }
                Object.prototype[testProp] = testValue;
                pollutionDone = true;
                log(`Object.prototype.${testProp} poluído.`, 'info');

                log("Acedendo ao iframe existente e verificando srcdoc...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const iframe = document.getElementById(iframeId);

                if (iframe) {
                    // Força uma re-renderização ou acesso que possa acionar a herança
                    // A simples leitura de iframe.srcdoc pode não ser suficiente
                    log(`Verificando iframe.contentWindow.location (pode não refletir srcdoc imediatamente)...`, 'info');
                     try {
                         // Tenta aceder ao conteúdo - pode falhar devido a same-origin se srcdoc funcionar
                         const iframeContent = iframe.contentWindow.document.body.innerHTML;
                         log(`Conteúdo inicial do iframe (antes de srcdoc ter efeito?): ${iframeContent.substring(0,50)}...`, 'info');
                     } catch(e) {
                         log(`AVISO: Erro ao aceder conteúdo do iframe (esperado se srcdoc funcionou?): ${e.message}`, 'warn');
                     }

                    // A melhor forma de verificar é visualmente ou esperando um pouco
                    log("Verifique VISUALMENTE se o conteúdo do iframe abaixo mudou (fundo vermelho, texto).", 'warn');
                    // Vamos assumir sucesso se a poluição foi feita, a verificação visual é necessária
                    // Poderíamos tentar um timeout e verificar o conteúdo depois, mas é complexo
                    gadgetWorked = true; // Assume sucesso para log, mas requer confirmação visual
                    log(`VULN?: PP Gadget srcdoc potencialmente funcionou. Confirmação visual necessária.`, 'vuln');

                } else {
                    log(`Erro: Iframe com id "${iframeId}" não encontrado.`, 'error');
                }

            } catch (e) {
                log(`Erro durante teste PP Gadget srcdoc: ${e.message}`, 'error');
            } finally {
                // Limpeza
                if (pollutionDone) {
                    try { delete Object.prototype[testProp]; } catch(e){}
                    log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
                }
            }
            log(`--- Teste 4 Concluído (PP Gadget srcdoc ${gadgetWorked ? 'Potencialmente Funcionou' : 'Falhou'}) ---`, 'test');
            return gadgetWorked; // Retorna true se tentou, requer confirmação visual
        };

        // --- Teste 5: PP Hijack (document.createElement) ---
        // NOVO: Tenta sequestrar a criação de elementos
        const testPPCreateElementHijack = async () => {
            log("--- Iniciando Teste 5: PP Hijack (document.createElement) ---", 'test');
            // Guarda a função original (importante!)
            const originalCreateElement = document.createElement;
            let hijackSuccessful = false;
            let executionSuccessful = false;

            try {
                log("Tentando sobrescrever document.createElement...", 'subtest');
                // ATENÇÃO: Mexer em document pode ser instável!
                // Usar Object.prototype aqui pode não funcionar diretamente para métodos do 'document'.
                // Vamos tentar poluir o protótipo do próprio 'document' se possível, ou globalmente.
                // Abordagem mais segura: poluir globalmente e esperar que afete o document.
                 if (Object.prototype.hasOwnProperty('createElement')) {
                     log(`Aviso: Object.prototype já possui createElement. Teste abortado.`, 'warn');
                     log(`--- Teste 5 Concluído (Abortado) ---`, 'test');
                     return false;
                 }

                Object.prototype.createElement = function hijackedCreateElement(tagName, options) {
                    log(`===> VULN: DENTRO DA FUNÇÃO document.createElement SEQUESTRADA! (Tentativa de criar: ${tagName}) <===`, 'vuln');
                    hijackSuccessful = true;

                    // Loga os argumentos recebidos
                    log(`  -> Hijack createElement: tagName=${tagName}, options=${options}`, 'info');

                    // Chama a função original para realmente criar o elemento
                    // É crucial chamar a original para não quebrar completamente o DOM
                    try {
                         log(`  -> Hijack createElement: Chamando originalCreateElement...`, 'info');
                         // 'this' aqui pode não ser 'document', usar 'document' explicitamente
                         const element = originalCreateElement.call(document, tagName, options);
                         log(`  -> Hijack createElement: Elemento criado pela original: ${element ? element.tagName : 'null'}`, 'info');
                         // Poderia modificar o elemento aqui antes de retornar
                         // Ex: element.style.border = "2px solid magenta";
                         return element;
                    } catch(e) {
                         log(`  -> Hijack createElement: Erro ao chamar original: ${e.message}`, 'error');
                         // Tenta retornar um placeholder para evitar mais erros
                         return originalCreateElement.call(document, 'div'); // Cria um div como fallback
                    }
                };
                log("Object.prototype.createElement poluído.", 'info');


                log("Testando a função createElement sequestrada criando um <span>...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    const newSpan = document.createElement('span'); // Chama a função (potencialmente sequestrada)
                    log(`Elemento criado: ${newSpan ? newSpan.tagName : 'null'}`, 'info');
                    // Verifica se o log interno do hijack apareceu
                    // A confirmação real vem da mensagem "DENTRO DA FUNÇÃO..."
                    if (hijackSuccessful) {
                        log("VULN: Execução da função createElement sequestrada confirmada pelo log interno!", 'vuln');
                        executionSuccessful = true;
                    }
                } catch(e) {
                     log(`Erro ao tentar criar elemento com createElement sequestrado: ${e.message}`, 'error');
                }

            } catch (e) {
                log(`Erro durante teste PP Hijack createElement: ${e.message}`, 'error');
            } finally {
                // Restaura a função original SEMPRE
                // A restauração pode falhar se o protótipo foi alterado de forma inesperada
                try {
                     // Tenta restaurar no protótipo e no document para garantir
                     delete Object.prototype.createElement;
                     document.createElement = originalCreateElement;
                     log("Tentativa de restauração de document.createElement realizada.", 'info');
                     if (document.createElement === originalCreateElement) { log("Restauração de createElement confirmada.", 'info'); }
                     else { log("ERRO CRÍTICO: FALHA ao restaurar document.createElement!", 'error'); }
                } catch(restoreError) {
                     log(`Erro ao restaurar createElement: ${restoreError.message}`, 'error');
                }
            }
            log(`--- Teste 5 Concluído (PP Hijack createElement ${executionSuccessful ? 'Confirmado' : 'Falhou'}) ---`, 'test');
            return executionSuccessful;
        };


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO TODOS OS TESTES COMBINADOS v12 (PP Agressivo 2) ====", 'critical');

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testOOBReadInfoLeakEnhanced(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3 (PP Básica primeiro)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testPPSrcdocGadget(); // Teste 4 (NOVO - srcdoc)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testPPCreateElementHijack(); // Teste 5 (NOVO - createElement)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            log("\n==== TODOS OS TESTES COMBINADOS v12 CONCLUÍDOS ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
```

**O que procurar nos resultados:**

* **Teste 4 (PP Gadget `srcdoc`):** Olhe para o `<iframe>` na parte inferior da página. Mudou o conteúdo para ter fundo vermelho e o texto "PP Gadget srcdoc Funcionou!"? O log indicará "Potencialmente Funcionou", mas a confirmação é visual.
* **Teste 5 (PP Hijack `createElement`):** Procure no log pela mensagem `VULN: DENTRO DA FUNÇÃO document.createElement SEQUESTRADA!`. Se ela aparecer quando o script tenta criar um `<span>`, o hijack funcionou.

Estes testes exploram vetores diferentes de PP. O sucesso em qualquer um deles demonstra um controlo significativo sobre o ambiente do navegad
