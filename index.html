<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Script Isolado - Parte 2 Revisada (Canvas v18 Debug)</title>
    <style>
        /* Estilos CSS Essenciais para Parte 2 */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 75vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Script Isolado - Parte 2 Revisada (Canvas v18 Debug)</h1>
    <section>
        <h2>Teste de Canvas Focado (v18)</h2>
        <p>Foco: PP Avançado++, Gadget Impact, OOB Read++(Heuristics), OOB Write->Metadata(Detailed Log), Complex Canvas, WebGL(N/A), FileSystem(N/A), WebGPU(N/A), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="350" height="200"></canvas> 
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v18</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 2 Revisado: Canvas (v18 Debug) ---

        // --- Variáveis Globais ---
        const SHORT_PAUSE_CANVAS = 50;
        const MEDIUM_PAUSE_CANVAS = 400;
        let canvasClickListener = null; 
        let canvasMoveListener = null; 
        let currentHoverTarget = null;
        const interactiveAreas = [
            { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' },
            { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' },
            { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' }
        ];
        const imgSquareSize = 30; 
        const imgSquareSpacing = 6; 
        const imgSquares = []; 
        const imgSquaresStartY = 55;
        let leakedValueFromOOB = null; // Viria do Script 1
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; 
        let coordStatusDiv = null; 
        let canvasElement = null; 
        let ctx = null; 
        let glContext = null; 
        let isWebGL2 = false;
        let gpuAdapter = null; 
        let gpuDevice = null;
        let ppGadgetsDetected = {};

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        
        const logCanvas = (message, type = 'info', funcName = '') => {
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const escapedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                
                if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas');
                if (!outputDivCanvas) return;

                const logEntry = `<span class="log-${logClass}">${timestamp} ${funcName ? `[${funcName}] ` : ''}${escapedMessage}\n</span>`;
                
                // Handle log truncation
                if (outputDivCanvas.innerHTML.length > 900000) {
                    outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 450000);
                    outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML;
                }
                outputDivCanvas.innerHTML += logEntry;
                outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight;
            } catch (e) {
                console.error("Erro ao registrar no log:", e);
            }
        };

        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(resolve => setTimeout(resolve, ms));

        const toHexCanvas = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            const n = bits <= 32 ? val >>> 0 : val;
            const hex = n.toString(16).toUpperCase().padStart(Math.ceil(bits / 4), '0');
            return '0x' + hex;
        };

        const redrawAll = () => {
            if (!ctx || !canvasElement) return;
            try {
                ctx.save();
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.fillStyle = "#334";
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);

                interactiveAreas.forEach(area => {
                    ctx.fillStyle = (currentHoverTarget === area.id) ? area.hoverColor : area.color;
                    ctx.fillRect(area.x, area.y, area.w, area.h);
                    ctx.fillStyle = "#FFF";
                    ctx.font = "bold 12px mono";
                    ctx.textAlign = "center";
                    ctx.fillText(area.text, area.x + area.w / 2, area.y + area.h / 2 + 4);
                });

                ctx.textAlign = "start";
                ctx.fillStyle = currentLeakData.color;
                ctx.font = "12px mono";
                ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5);
                ctx.restore();
            } catch (e) {
                logCanvas(`Erro no redrawAll: ${e.message}`, 'error', 'redrawAll');
            }
        };

        // --- Função Principal ---
        const runCanvasTestSequence = async () => {
            outputDivCanvas = document.getElementById('output-canvas');
            coordStatusDiv = document.getElementById('canvas-coord-status');
            canvasElement = document.getElementById('interactive-canvas');
            const runBtnCanvas = document.getElementById('runCanvasBtn');

            if (!outputDivCanvas || !canvasElement || !coordStatusDiv || !runBtnCanvas) {
                alert("Erro: Elementos essenciais não encontrados!");
                console.error("Erro: IDs output-canvas, interactive-canvas, canvas-coord-status ou runCanvasBtn ausentes.");
                return;
            }

            runBtnCanvas.disabled = true;
            outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência de testes do Canvas (v18)...", "test");

            try {
                ctx = canvasElement.getContext('2d');
                if (!ctx) throw new Error("Falha ao obter contexto 2D.");
                redrawAll();
                await PAUSE();

                // Realizar os testes (chamadas de funções de teste específicas)
                logCanvas("--- Sequência concluída ---", 'test');
            } catch (e) {
                logCanvas(`Erro geral no script: ${e.message}`, 'critical');
                console.error(e);
            } finally {
                runBtnCanvas.disabled = false;
            }
        };

        const runCanvasTest = async () => { await runCanvasTestSequence(); };

        window.addEventListener('unload', () => {
            try {
                if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener);
                if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener);
                gpuDevice = null;
                gpuAdapter = null;
            } catch (e) {
                console.error("Erro ao limpar recursos:", e);
            }
        });
    </script>
</body>
</html>
