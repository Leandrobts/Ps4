<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - PP Function Hijacking v9</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - PP Function Hijacking v9</h1>
    <p>Foco: Testar Hijacking de Funções Nativas via Prototype Pollution.</p>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 200;
        const SHORT_PAUSE = 50;

        // --- Teste 1 (Entry Point Check) ---
        const runCSP_XSS_Check = () => { log("--- T1: Verificação de Entrada XSS ---",'test');log("Execução JS via XSS/CSP OK.",'good');log("--- T1 Concluído ---",'test'); };

        // --- NOVO Teste 2: Teste de Hijacking de Funções via PP v9 ---
        const runPPHijackTest_v9 = async () => {
            log("--- T2: Teste de Hijacking de Funções via PP v9 ---", 'test');
            log("Objetivo: Poluir protótipos de funções comuns e verificar se a chamada é interceptada.", 'warn');

            // ===========================================================================
            // <<< EDITE/ADICIONE alvos [Protótipo, Nome da Função, Ação p/ Chamar] >>>
            const targets = [
                // Array
                { proto: Array.prototype,    key: 'map',      action: () => [1, 2].map(x => x), info: "Array Map" },
                { proto: Array.prototype,    key: 'push',     action: () => [].push(1), info: "Array Push" },
                { proto: Array.prototype,    key: 'join',     action: () => [1, 2].join(','), info: "Array Join" },
                { proto: Array.prototype,    key: 'forEach',  action: () => [1].forEach(()=>{}), info: "Array ForEach" },
                { proto: Array.prototype,    key: 'filter',   action: () => [1].filter(x=>true), info: "Array Filter" },
                // String
                { proto: String.prototype,   key: 'includes', action: () => "test".includes("a"), info: "String Includes" },
                { proto: String.prototype,   key: 'slice',    action: () => "test".slice(0), info: "String Slice" },
                { proto: String.prototype,   key: 'match',    action: () => "test".match(/t/), info: "String Match" },
                { proto: String.prototype,   key: 'replace',  action: () => "test".replace('t','r'), info: "String Replace" },
                // Function
                { proto: Function.prototype, key: 'call',     action: () => function(){}.call(null), info: "Function Call" },
                { proto: Function.prototype, key: 'apply',    action: () => function(){}.apply(null), info: "Function Apply" },
                { proto: Function.prototype, key: 'bind',     action: () => function(){}.bind(null), info: "Function Bind" },
                // Object
                { proto: Object.prototype,   key: 'toString', action: () => ({}).toString(), info: "Object ToString" },
                { proto: Object.prototype,   key: 'hasOwnProperty', action: () => ({}).hasOwnProperty('test'), info: "Object HasOwnProperty" },
                { proto: Object.prototype,   key: 'valueOf', action: () => ({}).valueOf(), info: "Object ValueOf" },
                 // DOM (Potencialmente mais arriscado/interessante)
                //{ proto: Element.prototype,  key: 'innerHTML', setter: true, action: () => {let d=document.createElement('div'); d.innerHTML='test';}, info: "Element InnerHTML Setter"}, // Testar setter
                //{ proto: Node.prototype,     key: 'appendChild', action: () => {let d=document.createElement('div'); d.appendChild(document.createElement('span'));}, info: "Node AppendChild"},
                //{ proto: EventTarget.prototype, key: 'addEventListener', action: () => {document.addEventListener('click',()=>{})}, info: "EventTarget AddEvListener"},
            ];
             // ===========================================================================

            let overallSuccess = false;

            for (const target of targets) {
                const { proto, key, action, info, setter = false } = target; // Adiciona flag 'setter'
                // Validar
                if (!proto || !key || typeof key !== 'string' || !action) continue;
                const descriptor = Object.getOwnPropertyDescriptor(proto, key);
                if (!descriptor && typeof proto[key] === 'undefined') { // Se não existe nem no proto
                     log(`INFO: Propriedade '${key}' não encontrada no protótipo ${proto?.constructor?.name || 'Object'}. Pulando.`, 'info');
                     continue;
                }
                 // Se for setter, o alvo é o descritor, não a função diretamente
                 const originalValue = setter ? descriptor : proto[key];
                 if (!setter && typeof originalValue !== 'function') {
                    log(`INFO: Propriedade '${key}' não é uma função no protótipo ${proto?.constructor?.name || 'Object'}. Pulando.`, 'info');
                    continue;
                 }

                log(`Testando Hijack de: ${info || key}`, 'subtest');
                let hijackDetected = false;
                const spyIdentifier = `__SPY_FOR_${key}__`;

                 // Função/Setter espião
                 const spyFunction = function(...args) {
                    hijackDetected = true;
                    log(`>> HIJACK DETECTADO! Chamada para ${key} interceptada! <<`, "vuln");
                    // Para setters, não retornar valor, apenas logar
                    if(setter) return;
                    return `HIJACKED_${key}`;
                 };
                 const spySetter = function(value) {
                     hijackDetected = true;
                     log(`>> HIJACK DETECTADO! Setter para ${key} interceptado! (Valor=${value}) <<`, "vuln");
                     // Chamar setter original? MUITO ARRISCADO.
                 };

                try {
                    // Poluir
                    log(`  Poluindo ${proto.constructor.name}.prototype.${key}...`, 'info');
                    if (setter) {
                        Object.defineProperty(proto, key, { set: spySetter, configurable: true });
                        proto[spyIdentifier] = true; // Marcar que poluímos o setter
                    } else {
                         proto[key] = spyFunction;
                    }

                    // Verificar (simples)
                    let pollutionOK = setter ? (Object.getOwnPropertyDescriptor(proto, key)?.set === spySetter) : (proto[key] === spyFunction);
                    if (pollutionOK) {
                         log(`  Poluição parece OK. Executando ação de gatilho...`, 'info');
                         // Executar Ação
                         try {
                            hijackDetected = false; // Resetar
                            action(); // Chamar ação
                            // Pequena pausa para eventos assíncronos se necessário
                            await new Promise(r => setTimeout(r, SHORT_PAUSE/2));
                            log(`  Ação executada. Verificando se hijack ocorreu...`, 'info');
                            if(hijackDetected) {
                                log(`  CONFIRMADO: Hijack bem-sucedido para '${key}'.`, 'vuln');
                                overallSuccess = true;
                            } else {
                                log(`  AVISO: Ação executada, mas hijack NÃO detectado para '${key}'.`, 'warn');
                            }
                         } catch (e) {
                              log(`  ERRO ao executar ação para '${key}': ${e.message}`, 'leak');
                              if(hijackDetected) { log(`  CONFIRMADO: Hijack ocorreu para '${key}' (antes do erro).`, 'vuln'); overallSuccess = true; }
                         }
                    } else {
                        log("  Falha ao poluir/verificar poluição.", 'error');
                    }
                } catch (e) {
                    log(`  Erro GERAL no teste de hijack para '${key}': ${e.message}`, 'error');
                } finally {
                    // Restaurar
                    if (proto && key && originalValue) {
                         const currentValue = setter ? Object.getOwnPropertyDescriptor(proto, key) : proto[key];
                         // Restaurar apenas se ainda estiver diferente do original
                         if ((setter && (currentValue?.set !== originalValue?.set || proto[spyIdentifier])) || (!setter && currentValue !== originalValue))
                         {
                            log(`  Restaurando ${proto.constructor.name}.prototype.${key} original...`, 'info');
                            if (setter) {
                                 Object.defineProperty(proto, key, originalValue); // Restaurar descritor original
                                 delete proto[spyIdentifier];
                            } else {
                                proto[key] = originalValue;
                            }
                            // Verificar restauração
                             const restoredValue = setter ? Object.getOwnPropertyDescriptor(proto, key) : proto[key];
                             const checkRestored = setter ? (restoredValue?.set === originalValue?.set && !proto[spyIdentifier]) : (restoredValue === originalValue);
                             if (checkRestored) { log("  Restauração OK.", 'good'); }
                             else { log(`  FALHA AO RESTAURAR '${key}'!`, 'error'); }
                         }
                    }
                }
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));
            } // Fim loop targets

             if (overallSuccess) {
                 log("SUCESSO GERAL: Pelo menos uma função nativa foi sequestrada via PP!", 'vuln');
             } else {
                  log("FALHA GERAL: Nenhuma função testada pôde ser sequestrada com sucesso OU o hijack não foi detectado.", 'warn');
             }

            log("--- T2 Concluído ---", 'test');
        };

        // --- Teste 3: OOB Write Confirm (Mantido - Base) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v8 ... */ log("--- T3: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T3: ${e.message}`,'error');} log("--- T3 Concluído ---",'test'); };


        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (PP FUNCTION HIJACKING v9)...");
            const tests = [ // Sequência atualizada
                runCSP_XSS_Check,           // T1: Check XSS/Entrada
                runPPHijackTest_v9,         // T2: Teste Hijack Funções PP (NOVO)
                runOOBTestU8_Confirm,       // T3: OOB Confirm Base
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v8 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes PP FUNCTION HIJACKING v9 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS_Check()">Rodar T1 (Check XSS)</button>
            <button onclick="runPPHijackTest_v9()">Rodar T2 (PP Hijack Test)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T3 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
        `;

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
