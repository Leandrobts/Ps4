<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (Verbose Logging - Rebuilt)</title>
    <style>
        /* Estilos CSS Idênticos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; transition: background-color 0.5s ease; /* Adiciona transição */}
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; }
        .extended-test { color: #03A9F4; }
        .verbose-log { color: #BDBDBD; font-size: 0.9em; }
        /* Estilo para o overlay de impacto DOM */
        #csp-impact-overlay {
            position: fixed; top: 10%; left: 10%; width: 80%; height: 80%;
            background: rgba(255, 0, 0, 0.85); color: white;
            border: 5px solid white; font-size: 2em; text-align: center;
            display: flex; justify-content: center; align-items: center;
            z-index: 10000; flex-direction: column;
            opacity: 0; transition: opacity 0.5s ease-in-out; /* Animação */
        }
    </style>
</head>
<body>
    <h1>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (Verbose Logging - Rebuilt)</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_tests">Run All Tests (Incl. Ext. Detection - Verbose)</option>
            <option value="oob_write_aggressive">Aggressive OOB Write (Info Leak Demo)</option>
            <option value="oob_impact_tests">OOB Impact (Metadata/Crash)</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass (Direct Impact)</option>
            <option value="uaf_basic_verbose">Basic Use-After-Free Tests (Verbose Log)</option>
            <option value="type_confusion_basic_verbose">Basic Type Confusion Tests (Verbose Log)</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>
    <div id="csp-impact-overlay" style="opacity: 0;"></div>

<script>
// ======================
// CONFIGURAÇÃO IMPORTANTE!
// ======================
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!

// ======================
// Coleta de Informações e Logging (Idêntico)
// ======================
document.addEventListener('DOMContentLoaded', function() { /*...*/ });
function log(message, type = '') { /*...*/ }
function clearLog() { /*...*/ }
var potentialVulnsFound = { oobWrite: false };
async function sendVulnerabilityNotification(payload) { /*...*/ }
function demonstrateCookieRead() { /*...*/ }
function demonstrateDomManipulation() { /*...*/ } // Versão com Overlay
function demonstrateNetworkRequest() { /*...*/ }

// ======================
// Aggressive POC Tests (Base da Resposta #30 + Funções UAF/TC Verbose da Resposta #32)
// ======================
const aggressiveTests = {

    // Testes OOB e CSP da Resposta #30 (já incluíam Info Leak e Direct Impact/Notify)
    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write (Info Leak Demo)...", "info section");
        potentialVulnsFound.oobWrite = false; this.infoLeakNotified = false;
        try {
            const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
            const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10];
            const readOffsets = [-5, 0, 5, bufferSize - 1, bufferSize, bufferSize + 5, bufferSize + 8, bufferSize + 16];

            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info");
                let oobWriteSuccess = false;
                try { view[writeOffset] = writeValue; log(`⚠️ OOB write at offset ${writeOffset} successful (no error).`, "warning"); potentialVulnsFound.oobWrite = true; oobWriteSuccess = true;
                } catch (writeError) { log(`✅ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success"); }

                if(oobWriteSuccess || (writeOffset >= 0 && writeOffset < bufferSize)) {
                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const readValue = view[readOffset]; const readValueHex = (readValue !== undefined ? `0x${readValue.toString(16)}` : 'undefined');
                            log(`[OOB-AGG] Read ${readValueHex} at offset ${readOffset} after write at ${writeOffset}.`, "info");

                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                                const detailMsg = `Wrote at ${writeOffset}, read ${readValueHex} at IN-BOUNDS offset ${readOffset}.`;
                                log(`<span class="poc-potential defense-bypass privilege-escalation">🚩 Potential OOB Write Corruption: ${detailMsg}</span>`, "danger");
                                sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg });
                            }
                            if (readOffset >= bufferSize && readValue !== undefined) {
                                let leakedBytes = []; const bytesToRead = 8;
                                for (let i = 0; i < bytesToRead; i++) { try { const leakOffset = readOffset + i; leakedBytes.push(view[leakOffset]?.toString(16).padStart(2, '0') ?? '??'); } catch (leakReadError) { leakedBytes.push('ERR'); break; } }
                                const leakHex = leakedBytes.join(' '); const detailMsg = `Read ${readValueHex} at OOB offset ${readOffset}. Following ${bytesToRead} bytes: ${leakHex}`;
                                log(`<span class="poc-potential impact">💧 Potential Info Leak: ${detailMsg}</span>`, "warning impact");
                                if(!this.infoLeakNotified) { sendVulnerabilityNotification({ vulnerability: 'OOB_INFO_LEAK_ADJACENT', details: detailMsg }); this.infoLeakNotified = true; }
                            }
                        } catch (readError) { log(`⚠️ Error reading at offset ${readOffset}: ${readError.message}`, "warning"); }
                    }
                } await new Promise(resolve => setTimeout(resolve, 100));
            } log("[OOB-AGG] Completed OOB write / info leak testing.", "info");
        } catch (e) { log(`❌ Test error (OOB Write/Leak): ${e.message}`, "danger"); console.error(e); }
         this.infoLeakNotified = false;
    },
    "test_oob_metadata": async function() { /* ... código idêntico anterior ... */ },
    "test_oob_crash_probe": async function() { /* ... código idêntico anterior ... */ },
    "csp_bypass_aggressive": async function() { /* ... código idêntico anterior ... */ },

    // Testes UAF/TC Verbosos da Resposta #32 Adicionados Aqui
    "uaf_basic_verbose": async function() {
        log("[UAF-VERBOSE] Attempting basic Use-After-Free scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state before potential issues.", "info");
        let parent, child, childRef, tagName, rect;
        try {
            log("[UAF-VERBOSE] Scenario 1: DOM Node Ref After Removal", "extended-test"); log("[UAF-VERBOSE] Creating parent div...", "verbose-log"); parent = document.createElement('div'); log("[UAF-VERBOSE] Creating child span...", "verbose-log"); child = document.createElement('span'); log("[UAF-VERBOSE] Appending child to parent...", "verbose-log"); parent.appendChild(child); log("[UAF-VERBOSE] Appending parent to body...", "verbose-log"); document.body.appendChild(parent); log("[UAF-VERBOSE] Storing reference to child.", "verbose-log"); childRef = child; log("[UAF-VERBOSE] Removing child from parent...", "verbose-log"); parent.removeChild(child); log("[UAF-VERBOSE] Removing parent from body...", "verbose-log"); document.body.removeChild(parent); log("[UAF-VERBOSE] Parent and child removed from DOM.", "verbose-log"); log("[UAF-VERBOSE] Hinting GC by allocating memory...", "verbose-log"); try { new ArrayBuffer(10 * 1024 * 1024); log("[UAF-VERBOSE] Memory allocated.", "verbose-log"); } catch(e) {log("[UAF-VERBOSE] Memory allocation failed (expected?).", "verbose-log warning");} log("[UAF-VERBOSE] Waiting 500ms...", "verbose-log"); await new Promise(resolve => setTimeout(resolve, 500)); log(`[UAF-VERBOSE] --> Accessing childRef.tagName after potential free...`, "info extended-test"); tagName = childRef.tagName; log(`[UAF-VERBOSE] <-- childRef.tagName accessed. Value = ${tagName}. Type = ${typeof tagName}`, "verbose-log success"); log(`[UAF-VERBOSE] --> Calling childRef.getBoundingClientRect() after potential free...`, "info extended-test"); rect = childRef.getBoundingClientRect(); log(`[UAF-VERBOSE] <-- getBoundingClientRect called. Return type = ${typeof rect}. Properties sample: width=${rect?.width}`, "verbose-log success"); log("[UAF-VERBOSE] Releasing childRef.", "verbose-log"); childRef = null;
        } catch (e) { log(`❌ Error in UAF Scenario 1: ${e.message}. Check preceding logs. Potential UAF?`, "danger extended-test"); console.error("UAF Scenario 1 Error Details:", e); sendVulnerabilityNotification({ vulnerability: 'UAF_BASIC_SCENARIO1_ERROR', details: e.message }); }
        finally { log("[UAF-VERBOSE] Scenario 1 finished.", "verbose-log info"); }
        log("[UAF-VERBOSE] Scenario 2: ArrayBuffer/TypedArray (Placeholder - complex)", "extended-test info"); log("INFO: Reliable UAF tests for buffers usually require specific engine bugs/APIs.", "info"); log("[UAF-VERBOSE] Completed basic UAF tests.", "extended-test info");
    },
    "type_confusion_basic_verbose": async function() {
        log("[TYPE-CONFUSION-VERBOSE] Attempting basic Type Confusion scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state.", "info");
        try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 1: Incorrect type to DOM API", "extended-test"); log(`[TYPE-CONFUSION-VERBOSE] --> Sending 'window' via postMessage...`, "info extended-test"); try { window.postMessage(window, "*"); log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) did not throw.`, "verbose-log success"); } catch(e_pm1) { log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) threw: ${e_pm1.message}`, "verbose-log success"); } let fakeEvent = { target: document.body, type: "click", bubbles: false }; log(`[TYPE-CONFUSION-VERBOSE] Created fake event object: ${JSON.stringify(fakeEvent)}`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] --> Dispatching fake event object...`, "info extended-test"); try { document.dispatchEvent(fakeEvent); log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) did not throw.`, "verbose-log success"); } catch(e_de1) { log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) threw: ${e_de1.message}`, "verbose-log success"); } log("[TYPE-CONFUSION-VERBOSE] Scenario 1 Part 1 finished.", "verbose-log info");
        } catch (e) { log(`❌ Error in Type Confusion Scenario 1: ${e.message}. Investigate.`, "danger extended-test"); console.error("Type Confusion Scenario 1 Error:", e); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO1_ERROR', details: e.message }); }
        finally { log("[TYPE-CONFUSION-VERBOSE] Scenario 1 finished.", "verbose-log info"); }
         try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 2: Primitive vs Object", "extended-test"); let nP = 5; let nO = new Number(5); log(`[TYPE-CONFUSION-VERBOSE] numPrimitive = ${nP} (type: ${typeof nP})`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] numObject = ${nO} (type: ${typeof nO})`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] --> Calling nP.toFixed(nO)...`, "info extended-test"); try { let r = nP.toFixed(nO); log(`[TYPE-CONFUSION-VERBOSE] <-- nP.toFixed(nO) returned: ${r}. Type: ${typeof r}`, "verbose-log success"); } catch(e_tf1) { log(`[TYPE-CONFUSION-VERBOSE] <-- nP.toFixed(nO) threw: ${e_tf1.message}`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numObject) error: ${e_tf1.message}` }); } log(`[TYPE-CONFUSION-VERBOSE] --> Calling nO.toFixed(nP)...`, "info extended-test"); try { let r2 = nO.toFixed(nP); log(`[TYPE-CONFUSION-VERBOSE] <-- nO.toFixed(nP) returned: ${r2}. Type: ${typeof r2}`, "verbose-log success"); } catch(e_tf2) { log(`[TYPE-CONFUSION-VERBOSE] <-- nO.toFixed(nP) threw: ${e_tf2.message}`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numPrimitive) error: ${e_tf2.message}` }); }
        } catch(e) { log(`❌ Error in Type Confusion Scenario 2: ${e.message}. Investigate.`, "danger extended-test"); console.error("Type Confusion Scenario 2 Error:", e); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: e.message }); }
        finally { log("[TYPE-CONFUSION-VERBOSE] Scenario 2 finished.", "verbose-log info"); }
        log("[TYPE-CONFUSION-VERBOSE] Completed basic Type Confusion tests.", "extended-test info");
    },

    // --- Executor Principal Atualizado para incluir tudo ---
    "all_tests": async function() {
        log("=== Running All Tests (Incl. Extended Detection - Verbose Log) ===", "section");
        await aggressiveTests["oob_write_aggressive"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));
        if (potentialVulnsFound.oobWrite) { await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000)); await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000)); }
        else { log("Skipping OOB impact tests.", "warning"); }
        await aggressiveTests["csp_bypass_aggressive"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        await aggressiveTests["uaf_basic_verbose"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000)); // Chama a versão verbosa
        await aggressiveTests["type_confusion_basic_verbose"](); // Chama a versão verbosa
        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },
    // Mantém executor só para OOB Impact
    "oob_impact_tests": async function() { /* ... código idêntico anterior ... */ }
    // Adiciona alias para conveniência (apontam para as versões verbosas)
    ,"uaf_basic": async function() { await this.uaf_basic_verbose(); }
    ,"type_confusion_basic": async function() { await this.type_confusion_basic_verbose(); }
};
// Garante que as funções verbose estão no objeto para seleção individual
aggressiveTests["uaf_basic_verbose"] = aggressiveTests.uaf_basic_verbose;
aggressiveTests["type_confusion_basic_verbose"] = aggressiveTests.type_confusion_basic_verbose;


// ======================
// Test Runner (Atualizado para novas opções)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;
    // Usa o nome da função selecionada diretamente (já inclui _verbose se for o caso)
    const testFunctionToRun = selectedTest;

    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first for best results.", "warning"); }
    clearLog(); log(`=== Starting Test: ${testFunctionToRun} ===`, "section");

    if (aggressiveTests[testFunctionToRun]) {
        await aggressiveTests[testFunctionToRun](); // Chama a função de teste correta
        log(`\n=== Test Execution for "${testFunctionToRun}" Completed. Review logs & endpoint. ===`, "section");
    } else {
        log(`Error: Test "${testFunctionToRun}" not found.`, "danger");
    }
}
</script>
</body>
</html>
