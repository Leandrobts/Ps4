<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - PP Function Hijacking v9</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - PP Function Hijacking v9</h1>
    <p>Foco: Testar Hijacking de Funções Nativas via Prototype Pollution.</p>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 200;
        const SHORT_PAUSE = 50;

        // --- Teste 1 (Entry Point Check) ---
        const runCSP_XSS_Check = () => { log("--- T1: Verificação de Entrada XSS ---",'test');log("Execução JS via XSS/CSP OK.",'good');log("--- T1 Concluído ---",'test'); };

        // --- NOVO Teste 2: Teste de Hijacking de Funções via PP v9 ---
        const runPPHijackTest_v9 = async () => {
            log("--- T2: Teste de Hijacking de Funções via PP v9 ---", 'test');
            log("Objetivo: Poluir protótipos de funções comuns e verificar se a chamada é interceptada.", 'warn');

            // ===========================================================================
            // <<< EDITE/ADICIONE alvos [Protótipo, Nome da Função, Ação p/ Chamar] >>>
            //      Baseado na sua pesquisa externa por gadgets PP!
            const targets = [
                // Array
                { proto: Array.prototype,    key: 'map',      action: () => [1, 2].map(x => x), info: "Array Map" },
                { proto: Array.prototype,    key: 'push',     action: () => [].push(1), info: "Array Push" },
                { proto: Array.prototype,    key: 'join',     action: () => [1, 2].join(','), info: "Array Join" },
                { proto: Array.prototype,    key: 'forEach',  action: () => [1].forEach(()=>{}), info: "Array ForEach" },
                { proto: Array.prototype,    key: 'filter',   action: () => [1].filter(x=>true), info: "Array Filter" },
                // String
                { proto: String.prototype,   key: 'includes', action: () => "test".includes("a"), info: "String Includes" },
                { proto: String.prototype,   key: 'slice',    action: () => "test".slice(0), info: "String Slice" },
                { proto: String.prototype,   key: 'match',    action: () => "test".match(/t/), info: "String Match" },
                { proto: String.prototype,   key: 'replace',  action: () => "test".replace('t','r'), info: "String Replace" },
                // Function
                { proto: Function.prototype, key: 'call',     action: () => function(){}.call(null), info: "Function Call" },
                { proto: Function.prototype, key: 'apply',    action: () => function(){}.apply(null), info: "Function Apply" },
                { proto: Function.prototype, key: 'bind',     action: () => function(){}.bind(null), info: "Function Bind" },
                // Object
                { proto: Object.prototype,   key: 'toString', action: () => ({}).toString(), info: "Object ToString" },
                { proto: Object.prototype,   key: 'hasOwnProperty', action: () => ({}).hasOwnProperty('test'), info: "Object HasOwnProperty" },
                { proto: Object.prototype,   key: 'valueOf', action: () => ({}).valueOf(), info: "Object ValueOf" },
                 // DOM (Exemplos - podem precisar de mais contexto ou não ser poluíveis)
                //{ proto: Element.prototype,  key: 'innerHTML', setter: true, action: () => {let d=document.createElement('div'); d.innerHTML='test';}, info: "Element InnerHTML Setter"},
                //{ proto: Node.prototype,     key: 'appendChild', action: () => {let d=document.createElement('div'); try{d.appendChild(document.createElement('span'));}catch(e){}}, info: "Node AppendChild"},
                //{ proto: EventTarget.prototype, key: 'addEventListener', action: () => {try{document.addEventListener('click',()=>{})}catch(e){}}, info: "EventTarget AddEvListener"},
            ];
             // ===========================================================================

            let overallSuccess = false;

            for (const target of targets) {
                if (!outputDiv) { log("Output Div NULO, parando testes.", "error"); break; } // Checar div a cada iteração

                const { proto, key, action, info, setter = false } = target;
                // Validar se proto existe antes de acessar
                 if (!proto || !key || typeof key !== 'string' || !action) {
                     log(`INFO: Definição de alvo inválida para '${info || key}'. Pulando.`, 'warn');
                     continue;
                 }
                 const protoName = proto.constructor?.name || 'Object'; // Nome mais robusto

                // Validar se a chave existe E é uma função (ou tem setter)
                const descriptor = Object.getOwnPropertyDescriptor(proto, key);
                const originalValue = setter ? descriptor : proto[key]; // Salvar original

                if (setter && (!descriptor || !descriptor.set)) {
                    log(`INFO: Propriedade '${key}' não tem um setter no protótipo ${protoName}. Pulando.`, 'info');
                    continue;
                 }
                 if (!setter && typeof originalValue !== 'function') {
                    log(`INFO: Propriedade '${key}' não é uma função no protótipo ${protoName}. Pulando.`, 'info');
                    continue;
                 }

                log(`Testando Hijack de: ${info || key}`, 'subtest');
                let hijackDetected = false;
                const spyIdentifier = `__SPY_FOR_${key}__`; // Identificador único

                 // Função/Setter espião
                 const createSpyFunction = (keyName) => {
                     return function(...args) {
                        if (!outputDiv) return; // Checar log div dentro da spy
                        hijackDetected = true;
                        log(`>> HIJACK DETECTADO! Chamada para ${keyName} interceptada! <<`, "vuln");
                        return `HIJACKED_${keyName}`;
                    };
                 };
                 const createSpySetter = (keyName) => {
                      return function(value) {
                         if (!outputDiv) return;
                         hijackDetected = true;
                         log(`>> HIJACK DETECTADO! Setter para ${keyName} interceptado! (Valor=${String(value).substring(0,30)}) <<`, "vuln");
                     };
                 };

                const spyHandler = setter ? createSpySetter(key) : createSpyFunction(key);

                try {
                    // Poluir
                    log(`  Poluindo ${protoName}.prototype.${key}...`, 'info');
                    if (setter) {
                        Object.defineProperty(proto, key, { set: spyHandler, configurable: true });
                        proto[spyIdentifier] = true;
                    } else {
                         proto[key] = spyHandler;
                    }

                    // Verificar
                    let pollutionOK = setter ? (Object.getOwnPropertyDescriptor(proto, key)?.set === spyHandler) : (proto[key] === spyHandler);
                    if (pollutionOK) {
                         log("  Poluição parece OK. Executando ação de gatilho...", 'info');
                         try {
                            hijackDetected = false;
                            action(); // Chamar ação
                            await new Promise(r => setTimeout(r, SHORT_PAUSE/2)); // Pausa curta
                            log(`  Ação executada. Verificando se hijack ocorreu...`, 'info');
                            if(hijackDetected) {
                                log(`  CONFIRMADO: Hijack bem-sucedido para '${key}'.`, 'vuln');
                                overallSuccess = true;
                            } else {
                                log(`  AVISO: Ação executada, mas hijack NÃO detectado para '${key}'.`, 'warn');
                            }
                         } catch (e) {
                              log(`  ERRO ao executar ação para '${key}' (efeito PP?): ${e.message}`, 'leak');
                              if(hijackDetected) { log(`  CONFIRMADO: Hijack ocorreu para '${key}' (antes do erro).`, 'vuln'); overallSuccess = true; }
                         }
                    } else {
                        log("  Falha ao poluir/verificar poluição.", 'error');
                    }
                } catch (e) {
                    log(`  Erro GERAL no teste de hijack para '${key}': ${e.message}`, 'error');
                } finally {
                    // Restaurar SEMPRE
                    if (proto && key && originalValue) {
                         const currentValue = setter ? Object.getOwnPropertyDescriptor(proto, key) : proto[key];
                         if ((setter && (currentValue?.set !== originalValue?.set || proto[spyIdentifier])) || (!setter && currentValue !== originalValue))
                         {
                            log(`  Restaurando ${protoName}.prototype.${key} original...`, 'info');
                            try {
                                if (setter) {
                                    Object.defineProperty(proto, key, originalValue);
                                    delete proto[spyIdentifier];
                                } else {
                                    proto[key] = originalValue;
                                }
                                 // Verificar restauração
                                const restoredValue = setter ? Object.getOwnPropertyDescriptor(proto, key) : proto[key];
                                const checkRestored = setter ? (restoredValue?.set === originalValue?.set && !proto[spyIdentifier]) : (restoredValue === originalValue);
                                if (checkRestored) { log("  Restauração OK.", 'good'); }
                                else { log(`  FALHA AO RESTAURAR '${key}'!`, 'error'); }
                            } catch (restoreError) {
                                 log(`  ERRO AO RESTAURAR '${key}': ${restoreError.message}`, 'error');
                            }
                         }
                    }
                }
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));
            } // Fim loop targets

             if (overallSuccess) {
                 log("SUCESSO GERAL: Pelo menos uma função nativa foi sequestrada via PP!", 'vuln');
             } else {
                  log("FALHA GERAL: Nenhuma função testada pôde ser sequestrada com sucesso OU o hijack não foi detectado.", 'warn');
             }

            log("--- T2 Concluído ---", 'test');
        };

        // --- Teste 3: OOB Write Confirm (Mantido - Base) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v8 ... */ log("--- T3: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T3: ${e.message}`,'error');} log("--- T3 Concluído ---",'test'); };


        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (PP FUNCTION HIJACKING v9)...");
            const tests = [ // Sequência atualizada
                runCSP_XSS_Check,           // T1: Check XSS/Entrada
                runPPHijackTest_v9,         // T2: Teste Hijack Funções PP (NOVO - Editável)
                runOOBTestU8_Confirm,       // T3: OOB Confirm Base
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v8 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes PP FUNCTION HIJACKING v9 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS_Check()">Rodar T1 (Check XSS)</button>
            <button onclick="runPPHijackTest_v9()">Rodar T2 (PP Hijack Test)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T3 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
        `;

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
