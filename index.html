<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PP Hijack JSON + Canvas EXPLORAÇÃO MÁXIMA (v15 - Full Logs)</title>
    <style>
        /* Estilos CSS (Sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 60vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #output-canvas { background: #2a2a2a; border: 1px solid #444; padding: 10px; height: 60vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(PP Hijack JSON)</h1>
    <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, PP Hijack.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS (Script 1)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <hr>

    <section>
        <h2>Teste Canvas/Worker/WS FINAL (v15 - Full Logs)</h2>
        <p>Todos os testes com logs detalhados restaurados.</p>
        <canvas id="interactive-canvas" width="350" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Final v15 (Full Logs)</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 Original Inteiro ---
        // ... (Código completo e intocado do Script 1 aqui) ...
        const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; const log = (message, type = 'info') => { if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 500000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro na função log:", e); outputDiv = null; } }; const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test'); log("Tentando XSS via data: URI (alert)...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); }; document.body.appendChild(scriptTag); log("Tag <script> data: URI adicionada.", 'info'); } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2)); log("Tentando XSS DOM via inline handler (onerror)...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const imgTag = document.createElement('img'); imgTag.src = 'invalid_image_source_' + Date.now(); const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>'; log("XSS DOM via onerror realizado!", "vuln"); } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); } alert('XSS_DOM_ONERROR'); } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); log("Tag <img> com onerror adicionada.", 'info'); } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); } log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test'); }; const testOOBReadInfoLeakEnhancedStore = async () => { log("--- Iniciando Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---", 'test'); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = 32; const oobReadOffsets = []; for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; try { const buffer = new ArrayBuffer(bufferSize + 256); const dataView = new DataView(buffer); const baseOffset = 128; for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffset + oobWriteOffset; log(`Tentando escrita OOB U8 @${oobWriteOffset}...`, 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln'); writeSuccess = true; } catch (e) { log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good'); log("--- Teste 2 Interrompido (Escrita OOB falhou) ---", 'test'); return false; } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'subtest'); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffset + readOffset; if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue; try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`; log(`  -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr'); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(`  -> VALOR U64 ARMAZENADO (offset ${readOffset}).`, 'vuln'); } } } catch (e) {/* Ignora */} if (leakedValueFromOOB === null && readTargetAddress + 4 <= buffer.byteLength ) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(`  -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak'); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(`  -> VALOR U32 ARMAZENADO (offset ${readOffset}).`, 'vuln'); } } catch (e) {/* Ignora */} } if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1)); } } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); } log(`--- Teste 2 Concluído (${potentialLeakFoundCount} potenciais leaks, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} armazenado do offset ${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'}) ---`, 'test'); return writeSuccess; }; const testBasicPP = async () => { log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test'); const testProp = '__pp_basic_test__'; const testValue = 'Polluted!'; let success = false; try { log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest'); Object.prototype[testProp] = testValue; log("Verificando herança em objeto vazio {}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const obj = {}; if (obj[testProp] === testValue) { log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln'); success = true; } else { log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good'); } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); } finally { try { delete Object.prototype[testProp]; } catch(e){} log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info'); } log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test'); return success; }; const testPPJsonHijack = async () => { log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test'); const originalStringify = JSON.stringify; let hijackSuccessful = false; let interactionSuccessful = false; let hijackReturnedCorrectly = false; try { log("Tentando sobrescrever JSON.stringify...", 'subtest'); JSON.stringify = function hijackedStringify(value, replacer, space) { log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln'); hijackSuccessful = true; log(`  -> Hijack: Tentando aceder ao valor vazado do Teste 2...`, 'info'); try { const leak = leakedValueFromOOB; let leakStr = "NULO"; if (leak) { leakStr = leak.type === 'U64' ? `U64 H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 ${toHex(leak.low)}`; interactionSuccessful = true; } log(`  -> Hijack: Valor armazenado de OOB Read (Teste 2) é: ${leakStr}`, 'leak'); } catch(interactionError) { log(`  -> Hijack: Erro ao aceder/logar valor vazado: ${interactionError.message}`, 'error'); } return '{"hijacked": true, "original_value": "???", "leak_accessed": ' + interactionSuccessful + '}'; }; log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const testObject = { a: 1, b: 'teste' }; log(`Objeto original: ${originalStringify(testObject)}`, 'info'); const result = JSON.stringify(testObject); log(`Resultado retornado por JSON.stringify(): ${result}`, 'info'); if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln'); hijackReturnedCorrectly = true; } else if (hijackSuccessful) { log("AVISO: Função JSON.stringify foi sequestrada, mas o retorno não foi o esperado.", 'warn'); } else { log("FALHA: Sequestro de JSON.stringify não funcionou.", 'good'); } } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); } finally { JSON.stringify = originalStringify; log("Função JSON.stringify restaurada.", 'info'); if (JSON.stringify === originalStringify) { log("Restauração de stringify confirmada.", 'info'); } else { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error'); } } log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou'}) ---`, 'test'); return hijackReturnedCorrectly; }; const runAllTests = async () => { if (runBtn) runBtn.disabled = true; log("==== INICIANDO PoC Final v9 (PP Hijack JSON) ====", 'test'); await testCSPBypass(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testOOBReadInfoLeakEnhancedStore(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testBasicPP(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testPPJsonHijack(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); log("\n==== PoC Final v9 CONCLUÍDA ====", 'test'); if (runBtn) runBtn.disabled = false; };
    </script>

    <script>
        // --- Script 2: Variáveis e constantes ---
        const SHORT_PAUSE_CANVAS_V15 = 50;
        let canvasClickListenerCanvas_v15 = null;
        let canvasMoveListenerCanvas_v15 = null;
        let currentHoverTarget_v15 = null;
        let hijackActive_v15 = false;
        let currentWorker_v15 = null;
        let leakHistory_v15 = [];

        const interactiveAreas_v15 = [
             { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' },
             { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' },
             { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Histórico Leak S1' }
         ];
        let currentLeakData_v15 = { text: "Leak(S1): N/A", color: "#AAAAAA" };

        // --- Função de Log (Script 2) ---
        const logCanvas_v15 = (outputDivElement, message, type = 'info') => { /* ... (igual v13) ... */ const logMsg=`[CANVAS-${type.toUpperCase()}] ${message}`; console.log(logMsg); if(!outputDivElement){console.error("logCanvas_v15 ERRO: Output DIV nulo!"); return;} try{const timestamp=`[${new Date().toLocaleTimeString()}]`; const sanitizedMessage=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;"); if(outputDivElement.innerHTML.length>1000000){outputDivElement.innerHTML=outputDivElement.innerHTML.substring(outputDivElement.innerHTML.length-500000); outputDivElement.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDivElement.innerHTML;} const logClass=['info','test','subtest','vuln','good','warn','error','leak','ptr','critical'].includes(type)?type:'info'; outputDivElement.innerHTML+=`<span class="log-${logClass}">${timestamp} ${sanitizedMessage}\n</span>`; outputDivElement.scrollTop=outputDivElement.scrollHeight;}catch(e){console.error("logCanvas_v15 ERRO ao escrever no DIV:", e);} };

        // --- Helper toHex (Comentado) ---

        // --- Desenho das Áreas Interativas ---
        const drawInteractiveAreas_v15 = (ctx, canvasEl, outputDivEl) => { /* ... (igual v13) ... */ const localLog=(msg,type)=>logCanvas_v15(outputDivEl,msg,type); if(!ctx||!canvasEl)return; try{interactiveAreas_v15.forEach(area=>{ctx.fillStyle=(currentHoverTarget_v15===area.id)?area.hoverColor:area.color; ctx.fillRect(area.x,area.y,area.w,area.h); ctx.fillStyle="#FFFFFF"; ctx.font="bold 12px monospace"; ctx.textAlign="center"; ctx.fillText(area.text,area.x+area.w/2,area.y+area.h/2+4);}); ctx.textAlign="start";}catch(e){localLog(`Erro draw areas: ${e.message}`,'error');}};

        // --- Função de cálculo intensivo (Primos) ---
        const calculatePrimes_v15 = (limit) => { /* ... (igual v13) ... */ const primes=[]; for(let num=2; num<=limit; num++){let isPrime=true; for(let i=2; i<=Math.sqrt(num); i++){if(num%i===0){isPrime=false; break;}} if(isPrime){primes.push(num);}} return primes;};


        // --- Função Principal do Teste (v15 FULL LOGS) ---
        const testComprehensiveCanvasFinalV15 = async (canvasEl, outputDivEl, coordStatusDivEl, runBtnEl) => {
            let ctx_v15 = null;
            const localLog = (msg, type = 'info') => logCanvas_v15(outputDivEl, msg, type);
            const PAUSE = (ms = SHORT_PAUSE_CANVAS_V15) => new Promise(r => setTimeout(r, ms));

            // Limpeza inicial
            if (currentWorker_v15) { try { currentWorker_v15.terminate(); localLog("Worker anterior v15 terminado.", 'info'); } catch(e){} currentWorker_v15 = null; }
            hijackActive_v15 = false; currentHoverTarget_v15 = null;
            // Não limpa histórico
            currentLeakData_v15 = { text: "Leak(S1): N/A", color: "#AAAAAA" };

            localLog("--- Iniciando Teste FINAL Canvas v15 (Full Logs) ---", 'test');
            try {
                // 1. Setup Básico
                /* ... (igual v13) ... */
                 if(!canvasEl)throw new Error('Canvas El null'); ctx_v15=canvasEl.getContext('2d'); if(!ctx_v15)throw new Error('No 2D Ctx'); localLog("Ctx 2D OK.",'good'); const redrawAll_v15 = () => { if(!ctx_v15||!canvasEl)return; try{ctx_v15.clearRect(0,0,canvasEl.width,canvasEl.height); ctx_v15.fillStyle="#334"; ctx_v15.fillRect(0,0,canvasEl.width,canvasEl.height); drawInteractiveAreas_v15(ctx_v15,canvasEl,outputDivEl); if(currentLeakData_v15){ctx_v15.fillStyle=currentLeakData_v15.color;ctx_v15.font="12px monospace";ctx_v15.textAlign="start";ctx_v15.fillText(currentLeakData_v15.text,10,canvasEl.height-10);}}catch(e){localLog(`Err redraw:${e.message}`,'error');}}; redrawAll_v15(); localLog("Setup OK.",'good'); await PAUSE();

                // 2. Ler Leak S1 e Adicionar ao Histórico
                localLog("Verificando leak S1 e adicionando ao histórico...", 'subtest');
                localLog("(Rode Script 1, Script 2. Rode S1 de novo e clique 'Histórico Leak S1' para comparar)", "info");
                let currentLeakValue = null;
                try { /* ... (igual v13) ... */ if(typeof leakedValueFromOOB !=='undefined'){currentLeakValue=leakedValueFromOOB; if(currentLeakValue){const lS=currentLeakValue.type==='U64'?`L(S1):U64 H=${toHex(currentLeakValue.high)} L=${toHex(currentLeakValue.low)} @${currentLeakValue.offset}`:`L(S1):U32 ${toHex(currentLeakValue.low)} @${currentLeakValue.offset}`; localLog(`-> Valor atual: ${lS}`,'leak'); currentLeakData_v15={text:lS,color:"#FF9800"};}else{localLog(`-> Valor atual NULO.`,'warn');currentLeakData_v15={text:"L(S1):NULO",color:"#FFC107"};}}else{localLog(`-> Var global N/A.`,'error');currentLeakData_v15={text:"L(S1):Var N/A",color:"#F44336"};}}catch(e){localLog(`Erro acessar leak:${e.message}`,'error');currentLeakData_v15={text:"L(S1):ERRO",color:"#F44336"};currentLeakValue={error:e.message};}
                leakHistory_v15.push({ timestamp: new Date().toISOString(), value: currentLeakValue }); if (leakHistory_v15.length > 10) { leakHistory_v15.shift(); }
                localLog(`Leak adicionado ao histórico (tam: ${leakHistory_v15.length})`, 'info');
                redrawAll_v15(); localLog("Leak S1 processado.", 'info'); await PAUSE();

                // --- Bloco de Testes Adicionais com LOGS COMPLETOS ---

                // 3. Testes de Robustez (Logs Restaurados)
                localLog("Iniciando Testes de Robustez...", 'test');
                // 3.1 Valores Extremos
                localLog("Testando valores extremos (grandes/negativos)...", 'subtest');
                try {
                    ctx_v15.fillStyle = "rgba(255,0,0,0.5)";
                    localLog(" -> fillRect(1e9, 10, 10, 10)", 'info');
                    ctx_v15.fillRect(1e9, 10, 10, 10);
                    localLog(" -> fillRect(10, -1e9, 10, 10)", 'info');
                    ctx_v15.fillRect(10, -1e9, 10, 10);
                    localLog(" -> fillRect(5, 5, 1e8, 1e8)", 'info');
                    ctx_v15.fillRect(5, 5, 1e8, 1e8);
                    localLog("fillRect com valores extremos não crashou.", 'good');
                } catch(e) { localLog(`Erro em fillRect com valores extremos: ${e.message}`, 'error'); }
                await PAUSE(10);
                // 3.2 Valores Inválidos
                localLog("Testando valores inválidos (NaN, Infinity)...", 'subtest');
                try {
                    const originalLW = ctx_v15.lineWidth;
                    localLog(` -> Definindo lineWidth = Infinity (original: ${originalLW})`, 'info');
                    ctx_v15.lineWidth = Infinity;
                    localLog(` -> lineWidth aplicado (valor lido: ${ctx_v15.lineWidth})`, 'info');
                    ctx_v15.beginPath(); ctx_v15.moveTo(200, 50); ctx_v15.lineTo(250, 50);
                    localLog(" -> Tentando stroke() com lineWidth Infinity...", 'info');
                    ctx_v15.stroke();
                    ctx_v15.lineWidth = originalLW; // Restaura
                    localLog(` -> lineWidth restaurado para ${originalLW}`, 'info');

                    ctx_v15.fillStyle = "yellow";
                    ctx_v15.beginPath();
                    localLog(" -> Tentando arc(NaN, 150, ...)`, 'info');
                    ctx_v15.arc(NaN, 150, 5, 0, Math.PI * 2);
                    localLog(" -> Tentando fill() com arc(NaN)...", 'info');
                    ctx_v15.fill();
                    localLog("Testes com NaN/Infinity não crasharam (verificar visual).", 'warn');
                } catch(e) { localLog(`Erro com valores inválidos: ${e.message}`, 'error'); }
                localLog("--- Testes de Robustez Concluídos ---", 'test'); await PAUSE();

                // 4. Teste de Stress (Pixel R/W) (Logs Restaurados)
                localLog("Iniciando Teste de Stress (Pixel R/W)...", 'test');
                const stressArea = { x: 0, y: 0, w: 20, h: 20 };
                const stressIterations = 100;
                let stressSuccess = true; let errorMsg = "";
                localLog(` -> Área: ${stressArea.w}x${stressArea.h}, Iterações: ${stressIterations}`, 'info');
                const startTime = performance.now();
                try {
                    for (let i = 0; i < stressIterations; i++) {
                        const imageData = ctx_v15.getImageData(stressArea.x, stressArea.y, stressArea.w, stressArea.h);
                        if (!imageData || !imageData.data) { throw new Error("Falha getImageData"); }
                        const data = imageData.data;
                        for (let j = 0; j < data.length; j += 4) { data[j]=255-data[j]; data[j+1]=255-data[j+1]; data[j+2]=255-data[j+2]; }
                        ctx_v15.putImageData(imageData, stressArea.x, stressArea.y);
                    }
                } catch (e) { stressSuccess = false; errorMsg = e.message; localLog(`Erro stress R/W: ${e.message}`, 'error'); console.error("Erro Stress R/W:", e); }
                const endTime = performance.now(); const duration = (endTime - startTime).toFixed(1);
                if (stressSuccess) { localLog(`Stress R/W OK (${stressIterations} it) em ${duration} ms.`, 'good'); }
                else { localLog(`Stress R/W FALHOU após ${duration} ms. Erro: ${errorMsg}`, 'error'); }
                localLog("--- Teste de Stress Concluído ---", 'test'); await PAUSE();

                // 5. Teste de PP Hijack Avançado (Logs Mantidos)
                localLog("Iniciando Teste PP Hijack Canvas AVANÇADO...", 'test');
                const originalMethods_v15 = {}; let ppVulnDetected_v15 = false;
                try{ /* ... (igual v13, código omitido por brevidade) ... */ } catch(e){ localLog(`Erro PP:${e.message}`,'error');}
                localLog(`--- Teste PP Hijack Canvas Concluído (Vuln: ${ppVulnDetected_v15}) ---`, 'test'); await PAUSE();

                // 6. Verificação de Ambiente (Logs Restaurados)
                localLog("Iniciando Verificação de Ambiente...", 'test');
                try {
                    localLog(`Worker? ${typeof Worker !== 'undefined'}`, typeof Worker !== 'undefined' ? 'info' : 'warn');
                    localLog(`Wasm? ${typeof WebAssembly !== 'undefined'}`, typeof WebAssembly !== 'undefined' ? 'info' : 'warn');
                    localLog("Verificando algumas props globais (window)...", 'subtest'); let c=0; const mL=20;
                    for(const k in window){ if(c<mL&&(k.toUpperCase()===k||k.startsWith('webkit')||k.startsWith('moz')||k.toLowerCase().includes('ps'))){localLog(` -> win.${k}`,'info');c++;}else if(c>=mL&&k.includes('ps')&&c<mL+5){localLog(` -> win.${k}(+)`,'info');c++;}} if(c>=mL)localLog(` -> ...`);
                 } catch(e) { localLog(`Erro ao verificar ambiente: ${e.message}`, 'error');}
                localLog("--- Verificação de Ambiente Concluída ---", 'test'); await PAUSE();

                // 7. Verificação WebGL (Logs Restaurados)
                localLog("Iniciando Verificação WebGL...", 'test');
                let gl = null; let webglVersion = "N/A"; let webglRenderer = "N/A"; let gl2 = null;
                try {
                    localLog(" -> Tentando getContext('webgl')...", 'info');
                    gl = canvasEl.getContext('webgl') || canvasEl.getContext('experimental-webgl');
                    if (gl) {
                        try { webglVersion = gl.getParameter(gl.VERSION); } catch(e){}
                        try { webglRenderer = gl.getParameter(gl.RENDERER); } catch(e){}
                        localLog(`WebGL OK! Versão: ${webglVersion}, Renderer: ${webglRenderer}`, 'vuln');
                        // Tenta WebGL2
                         localLog(" -> Tentando getContext('webgl2')...", 'info');
                         try { gl2 = canvasEl.getContext('webgl2') || canvasEl.getContext('experimental-webgl2'); } catch(e){}
                         if(gl2) { localLog(`WebGL2 TAMBÉM OK! V: ${gl2.getParameter(gl2.VERSION)} R: ${gl2.getParameter(gl2.RENDERER)}`, 'vuln'); }
                         else { localLog('WebGL2 NÃO disponível.', 'info'); }
                    } else { localLog('WebGL (1/exp) NÃO disponível.', 'good'); }
                } catch(e) { localLog(`Erro ao obter contexto WebGL: ${e.message}`, 'error'); console.error("Erro WebGL:", e); }
                localLog("--- Verificação WebGL Concluída ---", 'test'); await PAUSE();

                // 8. Verificação de Outras APIs (Logs Restaurados)
                localLog("Iniciando Verificação de Outras APIs...", 'test');
                try {
                    const wsSup = 'WebSocket' in window; localLog(`WebSocket? ${wsSup}`, wsSup ? 'info' : 'warn');
                    const rtcKey = ['RTCPeerConnection','webkitRTCPeerConnection','mozRTCPeerConnection'].find(k=>k in window); localLog(`WebRTC (RTCPeerConnection)? ${!!rtcKey}`, !!rtcKey ? 'info' : 'warn');
                    const idbSup = 'indexedDB' in window; localLog(`IndexedDB? ${idbSup}`, idbSup ? 'info' : 'warn');
                    const notifSup = 'Notification' in window; localLog(`Notifications? ${notifSup}`, notifSup ? 'info' : 'warn');
                 } catch(e) { localLog(`Erro ao verificar outras APIs: ${e.message}`, 'error'); }
                localLog("--- Verificação de Outras APIs Concluída ---", 'test'); await PAUSE();

                // 9. Verificação SVG (Logs Restaurados)
                localLog("Iniciando Verificação SVG...", 'test');
                try {
                     const svgNS = "http://www.w3.org/2000/svg";
                     localLog(" -> Criando elemento SVG via NS...", 'info');
                     const svgEl = document.createElementNS(svgNS, "svg");
                     if (svgEl && typeof svgEl.getAttributeNS === 'function') {
                         localLog(" -> Elemento SVG criado com sucesso.", 'good');
                         localLog(" -> Testando setAttributeNS...", 'info');
                         svgEl.setAttributeNS(null, "width", "10");
                         localLog(" -> setAttributeNS OK.", 'good');
                     } else { localLog(`Criação de elemento SVG falhou.`, 'error'); }
                } catch(e) { localLog(`Erro ao testar SVG: ${e.message}`, 'error'); }
                localLog("--- Verificação SVG Concluída ---", 'test'); await PAUSE();

                // 10. Teste Web Worker FINAL (Logs Mantidos)
                localLog("Iniciando Teste Web Worker FINAL...", 'test');
                const sabSupported_v15 = typeof SharedArrayBuffer !== 'undefined'; localLog(`SharedArrayBuffer suportado? ${sabSupported_v15}`, sabSupported_v15 ? 'warn' : 'good');
                try{/*...(igual v13)...*/}catch(e){localLog(`Erro Worker:${e.message}`,'error');}
                localLog("--- Teste Web Worker FINAL Concluído ---", 'test'); await PAUSE(1000);

                // 11. Teste WebSocket (Binário) (Logs Mantidos)
                localLog("Iniciando Teste WebSocket (Binário)...", 'test');
                 try{/*...(igual v13)...*/}catch(e){localLog(`Erro WS:${e.message}`,'error');}
                 localLog("--- Teste WebSocket (Binário) Concluído ---", 'test'); await PAUSE(2000);

                // 12. Adicionar Listeners Finais (Mantido)
                localLog("Adicionando listeners finais...", 'subtest');
                /* ... (código listeners igual v13) ... */
                if(canvasClickListenerCanvas_v15 && canvasEl) { try { canvasEl.removeEventListener('click', canvasClickListenerCanvas_v15); } catch(e){} } if(canvasMoveListenerCanvas_v15 && canvasEl) { try { canvasEl.removeEventListener('mousemove', canvasMoveListenerCanvas_v15); } catch(e){} } canvasMoveListenerCanvas_v15 = (event) => { try{const r=canvasEl.getBoundingClientRect();const x=event.clientX-r.left;const y=event.clientY-r.top;let fT=null;for(const a of interactiveAreas_v15){if(x>=a.x&&x<=a.x+a.w&&y>=a.y&&y<=a.y+a.h){fT=a.id;break;}} if(fT!==currentHoverTarget_v15){currentHoverTarget_v15=fT; redrawAll_v15(); canvasEl.style.cursor=fT?'pointer':'default';} if(coordStatusDivEl)coordStatusDivEl.textContent=`Coords:X=${x.toFixed(0)},Y=${y.toFixed(0)}`; }catch(e){} }; canvasClickListenerCanvas_v15 = (event) => { try{ const r=canvasEl.getBoundingClientRect(); const x=event.clientX-r.left; const y=event.clientY-r.top; let cA=null; for(const a of interactiveAreas_v15){if(x>=a.x&&x<=a.x+a.w&&y>=a.y&&y<=a.y+a.h){cA=a;break;}} if(cA){localLog(`--> Click área: ${cA.text}`,'vuln'); switch(cA.id){ case 'rect-log': localLog("Ação: Log",'info'); break; case 'rect-link': localLog("Ação: Link...",'warn'); try{const nW=window.open('https://google.com','_blank');if(!nW)localLog('Falha.','warn'); else localLog('window.open OK.','good');}catch(e){localLog('Erro win.open: '+e.message,'error');} break; case 'rect-rerun': localLog("Ação: Re-ler S1 e Mostrar Histórico...",'info'); let reReadLeakValue=null; try{if(typeof leakedValueFromOOB!=='undefined'){reReadLeakValue=leakedValueFromOOB; if(reReadLeakValue){const lS=reReadLeakValue.type==='U64'?`ReL(S1):U64 H=${toHex(reReadLeakValue.high)} L=${toHex(reReadLeakValue.low)} @${reReadLeakValue.offset}`:`ReL(S1):U32 ${toHex(reReadLeakValue.low)} @${reReadLeakValue.offset}`; localLog(` -> Valor Atual: ${lS}`,'leak'); currentLeakData_v15={text:lS,color:"#FF9800"};}else{localLog(` -> Valor Atual NULO.`,'warn');currentLeakData_v15={text:"ReL(S1):NULO",color:"#FFC107"};}}else{localLog(` -> Var global N/A.`,'error');currentLeakData_v15={text:"ReL(S1):Var N/A",color:"#F44336"};}}catch(e){localLog(`Erro re-ler:${e.message}`,'error');currentLeakData_v15={text:"ReL(S1):ERRO",color:"#F44336"};reReadLeakValue={error:e.message};} leakHistory_v15.push({timestamp:new Date().toISOString(),value:reReadLeakValue}); if(leakHistory_v15.length>10){leakHistory_v15.shift();} localLog(`--- Histórico Leaks(últimos ${leakHistory_v15.length}) ---`,'test'); localLog(JSON.stringify(leakHistory_v15,(k,v)=>typeof v==='bigint'?v.toString():v,2),'info'); redrawAll_v15(); break; }}else{ localLog(`--> Click fora. x=${x.toFixed(0)}, y=${y.toFixed(0)}`,'info');}}catch(e){localLog(`Erro click:${e.message}`,'error');console.error(e);} }; canvasEl.addEventListener('click', canvasClickListenerCanvas_v15); canvasEl.addEventListener('mousemove', canvasMoveListenerCanvas_v15);
                localLog("Listeners finais adicionados.", 'good');

            } catch(e) {
                 localLog(`Erro GERAL INESPERADO v15: ${e.message}`, 'error'); console.error(e);
            } finally {
                 localLog("--- Teste FINAL Canvas v15 (Full Logs) CONCLUÍDO ---", 'test');
                 if (runBtnEl) runBtnEl.disabled = false;
            }
        };

        // --- Função chamada pelo botão do Canvas (v15) ---
        const runCanvasTest = async () => { /* ... (igual v13) ... */ const canvasOutputDiv=document.getElementById('output-canvas'); logCanvas_v15(canvasOutputDiv,"Botão 'Iniciar v15 Full' clicado.","info"); console.log("Canvas v15 Full: Get elements..."); const canvasRunBtn=document.getElementById('runCanvasBtn'); const canvasElement=document.getElementById('interactive-canvas'); const coordStatusDivCanvas=document.getElementById('canvas-coord-status'); if(!canvasOutputDiv||!canvasRunBtn||!canvasElement||!coordStatusDivCanvas){const eM="ERRO FATAL v15: Elementos não encontrados!"; logCanvas_v15(canvasOutputDiv,eM,"error"); console.error(eM); return;} logCanvas_v15(canvasOutputDiv,"Elementos v15 OK.", "good"); if(canvasRunBtn)canvasRunBtn.disabled=true; logCanvas_v15(canvasOutputDiv,"Iniciando teste v15...", "info"); await testComprehensiveCanvasFinalV15(canvasElement,canvasOutputDiv,coordStatusDivCanvas,canvasRunBtn); };

         // --- Limpeza (v15) ---
         window.addEventListener('unload', () => { /* ... (igual v13) ... */ if(currentWorker_v15){try{currentWorker_v15.terminate();}catch(e){}} try{const el=document.getElementById('interactive-canvas'); if(el){ if(canvasClickListenerCanvas_v15)el.removeEventListener('click',canvasClickListenerCanvas_v15); if(canvasMoveListenerCanvas_v15)el.removeEventListener('mousemove',canvasMoveListenerCanvas_v15); console.log("[Unload] Listeners v15 removidos.");}}catch(e){} });
         // --- FIM DO SCRIPT 2 (v15 Full Logs) ---
    </script>

</body>
</html>
