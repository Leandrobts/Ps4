<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Info Leak Hunter para ASLR (Focado)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; display: none; /* Ocultado pois XSS não é o foco */ }
        #interactive-canvas { display: none; /* Ocultado pois Canvas não é o foco principal */ }
        #canvas-coord-status { display: none; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Info Leak Hunter (OOB Read) - Foco em ASLR Bypass</h1>
    <p>Este script foca em executar o teste <code>testOOBReadInfoLeakEnhancedStore</code> para tentar vazar ponteiros da memória, auxiliando na análise para contornar o ASLR.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Teste de Info Leak</button>
    <div id="output"></div>
    <script>
        'use strict';
        // --- Script Utilities (Shared) ---
        const SCRIPT_UTILS = {
            TO_HEX: (val, bits = 32) => {
                if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
                let num = Number(val);
                if (bits <= 32) { num = num >>> 0; }
                const pad = Math.ceil(bits / 4);
                return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
            },
            IS_POTENTIAL_POINTER_64: (high, low) => {
                if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
                if (high === 0 && low === 0) return false;
                if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; // Common invalid/fill patterns
                if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Common fill pattern
                // Ajuste: Permitir ponteiros para regiões mais baixas se high não for 0,
                // mas manter restrição se high for 0 (evitar falsos positivos com pequenos inteiros)
                if (high === 0 && low < 0x10000) return false; // Pointers to very low memory if high is also 0
                if (high < 0x100 && low < 0x10000) return false; // Heuristic: avoid small numbers that are unlikely pointers
                return true;
            },
            IS_POTENTIAL_DATA_32: (val) => {
                if (val === null || typeof val !== 'number') return false;
                val = val >>> 0;
                if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; // Common fill/invalid patterns
                if (val < 0x1000) return false; // Exclude very small numbers
                return true;
            }
        };

        // --- Log Constants ---
        const LOG_TRUNCATE_MSG_S1 = "[Log S1 Truncado...]";
        const LOG_MAX_LENGTH = 600000;
        const LOG_TRUNCATE_KEEP_LENGTH = 300000;

        // --- Script 1 (v18.4-infoleak-focused) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500; // Mantido para consistência, mas menos relevante agora
        let leakedValueFromOOB = null; // Variável global para armazenar o primeiro leak significativo

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const log = (message, type = 'info', funcName = '') => {
            // Lógica de filtragem de log mantida, adaptada se necessário
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
            if (!keepLog && type === 'good') {
                const lowerMsg = String(message).toLowerCase();
                 if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('concluído')) { keepLog = true; }
            }
            if (!keepLog) return;

            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';

                if(outputDiv.innerHTML.length > LOG_MAX_LENGTH){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - LOG_TRUNCATE_KEEP_LENGTH);
                    outputDiv.innerHTML = `<span>${LOG_TRUNCATE_MSG_S1}</span>\n` + outputDiv.innerHTML;
                }

                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore';
            log("--- Iniciando Teste ÚNICO: OOB Write/Read (Info Leak para ASLR) ---", 'test', FNAME);
            const bufferSize = 32; // Tamanho do buffer principal
            const writeValue = 0xEE; // Valor a ser escrito OOB
            const oobWriteOffset = bufferSize; // Onde escrever OOB em relação ao início do buffer lógico
            const readRangeStart = -128; // Quão "antes" do buffer lógico começar a ler
            const readRangeEnd = bufferSize + 128; // Quão "depois" do buffer lógico terminar de ler
            const allocationSize = bufferSize + 512; // Tamanho real da alocação para dar espaço para leituras OOB
            const baseOffsetInBuffer = 256; // Onde o buffer lógico começa dentro da alocação real

            const oobReadOffsets = [];
            for (let i = readRangeStart; i < readRangeEnd; i += 4) { // Ler a cada 4 bytes (tamanho de U32)
                oobReadOffsets.push(i);
            }

            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Resetar leak global

            try {
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);

                // Preencher o buffer com um padrão conhecido (0xAA)
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xAA);
                }

                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;
                await PAUSE_S1();

                // Tentar a escrita Out-Of-Bounds
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @offset_relativo ${oobWriteOffset} (endereço_no_buffer_real ${writeTargetAddress}) OK! Valor escrito=${SCRIPT_UTILS.TO_HEX(writeValue, 8)}`, 'vuln', FNAME);
                    log(`---> PRIMITIVA OOB WRITE OBTIDA <---`, 'escalation', FNAME);
                    writeSuccess = true;
                } catch (e) {
                    log(`Escrita OOB U8 @offset_relativo ${oobWriteOffset} (endereço_no_buffer_real ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME);
                    log(`--- Teste Concluído (Escrita OOB Falhou, não é possível prosseguir com a leitura para leak) ---`, 'test', FNAME);
                    return false; // Se a escrita falhar, a leitura para leak pode não ser significativa
                }

                await PAUSE_S1();
                log("Iniciando varredura de memória OOB para potenciais ponteiros...", 'info', FNAME);

                // Ler a memória ao redor (incluindo OOB)
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@offset_relativo ${readOffset} (addr_real ${readTargetAddress})`;

                    // Tentar ler como U64 (8 bytes)
                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true); // Little-endian
                            const high = dataView.getUint32(readTargetAddress + 4, true); // Little-endian

                            if (SCRIPT_UTILS.IS_POTENTIAL_POINTER_64(high, low)) {
                                const vStr = `High=${SCRIPT_UTILS.TO_HEX(high)} Low=${SCRIPT_UTILS.TO_HEX(low)}`;
                                log(`LEAK PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++;
                                if (leakedValueFromOOB === null) { // Armazenar o primeiro leak significativo
                                    leakedValueFromOOB = { high, low, type: 'U64', offset_relativo: readOffset, offset_real: readTargetAddress };
                                    log(` ---> PRIMEIRO LEAK U64 SIGNIFICATIVO ARMAZENADO: ${vStr} ${relOffsetStr}.`, 'vuln', FNAME);
                                    log(`    ---> GUIA ASLR/EXPLOIT:
        1. IDENTIFIQUE ESTE PONTEIRO: Compare '${vStr}' com os endereços nos seus arquivos:
           - 'endereços base.txt': Este ponteiro está próximo a algum base (ex: libkernel, libc)?
           - Se sim, calcule o SLIDE ASLR: slide = (valor_do_ponteiro_vazado) - (offset_conhecido_do_item_apontado_na_lib_OU_base_da_lib_se_vazou_ponteiro_para_inicio_de_funcao).
        2. CALCULE ENDEREÇOS REAIS: Use o SLIDE com os offsets dos seus arquivos:
           - 'libkernel.sprx.txt', 'libkernel_web.sprx.txt': Para achar gadgets ROP e funções. Endereço Real = offset_do_gadget/funcao_no_arquivo + slide.
           - 'offsets base libkernel web.txt': Para syscalls como open/read/write. Endereço Real = offset_do_arquivo + slide_da_libkernel_web.
           - 'sceKernelMprotect.txt': Para obter o endereço real de sceKernelMprotect. Endereço Real = offset_mprotect (ex: 0x24280) + slide_da_libkernel.
        3. PLANEJE SEU EXPLOIT: Com endereços reais, construa sua ROP chain para chamar sceKernelMprotect, depois seu shellcode, ou outras funções.
        4. ALOCADOR: Use 'alocador de memoria customizado.txt' para entender como sua primitiva OOB Write pode ser usada para corromper o heap e obter R/W arbitrário, caso este leak não seja suficiente por si só.`, 'escalation', FNAME);

                                }
                            }
                        } catch (e) { /* Silenciar erros de leitura OOB se estiverem fora dos limites estritos, focando nos sucessos */ }
                    }
                    
                    // Tentar ler como U32 (4 bytes), se não for parte de um U64 já logado como mais provável
                    // e se o leakedValueFromOOB (que prioriza U64) ainda não foi preenchido.
                    if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) {
                        try {
                            // Evitar re-logar a parte baixa de um U64 como um U32 separado se já consideramos U64
                            let partOfExistingU64 = false;
                            if (potentialLeakFoundCount > 0 && leakedValueFromOOB && leakedValueFromOOB.type === 'U64') {
                                if (readOffset === leakedValueFromOOB.offset_relativo || readOffset === leakedValueFromOOB.offset_relativo + 4) {
                                    partOfExistingU64 = true;
                                }
                            }

                            if (!partOfExistingU64) {
                                const val32 = dataView.getUint32(readTargetAddress, true);
                                if (SCRIPT_UTILS.IS_POTENTIAL_DATA_32(val32) && !SCRIPT_UTILS.IS_POTENTIAL_POINTER_64(0, val32) ) { // Evitar que pequenos ponteiros (high=0) sejam apenas "dados"
                                    const vStr32 = SCRIPT_UTILS.TO_HEX(val32);
                                    log(`LEAK DATA? U32 ${relOffsetStr}: ${vStr32}`, 'leak', FNAME);
                                    potentialLeakFoundCount++;
                                    // Não sobrescrever leakedValueFromOOB se já tivermos um U64, que é geralmente mais útil para ASLR
                                }
                            }
                        } catch (e) { /* Silenciar */ }
                    }

                    if (readOffset % 32 === 0) await PAUSE_S1(1); // Pequena pausa para não sobrecarregar
                }
            } catch (e) {
                log(`Erro FATAL no Teste de Info Leak: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                const leakStatus = leakedValueFromOOB ? `1º leak U64 ARMAZENADO: High=${SCRIPT_UTILS.TO_HEX(leakedValueFromOOB.high)} Low=${SCRIPT_UTILS.TO_HEX(leakedValueFromOOB.low)} @rel ${leakedValueFromOOB.offset_relativo}` : 'nenhum U64 significativo armazenado globalmente';
                log(`--- Teste de Info Leak Concluído ---
    Escrita OOB bem-sucedida: ${writeSuccess}
    Total de leaks U64/U32 potenciais visualizados: ${potentialLeakFoundCount}
    Status do 1º Leak U64 Armazenado: ${leakStatus}
    Utilize os logs 'LEAK PTR? U64' e o 'GUIA ASLR/EXPLOIT' acima com seus arquivos de firmware.`, 'test', FNAME);
                 /* Comentário de Contexto para Exploração (Mantido):
                 Uma primitiva de leitura OOB confiável que vaza ponteiros válidos é o primeiro passo para contornar o ASLR.
                 A exploração normalmente envolveria:
                 1. Identificar a qual módulo/região o ponteiro vazado pertence (usando os seus arquivos .txt).
                 2. Calcular o endereço base desse módulo (slide ASLR).
                 3. Com o endereço base, calcular os endereços de funções/gadgets ROP dentro desse módulo.
                 Isto requer conhecimento da arquitetura do processo e dos módulos carregados.
                 */
            }
            return writeSuccess; // Retorna se a escrita OOB (pré-requisito para o leak intencional) funcionou
        };

        const runAllTests = async () => {
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = ''; // Limpar logs anteriores
            log("==== INICIANDO Script Info Leak Hunter (v18.4-infoleak-focused) ====", 'test', FNAME);

            await testOOBReadInfoLeakEnhancedStore(); // Único teste a ser executado

            log("\n==== Script Info Leak Hunter CONCLUÍDO (v18.4-infoleak-focused) ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        'use strict';
        // --- Script 2: Canvas (v18.4-infoleak-focused) ---
        // Funcionalidade do Canvas removida/minimizada para focar no Script 1.
        // SCRIPT_UTILS e constantes de log já estão definidos globalmente.

        let outputDivCanvas = null;
        const LOG_TRUNCATE_MSG_S2 = "[Log S2 Truncado...]";


        const logCanvas = (message, type = 'info', funcName = '') => {
            // Lógica de log simplificada para o canvas, se necessário, ou pode ser removida se o canvas não logar nada.
            if (!outputDivCanvas) outputDivCanvas = document.getElementById('output-canvas');
            if (!outputDivCanvas) return;

            const timestamp = `[${new Date().toLocaleTimeString()}]`;
            const prefix = funcName ? `[CANVAS-${funcName}] ` : '[CANVAS] ';
            const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
            const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error', 'critical'].includes(type) ? type : 'info';

             if(outputDivCanvas.innerHTML.length > LOG_MAX_LENGTH){ // Usando LOG_MAX_LENGTH global
                 outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - LOG_TRUNCATE_KEEP_LENGTH); // Usando LOG_TRUNCATE_KEEP_LENGTH global
                 outputDivCanvas.innerHTML = `<span>${LOG_TRUNCATE_MSG_S2}</span>\n` + outputDivCanvas.innerHTML;
            }
            outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
            outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight;
        };
        
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas');
            const runBtnCanvas = document.getElementById('runCanvasBtn');

            if (runBtnCanvas) runBtnCanvas.disabled = true;
            if (outputDivCanvas) outputDivCanvas.innerHTML = '';

            logCanvas("Script Canvas (v18.4-infoleak-focused): Nenhuma tarefa de teste de vulnerabilidade ativa nesta versão.", "info", FNAME);
            // Nenhuma chamada de teste de vulnerabilidade aqui.
            // A lógica de desenho e interação com quadrados foi removida.
            // O canvas e o botão permanecem no HTML, mas o botão não dispara testes complexos.

            logCanvas("--- Fim da execução Script Canvas (v18.4-infoleak-focused) ---", 'test', FNAME);
            if (runBtnCanvas) runBtnCanvas.disabled = false;
        };

        const runCanvasTest = async () => {
            await runCanvasTestSequence();
        };
        
        // Event listener de unload pode ser mantido para limpeza genérica se houver.
        window.addEventListener('unload', () => { 
            console.log("[App Unload] Limpeza geral (se houver)."); 
        });
    </script>

</body>
</html>
