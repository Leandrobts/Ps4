<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vulnerability Scanner | Impact Demonstration</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 500px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #4CAF50; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>PS4 WebKit Vulnerability Scanner</h1>
    <h3>Firmware 12.00 | Impact Demonstration & Detailed Logging</h3>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Language:</strong> <span id="language"></span><br>
        <strong>Cookies Enabled:</strong> <span id="cookiesEnabled"></span><br>
    </div>

    <div>
        <select id="testSelector">
            <option value="all">Run All Impact Tests</option>
            <option value="oob_write_exploit">Attempt ArrayBuffer OOB Write Exploit</option>
            <option value="huge_allocation_impact">Test Huge Memory Allocation Impact</option>
            <option value="canvas_memory_exhaustion">Test Canvas Memory Exhaustion</option>
            <option value="fetch_dos">Attempt Fetch API DoS</option>
            <option value="websocket_flood">Attempt WebSocket Flood</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// Collect Browser Information
// ======================
document.addEventListener('DOMContentLoaded', function() {
    const userAgentElement = document.getElementById('userAgent');
    const platformElement = document.getElementById('platform');
    const languageElement = document.getElementById('language');
    const cookiesEnabledElement = document.getElementById('cookiesEnabled');

    if (userAgentElement) userAgentElement.textContent = navigator.userAgent;
    if (platformElement) platformElement.textContent = navigator.platform;
    if (languageElement) languageElement.textContent = navigator.language;
    if (cookiesEnabledElement) cookiesEnabledElement.textContent = navigator.cookieEnabled;
});

// ======================
// Logging Function
// ======================
function log(message, type = '') {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        const line = document.createElement('div');
        line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (type) {
            line.className = type;
        }
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight;
    } else {
        console.error("Error: #log element not found!");
    }
}

function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        logDiv.innerHTML = '';
    }
}

// ======================
// Impact Demonstration Tests
// ======================
const impactTests = {
    "oob_write_exploit": async function() {
        log("[EXPLOIT] Attempting ArrayBuffer OOB Write Exploit...", "info");
        try {
            const buffer = new ArrayBuffer(10);
            const view = new Uint8Array(buffer);

            // Tentativa de escrever além dos limites
            for (let i = 0; i < 20; i++) {
                view[i] = 0x41;
            }
            log("⚠️ Attempted OOB write. Monitoring browser for instability or crash...", "warning");

            // Adicionando uma pequena pausa para observar o comportamento
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Tentando ler os dados fora dos limites para ver se algo foi sobrescrito
            try {
                const oobValue = view[15];
                log(`⚠️ Read OOB value: ${oobValue}. This might indicate a vulnerability.`, "warning");
                return true; // Indica potencial vulnerabilidade
            } catch (e) {
                log(`✅ OOB read resulted in error: ${e.message}`, "success");
            }

        } catch (e) {
            log(`✅ Test error: ${e.message}`, "success");
        }
        return false;
    },

    "huge_allocation_impact": async function() {
        log("[IMPACT] Testing Huge Memory Allocation Impact...", "info");
        try {
            const allocations = [];
            for (let i = 0; i < 500; i++) { // Aumentando a tentativa de alocação
                allocations.push(new ArrayBuffer(1024 * 1024)); // 1MB per buffer
                log(`[ALLOC] Allocated ${i + 1}MB`, "info");
                await new Promise(resolve => setTimeout(resolve, 10)); // Pequena pausa entre alocações
            }
            log("⚠️ Huge memory allocation sequence completed. Monitor browser for crashes or extreme slowness.", "warning");
            return true; // Indica que a alocação massiva foi tentada
        } catch (e) {
            log(`✅ Allocation error: ${e.message}`, "success");
            return false;
        }
    },

    "canvas_memory_exhaustion": async function() {
        log("[IMPACT] Testing Canvas Memory Exhaustion...", "info");
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            let width = 2048;
            let height = 2048;
            for (let i = 0; i < 10; i++) {
                width *= 2;
                height *= 2;
                canvas.width = width;
                canvas.height = height;
                const imageData = ctx.getImageData(0, 0, width, height);
                log(`[CANVAS] Created image data: ${width}x${height}`, "info");
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            log("⚠️ Attempted to exhaust Canvas memory. Monitor for crashes.", "warning");
            return true;
        } catch (e) {
            log(`✅ Canvas test error: ${e.message}`, "success");
            return false;
        }
    },

    "fetch_dos": async function() {
        log("[IMPACT] Attempting Fetch API DoS...", "info");
        const startTime = Date.now();
        let requestsSent = 0;
        try {
            for (let i = 0; i < 50; i++) { // Tentando várias requisições rápidas
                fetch('http://example.com/nonexistent', { mode: 'no-cors' }) // Usando no-cors para evitar problemas de CORS
                    .then(response => log(`[FETCH] Response ${response.status}`, "info"))
                    .catch(error => log(`[FETCH] Error: ${error}`, "warning"));
                requestsSent++;
            }
            log(`⚠️ Sent ${requestsSent} rapid Fetch requests. Monitor for browser slowdown or unresponsiveness.`, "warning");
            return true;
        } catch (e) {
            log(`✅ Fetch test error: ${e.message}`, "success");
            return false;
        } finally {
            const endTime = Date.now();
            log(`[FETCH] Test duration: ${endTime - startTime}ms`, "info");
        }
    },

    "websocket_flood": async function() {
        log("[IMPACT] Attempting WebSocket Flood...", "info");
        try {
            const ws = new WebSocket('ws://echo.websocket.events');
            let messagesSent = 0;
            ws.onopen = () => {
                for (let i = 0; i < 100; i++) { // Enviando várias mensagens rapidamente
                    ws.send('Flood'.repeat(100));
                    messagesSent++;
                }
                log(`[WS] Sent ${messagesSent} messages. Monitor for browser instability or connection issues.`, "warning");
            };
            ws.onerror = (error) => {
                log(`[WS] Error: ${error}`, "danger");
            };
            return new Promise((resolve) => {
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                        ws.close();
                        log("[WS] Closing WebSocket connection.", "info");
                    }
                    resolve(true);
                }, 10000); // Tempo limite para o teste
            });
        } catch (e) {
            log(`✅ WebSocket test error: ${e.message}`, "success");
            return false;
        }
    }
};

// ======================
// Test Runner
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;

    clearLog();
    log("=== Starting Impact Demonstration Tests ===", "section");

    if (selectedTest === "all") {
        let impactsObserved = 0;
        for (const [testName, test] of Object.entries(impactTests)) {
            log(`\nRunning ${testName}...`, "info");
            if (await test()) impactsObserved++;
            await new Promise(resolve => setTimeout(resolve, 2000)); // Aumentando a pausa para observação
        }
        log("\n=== Summary ===", "section");
        log(`Observed potential impacts in ${impactsObserved} tests (monitor browser behavior)`,
            impactsObserved > 0 ? "warning" : "success");
    } else if (impactTests[selectedTest]) {
        await impactTests[selectedTest]();
    } else {
        log(`Error: Test "${selectedTest}" not found.`, "danger");
    }

    log("\nImpact demonstration tests completed. Review logs and browser behavior.", "info");
}

function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        logDiv.innerHTML = '';
    }
}
</script>
</body>
</html>
