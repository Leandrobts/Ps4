<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - Teste Combinado v7 (Notificação Web)</title>
    <style>
        /* Estilos CSS (iguais aos anteriores) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - Teste Combinado v7 (Notificação Web)</h1>
    <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, Notificação Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 100; // ms
        const MEDIUM_PAUSE = 500; // ms

        // --- Função de Log ---
        // (Função log igual à versão anterior)
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        // (Função toHex igual à versão anterior)
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        // (Função isPotentialPointer64 igual à versão anterior)
        const isPotentialPointer64 = (high, low) => {
            if (high === 0 && low === 0) return false;
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low < 0x100000) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if ((low >>> 24) === 0) return false;
            // if (low % 8 !== 0) return false; // Alinhamento (opcional)
            return true;
        };

        // --- Teste 1: CSP Bypass / XSS ---
        // (Função testCSPBypass igual à versão anterior)
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // ... (código igual ao script v6) ...
             // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now(); // Fonte inválida única
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        // --- Teste 2: OOB Write/Read (Tentativa de Info Leak) ---
        // (Função testOOBReadInfoLeak igual à versão anterior - v6)
        const testOOBReadInfoLeak = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read (Tentativa de Info Leak) ---", 'test');
            // ... (código igual ao script v6) ...
            const bufferSize = 32;
            const writeValue = 0xEE;
            const oobWriteOffset = 32;
            const oobReadOffsets = [-32, -24, -16, -8, bufferSize, bufferSize + 8, bufferSize + 16, bufferSize + 24];
            let writeSuccess = false;
            let potentialLeakFound = false;

            try {
                const buffer = new ArrayBuffer(bufferSize + 128);
                const dataView = new DataView(buffer);
                const baseOffset = 64;
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) com valor ${toHex(writeValue, 8)}...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                    writeSuccess = true;
                } catch (e) {
                    log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good');
                    log("--- Teste 2 Interrompido (Escrita OOB falhou) ---", 'test');
                    return false;
                }
                 await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                 log(`Tentando leituras OOB U64 nos offsets relativos: [${oobReadOffsets.join(', ')}]`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;
                    if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) {
                         log(`  Leitura @${readOffset} (addr ${readTargetAddress}) ignorada (fora do buffer de teste).`, 'info');
                         continue;
                    }
                    log(`  Tentando leitura U64 @${readOffset} (addr ${readTargetAddress})...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE / 2));
                    try {
                        const low = dataView.getUint32(readTargetAddress, true);
                        const high = dataView.getUint32(readTargetAddress + 4, true);
                        const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                        if (isPotentialPointer64(high, low)) {
                            log(`  -> POTENCIAL PONTEIRO? Leitura OOB U64 @${readOffset}: ${valueStr}`, 'ptr');
                            potentialLeakFound = true;
                        } else {
                            if (low !== 0xAAAAAAAA || high !== 0xAAAAAAAA) {
                                log(`  -> Leitura OOB U64 @${readOffset}: ${valueStr}`, 'leak');
                            }
                        }
                    } catch (e) { log(`  -> Leitura OOB U64 @${readOffset}: FALHA (${e.message})`, 'warn'); }
                }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }

            if (potentialLeakFound) { log(`--- Teste 2 Concluído (POTENCIAL VAZAMENTO DE PONTEIRO DETETADO!) ---`, 'test'); }
            else if (writeSuccess) { log(`--- Teste 2 Concluído (Escrita OOB OK, mas nenhum valor suspeito de ser ponteiro foi lido) ---`, 'test'); }
            else { log(`--- Teste 2 Concluído (Falha na escrita OOB inicial) ---`, 'test'); }
            return potentialLeakFound;
        };

        // --- Teste 3: Prototype Pollution (Básica) ---
        // (Função testBasicPP igual à versão anterior)
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            // ... (código igual ao script v6) ...
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: Notificação Web (API Padrão) ---
        // NOVO TESTE: Tenta usar a API de Notificações Web
        const testWebNotification = async () => {
            log("--- Iniciando Teste 4: Notificação Web (API Padrão) ---", 'test');
            let permissionGranted = false;
            let notificationShown = false;

            // Verifica se a API de Notificação existe no navegador
            if (!("Notification" in window)) {
                log("FALHA: API de Notificação Web não suportada neste navegador.", 'error');
                log("--- Teste 4 Concluído (API Não Suportada) ---", 'test');
                return false;
            }

            log("Verificando permissão de notificação atual...", 'subtest');
            log(`Permissão atual: ${Notification.permission}`, 'info');

            // Pede permissão (pode exigir interação do utilizador ou ser bloqueado)
            try {
                log("Solicitando permissão para notificações...", 'warn');
                const permission = await Notification.requestPermission();
                log(`Permissão solicitada. Resultado: ${permission}`, 'info');

                if (permission === "granted") {
                    permissionGranted = true;
                    log("Permissão CONCEDIDA para notificações!", 'vuln'); // Consideramos 'vuln' pois conseguimos a permissão

                    // Tenta exibir uma notificação
                    log("Tentando exibir uma notificação de teste...", 'subtest');
                    await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                    try {
                        const notification = new Notification("PS4 WebKit Teste", {
                            body: "Se você vê isto, a API de Notificação funcionou!",
                            icon: "https://via.placeholder.com/64" // Ícone placeholder
                        });
                        notification.onclick = () => { log("Notificação clicada!", 'info'); };
                        notification.onshow = () => { log("Notificação exibida (onshow).", 'info'); notificationShown = true;}; // Evento pode não ser suportado
                        notification.onclose = () => { log("Notificação fechada.", 'info'); };
                        notification.onerror = (err) => { log(`Erro ao exibir notificação: ${err}`, 'error'); };

                        log("Objeto de notificação criado. Verifique se a notificação apareceu.", 'warn');
                        // Não há garantia que 'onshow' dispare, então logamos sucesso aqui
                        // O sucesso real é a notificação visual aparecer
                        notificationShown = true; // Assume que foi mostrada se não deu erro

                    } catch (e) {
                        log(`Erro ao criar/exibir Notificação: ${e.message}`, 'error');
                    }
                } else {
                    log(`Permissão NÃO CONCEDIDA (${permission}). Não é possível exibir notificações.`, 'good');
                }
            } catch (e) {
                log(`Erro ao solicitar permissão de Notificação: ${e.message}`, 'error');
            }

            log(`--- Teste 4 Concluído (Permissão ${permissionGranted ? 'Concedida' : 'Negada/Padrão'}, Notificação ${notificationShown ? 'Tentada' : 'Não Tentada'}) ---`, 'test');
            return permissionGranted && notificationShown;
        };


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO TODOS OS TESTES COMBINADOS v7 (Web Notification Attempt) ====", 'critical');

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testOOBReadInfoLeak(); // Teste 2 (Info Leak)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testWebNotification(); // Teste 4 (NOVO - Notificação Web)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            log("\n==== TODOS OS TESTES COMBINADOS v7 CONCLUÍDOS ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // Opcional: descomente para rodar automaticamente ao carregar
        // document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
```

**O que esperar deste script:**

1.  Os Testes 1, 2 e 3 devem funcionar como na versão v6.
2.  **Teste 4 (Notificação Web):**
    * O script verificará se a API `Notification` existe.
    * Pedirá permissão ao utilizador. **Isto pode fazer aparecer uma barra ou popup do próprio navegador a pedir para permitir ou bloquear notificações para este site.** Você precisará interagir com isso (Permitir).
    * Se a permissão for concedida, ele tentará criar e exibir uma notificação com o título "PS4 WebKit Teste".
    * **Observe atentamente:** Onde e como esta notificação aparece? É dentro da janela do navegador? Tem um aspeto diferente de um `alert()`? Parece minimamente com uma notificação do sistema?
    * O log indicará se a permissão foi concedida e se a tentativa de mostrar a notificação foi feita.

**Importante:** É muito provável que isto **não** acione uma notificação *nativa* do sistema PS4. No entanto, é o teste mais próximo que posso fornecer dentro das minhas regras para tentar algo visualmente diferente e potencialmente mais impactante do que um `alert()`. Se funcionar e tiver um aspeto único no PS4, pode ser um elemento adicional para a sua PoC em víd
