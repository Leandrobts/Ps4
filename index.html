<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection</title>
    <style>
        /* Estilos CSS Idênticos */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; }
        .extended-test { color: #03A9F4; } /* Classe para novos tipos de teste */
    </style>
</head>
<body>
    <h1>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection</h1>

    <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
        <select id="testSelector">
            <option value="all_tests">Run All Tests (Incl. Extended Detection)</option>
            <option value="oob_write_aggressive">Aggressive OOB Write (Info Leak Demo)</option>
            <option value="oob_impact_tests">OOB Impact (Metadata/Crash)</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass (Direct Impact)</option>
            <option value="uaf_basic">Basic Use-After-Free Tests</option>
            <option value="type_confusion_basic">Basic Type Confusion Tests</option>
        </select>
        <button onclick="runSelectedTest()">Run Selected Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>

<script>
// ======================
// CONFIGURAÇÃO IMPORTANTE!
// ======================
// SUBSTITUA ESTA URL PELO SEU ENDPOINT PARA RECEBER AS NOTIFICAÇÕES
// Exemplo usando httpbin (ele apenas ecoa o POST): 'https://httpbin.org/post'
// Use um serviço como Beeceptor.com ou seu próprio servidor.
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!

// ======================
// Coleta de Informações e Logging
// ======================
document.addEventListener('DOMContentLoaded', function() {
    const userAgentElement = document.getElementById('userAgent');
    const platformElement = document.getElementById('platform');
    try { if (userAgentElement) userAgentElement.textContent = navigator.userAgent; } catch (e) { console.error("Error getting userAgent:", e); if (userAgentElement) userAgentElement.textContent = "N/A"; }
    try { if (platformElement) platformElement.textContent = navigator.platform; } catch (e) { console.error("Error getting platform:", e); if (platformElement) platformElement.textContent = "N/A"; }
    const endpointDisplay = document.getElementById('notificationEndpointDisplay');
    if(endpointDisplay) endpointDisplay.textContent = NOTIFICATION_ENDPOINT;
});

function log(message, type = '') {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        const line = document.createElement('div');
        const timestamp = `[${new Date().toLocaleTimeString()}] `;
        const textNode = document.createTextNode(timestamp + message.replace(/<[^>]*>/g, '')); // Basic sanitation
        if (type && message.startsWith('<span')) { // Allow specific span tags
             line.innerHTML = timestamp + message;
             if (type) line.classList.add(...type.split(' '));
        } else {
            line.appendChild(textNode);
            if (type) line.className = type;
        }
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll
    } else { console.error("Error: #log element not found!"); }
}

function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) { logDiv.innerHTML = ''; }
}

// Flag global APENAS para OOB
var potentialVulnsFound = { oobWrite: false };

// ======================
// Função para Enviar Notificação
// ======================
async function sendVulnerabilityNotification(payload) {
    if (!NOTIFICATION_ENDPOINT || NOTIFICATION_ENDPOINT === 'YOUR_ENDPOINT_HERE' || NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') {
         log(`[NOTIFY] Notification sending skipped: Endpoint not configured or using placeholder.`, 'notification warning');
         if (NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') { console.warn("Notification endpoint is httpbin.org/post. Change it."); }
         else { console.error("Configure the NOTIFICATION_ENDPOINT constant!"); }
         return;
    }
    log(`[NOTIFY] Sending notification for: ${payload.vulnerability}...`, 'notification info');
    try {
        const response = await fetch(NOTIFICATION_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                finding: payload
            }),
            mode: 'cors'
        });
        if (response.ok) { log(`[NOTIFY] Notification sent successfully to ${NOTIFICATION_ENDPOINT}. Status: ${response.status}`, 'notification success'); }
        else { log(`[NOTIFY] Failed to send notification. Status: ${response.status} ${response.statusText}`, 'notification danger'); }
    } catch (error) { log(`[NOTIFY] Error sending notification via fetch: ${error.message}`, 'notification danger'); console.error("Notification Fetch Error:", error); }
}

// ======================
// Funções Auxiliares para Demonstração de Impacto (globais)
// ======================
function demonstrateCookieRead() { try { const c = document.cookie || '(no cookies)'; log('[IMPACT-CSP] Cookie Read: ' + c, 'impact danger'); } catch(e) { log('[IMPACT-CSP] Error reading cookies: ' + e.message, 'danger'); } }
function demonstrateDomManipulation() { try { const id = 'csp-impact-div-' + Date.now(), div = document.createElement('div'); div.id = id; div.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:red;color:white;text-align:center;padding:10px;z-index:9999;'; div.textContent = '!! CSP Bypass Impact: DOM Manipulation !!'; const old = document.getElementById('csp-impact-div-active'); if(old) { try{old.remove();} catch(e){} } div.id = 'csp-impact-div-active'; document.body.appendChild(div); log('[IMPACT-CSP] DOM Manipulation Executed.', 'impact danger'); } catch(e) { log('[IMPACT-CSP] Error manipulating DOM: ' + e.message, 'danger'); } }
function demonstrateNetworkRequest() { const url = 'https://httpbin.org/get?csp_bypass_poc_direct=true'; try { log('[IMPACT-CSP] Attempting fetch to ' + url + '...', 'info'); fetch(url).then(r => log(`[IMPACT-CSP] Network Request ${r.ok ? 'OK' : 'Failed'}: Status ${r.status}`, r.ok ? 'impact danger' : 'warning')).catch(e => { log('[IMPACT-CSP] Network Request Error: ' + e.message, 'warning'); log('[IMPACT-CSP] Note: Check connect-src, CORS, network.', 'info'); }); } catch(e) { log('[IMPACT-CSP] Error attempting fetch: ' + e.message, 'danger'); } }

// ======================
// Aggressive POC Tests (Com Novas Detecções e Info Leak)
// ======================
const aggressiveTests = {

    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write (Info Leak Demo)...", "info section");
        potentialVulnsFound.oobWrite = false; this.infoLeakNotified = false; // Resetar flag de notificação de leak
        try {
            const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer);
            const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10];
            const readOffsets = [-5, 0, 5, bufferSize - 1, bufferSize, bufferSize + 5, bufferSize + 8, bufferSize + 16];

            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info");
                let oobWriteSuccess = false;
                try {
                    view[writeOffset] = writeValue;
                    log(`⚠️ OOB write at offset ${writeOffset} successful (no error).`, "warning");
                    potentialVulnsFound.oobWrite = true; oobWriteSuccess = true;
                } catch (writeError) { log(`✅ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success"); }

                if(oobWriteSuccess || (writeOffset >= 0 && writeOffset < bufferSize)) {
                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const readValue = view[readOffset];
                            const readValueHex = (readValue !== undefined ? `0x${readValue.toString(16)}` : 'undefined');
                            log(`[OOB-AGG] Read ${readValueHex} at offset ${readOffset} after write at ${writeOffset}.`, "info");

                            // Detecção de Corrupção
                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) {
                                const detailMsg = `Wrote at ${writeOffset}, read ${readValueHex} at IN-BOUNDS offset ${readOffset}.`;
                                log(`<span class="poc-potential defense-bypass privilege-escalation">🚩 Potential OOB Write Corruption: ${detailMsg}</span>`, "danger");
                                sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg });
                            }

                            // Demonstração de Info Leak Controlado
                            if (readOffset >= bufferSize && readValue !== undefined) {
                                let leakedBytes = []; const bytesToRead = 8;
                                for (let i = 0; i < bytesToRead; i++) {
                                    try {
                                        const leakOffset = readOffset + i;
                                        leakedBytes.push(view[leakOffset]?.toString(16).padStart(2, '0') ?? '??');
                                    } catch (leakReadError) { leakedBytes.push('ERR'); break; }
                                }
                                const leakHex = leakedBytes.join(' ');
                                const detailMsg = `Read ${readValueHex} at OOB offset ${readOffset}. Following ${bytesToRead} bytes: ${leakHex}`;
                                log(`<span class="poc-potential impact">💧 Potential Info Leak: ${detailMsg}</span>`, "warning impact");
                                if(!this.infoLeakNotified) {
                                     sendVulnerabilityNotification({ vulnerability: 'OOB_INFO_LEAK_ADJACENT', details: detailMsg });
                                     this.infoLeakNotified = true;
                                }
                            }
                        } catch (readError) { log(`⚠️ Error reading at offset ${readOffset}: ${readError.message}`, "warning"); }
                    } // end read loop
                } // end if write success
                await new Promise(resolve => setTimeout(resolve, 100));
            } // end write loop
            log("[OOB-AGG] Completed OOB write / info leak testing.", "info");
        } catch (e) { log(`❌ Test error (OOB Write/Leak): ${e.message}`, "danger"); console.error(e); }
         this.infoLeakNotified = false; // Garante reset no final
    },

    "test_oob_metadata": async function() { /* ... código idêntico anterior ... */ },
    "test_oob_crash_probe": async function() { /* ... código idêntico anterior ... */ },
    "csp_bypass_aggressive": async function() { /* ... código idêntico anterior ... */ },

    // --- NOVOS TESTES DE DETECÇÃO ---
    "uaf_basic": async function() {
        log("[UAF-BASIC] Attempting basic Use-After-Free scenarios...", "section extended-test");
        log("INFO: Generic tests, may not trigger specific UAFs.", "info");
        // Cenário 1: DOM Node
        try {
            log("[UAF-BASIC] Scenario 1: DOM Node Ref After Removal", "extended-test");
            let p = document.createElement('div'), c = document.createElement('span'); p.appendChild(c); document.body.appendChild(p);
            let cRef = c; p.removeChild(c); document.body.removeChild(p);
            try { new ArrayBuffer(10*1024*1024); } catch(e) {} // Hint GC
            await new Promise(r => setTimeout(r, 500));
            log(`[UAF-BASIC] Accessing childRef.tagName...`, "info"); let tn = cRef.tagName;
            log(`[UAF-BASIC] childRef.tagName = ${tn}. No immediate error.`, "success");
            log(`[UAF-BASIC] Calling childRef.getBoundingClientRect()...`, "info"); cRef.getBoundingClientRect();
            log(`[UAF-BASIC] Call OK. No immediate error.`, "success"); cRef = null;
        } catch (e) { log(`❌ Error UAF Scenario 1: ${e.message}. Investigate.`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'UAF_BASIC_SCENARIO1_ERROR', details: e.message }); }
        // Cenário 2: Placeholder
        log("[UAF-BASIC] Scenario 2: ArrayBuffer/TypedArray (Placeholder - complex)", "extended-test info");
        log("[UAF-BASIC] Completed basic UAF tests.", "extended-test info");
    },

    "type_confusion_basic": async function() {
        log("[TYPE-CONFUSION] Attempting basic Type Confusion scenarios...", "section extended-test");
        log("INFO: Generic tests, may not trigger specific type confusions.", "info");
        // Cenário 1: API DOM
        try {
            log("[TYPE-CONFUSION] Scenario 1: Incorrect type to DOM API", "extended-test");
            log(`[TYPE-CONFUSION] Sending self via postMessage...`, "info"); try { window.postMessage(window, "*"); log(`[TYPE-CONFUSION] postMessage(window) OK.`, "success"); } catch(e) { log(`[TYPE-CONFUSION] postMessage(window) threw: ${e.message}`, "success"); }
            let fakeEvent = { target: document.body, type: "click" }; log(`[TYPE-CONFUSION] Dispatching fake event...`, "info"); try { document.dispatchEvent(fakeEvent); log(`[TYPE-CONFUSION] dispatchEvent(fakeEvent) OK.`, "success"); } catch(e) { log(`[TYPE-CONFUSION] dispatchEvent(fakeEvent) threw: ${e.message}`, "success"); }
        } catch (e) { log(`❌ Error Type Confusion Scenario 1: ${e.message}. Investigate.`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO1_ERROR', details: e.message }); }
        // Cenário 2: Primitivo vs Objeto
        try {
            log("[TYPE-CONFUSION] Scenario 2: Primitive vs Object", "extended-test");
            let nP = 5, nO = new Number(5); log(`[TYPE-CONFUSION] Calling nP.toFixed(nO)...`, "info"); try { let r = nP.toFixed(nO); log(`[TYPE-CONFUSION] nP.toFixed(nO) = ${r}.`, "success"); } catch(e) { log(`[TYPE-CONFUSION] nP.toFixed(nO) threw: ${e.message}`, "danger"); }
        } catch(e) { log(`❌ Error Type Confusion Scenario 2: ${e.message}. Investigate.`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: e.message }); }
        log("[TYPE-CONFUSION] Completed basic Type Confusion tests.", "extended-test info");
    },

    // --- Executor Principal Atualizado ---
    "all_tests": async function() {
        log("=== Running All Tests (OOB, CSP, UAF Basic, Type Confusion Basic) ===", "section");
        await aggressiveTests["oob_write_aggressive"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));
        if (potentialVulnsFound.oobWrite) { await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000)); await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000)); }
        else { log("Skipping OOB impact tests.", "warning"); }
        await aggressiveTests["csp_bypass_aggressive"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        await aggressiveTests["uaf_basic"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        await aggressiveTests["type_confusion_basic"]();
        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },
    "oob_impact_tests": async function() { /* ... código idêntico anterior ... */ }
};

// ======================
// Test Runner (Atualizado)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;
    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first for best results.", "warning"); }
    clearLog(); log(`=== Starting Test: ${selectedTest} ===`, "section");
    if (aggressiveTests[selectedTest]) { await aggressiveTests[selectedTest](); log(`\n=== Test Execution for "${selectedTest}" Completed. Review logs & endpoint. ===`, "section"); }
    else { log(`Error: Test "${selectedTest}" not found.`, "danger"); }
}
</script>
</body>
</html>
