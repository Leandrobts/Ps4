<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v15 - Original + Aprofundamento Interativo</title>
    <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
    </style>
</head>
<body>
    <h1>PoC v15 - Original + Aprofundamento Interativo</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="300" height="150"></canvas>
    <p>Fase 1: Executa o PoC Original (XSS, OOB, PP Básica, PP Hijack). Fase 2: Aprofunda análise com base nos resultados (Fingerprinting, Canvas, PP Avançada/Gadgets, Erros, Interações).</p>
    <button id="runBtn" onclick="runEverythingSequentially()">Iniciar Teste Completo (Fase 1 + Fase 2)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Teste OOB Original
        let canvasClickListener = null;
        let xssRanFlag = false; // Flag para interação com XSS

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... (implementação anterior) ... */ if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 1200000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 600000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro na função log:", e); outputDiv = null; } };

        // --- Helpers (toHex, Heurísticas) ---
        const toHex = (val, bits = 32) => { /* ... (implementação anterior) ... */ if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const isPotentialPointer64 = (high, low) => { /* ... (heurística original ou ajustada) ... */ if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; /* Não filtra EE aqui para log */ if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { /* ... (heurística original ou ajustada) ... */ if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false; /* Não filtra EE */ if (val < 0x1000) return false; return true; };

        // ==================================================
        // --- FASE 1: Testes Originais (do Script Inicial) ---
        // ==================================================
        log("Definindo Testes da Fase 1 (Originais)", "info");

        // Teste Original 1: CSP Bypass / XSS (com adição de flag)
        const originalTestCSPBypass = async () => {
            log("--- [Fase 1] Iniciando Teste Original 1: CSP Bypass / XSS ---", 'test');
            xssRanFlag = false; // Reseta flag
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { log("[Payload Data / Fase 1:] Alerta data: URI executado!", "vuln"); window.xssRanFlag = true; alert('XSS via Data URI! (Fase 1)'); } catch(e) { log("[Payload Data / Fase 1:] Alerta data: URI bloqueado: " + e.message, "good"); }`; // Seta flag
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("[Fase 1] ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("[Fase 1] Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`[Fase 1] Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) { target.innerHTML = '<h2 class="log-vuln">[Fase 1] XSS DOM via ONERROR Executado!</h2>'; }
                        log("[Fase 1] XSS DOM via onerror realizado!", "vuln");
                        window.xssRanFlag = true; // Seta flag
                        alert('XSS_DOM_ONERROR (Fase 1)');
                    } catch(e) { log("[Fase 1] Erro no payload onerror: " + e.message, "warn"); }`;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("[Fase 1] Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`[Fase 1] Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- [Fase 1] Teste Original 1 Concluído ---", 'test');
        };

        // Teste Original 2: OOB Write/Read Extensivo (Info Leak Aprimorado com Armazenamento)
        const originalTestOOBReadInfoLeak = async () => {
            log("--- [Fase 1] Iniciando Teste Original 2: OOB Write/Read (Armazena Leak) ---", 'test');
            log("AVISO: Tentará armazenar o primeiro valor U64/U32 'interessante' (não-padrão preenchimento) lido via OOB.", 'warn');
            const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = 32;
            const oobReadOffsets = []; for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false; let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Reseta

            try {
                const buffer = new ArrayBuffer(bufferSize + 256); const dataView = new DataView(buffer);
                const baseOffset = 128;
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } // Preenche com AA

                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress})...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`[Fase 1] VULN aparente: Escrita OOB U8 @${oobWriteOffset} permitida! (Valor: 0xEE)`, 'vuln'); // vuln aqui indica que a operação não deu erro
                    writeSuccess = true;
                } catch (e) {
                    log(`[Fase 1] BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good'); return false;
                }

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;
                    if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;
                    try { // Tenta ler U64
                        const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true);
                        const containsWrite = high === 0xAAAAAAAAEE || low === 0xAAAAAAAAEE; // Checa nosso padrão EE
                        if (isPotentialPointer64(high, low)) {
                            potentialLeakFoundCount++;
                            const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                            log(` [Fase 1] -> Potencial Ponteiro/Padrão? U64 @${readOffset}: ${valueStr}`, containsWrite ? 'leak' : 'ptr');
                            if (!containsWrite && leakedValueFromOOB === null) { // Armazena SÓ se NÃO for nosso padrão EE
                                leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset, phase: 1 };
                                log(` [Fase 1] -> VALOR U64 (não-padrão EE) ARMAZENADO (offset ${readOffset}).`, 'vuln');
                            }
                        }
                    } catch (e) {}
                    if (leakedValueFromOOB === null && readTargetAddress + 4 <= buffer.byteLength) { // Tenta ler U32 se U64 não armazenado
                         try {
                             const val32 = dataView.getUint32(readTargetAddress, true);
                             const containsWrite = val32 === 0xAAAAAAEE || val32 === 0xAAAAAAAAEE;
                             if (isPotentialData32(val32)) {
                                 potentialLeakFoundCount++;
                                 log(` [Fase 1] -> Leak/Padrão U32? @${readOffset}: ${toHex(val32, 32)}`, containsWrite ? 'leak' : 'leak');
                                 if (!containsWrite && leakedValueFromOOB === null) { // Armazena SÓ se NÃO for nosso padrão EE
                                     leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset, phase: 1 };
                                     log(` [Fase 1] -> VALOR U32 (não-padrão EE) ARMAZENADO (offset ${readOffset}).`, 'vuln');
                                 }
                             }
                         } catch(e) {}
                    }
                    if (readOffset % 64 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            } catch (e) { log(`[Fase 1] Erro inesperado OOB: ${e.message}`, 'error'); }
            log(`--- [Fase 1] Teste Original 2 Concluído (${potentialLeakFoundCount} leituras 'interessantes', ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} (não-EE) armazenado do offset ${leakedValueFromOOB.offset}` : 'nenhum valor não-EE armazenado'}) ---`, 'test');
            return writeSuccess;
        };

        // Teste Original 3: Prototype Pollution (Básica)
        const originalTestBasicPP = async () => {
            log("--- [Fase 1] Iniciando Teste Original 3: PP Básica ---", 'test');
            const testProp = '__pp_basic_test_orig__'; // Nome diferente para evitar colisão
            const testValue = 'PollutedOrig!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`[Fase 1] VULN: PP Básica confirmada!`, 'vuln'); success = true;
                } else { log(`[Fase 1] FALHA/BLOQUEADO: PP Básica não confirmada.`, 'good'); }
            } catch (e) { log(`[Fase 1] Erro PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; log(`[Fase 1] Limpeza de Object.prototype.${testProp} realizada.`, 'info'); }
                 catch(e){ log(`[Fase 1] Erro limpeza PP Básico: ${e.message}`, 'warn');}
            }
            log(`--- [Fase 1] Teste Original 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou/Bloqueada'}) ---`, 'test');
            return success;
        };

        // Teste Original 4: PP Hijack (JSON.stringify com Interação OOB)
        const originalTestPPJsonHijack = async () => {
            log("--- [Fase 1] Iniciando Teste Original 4: PP Hijack (JSON.stringify) ---", 'test');
            const originalStringify = JSON.stringify;
            let hijackSuccessful = false; let interactionSuccessful = false; let hijackReturnedCorrectly = false;
            try {
                log("Tentando sobrescrever JSON.stringify...", 'subtest');
                JSON.stringify = function hijackedStringifyOrig(value, replacer, space) {
                    log("[Fase 1] ===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! (Original) <===", 'vuln');
                    hijackSuccessful = true;
                    log(` [Fase 1] -> Hijack: Tentando aceder ao valor do Teste OOB Original...`, 'info');
                    try {
                        const leak = leakedValueFromOOB; // Acessa global da Fase 1
                        let leakStr = "NULO ou não armazenado (padrão EE?)";
                        if (leak && leak.phase === 1) { // Verifica se veio da Fase 1
                            leakStr = leak.type === 'U64' ? `U64 @${leak.offset}: H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 @${leak.offset}: ${toHex(leak.low)}`;
                            interactionSuccessful = true;
                        }
                        log(` [Fase 1] -> Hijack: Valor ARMAZENADO (não-EE) do Teste OOB é: ${leakStr}`, interactionSuccessful ? 'leak' : 'info');
                    } catch(interactionError) { log(` [Fase 1] -> Hijack: Erro ao aceder valor: ${interactionError.message}`, 'error'); interactionSuccessful = false; }
                    return `{"hijacked_phase1": true, "leak_accessed": ${interactionSuccessful}}`; // Marcador Fase 1
                };
                log("Testando a função JSON.stringify sequestrada...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const result = JSON.stringify({a: 1});
                log(`[Fase 1] Resultado retornado por JSON.stringify(): ${result}`, 'info');
                if (result && result.includes('"hijacked_phase1": true')) {
                    log("[Fase 1] VULN: Retorno da função sequestrada confirmado!", 'vuln'); hijackReturnedCorrectly = true;
                } else if (hijackSuccessful) { log("[Fase 1] AVISO: Hijack funcionou, mas retorno não foi o esperado.", 'warn');
                } else { log("[Fase 1] FALHA/BLOQUEADO: Sequestro não funcionou.", 'good'); }
            } catch (e) { log(`[Fase 1] Erro PP Hijack: ${e.message}`, 'error'); }
            finally { // CRÍTICO: Restaurar
                JSON.stringify = originalStringify; log("[Fase 1] Função JSON.stringify restaurada.", 'info');
                if (JSON.stringify === originalStringify && JSON.stringify({a:1}) === '{"a":1}') { log("[Fase 1] Restauração confirmada.", 'info'); }
                else { log("[Fase 1] ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error'); }
            }
            log(`--- [Fase 1] Teste Original 4 Concluído (PP Hijack ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou/Bloqueado'}) ---`, 'test');
            return hijackReturnedCorrectly;
        };

        // Função para rodar a Fase 1
        const runOriginalTests = async () => {
             log("==== [Fase 1] INICIANDO EXECUÇÃO DOS TESTES ORIGINAIS ====", 'critical');
             await originalTestCSPBypass(); // T1 com flag
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestOOBReadInfoLeak(); // T2 armazena leak (se não for EE)
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestBasicPP(); // T3
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestPPJsonHijack(); // T4 usa leak de T2
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             log("==== [Fase 1] EXECUÇÃO DOS TESTES ORIGINAIS CONCLUÍDA ====", 'critical');
             log(`==== [Fase 1] Estado Final: XSS Ran Flag = ${xssRanFlag}, Leaked OOB Value = ${leakedValueFromOOB ? JSON.stringify(leakedValueFromOOB) : 'null'} ====`,'info');
        }

        // ==================================================
        // --- FASE 2: Testes Adicionais Baseados em Evidências ---
        // ==================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");

        // Teste A: Coleta de Dados Básica (Equivalente ao Teste 5 anterior)
        const testBasicDataCollection = async () => { log("--- [Fase 2] Iniciando Teste A: Coleta Dados Básicos ---", 'test'); /* ... (código Teste 5 anterior) ... */ log("--- [Fase 2] Teste A Concluído ---", 'test'); };
        // Teste B: Sondagem do Ambiente (WebView/PWA) (Equivalente ao Teste 10 anterior)
        const testEnvironmentProbing = async () => { log("--- [Fase 2] Iniciando Teste B: Sondagem Ambiente ---", 'test'); /* ... (código Teste 10 anterior) ... */ log("--- [Fase 2] Teste B Concluído ---", 'test'); };
        // Teste C: Fingerprinting Avançado (Audio/Canvas Text) (Equivalente ao Teste 7 anterior)
        const testAdvancedFingerprinting = async () => { log("--- [Fase 2] Iniciando Teste C: Fingerprinting Avançado ---", 'test'); /* ... (código Teste 7 anterior) ... */ log("--- [Fase 2] Teste C Concluído ---", 'test'); };
        // Teste D: Canvas 2D Avançado e Quirks (Equivalente ao Teste 11 anterior)
        const testAdvancedCanvas = async () => { log("--- [Fase 2] Iniciando Teste D: Canvas Avançado/Quirks ---", 'test'); /* ... (código Teste 11 anterior, pode adicionar leitura de leakedValueFromOOB aqui se desejado) ... */ try{const c=fingerprintCanvas;const ctx=c.getContext('2d'); if(ctx && leakedValueFromOOB){ctx.fillStyle='#FFF'; ctx.font='10px monospace'; ctx.fillText(`OOB(F1): ${leakedValueFromOOB.type}@${leakedValueFromOOB.offset}`,5,c.height-5);} }catch(e){} log("--- [Fase 2] Teste D Concluído ---", 'test'); };
        // Teste E: Canvas 2D Interativo e Stress (Equivalente ao Teste 12 anterior, com interação flags)
        const testInteractiveCanvas = async () => { log("--- [Fase 2] Iniciando Teste E: Canvas Interativo/Stress ---", 'test'); /* ... (código Teste 12 anterior, ajustar handler de clique para usar xssRanFlag global) ... */ if(canvasClickListener&&fingerprintCanvas){try{fingerprintCanvas.removeEventListener('click',canvasClickListener);}catch(e){}} canvasClickListener=(event)=>{ /* ... cálculo x,y ... */ let area='fora'; /* ... if/else áreas ... */ log(`[Fase 2] Canvas Click! Área: ${area}. (Flag XSS Fase 1: ${xssRanFlag})`, 'info');}; try{fingerprintCanvas.addEventListener('click',canvasClickListener); log("[Fase 2] Listener 'click' adicionado.",'info');}catch(e){} /* ... stress tests ... */ log("--- [Fase 2] Teste E Concluído ---", 'test'); };
        // Teste F: Observação de Erros Detalhada (Equivalente ao Teste 8 anterior)
        const testErrorObservation = async () => { log("--- [Fase 2] Iniciando Teste F: Observação Erros ---", 'test'); /* ... (código Teste 8 anterior) ... */ log("--- [Fase 2] Teste F Concluído ---", 'test'); };
        // Teste J: PP Avançada (`__proto__`, Array) (Equivalente ao Teste 6 anterior)
        const testAdvancedPP = async () => { log("--- [Fase 2] Iniciando Teste J: PP Avançada ---", 'test'); /* ... (código Teste 6 anterior) ... */ log("--- [Fase 2] Teste J Concluído ---", 'test'); };
        // Teste K: Tentativas de PP Gadget Especulativo (Equivalente ao Teste 9 anterior + mais)
        const testPPGadgetAttempts = async () => { log("--- [Fase 2] Iniciando Teste K: PP Gadgets Especulativos ---", 'test'); /* ... (código Teste 9/K anterior com random etc) ... */ log("--- [Fase 2] Teste K Concluído ---", 'test'); };

        // Função para rodar a Fase 2
        const runNewTests = async () => {
            log("==== [Fase 2] INICIANDO EXECUÇÃO DOS TESTES ADICIONAIS ====", 'critical');
            log("INFO: Testes da Fase 2 podem usar resultados da Fase 1 (ex: OOB Leak, Flag XSS)", "info");

            // Ordem da Fase 2: Fingerprinting -> Canvas -> Erros -> PP Avançada
            await testBasicDataCollection(); // A
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testEnvironmentProbing(); // B
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedFingerprinting(); // C
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testAdvancedCanvas(); // D (Pode ler OOB)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testInteractiveCanvas(); // E (Lê flag XSS)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testErrorObservation(); // F
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Executar PP avançada sabendo que a básica funciona
            await testAdvancedPP(); // J
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPGadgetAttempts(); // K
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("==== [Fase 2] EXECUÇÃO DOS TESTES ADICIONAIS CONCLUÍDA ====", 'critical');
        }

        // --- Função Principal para Rodar Tudo ---
        const runEverythingSequentially = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v15 (Fase 1 Original + Fase 2 Aprofundamento) ====", 'critical');

            // Executa Fase 1
            await runOriginalTests();

             log("\n pausa antes da fase 2...\n", "warn");
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE * 2)); // Pausa maior entre fases


            // Executa Fase 2
            await runNewTests();


            log("\n==== PoC Final v15 CONCLUÍDA (Fase 1 + Fase 2) ====", 'critical');
            log("Listener de clique do Canvas da Fase 2 pode continuar ativo.", "warn");
            if (runBtn) runBtn.disabled = false;
        };


        // Limpeza do listener do canvas
        window.addEventListener('unload', () => {
            if (canvasClickListener && fingerprintCanvas) {
                 try { fingerprintCanvas.removeEventListener('click', canvasClickListener); } catch(e){}
            }
        });

        // document.addEventListener('DOMContentLoaded', runEverythingSequentially); // Para rodar automaticamente
    </script>

</body>
</html>
