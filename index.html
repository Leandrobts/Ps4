<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Foco: Teste de Vazamento de Ponteiro U64</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; } /* Rosa para ponteiros */
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Foco: Teste de Vazamento de Ponteiro U64 (Adaptado do Teste 2 Original)</h1>
    <p>Este script foca na tentativa de escrita OOB e na subsequente leitura para identificar potenciais ponteiros U64 na memória.</p>
    <button id="runBtn" onclick="runFocusedTest()">Iniciar Teste de Vazamento de Ponteiro U64</button>
    <div id="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // Pausa curta em milissegundos
        const MEDIUM_PAUSE = 200; // Pausa média em milissegundos

        // Tipos de log importantes a serem mantidos (para este script focado)
        const IMPORTANT_LOG_TYPES = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good', 'warn', 'info'];

        const log = (message, type = 'info', funcName = '') => {
            // Para este script focado, vamos tentar manter mais logs para análise detalhada
            let keepLog = IMPORTANT_LOG_TYPES.includes(type);

            if (!outputDiv) {
                console.log(`[${type.toUpperCase()}] ${funcName ? `[${funcName}] ` : ''}${message}`);
                return;
            }
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                // Sanitiza a mensagem para evitar XSS se a mensagem vier de fontes não confiáveis
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';

                // Limita o tamanho do log para evitar sobrecarga do navegador
                if (outputDiv.innerHTML.length > 800000) { // Aumentado um pouco o limite
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 400000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }

                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight; // Auto-scroll para o final
            } catch (e) {
                console.error("Erro ao logar:", e);
                if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`;
            }
        };

        const PAUSE = (ms = SHORT_PAUSE) => new Promise(resolve => setTimeout(resolve, ms));

        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { // Para números de 32 bits, trata como unsigned
                num = num >>> 0;
            }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };

        // Função para verificar se um par de valores (high, low) pode ser um ponteiro de 64 bits
        // Esta é uma heurística e pode precisar de ajustes.
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            // Exclui ponteiros nulos ou comuns de preenchimento/erro
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; // Ex: 0xFFFFFFFFFFFFFFFF
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Padrão de preenchimento comum
            if (high === 0xABABABAB && low === 0xABABABAB) return false;
            if (high === 0xCDCDCDCD && low === 0xCDCDCDCD) return false;
            if (high === 0xDDDDDDDD && low === 0xDDDDDDDD) return false;
            // Ponteiros para endereços muito baixos (ex: abaixo de 1MB) são frequentemente inválidos ou menos interessantes
            // mas isso depende muito da arquitetura e do sistema alvo. Para o PS4, isso pode ser relevante.
            // O log original mostrou H=0xAAAAAAAA L=0xAAAAAAAA como vazado, então a regra acima pode ter sido muito estrita no original.
            // Vamos ajustar com base no que foi efetivamente logado como PTR no PS4.
            // No log do PS4, H=0xAAAAAAAA L=0xAAAAAAAA foi classificado como ponteiro. Isso sugere que os padrões de preenchimento
            // podem ser ponteiros válidos em certos contextos ou que a checagem isPotentialPointer64 original era diferente.
            // Para este script focado, vamos ser um pouco mais permissivos na exibição, mas marcando claramente.

            // Uma heurística comum é que ponteiros válidos geralmente não apontam para endereços muito baixos (ex: < 0x10000 ou < 0x100000)
            // nem para o topo absoluto da memória, a menos que específicos.
            // if (high === 0 && low < 0x100000) return false; // Exclui ponteiros para o início da memória
            // A heurística original era: if (high === 0 && low < 0x100000) return false;
            // E também: if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false;
            // O fato do log do PS4 ter marcado 0xAAAA... como ponteiro é o mais intrigante.

            // Vamos logar mais e deixar a análise visual decidir por agora.
            // Se um valor como 0xAAAAAAAAAAAAAAA foi de fato um ponteiro válido no contexto do PS4,
            // a função original isPotentialPointer64 teria que ser mais permissiva ou o valor foi interpretado
            // incorretamente como padrão de preenchimento no momento da criação do script original.

            // Retornando true para a maioria dos não nulos para máxima informação, com log detalhado.
            return true;
        };

        // Função para verificar se um valor de 32 bits pode ser um dado interessante (não um ponteiro óbvio de 64 bits)
        const isPotentialData32 = (val) => {
            if (val === null || typeof val !== 'number') return false;
            val = val >>> 0; // Trata como unsigned
            if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
            if (val < 0x1000) return false; // Dados muito pequenos
            return true;
        };

        const focusTestU64PointerLeak = async () => {
            const FNAME = 'focusTestU64PointerLeak';
            log("--- Iniciando Teste Focado: Vazamento de Ponteiro U64 ---", 'test', FNAME);

            const bufferSize = 32;        // Tamanho nominal do buffer
            const writeValue = 0xEE;      // Valor a ser escrito OOB
            const oobWriteOffset = bufferSize; // Offset para a escrita OOB (imediatamente após o buffer)

            // Faixa de leitura: ler antes, dentro e depois do buffer nominal.
            // Aumentar a faixa pode revelar mais, mas também demora mais.
            // O log do PS4 mostrou @28, que está dentro do bufferSize=32 se o offset for relativo ao início do buffer de dados.
            // Se o baseOffsetInBuffer for usado, a interpretação muda. No script original, era baseOffsetInBuffer + readOffset.
            const readRangeStart = -128;  // Início da varredura de leitura (relativo ao baseOffsetInBuffer)
            const readRangeEnd = bufferSize + 128; // Fim da varredura de leitura

            // Tamanho da alocação do ArrayBuffer. Deve ser grande o suficiente para conter
            // o buffer de trabalho e a área de leitura OOB.
            const allocationSize = bufferSize + 256; // Tamanho do ArrayBuffer real
            const baseOffsetInBuffer = 128; // Offset dentro do ArrayBuffer onde nosso "buffer de trabalho" começa

            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            let foundPointersList = [];

            try {
                log(`Alocando ArrayBuffer de ${allocationSize} bytes.`, 'info', FNAME);
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);

                log(`Preenchendo ArrayBuffer com 0xAA...`, 'info', FNAME);
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xAA);
                }

                // Endereço absoluto dentro do ArrayBuffer para a escrita OOB
                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;
                log(`Tentando escrita OOB U8 (valor ${toHex(writeValue, 8)}) no endereço ${writeTargetAddress} (baseOffset ${baseOffsetInBuffer} + oobWriteOffset ${oobWriteOffset})`, 'info', FNAME);

                await PAUSE();

                try {
                    // Verifica se o endereço de escrita está dentro dos limites do ArrayBuffer alocado
                    // Esta é uma escrita "OOB" em relação ao 'bufferSize' lógico, mas dentro do 'allocationSize' físico.
                    if (writeTargetAddress >= 0 && writeTargetAddress < dataView.byteLength) {
                        dataView.setUint8(writeTargetAddress, writeValue);
                        log(`SUCESSO: Escrita OOB U8 @${oobWriteOffset} (endereço absoluto ${writeTargetAddress}) parece OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                        log(`---> Primitivo de Escrita OOB Simples (U8) confirmado.`, 'escalation', FNAME);
                        writeSuccess = true;
                    } else {
                        log(`ERRO: Endereço de escrita OOB (${writeTargetAddress}) está fora dos limites do ArrayBuffer alocado (${dataView.byteLength}). Escrita não realizada.`, 'error', FNAME);
                        writeSuccess = false;
                    }
                } catch (e) {
                    log(`FALHA/BLOQUEIO: Escrita OOB U8 @${oobWriteOffset} (endereço ${writeTargetAddress}) falhou: ${e.message}`, 'good', FNAME);
                    log("--- Teste Concluído (Escrita OOB Falhou, não é possível prosseguir com a leitura dependente) ---", 'test', FNAME);
                    return; // Não adianta ler se a escrita de marcação falhou
                }

                await PAUSE();
                log("--- Iniciando Varredura de Leitura para Ponteiros U64 ---", 'info', FNAME);
                log(`Faixa de leitura relativa ao baseOffset (${baseOffsetInBuffer}): de ${readRangeStart} a ${readRangeEnd-1} (passo de 4 bytes).`, 'info', FNAME);

                for (let readOffset = readRangeStart; readOffset < readRangeEnd; readOffset += 4) {
                    // Endereço absoluto dentro do ArrayBuffer para a leitura
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@${readOffset} (abs ${readTargetAddress})`;

                    // Verifica se estamos lendo dentro dos limites do ArrayBuffer para U64 (8 bytes)
                    if (readTargetAddress >= 0 && (readTargetAddress + 8) <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true);     // Little-endian
                            const high = dataView.getUint32(readTargetAddress + 4, true); // Little-endian

                            if (isPotentialPointer64(high, low)) {
                                const vStr = `H=${toHex(high)} L=${toHex(low)}`;
                                // O log do PS4 mostrou H=0xAAAAAAAA L=0xAAAAAAAA @28 (addr 156)
                                // baseOffset = 128. 128 + 28 = 156. Então o @28 é o readOffset.
                                if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) {
                                    log(`!!! PADRÃO OBSERVADO NO PS4 ENCONTRADO !!! U64 ${relOffsetStr}: ${vStr}`, 'critical', FNAME);
                                }

                                log(` -> POTENCIAL PONTEIRO U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++;
                                foundPointersList.push({offset: readOffset, absoluteAddress: readTargetAddress, high: toHex(high), low: toHex(low)});

                                // Log de contexto (similar ao original)
                                log(` ---> INSIGHT: O valor vazado ${vStr} (tipo U64) em ${relOffsetStr} é um candidato a ponteiro. Para contornar o ASLR, seria necessário analisar este valor e a memória ao redor dele (usando uma primitiva de leitura arbitrária mais poderosa, se disponível, para dereferenciar este ponteiro caso ele aponte para fora deste buffer) para identificar um endereço base de um módulo carregado ou uma estrutura de dados conhecida.`, 'info', FNAME);

                            }
                        } catch (e) {
                            // Ignora erros de leitura fora do buffer, pois estamos testando OOB.
                            // Esses erros são esperados se readTargetAddress + 8 ultrapassar buffer.byteLength
                            // log(`Aviso: Erro ao ler U64 em ${relOffsetStr}: ${e.message}`, 'warn', FNAME);
                        }
                    }

                    // Leitura de U32 para comparação ou dados adicionais (como no script original)
                    if (readTargetAddress >= 0 && (readTargetAddress + 4) <= buffer.byteLength) {
                        try {
                            const val32 = dataView.getUint32(readTargetAddress, true);
                            if (isPotentialData32(val32)) {
                                // Evitar logar novamente se já foi parte de um U64 potencial no mesmo offset
                                let partOfU64 = foundPointersList.some(p => p.absoluteAddress === readTargetAddress && p.low === toHex(val32));
                                if (!partOfU64) {
                                     // log(` -> Potencial Dado U32 ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME);
                                }
                            }
                            // Verifica se o valor escrito (0xEE) pode ser lido de volta (como parte de um U32)
                            if (writeSuccess && readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) {
                                log(` -> Leu valor OOB escrito (${toHex(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME);
                            } else if (writeSuccess && readOffset === oobWriteOffset && val32 !== (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) {
                                log(` -> Leu valor diferente do esperado no local da escrita OOB ${relOffsetStr}. LIDO: ${toHex(val32)}, ESPERADO (com preenchimento AA): ${toHex(writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))}`, 'warn', FNAME);
                            }


                        } catch (e) {
                            //log(`Aviso: Erro ao ler U32 em ${relOffsetStr}: ${e.message}`, 'warn', FNAME);
                        }
                    }

                    if (readOffset % 32 === 0) { // Pequena pausa a cada X leituras para não travar o navegador
                        await PAUSE(1);
                    }
                }

            } catch (e) {
                log(`Erro fatal no Teste Focado: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                const leakStatus = foundPointersList.length > 0
                    ? `${foundPointersList.length} ponteiro(s) U64 potenciais encontrados. O primeiro foi em offset rel ${foundPointersList[0].offset} (H=${foundPointersList[0].high} L=${foundPointersList[0].low})`
                    : 'Nenhum ponteiro U64 óbvio encontrado com os critérios atuais.';
                log(`--- Teste Focado Concluído (${potentialLeakFoundCount} leaks U64 potenciais, ${leakStatus}) ---`, 'test', FNAME);
                if(foundPointersList.length > 0){
                    log("Lista de Ponteiros U64 Potenciais Encontrados:", 'info', FNAME);
                    foundPointersList.forEach(p => {
                        log(`  Offset Rel: ${p.offset}, Endereço Abs: ${p.absoluteAddress}, High: ${p.high}, Low: ${p.low}`, 'ptr', FNAME);
                    });
                }
            }
        };

        const runFocusedTest = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = ''; // Limpa o log anterior
            log("==== INICIANDO TESTE FOCADO DE VAZAMENTO DE PONTEIRO U64 ====", 'test', 'Main');
            await focusTestU64PointerLeak();
            log("\n==== TESTE FOCADO CONCLUÍDO ====", 'test', 'Main');
            if (runBtn) runBtn.disabled = false;
        };

    </script>
</body>
</html>
