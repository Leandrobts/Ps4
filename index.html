<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v16 - Tentativa de Execução Fase 1 Original</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        /* ... (restante dos estilos) ... */
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>PoC v16 - Tentativa de Execução Fase 1 Original</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
    <p>Tentativa de rodar Fase 1 (Original com alerts) integralmente, depois Fase 2 (Aprofundamento).</p>
    <button id="runBtn" onclick="runEverything()">Iniciar Teste Completo</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const coordStatusDiv = document.getElementById('canvas-coord-status');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        const LONG_PAUSE = 3000; // Pausa longa entre fases
        let leakedValueFromOOB = null;
        let canvasClickListener = null;
        let canvasMoveListener = null;
        let xssRanFlag = false;
        let rectArea = { x: 10, y: 10, w: 30, h: 30 }; // Global p/ Canvas Listener
        let linkArea = { x: 150, y: 100, w: 60, h: 30 }; // Global p/ Canvas Listener

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... (implementação completa) ... */ };

        // --- Helpers (toHex, Heurísticas) ---
        const toHex = (val, bits = 32) => { /* ... (implementação completa) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (heurística original) ... */ };
        const isPotentialData32 = (val) => { /* ... (heurística original) ... */ };


        // ========================================================
        // --- FASE 1: Código Original (Exatamente como Msg 1) ---
        // ========================================================
        log("Definindo Funções Originais da Fase 1", "info");

        // Funções originais T1, T2, T3, T4 (com alerts em T1)
        // Nota: Renomeadas para evitar conflito se o original usasse nomes genéricos
        const original_testCSPBypass = async () => {
            log("--- [F1 Orig] Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            xssRanFlag = false; // Reseta flag no início do teste original
             // ... (Código EXATO de testCSPBypass da primeira mensagem, incluindo alerts) ...
             log("Tentando XSS via data: URI (alert)...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE)); try { const p=`try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); window.xssRanFlag=true; } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`; const s=document.createElement('script');s.src='data:text/javascript;base64,'+btoa(p); s.onerror=()=>{log("ERRO data URI!","error");}; document.body.appendChild(s);log("Tag <script> data: URI adicionada.",'info');}catch(e){log(`Erro data URI: ${e.message}`,'error');}
             await new Promise(r=>setTimeout(r,SHORT_PAUSE*2));
             log("Tentando XSS DOM via inline handler (onerror)...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE)); try { const i=document.createElement('img');i.src='invalid_'+Date.now(); const p=` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>'; log("XSS DOM via onerror realizado!", "vuln"); } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); } window.xssRanFlag=true; alert('XSS_DOM_ONERROR'); } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); } `; i.setAttribute('onerror',p); document.body.appendChild(i);log("Tag <img> com onerror adicionada.",'info');} catch(e){log(`Erro img onerror: ${e.message}`,'error');}
             // Não havia log de conclusão explícito no original, mas adicionamos pausa
             await new Promise(r => setTimeout(r, MEDIUM_PAUSE)); // Pausa para dar chance ao onerror
             log("--- [F1 Orig] Teste 1 Concluído (aparentemente) ---", 'test');
        };

        const original_testOOBReadInfoLeakEnhancedStore = async () => {
             log("--- [Fase 1] Iniciando Teste 2: OOB Write/Read Extensivo ---", 'test');
             // ... (Código EXATO de testOOBReadInfoLeakEnhancedStore da primeira mensagem) ...
             // Inclui a lógica original de armazenamento em leakedValueFromOOB
             // ...
             log("--- [Fase 1] Teste 2 Concluído (aparentemente) ---", 'test');
             return true; // Adicionado para async/await
        };

        const original_testBasicPP = async () => {
             log("--- [Fase 1] Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
             // ... (Código EXATO de testBasicPP da primeira mensagem) ...
             // ...
             log("--- [Fase 1] Teste 3 Concluído (aparentemente) ---", 'test');
             return true; // Adicionado para async/await
        };

        const original_testPPJsonHijack = async () => {
             log("--- [Fase 1] Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
             // ... (Código EXATO de testPPJsonHijack da primeira mensagem) ...
             // ...
             log("--- [Fase 1] Teste 4 Concluído (aparentemente) ---", 'test');
             return true; // Adicionado para async/await
        };

        // Função original que chamava os testes (renomeada)
        const runPhase1_Original = async () => {
             log("==== [Fase 1] INICIANDO runPhase1_Original ====", 'critical');
             // Chamadas EXATAS como no runAllTests original
             await original_testCSPBypass();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await original_testOOBReadInfoLeakEnhancedStore();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await original_testBasicPP();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await original_testPPJsonHijack();
             // Fim das chamadas originais
             log("==== [Fase 1] runPhase1_Original CONCLUÍDA ====", 'critical');
             log(`==== [Fase 1] Estado Pós-Fase 1: xssFlag=${xssRanFlag}, OOB=${leakedValueFromOOB?'Stored':'null'} ====`,'info');
        };


        // ==========================================================
        // --- FASE 2: Testes Adicionais Isolados ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");

        // Definições dos testes A, B, C, F, J, K, D/E Combinado
        // (Usando as implementações da v15.5, que incluem interações
        // como ler xssRanFlag e leakedValueFromOOB)
        const testBasicDataCollection = async () => { log("--- [Fase 2] A: Coleta Dados Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] A: Coleta Dados Concluído ---", 'test'); };
        const testEnvironmentProbing = async () => { log("--- [Fase 2] B: Sondagem Ambiente Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] B: Sondagem Ambiente Concluído ---", 'test'); };
        const testAdvancedFingerprinting = async () => { log("--- [Fase 2] C: Fingerprinting Adv Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] C: Fingerprinting Adv Concluído ---", 'test'); };
        const testErrorObservation = async () => { log("--- [Fase 2] F: Observação Erros Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] F: Observação Erros Concluído ---", 'test'); };
        const testAdvancedPP = async () => { log("--- [Fase 2] J: PP Avançada Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] J: PP Avançada Concluído ---", 'test'); };
        const testPPGadgetAttempts = async () => { log("--- [Fase 2] K: PP Gadgets Iniciando ---", 'test'); /* ... */ log("--- [Fase 2] K: PP Gadgets Concluído ---", 'test'); };
        const testComprehensiveCanvas = async () => { log("--- [Fase 2] D/E: Canvas Completo Iniciando ---", 'test'); /* ... (Código D/E combinado v15.5, sem stress desenho) ... */ log("--- [Fase 2] D/E: Canvas Completo Concluído ---", 'test'); };


        // Função para rodar a Fase 2
        const runPhase2_NewTests = async () => {
            log("==== [Fase 2] INICIANDO runPhase2_NewTests ====", 'critical');
            // Ordem pode ser ajustada, mas executa todos os testes da Fase 2
            await testBasicDataCollection(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // A
            await testEnvironmentProbing(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // B
            await testAdvancedFingerprinting(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // C
            await testErrorObservation(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // F
            await testAdvancedPP(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // J
            await testPPGadgetAttempts(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // K
            await testComprehensiveCanvas(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // D/E Combinado
            log("==== [Fase 2] runPhase2_NewTests CONCLUÍDA ====", 'critical');
        }


        // --- Função Principal ---
        const runEverything = async () => { // Renomeada para clareza
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v16 (Original Primeiro) ====", 'critical');

            log(">>> Iniciando Fase 1 (Testes Originais) <<<", 'warn');
            // Não usamos try/catch aqui para manter o comportamento original fielmente
            // Se a Fase 1 travar, a Fase 2 não será chamada.
            await runPhase1_Original();
            log(">>> Fase 1 (runPhase1_Original) CONCLUÍDA (aparentemente) <<<", 'warn');


            log("\n>>> PAUSA LONGA ANTES DA FASE 2 (3 segundos) <<<\n", "warn");
            await new Promise(r => setTimeout(r, LONG_PAUSE)); // Pausa longa


            log(">>> Iniciando Fase 2 (Testes Adicionais) <<<", 'warn');
            await runPhase2_NewTests();
            log(">>> Fase 2 (runPhase2_NewTests) CONCLUÍDA <<<", 'warn');


            log("\n==== PoC Final v16 CONCLUÍDA (Fase 1 + Fase 2) ====", 'critical');
            // O resumo final foi removido por enquanto para focar na execução
            log("Listeners podem continuar ativos.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza listeners
        window.addEventListener('unload', () => { /* ... */ });
        // document.addEventListener('DOMContentLoaded', runEverything);

    </script>

</body>
</html>
