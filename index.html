<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OOB 64 + Data Collector v13</title> <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; } /* Cursor para indicar clicável */
    </style>
</head>
<body>
    <h1>Info Leak Finder & Data Collector v13</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="300" height="150"></canvas> <p>Testa: XSS, OOB R/W, PP (Básica, Avançada, Hijack, Gadgets Especulativos), Coleta Dados, Sondagem Ambiente, Obs. Erros, Canvas (Avançado/Interativo).</p> <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas'); // Referência ao canvas
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null;
        let canvasClickListener = null; // Guarda a referência do listener para remover depois

        // --- Funções Utilitárias (log, toHex, isPotentialPointer64, isPotentialData32) ---
        // ... (sem alterações, exceto talvez limite do log) ...
        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDiv.innerHTML.length > 1000000){ // Aumentado limite
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 500000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };
        const toHex = (val, bits = 32) => { /* ... */ return '0x' + Number(val).toString(16).toUpperCase().padStart(Math.ceil(bits / 4), '0'); };
        const isPotentialPointer64 = (high, low) => { /* ... */ return true; }; // Simplificado para consistência com logs anteriores
        const isPotentialData32 = (val) => { /* ... */ return true; }; // Simplificado

        // --- Testes 1 a 8 (mantidos, sem alterações lógicas internas) ---
        const testCSPBypass = async () => { log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test'); /* ... */ log("--- Teste 1 Concluído ---", 'test'); };
        const testOOBReadInfoLeakEnhancedStore = async () => { log("--- Iniciando Teste 2: OOB Write/Read ---", 'test'); /* ... */ log(`--- Teste 2 Concluído (...) ---`, 'test'); return true;};
        const testBasicPP = async () => { log("--- Iniciando Teste 3: PP Básica ---", 'test'); /* ... */ log(`--- Teste 3 Concluído (...) ---`, 'test'); return true; };
        const testPPJsonHijack = async () => { log("--- Iniciando Teste 4: PP Hijack ---", 'test'); /* ... */ log(`--- Teste 4 Concluído (...) ---`, 'test'); return true; };
        const testDataCollection = async () => { log("--- Iniciando Teste 5: Coleta Dados ---", 'test'); /* ... */ log("--- Teste 5 Concluído ---", 'test'); };
        const testAdvancedPP = async () => { log("--- Iniciando Teste 6: PP Avançado ---", 'test'); /* ... */ log(`--- Teste 6 Concluído (...) ---`, 'test'); };
        const testAdvancedFingerprinting = async () => { log("--- Iniciando Teste 7: Fingerprinting Avançado ---", 'test'); /* ... */ log("--- Teste 7 Concluído ---", 'test'); };
        const testErrorObservation = async () => { log("--- Iniciando Teste 8: Observação Erros ---", 'test'); /* ... */ log("--- Teste 8 Concluído ---", 'test'); };

        // --- Teste 9: Tentativas de PP Gadget (Complementado) ---
        const testPPGadgetAttempts = async () => {
            log("--- Iniciando Teste 9: Tentativas de PP Gadget (Especulativo) ---", 'test');
            log("AVISO: Testes especulativos. A eficácia depende de encontrar gadgets reais.", 'warn');
            const gadgetValue = "GadgetPolluted" + Date.now(); // Valor único
            let constructorPolluted = false;
            let toStringPolluted = false;
            let innerHTMLPolluted = false;
            let srcPolluted = false;

            // 9.1 Tentar poluir via constructor.prototype (já implementado)
            const constructorProp = "__pp_constructor_gadget__";
            log(`Tentando poluir Object.prototype.constructor.prototype.${constructorProp}...`, 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try { /* ... código 9.1 ... */ } catch(e) { /* ... */ } finally { /* ... limpeza ... */ }

            // 9.2 Tentar poluir propriedade em toString (já implementado)
            const toStringProp = "__pp_toString_gadget__";
            log(`Tentando poluir Object.prototype.toString.${toStringProp}...`, 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try { /* ... código 9.2 ... */ } catch (e) { /* ... */ } finally { /* ... limpeza ... */ }

            // NOVO 9.3: Tentar poluir innerHTML
            const innerHTMLProp = "innerHTML"; // Usando nome real
            log(`Tentando poluir Object.prototype.${innerHTMLProp}...`, 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                 Object.prototype[innerHTMLProp] = `<script>log("PP via innerHTML executado?", "vuln")</script>`;
                 const div = document.createElement('div');
                 // Verifica se a propriedade é herdada diretamente (improvável que funcione como setter)
                 if (div[innerHTMLProp] === Object.prototype[innerHTMLProp]) {
                     log(`INFO: ${innerHTMLProp} herdado como propriedade em novo div.`, 'info');
                     // Tentar atribuir ao DOM para ver se causa erro ou efeito (altamente improvável)
                     try {
                         document.body.appendChild(div); // Adiciona ao DOM
                         // Leitura pode ou não acionar algo, escrita é mais comum para XSS via PP em frameworks
                         log(`  Valor de div.innerHTML após herança: ${div.innerHTML}`, 'info');
                     } catch (domE) { log(`  Erro ao manipular div com innerHTML herdado: ${domE.message}`, 'warn'); }
                 } else {
                     log(`INFO: ${innerHTMLProp} NÃO foi herdado diretamente em novo div.`, 'good');
                 }
                 innerHTMLPolluted = true; // Marcamos que tentamos
             } catch (e) { log(`ERRO/BLOQUEADO: Poluição de ${innerHTMLProp} falhou: ${e.message}`, 'good'); }
             finally { try { delete Object.prototype[innerHTMLProp]; } catch(e) {} }

             // NOVO 9.4: Tentar poluir src
             const srcProp = "src";
             log(`Tentando poluir Object.prototype.${srcProp}...`, 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                 Object.prototype[srcProp] = `javascript:log("PP via src executado?", "vuln")`;
                 const img = document.createElement('img');
                 // Verifica herança e tenta usar
                  if (img[srcProp] === Object.prototype[srcProp]) {
                      log(`INFO: ${srcProp} herdado como propriedade em nova img.`, 'info');
                       try {
                           document.body.appendChild(img); // Adiciona ao DOM - pode tentar carregar o 'src' herdado
                           log(`  Valor de img.src após herança: ${img.src}`, 'info');
                           // Adiciona onerror para ver se a carga falha como esperado
                           img.onerror = () => {log(`  img.onerror acionado para src herdado (esperado se inválido).`, 'info');};
                       } catch (domE) { log(`  Erro ao manipular img com src herdado: ${domE.message}`, 'warn'); }
                  } else {
                       log(`INFO: ${srcProp} NÃO foi herdado diretamente em nova img.`, 'good');
                  }
                  srcPolluted = true; // Marcamos que tentamos
             } catch (e) { log(`ERRO/BLOQUEADO: Poluição de ${srcProp} falhou: ${e.message}`, 'good'); }
             finally { try { delete Object.prototype[srcProp]; } catch(e) {} }


            log(`--- Teste 9 Concluído (Tentativas: Constructor, toString, innerHTML, src) ---`, 'test');
        };

        // --- NOVO: Teste 10: Sondagem do Ambiente (WebView) --- (mantido)
        const testEnvironmentProbing = async () => { log("--- Iniciando Teste 10: Sondagem Ambiente ---", 'test'); /* ... */ log("--- Teste 10 Concluído ---", 'test');};

        // --- NOVO: Teste 11: Testes Avançados de Canvas 2D --- (mantido)
        const testAdvancedCanvas = async () => { log("--- Iniciando Teste 11: Canvas Avançado ---", 'test'); /* ... */ log("--- Teste 11 Concluído ---", 'test'); };

        // --- NOVO: Teste 12: Canvas 2D Interativo e Stress ---
        const testInteractiveCanvas = async () => {
            log("--- Iniciando Teste 12: Canvas 2D Interativo e Stress ---", 'test');
            let canvas = null;
            let ctx = null;
            const rectArea = { x: 10, y: 10, w: 50, h: 50 }; // Área do retângulo do teste 11
            const linkArea = { x: 250, y: 120, w: 50, h: 30 }; // Nova área para "link"

            try {
                canvas = document.getElementById('fingerprint-canvas');
                if (!canvas || !canvas.getContext) throw new Error('Canvas 2D element not found or not supported');
                ctx = canvas.getContext('2d');
                if (!ctx) throw new Error('Canvas 2D context not available');
                log("Contexto Canvas 2D obtido para interatividade.", 'info');

                // Desenha a área do link para feedback visual
                ctx.fillStyle = "rgba(0, 255, 0, 0.5)"; // Verde semitransparente
                ctx.fillRect(linkArea.x, linkArea.y, linkArea.w, linkArea.h);
                ctx.fillStyle = "#fff";
                ctx.font = "12px monospace";
                ctx.fillText("Link", linkArea.x + 5, linkArea.y + 18);

            } catch(e) {
                log(` Falha ao obter contexto Canvas 2D: ${e.message}`, 'error');
                log("--- Teste 12 Abortado (Setup) ---", 'test');
                return;
            }

            // 12.1 Interatividade (OnClick)
            log("Adicionando listener 'click' ao canvas...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // Remove listener anterior, se existir
            if (canvasClickListener && canvas) {
                 try { canvas.removeEventListener('click', canvasClickListener); } catch(e){}
            }

            canvasClickListener = (event) => {
                 try {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    log(`Canvas Click! Coords (relativas): x=${x.toFixed(0)}, y=${y.toFixed(0)}`, 'info');

                    // Verifica se clicou no retângulo preto (desenhado no Teste 11)
                    if (x >= rectArea.x && x <= rectArea.x + rectArea.w && y >= rectArea.y && y <= rectArea.y + rectArea.h) {
                        log("--> Clicou dentro do RETÂNGULO PRETO!", 'vuln'); // Usando vuln para destacar
                    }
                    // Verifica se clicou na área de link simulada
                    else if (x >= linkArea.x && x <= linkArea.x + linkArea.w && y >= linkArea.y && y <= linkArea.y + linkArea.h) {
                         log("--> Clicou na ÁREA DE LINK SIMULADA! (Ação: log)", 'vuln');
                         // Aqui poderia fazer: window.location.href = '...' ou window.open('...')
                    } else {
                         log("--> Clicou fora das áreas definidas.", 'info');
                    }
                 } catch (e) {
                      log(`Erro no handler de clique do canvas: ${e.message}`, 'error');
                 }
            };
            try {
                 canvas.addEventListener('click', canvasClickListener);
                 log("Listener 'click' adicionado. Clique no canvas acima para testar.", 'info');
            } catch (e) {
                 log(`Erro ao adicionar listener: ${e.message}`, 'error');
                 canvasClickListener = null;
            }

            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); // Pausa para permitir cliques

            // 12.2 Teste de Stress de Desenho
            log("Iniciando teste de stress de desenho (1000 formas)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const startStress = performance.now();
                for (let i = 0; i < 1000; i++) {
                    ctx.fillStyle = `rgba(${(i*30)%255}, ${(i*50)%255}, ${(i*70)%255}, 0.1)`;
                    ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 10, 10);
                    if (i % 100 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield para não travar tanto
                }
                const endStress = performance.now();
                log(`  Stress de desenho concluído em ${(endStress - startStress).toFixed(2)} ms.`, 'info');
            } catch(e) {
                 log(`  Erro durante stress de desenho: ${e.message}`, 'error');
            }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

             // 12.3 Teste de Stress toDataURL
             log("Iniciando teste de stress toDataURL (10 chamadas)...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
              try {
                 const startStressURL = performance.now();
                 let totalLength = 0;
                 for (let i = 0; i < 10; i++) {
                     const url = canvas.toDataURL(); // PNG padrão
                     totalLength += url.length;
                     if (i % 2 === 0) await new Promise(resolve => setTimeout(resolve, 0)); // Yield
                 }
                 const endStressURL = performance.now();
                 log(`  Stress toDataURL concluído em ${(endStressURL - startStressURL).toFixed(2)} ms. Tamanho total: ${totalLength}`, 'info');
              } catch (e) {
                  log(`  Erro durante stress toDataURL: ${e.message}`, 'error');
              }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // 12.4 Teste measureText
             log("Testando measureText com strings variadas...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                const metrics1 = ctx.measureText("Simple text");
                log(`  measureText("Simple text"): width=${metrics1.width.toFixed(2)}`, 'info');
                const metrics2 = ctx.measureText("Texto com acentuação e ç");
                log(`  measureText("Texto com acentuação e ç"): width=${metrics2.width.toFixed(2)}`, 'info');
                const metrics3 = ctx.measureText("😊🇧🇷👍"); // Emojis
                log(`  measureText("😊🇧🇷👍"): width=${metrics3.width.toFixed(2)}`, 'info');
             } catch(e) {
                 log(`  Erro durante teste measureText: ${e.message}`, 'error');
             }

            log("--- Teste 12 Concluído ---", 'test');
            log("AVISO: O listener de clique do canvas permanecerá ativo.", 'warn');
        };


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v13 (PP Especulativa, Canvas Interativo) ====", 'critical'); // Versão atualizada

            // Ordem Reorganizada para agrupar tipos de teste
            // 1. Coleta de Dados e Fingerprinting
            await testDataCollection(); // Teste 5
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedFingerprinting(); // Teste 7
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testEnvironmentProbing(); // Teste 10
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

             // 2. Testes de Canvas (Funcionalidade, Avançado, Interativo, Stress)
            await testAdvancedCanvas(); // Teste 11
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testInteractiveCanvas(); // Teste 12 (Novo)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 3. Testes de Vulnerabilidade Clássicos
            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 4. Testes de Prototype Pollution (Básico a Especulativo)
            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedPP(); // Teste 6
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPGadgetAttempts(); // Teste 9 (Complementado)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPJsonHijack(); // Teste 4 (Depende do PP e Teste 2)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 5. Observação de Comportamento Esperado
            await testErrorObservation(); // Teste 8
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("\n==== PoC Final v13 CONCLUÍDA ====", 'critical'); // Versão atualizada
            log("Listener de clique do Canvas continua ativo. Limpeza não implementada para este PoC.", "warn");
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza do listener do canvas se a página for descarregada (boa prática)
        window.addEventListener('unload', () => {
            if (canvasClickListener && fingerprintCanvas) {
                 try { fingerprintCanvas.removeEventListener('click', canvasClickListener); } catch(e){}
            }
        });

        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
