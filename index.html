<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v19 Max OOB Read/Crash Attempt)</title> <style>
        /* Estilos CSS (Idênticos) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(PP Hijack JSON) - Script 1 (v19 - Base v15)</h1>
    <p>Testa: XSS Básico, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS (Script 1 v19)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v19 Max OOB Read/Crash Attempt) - Script 2</h2> <p>Foco: PP Avançado++, OOB Read++, OOB Write->Metadata, WebGL, Quadrados.</p>
        <canvas id="interactive-canvas" width="350" height="250"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v19 (Script 2)</button> <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 (Base v15 - Logs Concisos) ---
        // Código do Script 1 permanece o mesmo da versão v15.
        // ... (Código Omitido por Brevidade, usar o da v15/v19) ...
        const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr']; const log = (message, type = 'info', funcName = '') => { if (!IMPORTANT_LOG_TYPES_S1.includes(type)) { if (!(funcName.includes('Payload') && type === 'good')) { return; } } if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(outputDiv.innerHTML.length > 500000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } }; const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { const FNAME = 'testCSPBypass'; log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const payloadJS = `try { alert('XSS S1 via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = (e) => { log(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME); }; document.body.appendChild(scriptTag); } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME); } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2)); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const imgTag = document.createElement('img'); const imgSrc = 'invalid_img_' + Date.now(); imgTag.src = imgSrc; const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { log("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME); } log("--- Teste 1 Concluído ---", 'test', FNAME); }; const testOOBReadInfoLeakEnhancedStore = async () => { const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize; const readRangeStart = -64; const readRangeEnd = bufferSize + 64; const allocationSize = bufferSize + 256; const baseOffsetInBuffer = 128; const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; try { const buffer = new ArrayBuffer(allocationSize); const dataView = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Corrupção de Memória OOB Write Simples) ***`, 'escalation', FNAME); writeSuccess = true; } catch (e) { if (!IMPORTANT_LOG_TYPES_S1.includes('good')) { log(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU: ${e.message}`, 'error', FNAME); } log(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME); return false; } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffsetInBuffer + readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) { try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const vStr = `H=${toHex(high)} L=${toHex(low)}`; log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Vazamento de Ponteiro OOB Read - Bypass ASLR) ***`, 'escalation', FNAME); } } } catch (e) {} } if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Potencial Vazamento de Informação OOB Read U32 ***`, 'escalation', FNAME); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { log(` -> Leu valor OOB escrito (${toHex(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME); } } catch (e) {} } if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1)); } } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); } finally { const leakStatus = leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'; log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME); } return writeSuccess; }; const testBasicPP = async () => { const FNAME = 'testBasicPP'; log("--- Iniciando Teste 3: PP (Básica) ---", 'test', FNAME); const prop = '__pp_basic__'; const val = 'Polluted!'; let ok = false; let testObj = null; try { Object.prototype[prop] = val; await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); testObj = {}; const inheritedValue = testObj[prop]; if (inheritedValue === val) { log(`VULN: PP Básica OK! Objeto herdou a propriedade poluída.`, 'vuln', FNAME); ok = true; } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error', FNAME); console.error(e); } finally { try { delete Object.prototype[prop]; } catch(e){ log(`Erro ao limpar Object.prototype.${prop}: ${e.message}`, 'error', FNAME); } } log(`--- Teste 3 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test', FNAME); return ok; }; const testPPJsonHijack = async () => { const FNAME = 'testPPJsonHijack'; log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test', FNAME); const orig = JSON.stringify; let okH = false; let okL = false; let okR = false; try { JSON.stringify = function hijacked(v, r, s) { log("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln', FNAME); okH = true; try { const l = leakedValueFromOOB; let lStr = "NULO ou Indefinido"; if (l) { lStr = l.type === 'U64' ? `U64 H=${toHex(l.high)} L=${toHex(l.low)} @${l.offset}` : `U32 ${toHex(l.low)} @${l.offset}`; okL = true; log(` ---> INFO: Interação entre Hijack e OOB Read Leak BEM-SUCEDIDA.`, 'escalation', FNAME); } log(` -> Valor OOB lido: ${lStr}`, okL ? 'leak' : 'warn', FNAME); } catch(ie) { log(` -> Erro ao tentar ler leak OOB: ${ie.message}`, 'error', FNAME); console.error(ie); } const hijackReturnValue = '{"hijacked": true, "leak_read_success": ' + okL + '}'; return hijackReturnValue; }; await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const testObject = {a:1, b: 'test'}; const result = JSON.stringify(testObject); if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada verificado com sucesso!", 'vuln', FNAME); okR = true; } } catch (e) { log(`Erro fatal durante Teste 4: ${e.message}`, 'error', FNAME); console.error(e); } finally { const currentStringify = JSON.stringify; JSON.stringify = orig; if (currentStringify !== orig && JSON.stringify !== orig) { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'critical', FNAME); } } log(`--- Teste 4 Concluído (Hijack: ${okH}, Retorno: ${okR}, Leitura Leak: ${okL}) ---`, 'test', FNAME); return okR && okL; }; const runAllTests = async () => { const FNAME = 'runAllTests'; if (runBtn) runBtn.disabled = true; log("==== INICIANDO Script 1 (v19 - Base v15) ====", 'test', FNAME); await testCSPBypass(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testOOBReadInfoLeakEnhancedStore(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testBasicPP(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testPPJsonHijack(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); log("\n==== Script 1 CONCLUÍDO ====", 'test', FNAME); if (runBtn) runBtn.disabled = false; };

    </script>

    <script>
        // *** v19-debug: Adiciona Alerta de Diagnóstico (mantido por segurança) ***
        try {
             // Comentar ou remover este alert se ele apareceu corretamente no teste anterior
             // alert('Script 2 Bloco Iniciado');
        } catch(e) { console.error("ALERTA INICIAL FALHOU:", e); }

        // --- Script 2: Canvas (v19 Max OOB Read/Crash Attempt - Focado) ---

        // --- Variáveis Globais --- (sem alterações)
        const SHORT_PAUSE_CANVAS = 50; let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null; const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' }, { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ]; const imgSquareSize = 20; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 205; let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" }; let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false; let sprayHole = [];

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good', 'warn'];
        // logCanvas (código da v18)
        const logCanvas = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('webgl n/a') || lowerMsg.includes('fail: herança de \'__proto__\'') || lowerMsg.includes('não afetou \'input.value\'') || lowerMsg.includes('nenhum leak ou dado não-padrão') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') /* Removido check extra de canvas stress */) { keepLog = true; } } if (!keepLog && type === 'error' && String(message).includes('Element.innerHTML setter')) { keepLog = true; } if (!keepLog && type === 'error' && funcName === 'testAdvancedPP' && String(message).includes(' is not a function')) { keepLog = true; } if (!keepLog && type === 'warn' && funcName === 'testAdvancedPP' && String(message).includes('Uso de')) { keepLog = true; } if (!keepLog) { return; } if (!outputDivCanvas) return; const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; console.log(logMsg); try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(outputDivCanvas.innerHTML.length > 750000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 350000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } };
        // PAUSE, toHexCanvas, is*, draw*, redrawAll (código v16)
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms)); const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); }; const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }}; const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach((sq, index) => { ctx.fillStyle = sq.hover ? 'yellow' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#888'; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); if (sq.hover && sq.hoverText) { ctx.fillStyle = '#000'; ctx.font = 'bold 9px mono'; ctx.textAlign = 'center'; ctx.fillText(sq.hoverText, sq.x + sq.size / 2, sq.y + sq.size / 2 + 3); ctx.textAlign = 'start'; } }); } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); }}; const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};


        // --- Funções de Teste (Script 2 - v19 Focada) ---
        // testWebGLCheck, testAdvancedPP (código v17)
        const testWebGLCheck = async () => { /* ...código v15... */ }; const testAdvancedPP = async () => { /* ...código v17... */ };
        // *** v19: OOB Read "Máximo" (Range + U8/U16 Log) ***
        const testOOBReadEnhanced = async () => { /* ...código v19 da resposta anterior... */ const FNAME='testOOBReadEnhanced'; logCanvas("--- Teste: OOB Read Enhanced Scan (Max Range/Sizes + Spray) ---",'test', FNAME); const bufferSize=32; const readRangeStart=-256; const readRangeEnd=bufferSize+256; const allocationSize = bufferSize + 512; const baseOffsetInBuffer = 256; const fillPatternU8 = 0xCC; const fillPatternU16 = 0xCCCC; const fillPatternU32 = 0xCCCCCCCC; const sprayCount = 200; const sprayObjectSize = 128; let potentialLeakFoundCount=0; const foundPointers=[]; let loggedDataCount = 0; sprayHole = []; logCanvas(`Iniciando Heap Spray (${sprayCount} x ~${sprayObjectSize * 8} bytes)...`, 'test', FNAME); try { for (let i = 0; i < sprayCount; i++) { sprayHole.push(new Array(sprayObjectSize).fill(1.1 + i)); } logCanvas(`Heap Spray concluído. ${sprayHole.length} objetos mantidos.`, 'test', FNAME); } catch (e) { logCanvas(`Erro durante Heap Spray: ${e.message}`, 'error', FNAME); } await PAUSE(50); logCanvas(`AVISO: OOB Read Scan agora logará dados U8/U16 não-padrão. Log pode ser extenso.`, 'warn', FNAME); try{ const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer); for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, fillPatternU8); } for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=1){ const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; let loggedForThisOffset = false; if(readOffset % 4 === 0 && readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){ try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low !== fillPatternU32 || high !== fillPatternU32) { if(isPotentialPointer64_S2(high,low)){ const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U64', high, low, hex:valueStr}); logCanvas(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Vazamento de Ponteiro OOB Read - Bypass ASLR) ***`, 'escalation', FNAME); loggedForThisOffset = true; } else { logCanvas(` -> Data? U64 ${relOffsetStr}: H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } } }catch(e){} } if(!loggedForThisOffset && readOffset % 4 === 0 && readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){ try{ const val32=dataView.getUint32(readTargetAddress,true); if (val32 !== fillPatternU32) { let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64'); if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){ logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)}); logCanvas(` ---> *** ALERTA: Potencial Vazamento de Informação OOB Read U32 ***`, 'escalation', FNAME); loggedForThisOffset = true; } else if (!alreadyLoggedAsPtr64) { logCanvas(` -> Data? U32 ${relOffsetStr}: ${toHexCanvas(val32,32)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } } }catch(e){} } if(!loggedForThisOffset && readOffset % 2 === 0 && readTargetAddress>=0 && readTargetAddress+2<=buffer.byteLength){ try{ const val16=dataView.getUint16(readTargetAddress,true); if (val16 !== fillPatternU16) { logCanvas(` -> Data? U16 ${relOffsetStr}: ${toHexCanvas(val16,16)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } }catch(e){} } if(!loggedForThisOffset && readTargetAddress>=0 && readTargetAddress+1<=buffer.byteLength){ try{ const val8=dataView.getUint8(readTargetAddress); if (val8 !== fillPatternU8) { logCanvas(` -> Data? U8  ${relOffsetStr}: ${toHexCanvas(val8,8)}`, 'leak', FNAME); loggedDataCount++; } }catch(e){} } if(readOffset % 64 === 0) await PAUSE(1); } }catch(e){ logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); } finally { logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks ptr/data32 potenciais, ${loggedDataCount} outros dados U8/U16/U32/U64 não-padrão) ---`,'test', FNAME); if(potentialLeakFoundCount === 0 && loggedDataCount === 0){ logCanvas("Nenhum leak ou dado não-padrão encontrado nesta varredura.", 'good', FNAME); } else if (foundPointers.length > 0) { console.log("Potenciais Leaks Encontrados (OOB Read Enhanced):", foundPointers); } sprayHole = []; } await PAUSE(); return foundPointers; };
        // testOOBWriteMetadata, testWebGLDeeperPlus, testOOBWriteToImageDataCheck, testOOBWriteOnly (código da v15)
        const testOOBWriteMetadata = async () => { /* ...código v15... */ }; const testWebGLDeeperPlus = async () => { /* ...código v15... */ }; const testOOBWriteToImageDataCheck = async () => { /* ...código v15... */ }; const testOOBWriteOnly = async () => { /* ...código v15... */ };
        // testCanvasStress: REMOVIDO na v19 Focada
        // *** v19: Tentativa de Crash via OOB Write ***
        const testOOBWriteCrashAttempt = async () => { /* ...código v19 da resposta anterior... */ const FNAME = 'testOOBWriteCrashAttempt'; logCanvas("--- Teste: Tentativa de Crash via OOB Write Agressivo ---", 'test', FNAME); const bufferSize = 64; const allocationSize = bufferSize + 256; const baseOffsetInBuffer = 128; const oobWriteOffset = bufferSize; const writeLength = 4096; const writePattern = 0x41414141; let buffer = null; let dv = null; let writeSuccess = false; try { buffer = new ArrayBuffer(allocationSize); dv = new DataView(buffer); } catch (e) { logCanvas(`Erro fatal ao alocar buffer de controle: ${e.message}`, 'error', FNAME); console.error(e); return; } const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset; const endWriteAddr = targetWriteAddr + writeLength; logCanvas(`Tentando escrever ${writeLength} bytes (padrão ${toHexCanvas(writePattern)}) OOB a partir de @${oobWriteOffset} (addr ${targetWriteAddr}) até ${endWriteAddr}...`, 'test', FNAME); try { for (let currentAddr = targetWriteAddr; currentAddr < endWriteAddr; currentAddr += 4) { if (currentAddr >= 0 && currentAddr + 4 <= dv.byteLength) { dv.setUint32(currentAddr, writePattern, true); } else { logCanvas(`AVISO: Tentativa de escrita OOB excederia limites do ArrayBuffer alocado (${dv.byteLength}). Parando escrita em ${currentAddr}.`, 'warn', FNAME); break; } } logCanvas(`VULN?: Escrita OOB agressiva concluída (sem erros JS). Verifique por crash.`, 'vuln', FNAME); logCanvas(` ---> *** ALERTA: Primitivo OOB Write usado agressivamente. Potencial DoS. ***`, 'escalation', FNAME); writeSuccess = true; } catch (e) { logCanvas(`Erro JS durante escrita OOB agressiva: ${e.message}`, 'error', FNAME); console.error(e); } logCanvas(`--- Teste Tentativa de Crash via OOB Write Concluído (Sucesso JS: ${writeSuccess}). Verifique o estado do navegador. ---`, 'test', FNAME); await PAUSE(); };


        // --- Função Principal Canvas --- (v19 Focada - Sequência Ajustada)
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { /* ... erro fatal ... */ }
            if (runBtnCanvas) runBtnCanvas.disabled = true; outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência focada do Script 2 (v19 Focada)...", "test", FNAME);
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY; const squareActions = ['PP Adv', 'OOB Read', 'OOB Meta', 'OOB Img', 'Crash?'];
            for (let i = 0; i < 5; i++) { imgSquares.push({ id: `imgSq${i}`, x: sqX, y: sqY, size: imgSquareSize, color: 'green', hover: false, hoverText: squareActions[i] || `Act ${i}` }); sqX += imgSquareSize + imgSquareSpacing; }
            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha ao obter contexto 2D."); } catch(e) { /* ... erro fatal ... */ }
                 redrawAll(); await PAUSE();
                 try { logCanvas('User Agent: ' + navigator.userAgent, 'test', 'Environment'); } catch (e) { /* ... erro UA ... */ }
                 await PAUSE();
                 try { /* ... Leitura do Leak S1 ... */ } catch (e) { /* ... erro leak ... */ }
                 redrawAll(); await PAUSE();
                // --- Sequência Principal com Testes v19 Focada ---
                await testWebGLCheck();
                await testAdvancedPP();
                await testOOBReadEnhanced(); // v19 Max OOB Read
                await testOOBWriteMetadata();
                await testOOBWriteToImageDataCheck();
                // Teste CanvasStress REMOVIDO
                await testOOBWriteCrashAttempt(); // v19 Crash Attempt
                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME);
                await PAUSE(100);
                // Adicionar Listeners Interativos
                logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'info', FNAME);
                 // ...(código listeners v19 com ação imgSq4 atualizada)...
                 if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} } canvasMoveListener = (event) => { /* ... código v16 ... */ }; canvasClickListener = async (event) => { const FNAME_CLICK = 'CanvasClick'; try{ const r=canvasElement.getBoundingClientRect(); const x=event.clientX-r.left; const y=event.clientY-r.top; let clickedArea=null; let clickedSquareIndex=-1; for(const a of interactiveAreas){if(x>=a.x && x<=a.x+a.w && y>=a.y && y<=a.y+a.h){ clickedArea = a; break; }} if(!clickedArea){for(let i = 0; i < imgSquares.length; i++){ const sq = imgSquares[i]; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size){ clickedSquareIndex = i; break; } } } if(clickedArea){ /* ... código v17 ... */ } else if (clickedSquareIndex !== -1){ const sq = imgSquares[clickedSquareIndex]; logCanvas(`--> Click Quadrado Interativo ID: ${sq.id}`, 'vuln', FNAME_CLICK); let actionError = null; if (runBtnCanvas) runBtnCanvas.disabled = true; logCanvas(`Executando ação para ${sq.id}...`, 'test', FNAME_CLICK); try { switch(sq.id) { case 'imgSq0': await testAdvancedPP(); break; case 'imgSq1': await testOOBReadEnhanced(); break; case 'imgSq2': await testOOBWriteMetadata(); break; case 'imgSq3': await testOOBWriteToImageDataCheck(); break; case 'imgSq4': await testOOBWriteCrashAttempt(); break; default: logCanvas(`Ação não definida para ${sq.id}`, 'warn', FNAME_CLICK); } logCanvas(`Ação ${sq.id} concluída.`, 'good', FNAME_CLICK); } catch (e) { logCanvas(`Erro durante ação ${sq.id}: ${e.message}`, 'error', FNAME_CLICK); console.error(`Erro ação ${sq.id}:`, e); actionError = e; } finally { sq.color = actionError ? 'orange' : 'purple'; redrawAll(); if (runBtnCanvas) runBtnCanvas.disabled = false; logCanvas(`Re-run ${sq.id} finalizado.`, 'test', FNAME_CLICK); } } }catch(e){ logCanvas(`Erro GERAL no listener de clique: ${e.message}`,'error', FNAME_CLICK); console.error(e); if (runBtnCanvas) runBtnCanvas.disabled = false; } };
                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                logCanvas("Listeners de mouse (click, mousemove) adicionados ao canvas.", 'info', FNAME);
                redrawAll();
                logCanvas("-> TESTE INTERATIVO PRONTO <- Passe o mouse sobre os blocos verdes!", 'info', FNAME);
            } catch(e) { /* ... erro geral ... */ }
             finally { logCanvas("--- Fim da execução automática da sequência do Script 2 ---", 'test', FNAME); }
        };
        // Funções wrapper e unload
        const runCanvasTest = async () => {
             // *** v19-debug: Adiciona try...catch em volta da chamada principal ***
             try {
                 await runCanvasTestSequence();
             } catch (error) {
                 alert(`ERRO CRÍTICO ao iniciar/executar Script 2: ${error.message}\n\nStack: ${error.stack}`); // <-- ALERTA 2 (Erro)
                 console.error("ERRO CRÍTICO SCRIPT 2:", error);
                 try {
                     // Tenta logar no div se possível
                     logCanvas(`ERRO CRÍTICO SCRIPT 2: ${error.message}`, 'critical', 'runCanvasTest');
                 } catch (logError) {
                     // Ignora erro no log aqui
                 }
             }
        };
        window.addEventListener('unload', () => { console.log("[Canvas Unload] Limpando listeners..."); try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); sprayHole = []; } catch(e) { console.error("[Canvas Unload] Erro:", e); } console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
