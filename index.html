<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Isolado - Teste 1: XSS Básico</title>
    <style>
        /* Estilos CSS básicos para visualização */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>Teste 1 Isolado: XSS Básico</h1>
    <p>Testa XSS via Data URI e via atributo onerror.</p>
    <button id="runBtn" onclick="runTest1Only()">Iniciar Teste 1</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <script>
        // --- Script Isolado - Apenas Teste 1 (XSS Básico) ---

        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // Pausa curta em milissegundos

        // Função de log simplificada (sem filtro de tipo para este teste isolado)
        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                // Remover escaping HTML para payloads XSS funcionarem (cuidado ao usar!)
                // const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const sanitizedMessage = String(message); // Permitir HTML no log para ver o efeito do XSS
                const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error'].includes(type) ? type : 'info';

                // Limitar tamanho do log para evitar travamentos
                if(outputDiv.innerHTML.length > 200000){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 100000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                 // Usar innerHTML pode ser vulnerável se a mensagem contiver XSS,
                 // mas é útil para visualizar o resultado do teste DOM XSS.
                 // Para segurança em outros contextos, prefira textContent ou DOMPurify.
                 outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) {
                console.error("Erro na função log:", e);
                if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`;
            }
        };

        // Teste 1: XSS Básico (Função original: testCSPBypass)
        const testBasicXSS = async () => {
            const FNAME = 'testBasicXSS'; // Nome atualizado para clareza
            log("--- Iniciando Teste 1: XSS Básico ---", 'test');

            // 1. Teste Data URI
            log("Tentando XSS via Data URI...", 'info');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                // Payload que tenta logar sucesso ou falha
                const payloadJS = `try { console.log('Payload Data URI Executado!'); document.getElementById('output').innerHTML += '<span class="log-vuln">[${new Date().toLocaleTimeString()}] [Payload Data:] Alerta data: URI executado!</span>\\n'; alert('XSS S1 via Data URI!'); } catch(e) { console.error('Payload Data URI Bloqueado:', e); document.getElementById('output').innerHTML += '<span class="log-good">[${new Date().toLocaleTimeString()}] [Payload Data:] Alerta data: URI bloqueado: ' + e.message + '</span>\\n'; }`;
                const encodedPayload = btoa(payloadJS); // Codifica em Base64
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = (e) => {
                    log(`ERRO: Falha ao carregar script data: URI! Evento: ${e.type}`, 'error');
                };
                document.body.appendChild(scriptTag);
                // Espera um pouco para o script carregar/executar e depois remove
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 4));
                try { document.body.removeChild(scriptTag); } catch(e){}

            } catch (e) {
                log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error');
            }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 2. Teste OnError
            log("Tentando XSS DOM via onerror...", 'info');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                const imgSrc = 'imagem_invalida_' + Date.now(); // Força o erro
                imgTag.src = imgSrc;

                // Payload que tenta escrever no div alvo ou logar falha
                // Nota: alert() pode ser bloqueado por pop-up blockers
                 const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); const output = document.getElementById('output'); const ts = '[${new Date().toLocaleTimeString()}]'; if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; output.innerHTML += '<span class="log-vuln">' + ts + ' [ONERROR Payload] XSS DOM via onerror OK!</span>\\n'; } else { output.innerHTML += '<span class="log-error">' + ts + ' [ONERROR Payload] Alvo XSS DOM não encontrado.</span>\\n'; } alert('XSS_S1_DOM_ONERROR'); } catch(e) { console.error('Erro payload onerror:', e); document.getElementById('output').innerHTML += '<span class="log-warn">[${new Date().toLocaleTimeString()}] [ONERROR Payload] Erro payload onerror: ' + e.message + '</span>\\n'; } `;

                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                 // Espera um pouco para o erro acontecer e depois remove
                 await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 4));
                 try { document.body.removeChild(imgTag); } catch(e){}

            } catch (e) {
                log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error');
            }
            log("--- Teste 1 Concluído ---", 'test');
        };

        // Função para iniciar apenas este teste
        const runTest1Only = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO Teste 1 Isolado ====", 'test');
            await testBasicXSS();
            log("\n==== Teste 1 Isolado CONCLUÍDO ====", 'test');
            if (runBtn) runBtn.disabled = false;
        };

        // Opcional: Iniciar automaticamente ao carregar a página
        // window.onload = runTest1Only;

    </script>

</body>
</html>
