<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - Teste v10 (Info Leak Repetido)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - Teste v10 (Info Leak Repetido)</h1>
    <p>Testa: XSS, OOB Write/Read Repetido (Procura Ponteiros), PP Básica.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        const NUM_LEAK_ATTEMPTS = 5; // Número de vezes para repetir o Teste 2

        // --- Função de Log ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 // Limita o tamanho do log
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; } // Trata como Uint32
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        // Verifica se o valor não é trivial ou o nosso padrão
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Nosso padrão
            if (high === 0 && low < 0x100000) return false; // Valores muito pequenos
            // if (low % 8 !== 0) return false; // Alinhamento (opcional)
            return true; // Se passou, PODE ser um ponteiro
        };

         // --- Heurística Simples para Detetar Potenciais Dados U32 ---
         // Verifica se não é trivial ou o nosso padrão/escrita
         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0; // Trata como Uint32
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
             if (val < 0x1000) return false; // Filtra valores muito pequenos
             return true; // Se passou, PODE ser dados interessantes
         }

        // --- Teste 1: CSP Bypass / XSS ---
        // (Função testCSPBypass igual à versão anterior)
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };


        // --- Teste 2: OOB Write/Read Repetido (Tentativa de Info Leak Aprimorada) ---
        // Executa a lógica de OOB Read/Write várias vezes
        const runRepeatedInfoLeakTest = async () => {
            log(`--- Iniciando Teste 2: OOB Write/Read Repetido (${NUM_LEAK_ATTEMPTS} tentativas) ---`, 'test');
            let totalLeaksFound = 0; // Contagem total de leaks potenciais encontrados

            for (let attempt = 1; attempt <= NUM_LEAK_ATTEMPTS; attempt++) {
                log(`--- Tentativa ${attempt}/${NUM_LEAK_ATTEMPTS} de Info Leak ---`, 'subtest');

                // Variar ligeiramente o tamanho do buffer em cada tentativa pode influenciar o heap
                const bufferSize = 32 + (attempt * 4); // Ex: 36, 40, 44, 48, 52
                const writeValue = 0xEE;
                const oobWriteOffset = 32; // Offset de escrita OOB que funcionou anteriormente
                // Offsets RELATIVOS ao início do buffer para TENTAR LER OOB
                const oobReadOffsets = [];
                for (let i = -64; i < bufferSize + 64; i += 4) { // Ler a cada 4 bytes numa gama alargada
                    oobReadOffsets.push(i);
                }

                let writeSuccess = false;
                let potentialLeakFoundInAttempt = 0; // Leaks encontrados nesta tentativa específica

                try {
                    // Usar um escopo de função pode ajudar na limpeza da memória entre tentativas (GC)
                    await (async function() {
                        const buffer = new ArrayBuffer(bufferSize + 256); // Buffer maior para segurança nas leituras OOB
                        const dataView = new DataView(buffer);
                        const baseOffset = 128; // Começar mais tarde no buffer para ter espaço antes/depois

                        // Preenche com padrão reconhecível
                        for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }

                        // Realiza a escrita OOB
                        const writeTargetAddress = baseOffset + oobWriteOffset;
                        log(`  [Tentativa ${attempt}] Escrita OOB U8 @${oobWriteOffset} (buffer ${bufferSize}b)...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                        try {
                            dataView.setUint8(writeTargetAddress, writeValue);
                            log(`  [Tentativa ${attempt}] VULN: Escrita OOB permitida!`, 'vuln');
                            writeSuccess = true;
                        } catch (e) {
                            log(`  [Tentativa ${attempt}] BLOQUEADO: Escrita OOB impedida: ${e.message}`, 'good');
                            return; // Pula para a próxima tentativa se a escrita falhar
                        }

                        await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); // Pausa após escrita
                        log(`  [Tentativa ${attempt}] Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'info');

                        // Loop de Leitura OOB Extensivo
                        for (const readOffset of oobReadOffsets) {
                            const readTargetAddress = baseOffset + readOffset;
                            // Garante que estamos a tentar ler dentro dos limites do buffer maior alocado
                            if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;

                            // Tenta ler U64
                            try {
                                const low = dataView.getUint32(readTargetAddress, true); // Little-endian
                                const high = dataView.getUint32(readTargetAddress + 4, true); // Little-endian
                                if (isPotentialPointer64(high, low)) {
                                    const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                                    log(`  [Tentativa ${attempt}] -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr');
                                    potentialLeakFoundInAttempt++;
                                }
                            } catch (e) {/* Ignora falha */}

                            // Tenta ler U32
                             try {
                                const val32 = dataView.getUint32(readTargetAddress, true);
                                if (isPotentialData32(val32)) {
                                    log(`  [Tentativa ${attempt}] -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak');
                                    potentialLeakFoundInAttempt++;
                                }
                            } catch (e) {/* Ignora falha */}

                            // Pausa muito curta para não congelar a UI durante o scan intensivo
                            if (readOffset % 64 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                        } // Fim loop leitura OOB
                    })(); // Fim da função de escopo

                } catch (e) { log(`  [Tentativa ${attempt}] Erro inesperado: ${e.message}`, 'error'); }

                log(`--- Fim da Tentativa ${attempt}: ${potentialLeakFoundInAttempt} potenciais leaks encontrados. ---`, 'subtest');
                totalLeaksFound += potentialLeakFoundInAttempt; // Acumula o total de leaks
                // Pausa média entre as tentativas para permitir variações de memória
                await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            } // Fim loop de tentativas

            log(`--- Teste 2 Concluído (Total de ${totalLeaksFound} potenciais leaks encontrados em ${NUM_LEAK_ATTEMPTS} tentativas) ---`, 'test');
            return totalLeaksFound > 0; // Retorna true se encontrou algum leak em qualquer tentativa
        };


        // --- Teste 3: Prototype Pollution (Básica) ---
        // (Função testBasicPP igual à versão anterior)
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO TODOS OS TESTES COMBINADOS v10 (Info Leak Repetido) ====", 'critical');

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await runRepeatedInfoLeakTest(); // Teste 2 (Repetido)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Removido PP Hijack para focar no Info Leak repetido

            log("\n==== TODOS OS TESTES COMBINADOS v10 CONCLUÍDOS ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
```

**Como usar e o que observar:**

1.  Salve e hospede este script como `teste_combinado_v10.html`.
2.  Execute no navegador do PS4 FW 12.02.
3.  Clique em "Iniciar Todos os Testes".
4.  **Observe atentamente o log durante o Teste 2:**
    * O teste será repetido `NUM_LEAK_ATTEMPTS` (5) vezes.
    * Em cada tentativa, o script fará a escrita OOB e depois lerá muitos offsets antes e depois do buffer.
    * **Procure por linhas `POTENCIAL PONTEIRO?` (magenta) ou `Leak U32?` (laranja).** A esperança é que, com as repetições e a variação do tamanho do buffer, uma das tentativas consiga ler um valor que seja realmente um ponteiro ou dados internos significativos, em vez de apenas o padrão `0xAA` ou o valor escrito `0xEE`.
    * O log final do Teste 2 indicará o número total de "potenciais leaks" encontrados em todas as tentativas.
5.  **Para o vídeo PoC:** Se alguma tentativa mostrar um leak interessante (especialmente um `POTENCIAL PONTEIRO?` que não seja claramente um artefacto), foque essa parte no vídeo. Se não aparecerem leaks claros, o vídeo ainda demonstrará a capacidade de ler extensivamente fora dos limites repetidamente.

Esta abordagem de "scan" repetido é a tentativa mais robusta que podemos fazer para encontrar um Info Leak significativo usando a primitiva OOB Read, dentro das minhas limitaçõ
