<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Vulnerabilidades (Base Original + Correção)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh; /* Mantido de index-42.html */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        /* Estilos de Log (Inalterados da sua base index-42.html) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Testes de Vulnerabilidade - Script 1</h1>
    <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Suite de Vulnerabilidades - Canvas</h2>
        <p>Foco: PP Avançado++, OOB R/W (Metadata/ImageData), API Checks (GL/GPU/FS), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="300" height="100"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 (Base index-42.html + Correção allocationSize) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null;

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        // Função log (Inalterada da sua base)
        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
            if (!keepLog && type === 'good') { /* ... */ }
            if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; }
            if (!keepLog) return;
            if (!outputDiv) return;
            try { /* ... (Lógica de log completa) ... */ }
            catch(e) { console.error("Erro log S1:", e); /* ... */ }
        };

        // Funções utilitárias (Inalteradas da sua base)
        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => { /* ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... */ };
        const isPotentialData32 = (val) => { /* ... */ };
        // Removido toHex64 se não estiver na base original

        // === TESTES SCRIPT 1 (Todos mantidos da sua base index-42.html) ===

        const testCSPBypass = async () => { /* ... (Código original completo mantido) ... */ };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME);
            const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize;
            const readRangeStart = -64; const readRangeEnd = bufferSize + 64;
            // *** CORREÇÃO ÚNICA NESTA FUNÇÃO: DEFINIÇÃO DE allocationSize ***
            const allocationSize = bufferSize + 256;
            const baseOffsetInBuffer = 128;
            const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null;
            try {
                const buffer = new ArrayBuffer(allocationSize); // Agora usa a variável definida
                const dataView = new DataView(buffer);
                // ... (Restante do código interno da função mantido exatamente como em index-42.html) ...
                 for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                 const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await PAUSE_S1();
                 try { dataView.setUint8(writeTargetAddress, writeValue); /* ... logs ... */ writeSuccess = true; } catch (e) { /* ... logs ... */ return false; }
                 await PAUSE_S1();
                 for (const readOffset of oobReadOffsets) { /* ... (lógica OOB Read U64/U32 original mantida) ... */ }
            } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); }
            finally { /* ... (Log final e comentário de contexto originais mantidos) ... */ }
            return writeSuccess;
        };

        const testOOBUAFPattern = async () => {
             const FNAME = 'testOOBUAFPattern'; log("--- Iniciando Teste 3: OOB Write -> UAF Pattern ---", 'test', FNAME);
             const buffer1Size = 64; const buffer2Size = 128; const oobWriteOffset = buffer1Size; const corruptedValue = 0xDEADBEEF;
             // *** Garantindo que allocationSize1 esteja definido (já estava na sua base) ***
             const allocationSize1 = buffer1Size + 128;
             const baseOffset1 = 64; let buffer1 = null, buffer2 = null; let dv1 = null; let writeOK = false; let uafTriggered = false;
             try { /* ... (Código interno original mantido) ... */ }
             catch (e) { log(`Erro fatal no Teste 3 (OOB UAF): ${e.message}`, 'error', FNAME); console.error(e); }
             finally { /* ... (Log final e comentário de contexto originais mantidos) ... */ }
             return writeOK && uafTriggered;
        };

        const testOOBOtherTypes = async () => {
             const FNAME = 'testOOBOtherTypes'; log("--- Iniciando Teste 4: OOB Write/Read (Float64/BigInt64) ---", 'test', FNAME);
             const bufferSize = 64; const oobWriteOffset = bufferSize;
             // *** Garantindo que allocationSize esteja definido (já estava na sua base) ***
             const allocationSize = bufferSize + 128;
             const baseOffset = 64; let buffer = null; let dv = null; let writeF64OK = false; /* ... outras vars ... */
             try { /* ... (Código interno original mantido) ... */ }
             catch(e) { log(`Erro fatal no Teste 4 (OOB Types): ${e.message}`, 'error', FNAME); console.error(e); }
             finally { /* ... (Log final e comentário de contexto originais mantidos) ... */ }
        };

        const testBasicPP = async () => { /* ... (Código original completo mantido) ... */ };
        const testPPJsonHijack = async () => { /* ... (Código original completo mantido) ... */ };
        const testWebSockets = async () => { /* ... (Código original completo mantido) ... */ };
        const testWebWorkers = async () => { /* ... (Código original completo mantido) ... */ };
        const testIndexedDB = async () => { /* ... (Código original completo mantido - ele falhará mas será executado) ... */ };
        const testDOMStress = async () => { /* ... (Código original completo mantido) ... */ };

        // runAllTests mantido como na sua base index-42.html (incluindo chamada a testIndexedDB)
        const runAllTests = async () => {
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO Script 1 (v18.1 - Base Original + Correção) ====", 'test', FNAME); // Log interno original
            await testCSPBypass(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBReadInfoLeakEnhancedStore(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBUAFPattern(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBOtherTypes(); await PAUSE_S1(MEDIUM_PAUSE);
            await testBasicPP(); await PAUSE_S1(MEDIUM_PAUSE);
            await testPPJsonHijack(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebSockets(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebWorkers(); await PAUSE_S1(MEDIUM_PAUSE);
            await testIndexedDB(); await PAUSE_S1(MEDIUM_PAUSE); // Chamada mantida
            await testDOMStress(); await PAUSE_S1(MEDIUM_PAUSE);
            log("\n==== Script 1 CONCLUÍDO (v18.1 - Base Original + Correção) ====", 'test', FNAME); // Log interno original
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        // --- Script 2: Canvas (Base index-42.html + Correções allocationSize) ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ /* ... (mantido) ... */ ];
        const imgSquareSize = 28; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 45;
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;
        let gpuAdapter = null; let gpuDevice = null;
        // Variáveis ROP/Shellcode removidas
        // Variável arbitraryReadWriteBuffer removida (pois a demonstração foi removida por não funcionar)

        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        // Funções logCanvas, PAUSE, toHexCanvas, etc. (mantidas da sua base)
        const logCanvas = (message, type = 'info', funcName = '') => { /* ... */ };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { /* ... */ };
        // toHexCanvas64 definido como toHex64 de S1
        const toHexCanvas64 = toHex64;
        const isPotentialPointer64_S2 = isPotentialPointer64; // Reusa
        const isPotentialData32_S2 = isPotentialData32;   // Reusa
        const drawInteractiveAreas = () => { /* ... */ };
        const drawImageSquares = () => { /* ... */ };
        const redrawAll = () => { /* ... */ };


        // === TESTES SCRIPT 2 (Todos mantidos da sua base index-42.html, exceto ROP) ===

        const testWebGLCheck = async () => { /* ... (Código original completo mantido) ... */ };
        const testAdvancedPP = async () => { /* ... (Código original completo mantido) ... */ };

        const testOOBReadEnhanced = async () => {
             const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste S2: OOB Read Enhanced Scan ---",'test', FNAME);
             const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128;
             const allocationSize = bufferSize + 512; // *** CORRIGIDO ***
             const baseOffsetInBuffer = 256;
             const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
             let potentialLeakFoundCount=0;
             try{
                 const buffer=new ArrayBuffer(allocationSize); // Usa allocationSize
                 /* ... (Restante do código interno original mantido) ... */
             } catch(e) { /* ... */ } finally { /* ... */ }
             await PAUSE();
             // return potentialRealKernelPtr || potentialRealLibcPtr; // Removido retorno pois ROP foi removido
        };

        const testOOBWriteMetadata = async () => {
            const FNAME = 'testOOBWriteMetadata'; logCanvas("--- Teste: OOB Write -> Metadata ---",'test', FNAME);
            const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE;
            const targetBuffers=[]; let controlBuffer=null; let dv=null; let writeSuccessCount = 0; let corruptionSuccess = false;
            const allocationSize = controlBufferSize + 256; // *** CORRIGIDO (usando valor original da sua base) ***
            const baseOffsetInBuffer = 128;
            let foundOffset=-1;
            let finalResultLog = `AVISO: Escrita OOB realizada (${writeSuccessCount}x), mas nenhuma corrupção de byteLength detectada.`; // Mensagem original
            try{ controlBuffer=new ArrayBuffer(allocationSize); /* ... (preenchimento DD) ... */ } catch(e){ return; /* Simplificado */ }
            // Filler spray removido para manter o mais próximo do original
            logCanvas(`Alocando ${sprayCount} buffers alvo de ${targetBufferSize} bytes...`, 'info', FNAME);
            for(let i=0; i<sprayCount; i++){ /* ... */ }
            await PAUSE();
            const metadataOffsetsToTry=[-8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32]; // Offsets originais
            // Removido log sobre quantos offsets serão testados
            for(const tryOffset of metadataOffsetsToTry){
                /* ... (Lógica interna original mantida, incluindo a demonstração R/W que não funcionava) ... */
                /* A demonstração de R/W estendido (que tentava usar arbitraryReadWriteBuffer) é mantida como estava no seu arquivo base, mesmo que não tenha funcionado nos logs, para manter 100% fiel */
            }
            /* ... (Lógica final e log final mantidos como no original) ... */
            await PAUSE();
            // return corruptionSuccess; // Removido retorno pois ROP foi removido
        };

        const testWebGLDeeperPlus = async () => { /* ... (Código original completo mantido) ... */ };

        const testOOBWriteToImageDataCheck = async () => {
             const FNAME = 'testOOBWriteToImageDataCheck'; /* ... (Código original completo mantido) ... */
             // Necessário corrigir allocationSize aqui também
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Restante do código interno completo mantido) ... */
        };

        const testOOBWriteOnly = async () => {
             const FNAME = 'testOOBWriteOnly'; /* ... (Código original completo mantido) ... */
             // Necessário corrigir allocationSize aqui também
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Restante do código interno completo mantido) ... */
        };

        const testFileSystemAccess = async () => { /* ... (Código original completo mantido) ... */ };
        const testWebGPUCheck = async () => { /* ... (Código original completo mantido) ... */ };
        // attemptRopExecution REMOVIDO

        // Função principal Script 2 (Mantida como na sua base, sem chamada ROP)
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            outputDivCanvas.innerHTML = '';
            logCanvas("Iniciando sequência Script 2 (Base Original + Correção)...", "test", FNAME); // Atualizado

            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            // squareDefs originais mantidos
            const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP }, { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced }, { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq4', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq5', text: 'GPU', color: '#337BFF', action: testWebGPUCheck }, ];
            squareDefs.forEach(def => { /* ... (lógica de desenho original mantida) ... */ });

            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { throw e; } // Simplificado
                 redrawAll(); await PAUSE();
                 try { /* ... (lógica leak S1 original mantida) ... */ } catch (e) { /* ... */ }
                 redrawAll(); await PAUSE();

                // Executa TODOS os testes S2 originais
                await testWebGLCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testAdvancedPP(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteMetadata(); await PAUSE(SHORT_PAUSE_CANVAS);
                logCanvas("--- Iniciando Teste de Interação OOB Write -> WebGL (Pulado se WebGL N/A) ---", 'test', FNAME);
                const oobWriteInteractionOK = await testOOBWriteOnly(); // Mantido
                await testWebGLDeeperPlus(); // Mantido
                if (oobWriteInteractionOK && glContext) { logCanvas(` ---> *** ALERTA POTENCIAL: WebGL funcionou após OOB Write. Investigar se houve efeito não fatal. ***`, 'escalation', FNAME); }
                logCanvas("--- Teste Interação OOB Write -> WebGL Concluído ---", 'test', FNAME); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testFileSystemAccess(); await PAUSE(SHORT_PAUSE_CANVAS); // Mantido
                await testWebGPUCheck(); await PAUSE(SHORT_PAUSE_CANVAS); // Mantido

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME); // Log original
                await PAUSE(100);

                // Adiciona listeners (mantidos da sua base)
                if(canvasClickListener && canvasElement) { /* ... */ }
                if(canvasMoveListener && canvasElement) { /* ... */ }
                canvasMoveListener = (event) => { /* ... (Código original mantido) ... */ };
                canvasClickListener = async (event) => { /* ... (Código original mantido) ... */ };
                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                redrawAll();

            } catch(e) { logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack); }
            finally { logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME); if (runBtnCanvas) runBtnCanvas.disabled = false; }
        };

        // Wrapper e Unload (Mantidos da sua base)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { /* ... */ } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
