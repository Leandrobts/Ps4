<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OOB 64 + Data Collector v11</title> <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho para vulnerabilidade confirmada */
        .log-good { color: #4CAF50; } /* Verde para bloqueio esperado / falha */
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: none; } /* Canvas para fingerprinting pode ser oculto */
    </style>
</head>
<body>
    <h1>Info Leak Finder & Data Collector v11</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas> <canvas id="fingerprint-canvas" width="200" height="50"></canvas> <p>Testa: XSS, OOB R/W, PP (Básica, Avançada, Hijack), Coleta de Dados (Fingerprinting Básico/Avançado), Observação de Erros.</p> <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak

        // --- Função de Log ---
        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                if(outputDiv.innerHTML.length > 700000){ // Aumentado limite um pouco
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 350000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight; // Auto-scroll
            } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; } // Trata como Uint32
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        const isPotentialPointer64 = (high, low) => {
             // Revertendo a heurística para logar o que foi lido no teste OOB,
             // mesmo que seja o padrão EE, para fins de observação,
             // mas não armazenar como "leak real" se for o padrão.
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Nosso padrão de preenchimento
            // Não retorna false para o padrão EE aqui para permitir log 'ptr'
            if (high === 0 && low < 0x100000) return false; // Valores muito pequenos
            return true; // Se passou, PODE ser um ponteiro ou nosso padrão escrito
        };

        // --- Heurística Simples para Detetar Potenciais Dados U32 ---
        const isPotentialData32 = (val) => {
            if (val === null || typeof val !== 'number') return false;
            val = val >>> 0; // Trata como Uint32
            // Não filtra EE aqui para podermos observar se ele vaza para um U32
            if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false;
            if (val < 0x1000) return false; // Filtra valores muito pequenos
            return true; // Se passou, PODE ser dados interessantes ou nosso padrão
        }

        // --- Teste 1: CSP Bypass / XSS --- (Sem alterações)
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI! Teste 1.1'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado! (Teste 1.2)</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR Teste 1.2');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        // --- Teste 2: OOB Write/Read Extensivo --- (Lógica interna ajustada para logar mais)
        const testOOBReadInfoLeakEnhancedStore = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read Extensivo ---", 'test');
            const bufferSize = 32;
            const extraPadding = 256;
            const writeValue = 0xEE;
            const oobWriteOffset = bufferSize + 8; // Offset relativo ao início lógico
            const oobReadOffsets = [];
            for (let i = -bufferSize - 4; i < bufferSize + extraPadding / 2 + 4; i += 4) { oobReadOffsets.push(i); } // Ampliado range de leitura
            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Reseta

            try {
                const allocatedSize = bufferSize + extraPadding;
                const buffer = new ArrayBuffer(allocatedSize);
                const dataView = new DataView(buffer);
                const baseOffset = extraPadding / 2;

                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                log(`Buffer alocado (${allocatedSize} bytes), preenchido com 0xAA. Buffer lógico começa em ${baseOffset}.`, 'info');

                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @ offset relativo ${oobWriteOffset} (endereço absoluto ${writeTargetAddress})...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

                if (writeTargetAddress < 0 || writeTargetAddress >= buffer.byteLength) {
                     log(`AVISO: Endereço de escrita (${writeTargetAddress}) fora do buffer alocado. Teste OOB write abortado.`, 'warn');
                     return false;
                }

                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    if (dataView.getUint8(writeTargetAddress) === writeValue) {
                        log(`SUCESSO: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) realizada com 0x${writeValue.toString(16).toUpperCase()}.`, 'good');
                        writeSuccess = true;
                    } else {
                         log(`FALHA: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) não confirmada.`, 'warn');
                    }
                } catch (e) {
                    log(`ERRO/BLOQUEADO?: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) falhou: ${e.message}`, 'error');
                    return false;
                }
                 if (!writeSuccess) return false;

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets relativos...`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;
                    let loggedU64 = false;

                    // Leitura U64
                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true);
                            const high = dataView.getUint32(readTargetAddress + 4, true);
                            const valueStrU64 = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                            const isOurPattern = high === 0xAAAAAAAA && low === 0xAAAAAAAA;
                            const containsWrite = high === 0xAAAAAAAAEE || low === 0xAAAAAAAAEE || high === 0xEEEEEEEE || low === 0xEEEEEEEE; // Checa se nosso byte escrito aparece

                            if (isPotentialPointer64(high, low)) { // Usa heuristica (que agora permite nosso padrão escrito passar)
                                log(`  -> Potencial Ponteiro/Padrão? U64 @${readOffset} (abs ${readTargetAddress}): ${valueStrU64}`, containsWrite ? 'leak' : 'ptr'); // Marca 'leak' se contém EE
                                potentialLeakFoundCount++;
                                // Armazena SOMENTE se NÃO for nosso padrão de escrita E for o primeiro
                                if (!containsWrite && leakedValueFromOOB === null) {
                                    leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset };
                                    log(`  -> VALOR U64 (não-padrão) ARMAZENADO (offset ${readOffset}).`, 'vuln');
                                }
                                loggedU64 = true;
                            } else if (!isOurPattern) { // Loga se não for ponteiro mas tbm não for o fill pattern
                               // log(`  -> Lido U64 @${readOffset} (abs ${readTargetAddress}): ${valueStrU64}`, 'info');
                               // loggedU64 = true;
                            }
                        } catch (e) { /* Ignora */ }
                    }

                    // Leitura U32 (sempre tenta, mas prioriza log U64 se já feito)
                    if (readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) {
                         try {
                             const val32 = dataView.getUint32(readTargetAddress, true);
                             const isOurPatternFill = val32 === 0xAAAAAAAA;
                             const isOurPatternWrite = val32 === 0xAAAAAAEE || val32 === 0xAAAAAAAAEE || val32 === 0xEEEEEEEE; // Checa se nosso byte escrito aparece
                             const isZero = val32 === 0;

                            if (isPotentialData32(val32)) { // Usa heuristica (que permite nosso padrão escrito passar)
                                 log(`  -> Potencial Data/Padrão? U32 @${readOffset} (abs ${readTargetAddress}): ${toHex(val32, 32)}`, isOurPatternWrite ? 'leak' : 'leak'); // Marca 'leak' sempre q interessante/padrão
                                 potentialLeakFoundCount++;
                                 if (!isOurPatternWrite && leakedValueFromOOB === null) {
                                     leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset };
                                     log(`  -> VALOR U32 (não-padrão) ARMAZENADO (offset ${readOffset}).`, 'vuln');
                                 }
                             } else if (!loggedU64 && !isOurPatternFill && !isZero) { // Loga se não for U64, nem fill, nem zero
                                // log(`  -> Lido U32 @${readOffset} (abs ${readTargetAddress}): ${toHex(val32, 32)}`, 'info');
                             }
                        } catch(e) {/* Ignora */}
                    }
                    if (readOffset % 64 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }

            log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leituras não-padrão/interessantes, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} (não-padrão) armazenado do offset ${leakedValueFromOOB.offset}` : 'nenhum valor não-padrão armazenado'}) ---`, 'test');
            return writeSuccess;
        };

        // --- Teste 3: Prototype Pollution (Básica) --- (Sem alterações)
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA/BLOQUEADO: PP Básica não confirmada.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info'); }
                 catch(e){ log(`Erro na limpeza de Object.prototype.${testProp}: ${e.message}`, 'warn');}
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou/Bloqueada'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: PP Hijack (JSON.stringify) --- (Sem alterações lógicas)
        const testPPJsonHijack = async () => {
             log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
             // ... (código interno igual ao anterior) ...
             const originalStringify = JSON.stringify;
             let hijackSuccessful = false;
             let interactionSuccessful = false;
             let hijackReturnedCorrectly = false;
             try {
                 log("Tentando sobrescrever JSON.stringify...", 'subtest');
                 JSON.stringify = function hijackedStringify(value, replacer, space) {
                     log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln');
                     hijackSuccessful = true;
                     log(`  -> Hijack: Tentando aceder ao valor armazenado do Teste 2...`, 'info');
                     try {
                         const leak = leakedValueFromOOB;
                         let leakStr = "NULO ou não armazenado (padrão detectado)";
                         if (leak) {
                             leakStr = leak.type === 'U64' ? `U64 @${leak.offset}: H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 @${leak.offset}: ${toHex(leak.low)}`;
                             interactionSuccessful = true;
                         }
                         log(`  -> Hijack: Valor ARMAZENADO (não-padrão) de OOB Read é: ${leakStr}`, interactionSuccessful ? 'leak' : 'info');
                     } catch(interactionError) {
                         log(`  -> Hijack: Erro ao aceder/logar valor: ${interactionError.message}`, 'error');
                         interactionSuccessful = false;
                     }
                     return `{"hijacked": true, "original_value": "skipped", "leak_accessed": ${interactionSuccessful}}`;
                 };
                 log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest');
                 await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                 const testObject = { a: 1, b: 'teste' };
                 const result = JSON.stringify(testObject);
                 log(`Resultado retornado por JSON.stringify(): ${result}`, 'info');
                 if (result && result.includes('"hijacked": true')) {
                     log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln');
                     hijackReturnedCorrectly = true;
                 } else if (hijackSuccessful) {
                     log("AVISO: Hijack funcionou, mas retorno não foi o esperado.", 'warn');
                 } else {
                     log("FALHA/BLOQUEADO: Sequestro de JSON.stringify não funcionou.", 'good');
                 }
             } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); }
             finally {
                 JSON.stringify = originalStringify;
                 log("Função JSON.stringify restaurada.", 'info');
                 if (JSON.stringify === originalStringify && typeof JSON.stringify({a:1}) === 'string' && JSON.stringify({a:1}) === '{"a":1}') {
                      log("Restauração de stringify confirmada.", 'info');
                 } else {
                      log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error');
                 }
             }
             log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou/Bloqueado'}) ---`, 'test');
             return hijackReturnedCorrectly;
        };

        // --- Teste 5: Coleta de Dados do Ambiente (Fingerprinting) --- (Sem alterações lógicas)
        const testDataCollection = async () => {
            log("--- Iniciando Teste 5: Coleta de Dados do Ambiente ---", 'test');
            // ... (código interno igual ao anterior) ...
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            log("Coletando dados de Navigator...", 'subtest');
             try { log(`  navigator.userAgent: ${navigator.userAgent}`, 'info'); } catch(e) { log(`  Erro lendo userAgent: ${e.message}`, 'warn'); }
             // ... (restante das coletas do navigator) ...
             try { log(`  navigator.webdriver: ${navigator.webdriver === true ? 'True' : 'False/N/A'}`, 'info'); } catch(e) { log(`  Erro lendo webdriver: ${e.message}`, 'warn'); }
             try {
                 const plugins = navigator.plugins;
                 let pluginList = 'N/A';
                 if (plugins && plugins.length > 0) { pluginList = Array.from(plugins).map(p => p.name).join('; '); }
                 log(`  navigator.plugins: ${plugins ? plugins.length : 0} (${pluginList})`, 'info');
             } catch(e) { log(`  Erro lendo plugins: ${e.message}`, 'warn'); }
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             log("Coletando dados da Tela...", 'subtest');
             try { log(`  screen.width x screen.height: ${screen.width}x${screen.height}`, 'info'); } catch(e) { log(`  Erro lendo width/height: ${e.message}`, 'warn'); }
              // ... (restante das coletas da tela) ...
             try { log(`  window.devicePixelRatio: ${window.devicePixelRatio || 'N/A'}`, 'info'); } catch(e) { log(`  Erro lendo devicePixelRatio: ${e.message}`, 'warn'); }
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             log("Coletando dados de Recursos/Armazenamento...", 'subtest');
             try { log(`  typeof(Storage) !== 'undefined': ${typeof(Storage) !== 'undefined'}`, 'info'); } catch(e) { log(`  Erro verificando Storage: ${e.message}`, 'warn'); }
              // ... (restante das coletas de recursos) ...
             try { log(`  WebRTC (RTCPeerConnection) disponível: ${!!window.RTCPeerConnection}`, 'info'); } catch(e) { log(`  Erro verificando WebRTC: ${e.message}`, 'warn'); }
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             log("Coletando dados de Tempo/Performance...", 'subtest');
             try { log(`  Fuso horário (offset minutos): ${new Date().getTimezoneOffset()}`, 'info'); } catch(e) { log(`  Erro lendo timezoneOffset: ${e.message}`, 'warn'); }
             try {
                 const start = performance.now(); let count = 0; for(let i = 0; i < 1000000; i++) { count++; } const end = performance.now();
                 log(`  performance.now() disponível: Sim. Loop(1M) levou ${ (end - start).toFixed(2) } ms. Count: ${count}`, 'info');
             } catch(e) { log(`  Erro no teste performance.now(): ${e.message}`, 'warn'); }
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
              log("Coletando dados de WebGL...", 'subtest');
             try {
                 const canvas = document.getElementById('webgl-canvas'); if (!canvas) throw new Error('Canvas element not found');
                 const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                 if (gl) {
                     const debugInfo = gl.getExtension('WEBGL_debug_renderer_info'); let vendor = 'N/A'; let renderer = 'N/A';
                     if (debugInfo) { vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL); renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL); }
                     else { vendor = gl.getParameter(gl.VENDOR) || 'N/A'; renderer = gl.getParameter(gl.RENDERER) || 'N/A'; }
                     log(`  WebGL Vendor: ${vendor}`, 'info'); log(`  WebGL Renderer: ${renderer}`, 'info');
                 } else { log('  Contexto WebGL não disponível.', 'warn'); }
             } catch (e) { log(`  Erro ao obter dados WebGL: ${e.message}`, 'error'); }
            log("--- Teste 5 Concluído ---", 'test');
        };

        // --- NOVO: Teste 6: Prototype Pollution Avançado ---
        const testAdvancedPP = async () => {
            log("--- Iniciando Teste 6: Prototype Pollution Avançado ---", 'test');
            let protoPolluted = false;
            let arrayPolluted = false;
            const protoTestProp = '__pp_proto_test__';
            const arrayTestProp = '__pp_array_test__';
            const testValue = 'PollutedProto';

            // 6.1 Teste __proto__
            log(`Tentando poluir ({}).__proto__.${protoTestProp}...`, 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                ({}).__proto__[protoTestProp] = testValue;
                 // Verifica se funcionou (improvável em browsers modernos)
                 if (({})[protoTestProp] === testValue) {
                     log(`VULN?: Poluição via __proto__ parece ter funcionado para ${protoTestProp}!`, 'vuln');
                     protoPolluted = true;
                 } else {
                     log(`BLOQUEADO: Poluição direta via __proto__ para ${protoTestProp} não funcionou (esperado).`, 'good');
                 }
            } catch (e) {
                log(`ERRO/BLOQUEADO: Poluição direta via __proto__ falhou: ${e.message}`, 'good');
            } finally {
                 try { delete Object.prototype[protoTestProp]; } catch(e){} // Tenta limpar de qualquer forma
            }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // 6.2 Teste Array.prototype
            log(`Tentando poluir Array.prototype.${arrayTestProp}...`, 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                Array.prototype[arrayTestProp] = testValue;
                const testArr = [];
                if (testArr[arrayTestProp] === testValue) {
                    log(`VULN: Poluição de Array.prototype.${arrayTestProp} confirmada!`, 'vuln');
                    arrayPolluted = true;
                } else {
                    log(`FALHA/BLOQUEADO: Poluição de Array.prototype.${arrayTestProp} não confirmada.`, 'good');
                }
            } catch (e) {
                 log(`ERRO: Poluição de Array.prototype falhou: ${e.message}`, 'error');
            } finally {
                 try {
                     delete Array.prototype[arrayTestProp];
                     log(`Limpeza de Array.prototype.${arrayTestProp} realizada.`, 'info');
                 } catch(e){ log(`Erro na limpeza de Array.prototype.${arrayTestProp}: ${e.message}`, 'warn');}
            }

            log(`--- Teste 6 Concluído (__proto__ ${protoPolluted ? 'Funcionou?' : 'Bloqueado'}, Array ${arrayPolluted ? 'Confirmada' : 'Falhou/Bloqueado'}) ---`, 'test');
        };

        // --- NOVO: Teste 7: Fingerprinting Avançado (Audio/Canvas) ---
        const testAdvancedFingerprinting = async () => {
            log("--- Iniciando Teste 7: Fingerprinting Avançado ---", 'test');

            // 7.1 AudioContext Fingerprint
            log("Coletando dados de AudioContext...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            let audioCtx = null;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                    log(`  AudioContext disponível: Sim`, 'info');
                    log(`    sampleRate: ${audioCtx.sampleRate}`, 'info');
                    log(`    destination.channelCount: ${audioCtx.destination.channelCount}`, 'info');
                    log(`    currentTime: ${audioCtx.currentTime}`, 'info');
                    log(`    state: ${audioCtx.state}`, 'info');
                    // Poderia adicionar testes mais complexos (OscillatorNode, AnalyserNode) mas mantém simples
                } else {
                    log(`  AudioContext indisponível.`, 'warn');
                }
            } catch (e) {
                log(`  Erro ao testar AudioContext: ${e.message}`, 'error');
            } finally {
                // Tenta fechar o contexto para liberar recursos
                if (audioCtx && audioCtx.state !== 'closed') {
                    try { await audioCtx.close(); log('  AudioContext fechado.', 'info');} catch(e){}
                }
            }

             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

             // 7.2 Canvas Text Rendering Fingerprint (Básico)
             log("Coletando dados de Canvas Text Rendering...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try {
                const canvas = document.getElementById('fingerprint-canvas');
                if (!canvas || !canvas.getContext) throw new Error('Canvas 2D element not found or not supported');
                const ctx = canvas.getContext('2d');
                if (!ctx) throw new Error('Canvas 2D context not available');

                // Limpa o canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgb(255,255,255)"; // Fundo branco
                ctx.fillRect(0, 0, canvas.width, canvas.height);


                // Desenha o texto
                const textToRender = `Browser Text Test ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 @!$%^&*()[]{}-_=+;:'",.<>/?~`;
                ctx.font = "18px 'Arial'"; // Fonte comum
                ctx.fillStyle = "rgb(0,0,0)"; // Texto preto
                ctx.textBaseline = "top"; // Alinha no topo para consistência
                ctx.fillText(textToRender, 5, 5);

                // Extrai dados (exemplo: soma de valores RGBA como checksum simples)
                // Nota: toDataURL() é mais comum para fingerprinting real, mas mais complexo de processar aqui.
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let checksum = 0;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    checksum += imageData.data[i] + imageData.data[i+1] + imageData.data[i+2] + imageData.data[i+3];
                }
                log(`  Canvas 2D disponível: Sim`, 'info');
                log(`    Texto renderizado (checksum simples RGBA): ${checksum}`, 'info');
                // Poderia tentar toDataURL e logar o hash (requereria func de hash)
                // log(`    toDataURL (parcial): ${canvas.toDataURL().substring(0, 100)}...`, 'info');

             } catch(e) {
                 log(`  Erro ao testar Canvas Text: ${e.message}`, 'error');
             }

            log("--- Teste 7 Concluído ---", 'test');
        };

        // --- NOVO: Teste 8: Observação de Erros ---
        const testErrorObservation = async () => {
            log("--- Iniciando Teste 8: Observação de Erros ---", 'test');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            log("Testando acesso DataView com offsets inválidos...", 'subtest');
            try {
                const buffer = new ArrayBuffer(16);
                const dataView = new DataView(buffer);
                let errorCount = 0;

                // Leitura Negativa
                try { dataView.getUint32(-1); }
                catch(e) { log(`  getUint32(-1) Error: ${e.name} - ${e.message}`, 'good'); errorCount++; }

                // Leitura Fora (Alto)
                try { dataView.getUint32(100); }
                catch(e) { log(`  getUint32(100) Error: ${e.name} - ${e.message}`, 'good'); errorCount++; }

                // Escrita Negativa
                try { dataView.setInt8(-5, 1); }
                catch(e) { log(`  setInt8(-5, 1) Error: ${e.name} - ${e.message}`, 'good'); errorCount++; }

                // Escrita Fora (Alto)
                try { dataView.setInt8(20, 1); }
                catch(e) { log(`  setInt8(20, 1) Error: ${e.name} - ${e.message}`, 'good'); errorCount++; }

                if (errorCount < 4) {
                    log("AVISO: Nem todos os acessos inválidos ao DataView geraram erro!", 'warn');
                } else {
                    log("INFO: Erros esperados para acessos inválidos ao DataView foram capturados.", 'info');
                }

            } catch (e) {
                 log(`  Erro inesperado no teste de observação de erros: ${e.message}`, 'error');
            }

             log("--- Teste 8 Concluído ---", 'test');
        };


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v11 (Testes Adicionais) ====", 'critical'); // Versão atualizada

            await testDataCollection(); // Teste 5: Coleta de Dados primeiro
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testAdvancedFingerprinting(); // Teste 7: Fingerprinting Avançado
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testCSPBypass(); // Teste 1: XSS
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testOOBReadInfoLeakEnhancedStore(); // Teste 2: OOB R/W
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3: PP Básica
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

             await testAdvancedPP(); // Teste 6: PP Avançado
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testPPJsonHijack(); // Teste 4: PP Hijack (requer resultado do Teste 2 e PP habilitada)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testErrorObservation(); // Teste 8: Observação de Erros
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("\n==== PoC Final v11 CONCLUÍDA ====", 'critical'); // Versão atualizada
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests); // Descomente para rodar automaticamente
    </script>

</body>
</html>
