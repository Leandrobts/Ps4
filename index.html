<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v15.1 - Original + Aprofundamento Interativo (Canvas Fix)</title> <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
    </style>
</head>
<body>
    <h1>PoC v15.1 - Original + Aprofundamento Interativo (Canvas Fix)</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="300" height="150"></canvas>
    <p>Fase 1: PoC Original. Fase 2: Aprofundamento (Fingerprinting, Canvas, PP, Erros, Interações).</p> <button id="runBtn" onclick="runEverythingSequentially()">Iniciar Teste Completo (Fase 1 + Fase 2)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null;
        let canvasClickListener = null;
        let xssRanFlag = false;
        const INTERACTION_POLLUTION_PROP = '__pp_interaction_test__';

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... (implementação anterior) ... */ if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 1200000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 600000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro na função log:", e); outputDiv = null; } };

        // --- Helpers (toHex, Heurísticas) ---
        const toHex = (val, bits = 32) => { /* ... (implementação anterior) ... */ if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const isPotentialPointer64 = (high, low) => { /* ... (heurística) ... */ if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { /* ... (heurística) ... */ if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false; if (val < 0x1000) return false; return true; };


        // ==================================================
        // --- FASE 1: Testes Originais (do Script Inicial) ---
        // ==================================================
        log("Definindo Testes da Fase 1 (Originais)", "info");

        // Teste Original 1: CSP Bypass / XSS (com adição de flag)
        const originalTestCSPBypass = async () => { /* ... (código T1 v15)... */ log("--- [Fase 1] Teste Original 1 Concluído ---", 'test'); };
        // Teste Original 2: OOB Write/Read Extensivo (Armazena Leak)
        const originalTestOOBReadInfoLeak = async () => { /* ... (código T2 v15)... */ log(`--- [Fase 1] Teste Original 2 Concluído (...) ---`, 'test'); return true; };
        // Teste Original 3: Prototype Pollution (Básica)
        const originalTestBasicPP = async () => { /* ... (código T3 v15)... */ log(`--- [Fase 1] Teste Original 3 Concluído (...) ---`, 'test'); return true; };
        // Teste Original 4: PP Hijack (JSON.stringify com Interação OOB)
        const originalTestPPJsonHijack = async () => { /* ... (código T4 v15)... */ log(`--- [Fase 1] Teste Original 4 Concluído (...) ---`, 'test'); return true; };

        // Função para rodar a Fase 1
        const runOriginalTests = async () => {
             log("==== [Fase 1] INICIANDO EXECUÇÃO DOS TESTES ORIGINAIS ====", 'critical');
             await originalTestCSPBypass(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestOOBReadInfoLeak(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestBasicPP(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestPPJsonHijack(); await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             log("==== [Fase 1] EXECUÇÃO DOS TESTES ORIGINAIS CONCLUÍDA ====", 'critical');
             log(`==== [Fase 1] Estado Final: XSS Ran Flag = ${xssRanFlag}, Leaked OOB Value = ${leakedValueFromOOB ? JSON.stringify(leakedValueFromOOB) : 'null'} ====`,'info');
        }

        // ==========================================================
        // --- FASE 2: Testes Adicionais Baseados em Evidências ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");

        // Teste A: Coleta de Dados Básica
        const testBasicDataCollection = async () => { /* ... (código Teste A v15) ... */ log("--- [Fase 2] Teste A Concluído ---", 'test'); };
        // Teste B: Sondagem do Ambiente (WebView/PWA)
        const testEnvironmentProbing = async () => { /* ... (código Teste B v15) ... */ log("--- [Fase 2] Teste B Concluído ---", 'test'); };
        // Teste C: Fingerprinting Avançado (Audio/Canvas Text)
        const testAdvancedFingerprinting = async () => { /* ... (código Teste C v15) ... */ log("--- [Fase 2] Teste C Concluído ---", 'test'); };
        // Teste D: Canvas 2D Avançado e Quirks
        const testAdvancedCanvas = async () => { /* ... (código Teste D v15) ... */ log("--- [Fase 2] Teste D Concluído ---", 'test'); };

        // Teste E: Canvas 2D Interativo e Stress (AJUSTADO)
        const testInteractiveCanvas = async () => {
            log("--- [Fase 2] Iniciando Teste E: Canvas Interativo/Stress ---", 'test');
            let canvas = null; let ctx = null;
            // Coordenadas baseadas nos desenhos do Teste D (ajuste se o Teste D mudar)
            const rectArea = {x: 10, y: 10, w: 30, h: 30}; // Retângulo vermelho do Teste D
            const linkArea = {x: 150, y: 100, w: 60, h: 30}; // Área de link definida aqui

            try { // Setup do Canvas e desenho da área de link
                canvas = fingerprintCanvas; ctx = canvas.getContext('2d'); if(!ctx) throw new Error('No 2D Ctx');
                // Desenha área de link sobre o que já existe do Teste D
                ctx.fillStyle="rgba(0, 255, 0, 0.5)"; ctx.fillRect(linkArea.x, linkArea.y, linkArea.w, linkArea.h);
                ctx.fillStyle="#fff"; ctx.font="12px monospace"; ctx.fillText("Link?", linkArea.x + 5, linkArea.y + 18);
                log("[Fase 2 / E] Contexto Canvas 2D obtido, área de link desenhada.", 'info');
            } catch(e) { log(`[Fase 2 / E] Falha setup Canvas Interativo: ${e.message}`,'error'); return; }

            // Interatividade (OnClick)
            log("Adicionando listener 'click'...", 'subtest');
            if(canvasClickListener && canvas) { try { canvas.removeEventListener('click', canvasClickListener); } catch(e){} } // Remove anterior
            canvasClickListener = (event) => { // Define novo listener
                try {
                    const r = canvas.getBoundingClientRect(); const x = event.clientX-r.left; const y = event.clientY-r.top;
                    let area = 'fora';
                    if(x>=rectArea.x && x<=rectArea.x+rectArea.w && y>=rectArea.y && y<=rectArea.y+rectArea.h) area = 'Retângulo Vermelho (Teste D)';
                    else if(x>=linkArea.x && x<=linkArea.x+linkArea.w && y>=linkArea.y && y<=linkArea.y+linkArea.h) area = 'Área Link Simulado';
                    log(`[Fase 2 / E] Canvas Click! Coords: x=${x.toFixed(0)}, y=${y.toFixed(0)}. Área: ${area}. (Flag XSS Fase 1: ${xssRanFlag})`, 'info');
                    if (area === 'Área Link Simulado') {
                        log("--> Ação do Link Simulada (apenas log)", 'warn');
                        // Aqui poderia ter window.open(...) ou similar
                    }
                } catch(e) { log(`[Fase 2 / E] Erro click handler: ${e.message}`, 'error'); }
            };
            try { canvas.addEventListener('click', canvasClickListener); log("[Fase 2 / E] Listener 'click' adicionado.", 'info'); } catch(e) { log(`[Fase 2 / E] Erro add listener: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); // Pausa para permitir cliques

            // Teste de Stress toDataURL (Stress de desenho REMOVIDO)
            log("Iniciando teste de stress toDataURL (10 chamadas)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const startStressURL = performance.now(); let totalLength = 0;
                for (let i = 0; i < 10; i++) {
                    const url = canvas.toDataURL(); totalLength += url.length;
                    if (i % 2 === 0) await new Promise(r => setTimeout(r, 0)); // Yield
                }
                const endStressURL = performance.now();
                log(`[Fase 2 / E] Stress toDataURL concluído em ${(endStressURL - startStressURL).toFixed(2)} ms. Tamanho total: ${totalLength}`, 'info');
            } catch (e) { log(`[Fase 2 / E] Erro durante stress toDataURL: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // Teste measureText
            log("Testando measureText...", 'subtest');
             await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
             try { /* ... (código measureText) ... */ ctx.font="14px monospace"; const m1=ctx.measureText("Teste"); const m2=ctx.measureText("😊🇧🇷"); log(`[Fase 2 / E] measureText widths: "${m1.width.toFixed(2)}", "${m2.width.toFixed(2)}"`, 'info');} catch(e){log(`[Fase 2 / E] Erro measureText: ${e.message}`,'error');}

            log("--- [Fase 2] Teste E Concluído ---", 'test');
        };

        // Teste F: Observação de Erros Detalhada
        const testErrorObservation = async () => { /* ... (código Teste F v15) ... */ log("--- [Fase 2] Teste F Concluído ---", 'test'); };
        // Teste J: PP Avançada (`__proto__`, Array)
        const testAdvancedPP = async () => { /* ... (código Teste J v15) ... */ log("--- [Fase 2] Teste J Concluído ---", 'test'); };
        // Teste K: Tentativas de PP Gadget Especulativo
        const testPPGadgetAttempts = async () => { /* ... (código Teste K v15) ... */ log("--- [Fase 2] Teste K Concluído ---", 'test'); };
        // Teste L: PP Hijack (JSON.stringify) - Re-execução na Fase 2 pode ser interessante ou redundante? Vamos manter fora por enquanto.

        // Teste M: Interação PP -> Prep (Poluir)
        const testInteractionPrep = async () => { /* ... (código Teste M v15) ... */ };
        // Teste N: Interação PP -> Cleanup (Limpar)
        const testInteractionCleanup = async () => { /* ... (código Teste N v15) ... */ log("--- [Fase 2] Teste N Concluído ---", 'test'); };


        // --- Função Principal para Rodar Tudo ---
        const runEverythingSequentially = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v15.1 (Original + Aprofundamento c/ Fix Canvas) ====", 'critical');

            // ===== FASE 1 =====
            await runOriginalTests();

            log("\n pausa longa antes da fase 2...\n", "warn");
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE * 2));

            // ===== FASE 2 =====
            log("==== [Fase 2] INICIANDO EXECUÇÃO DOS TESTES ADICIONAIS ====", 'critical');

            // 2.1 Coleta/Fingerprinting
            await testBasicDataCollection(); // A
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testEnvironmentProbing(); // B
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testAdvancedFingerprinting(); // C
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 2.2 Preparar Interação PP -> Canvas/Erro
            await testInteractionPrep(); // M (Polui)
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // 2.3 Canvas Avançado/Interativo (Executa APÓS OOB da Fase 1)
            await testAdvancedCanvas(); // D (Verifica M, Desenha)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testInteractiveCanvas(); // E (Verifica M e flag XSS, Desenha Link, Adic Listener, Stress leve)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

             // 2.4 Observação de Erros (Verifica M)
            await testErrorObservation(); // F
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 2.5 Limpar Interação PP
            await testInteractionCleanup(); // N (Limpa M)
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // 2.6 PP Avançado/Especulativo (Executa após limpeza da interação)
            await testAdvancedPP(); // J
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPGadgetAttempts(); // K
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Teste L (PP Hijack) não é re-executado na Fase 2 por padrão, pois já rodou na Fase 1.

            log("\n==== PoC Final v15.1 CONCLUÍDA (Fase 1 + Fase 2) ====", 'critical');
            log("Listener de clique do Canvas da Fase 2 pode continuar ativo.", "warn");
            if (runBtn) runBtn.disabled = false;
        };


        // Limpeza do listener do canvas
        window.addEventListener('unload', () => { if (canvasClickListener && fingerprintCanvas) { try { fingerprintCanvas.removeEventListener('click', canvasClickListener); } catch(e){} } });
        // document.addEventListener('DOMContentLoaded', runEverythingSequentially);
    </script>

</body>
</html>
