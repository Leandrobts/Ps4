<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Vulnerabilidades (Base Original + Debug Logs)</title>
    <style>
        /* CSS original de index-42.html/download.html mantido */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 48vh; /* Mantido de index-42.html */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        #summary-s1, #summary-s2 { /* Estilos do sumário mantidos */
            background: #2a2a2a;
            border: 1px solid #555;
            padding: 10px;
            margin-top: 15px;
            font-size: 13px;
            max-height: 45vh;
            overflow-y: auto;
        }
        #summary-s1 h2, #summary-s2 h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary-s1 ul, #summary-s2 ul { padding-left: 20px; margin: 5px 0; }
        #summary-s1 li, #summary-s2 li { margin-bottom: 3px; }

        /* Estilos de Log (Originais) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Testes de Vulnerabilidade - Script 1 (Debug Mode)</h1>
    <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1</button>
    <div id="output"></div>
    <div id="summary-s1"></div> {/* Div do sumário mantido */}
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Suite de Vulnerabilidades - Canvas (Debug Mode)</h2>
        <p>Foco: PP Avançado++, OOB R/W (Metadata/ImageData), API Checks (GL/GPU/FS), Canvas Interact.</p>
        <canvas id="interactive-canvas" width="300" height="100"></canvas> {/* Canvas reduzido mantido */}
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas</button>
        <div id="output-canvas"></div>
        <div id="summary-s2"></div> {/* Div do sumário mantido */}
    </section>

    <script>
        // --- Script 1 (Base Original + Correção allocationSize + Debug Logs) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null;
        let findingsS1 = [];

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const log = (message, type = 'info', funcName = '') => { /* ... (Código original completo mantido) ... */ };
        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => { /* ... (Código original mantido) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (Código original mantido) ... */ };
        const isPotentialData32 = (val) => { /* ... (Código original mantido) ... */ };
        // Adicionado toHex64 se não estava na base
        const toHex64 = (high, low) => {
             if (typeof BigInt !== 'undefined') {
                 try { const fullBig = (BigInt(high >>> 0) << 32n) | BigInt(low >>> 0); return '0x' + fullBig.toString(16).toUpperCase().padStart(16, '0'); } catch(e) {}
             } return `H=${toHex(high)} L=${toHex(low)}`;
        };

        // === TESTES SCRIPT 1 (Originais + Correção allocationSize) ===

        const testCSPBypass = async () => {
             console.log("[runAllTests] Entering testCSPBypass");
             /* ... (Código original completo mantido) ... */
             console.log("[runAllTests] Exiting testCSPBypass");
        };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            console.log("[runAllTests] Entering testOOBReadInfoLeakEnhancedStore");
            const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME);
            const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize;
            const readRangeStart = -64; const readRangeEnd = bufferSize + 64;
            // *** CORRIGIDO AQUI ***
            const allocationSize = bufferSize + 256;
            const baseOffsetInBuffer = 128;
            const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null;
            try {
                log("Allocating buffer...", 'info', FNAME); // Log antes da alocação
                const buffer = new ArrayBuffer(allocationSize);
                log("Buffer allocated.", 'info', FNAME);
                const dataView = new DataView(buffer);
                 /* ... (Restante do código interno original MANTIDO) ... */
                 for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                 const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await PAUSE_S1();
                 log("Attempting OOB Write...", 'info', FNAME);
                 try { dataView.setUint8(writeTargetAddress, writeValue); /* ... logs ... */ writeSuccess = true; } catch (e) { /* ... logs ... */ return false; }
                 log("Attempting OOB Read loop...", 'info', FNAME);
                 await PAUSE_S1();
                 for (const readOffset of oobReadOffsets) { /* ... (lógica OOB Read U64/U32 original mantida) ... */ }
            } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); }
            finally { /* ... (Log final original mantido) ... */ }
            console.log("[runAllTests] Exiting testOOBReadInfoLeakEnhancedStore");
            return writeSuccess;
        };

        const testOOBUAFPattern = async () => {
            console.log("[runAllTests] Entering testOOBUAFPattern");
            const FNAME = 'testOOBUAFPattern'; /* ... */
            const buffer1Size = 64; const buffer2Size = 128; /* ... */
            const allocationSize1 = buffer1Size + 128; // *** CORRIGIDO/Confirmado ***
            /* ... (Restante do código original mantido) ... */
            console.log("[runAllTests] Exiting testOOBUAFPattern");
            return /* ... (retorno original) ... */;
        };

        const testOOBOtherTypes = async () => {
            console.log("[runAllTests] Entering testOOBOtherTypes");
            const FNAME = 'testOOBOtherTypes'; /* ... */
            const bufferSize = 64; const oobWriteOffset = bufferSize;
            const allocationSize = bufferSize + 128; // *** CORRIGIDO ***
            /* ... (Restante do código original mantido) ... */
            console.log("[runAllTests] Exiting testOOBOtherTypes");
            // return ... (não tinha retorno original)
        };

        const testBasicPP = async () => { console.log("[runAllTests] Entering testBasicPP"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testBasicPP"); return /* ... */ ; };
        const testPPJsonHijack = async () => { console.log("[runAllTests] Entering testPPJsonHijack"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testPPJsonHijack"); return /* ... */ ; };
        const testWebSockets = async () => { console.log("[runAllTests] Entering testWebSockets"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testWebSockets"); };
        const testWebWorkers = async () => { console.log("[runAllTests] Entering testWebWorkers"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testWebWorkers"); };
        const testIndexedDB = async () => { console.log("[runAllTests] Entering testIndexedDB"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testIndexedDB"); };
        const testDOMStress = async () => { console.log("[runAllTests] Entering testDOMStress"); /* ... (Código original completo mantido) ... */ console.log("[runAllTests] Exiting testDOMStress"); };

        // Função principal S1 (com chamadas comentadas para debug)
        const runAllTests = async () => {
            console.log("runAllTests() called"); // DEBUG LOG INICIAL
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            findingsS1 = []; const summaryDivS1 = document.getElementById('summary-s1');
            if (summaryDivS1) summaryDivS1.innerHTML = ''; outputDiv.innerHTML = '';

            log("==== INICIANDO Script 1 (Debug Mode) ====", 'test', FNAME);

            try {
                console.log("[runAllTests] Before testCSPBypass");
                await testCSPBypass();
                console.log("[runAllTests] After testCSPBypass");
                await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testOOBReadInfoLeakEnhancedStore");
                // await testOOBReadInfoLeakEnhancedStore();
                // console.log("[runAllTests] After testOOBReadInfoLeakEnhancedStore");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testOOBUAFPattern");
                // await testOOBUAFPattern();
                // console.log("[runAllTests] After testOOBUAFPattern");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testOOBOtherTypes");
                // await testOOBOtherTypes();
                // console.log("[runAllTests] After testOOBOtherTypes");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testBasicPP");
                // await testBasicPP();
                // console.log("[runAllTests] After testBasicPP");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testPPJsonHijack");
                // await testPPJsonHijack();
                // console.log("[runAllTests] After testPPJsonHijack");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testWebSockets");
                // await testWebSockets();
                // console.log("[runAllTests] After testWebSockets");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testWebWorkers");
                // await testWebWorkers();
                // console.log("[runAllTests] After testWebWorkers");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testIndexedDB");
                // await testIndexedDB(); // Mantido mas comentado
                // console.log("[runAllTests] After testIndexedDB");
                // await PAUSE_S1(MEDIUM_PAUSE);

                // console.log("[runAllTests] Before testDOMStress");
                // await testDOMStress();
                // console.log("[runAllTests] After testDOMStress");
                // await PAUSE_S1(MEDIUM_PAUSE);

            } catch (error) {
                 console.error("[runAllTests] ERRO DURANTE EXECUÇÃO:", error);
                 log(`ERRO FATAL EM runAllTests: ${error.message}`, 'critical', FNAME);
            } finally {
                 // Geração de Sumário S1 (mantida)
                 log("\n==== GERANDO SUMÁRIO Script 1 ====", 'test', FNAME);
                 if (summaryDivS1) { /* ... (lógica sumário mantida) ... */ }
                 log("\n==== Script 1 CONCLUÍDO (Debug Mode) ====", 'test', FNAME);
                 if (runBtn) runBtn.disabled = false;
            }
        };
        console.log("Script 1 Parsed"); // DEBUG LOG FINAL S1
    </script>

    <script>
        // --- Script 2: Canvas (Base Original + Correção allocationSize + Debug Logs) ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; /* ... */ let currentHoverTarget = null;
        const interactiveAreas = [ /* ... */ ];
        const imgSquareSize = 40; const imgSquareSpacing = 8; const imgSquares = []; const imgSquaresStartY = 145;
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;
        let gpuAdapter = null; let gpuDevice = null;
        let findingsS2 = []; // Sumário mantido

        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        const logCanvas = (message, type = 'info', funcName = '') => { /* ... (Código original completo mantido) ... */ };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { /* ... (Código original mantido) ... */ };
        const toHexCanvas64 = toHex64; // Reusa S1
        const isPotentialPointer64_S2 = isPotentialPointer64; // Reusa S1
        const isPotentialData32_S2 = isPotentialData32; // Reusa S1
        const drawInteractiveAreas = () => { /* ... (Código original mantido) ... */ };
        const drawImageSquares = () => { /* ... (Código original mantido) ... */ };
        const redrawAll = () => { /* ... (Código original mantido) ... */ };

        // --- Testes Script 2 (Originais + Correção allocationSize) ---
        const testWebGLCheck = async () => { console.log("[runCanvasTestSequence] Entering testWebGLCheck"); /* ... (Código original completo mantido) ... */ console.log("[runCanvasTestSequence] Exiting testWebGLCheck"); };
        const testAdvancedPP = async () => { console.log("[runCanvasTestSequence] Entering testAdvancedPP"); /* ... (Código original completo mantido) ... */ console.log("[runCanvasTestSequence] Exiting testAdvancedPP"); };

        const testOOBReadEnhanced = async () => {
             console.log("[runCanvasTestSequence] Entering testOOBReadEnhanced");
             const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste S2: OOB Read Enhanced Scan ---",'test', FNAME);
             const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128;
             const allocationSize = bufferSize + 512; // *** CORRIGIDO ***
             const baseOffsetInBuffer = 256;
             /* ... (Restante do código interno original MANTIDO) ... */
             console.log("[runCanvasTestSequence] Exiting testOOBReadEnhanced");
        };

        const testOOBWriteMetadata = async () => {
            console.log("[runCanvasTestSequence] Entering testOOBWriteMetadata");
            const FNAME = 'testOOBWriteMetadata'; logCanvas("--- Teste: OOB Write -> Metadata ---",'test', FNAME);
            const controlBufferSize=64; const targetBufferSize=64; const sprayCount=50; const targetValue=0x7FFFFFFE;
            const allocationSize = controlBufferSize + 256; // *** CORRIGIDO ***
            /* ... (Restante do código interno original MANTIDO) ... */
            console.log("[runCanvasTestSequence] Exiting testOOBWriteMetadata");
        };

        const testWebGLDeeperPlus = async () => { console.log("[runCanvasTestSequence] Entering testWebGLDeeperPlus"); /* ... (Código original completo mantido) ... */ console.log("[runCanvasTestSequence] Exiting testWebGLDeeperPlus"); };

        const testOOBWriteToImageDataCheck = async () => {
             console.log("[runCanvasTestSequence] Entering testOOBWriteToImageDataCheck");
             const FNAME = 'testOOBWriteToImageDataCheck'; /* ... */ const bufferOOBSize=64;
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Restante do código interno original MANTIDO) ... */
             console.log("[runCanvasTestSequence] Exiting testOOBWriteToImageDataCheck");
        };

        const testOOBWriteOnly = async () => {
             console.log("[runCanvasTestSequence] Entering testOOBWriteOnly");
             const FNAME = 'testOOBWriteOnly'; /* ... */ const bufferOOBSize=64;
             const allocationSize = bufferOOBSize + 256; // *** CORRIGIDO ***
             /* ... (Restante do código interno original MANTIDO) ... */
             console.log("[runCanvasTestSequence] Exiting testOOBWriteOnly");
             return /* ... (retorno original) ... */ ;
        };

        const testFileSystemAccess = async () => { console.log("[runCanvasTestSequence] Entering testFileSystemAccess"); /* ... (Código original completo mantido) ... */ console.log("[runCanvasTestSequence] Exiting testFileSystemAccess"); };
        const testWebGPUCheck = async () => { console.log("[runCanvasTestSequence] Entering testWebGPUCheck"); /* ... (Código original completo mantido) ... */ console.log("[runCanvasTestSequence] Exiting testWebGPUCheck"); };

        // Função principal Script 2 (com chamadas comentadas para debug)
        const runCanvasTestSequence = async () => {
            console.log("runCanvasTestSequence() starting..."); // DEBUG LOG INICIAL S2
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn');
            const summaryDivS2 = document.getElementById('summary-s2');

            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv || !summaryDivS2) { console.error("FATAL: Elementos essenciais S2 não encontrados!"); return; }

            if (runBtnCanvas) runBtnCanvas.disabled = true;
            findingsS2 = []; outputDivCanvas.innerHTML = ''; if (summaryDivS2) summaryDivS2.innerHTML = '';

            logCanvas("Iniciando sequência Script 2 (Debug Mode)...", "test", FNAME);

            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            const squareDefs = [ /* ... (Definições originais mantidas) ... */ ];
            squareDefs.forEach(def => { /* ... (Lógica original mantida) ... */ });

            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { throw e; }
                 redrawAll(); await PAUSE();
                 try { /* ... (lógica leak S1 original mantida) ... */ } catch (e) { /* ... */ }
                 redrawAll(); await PAUSE();

                // Executa apenas o primeiro teste para isolar
                console.log("[runCanvasTestSequence] Before testWebGLCheck");
                await testWebGLCheck(); // WebGL N/A, mas deve rodar sem erro fatal
                console.log("[runCanvasTestSequence] After testWebGLCheck");
                await PAUSE(SHORT_PAUSE_CANVAS);

                // Comente as linhas abaixo para testar um por um
                // console.log("[runCanvasTestSequence] Before testAdvancedPP");
                // await testAdvancedPP();
                // console.log("[runCanvasTestSequence] After testAdvancedPP");
                // await PAUSE(SHORT_PAUSE_CANVAS);

                // console.log("[runCanvasTestSequence] Before testOOBReadEnhanced");
                // await testOOBReadEnhanced();
                // console.log("[runCanvasTestSequence] After testOOBReadEnhanced");
                // await PAUSE(SHORT_PAUSE_CANVAS);

                // ... (Comentar as outras chamadas await test...() similarmente) ...


                logCanvas("--- Sequência principal de testes (parcialmente executada para debug) ---", 'test', FNAME);
                await PAUSE(100);

                // Adiciona listeners (originais)
                if(canvasClickListener && canvasElement) { /* ... */ }
                if(canvasMoveListener && canvasElement) { /* ... */ }
                canvasMoveListener = (event) => { /* ... */ };
                canvasClickListener = async (event) => { /* ... */ };
                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                redrawAll();

            } catch(e) {
                console.error("[runCanvasTestSequence] ERRO DURANTE EXECUÇÃO:", e);
                logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); if(e.stack) console.error(e.stack);
            }
            finally {
                // Geração de Sumário S2 (original mantida)
                logCanvas("\n==== GERANDO SUMÁRIO Script 2 ====", 'test', FNAME);
                if (summaryDivS2) { /* ... (lógica sumário mantida) ... */ }
                logCanvas("--- Fim da execução Script 2 (Debug Mode) ---", 'test', FNAME);
                if (runBtnCanvas) runBtnCanvas.disabled = false;
            }
        };

        // Wrapper e Unload (Originais)
        const runCanvasTest = async () => {
            console.log("runCanvasTest() called"); // DEBUG LOG
            await runCanvasTestSequence();
        };
        window.addEventListener('unload', () => { /* ... */ });

        console.log("Script 2 Parsed"); // DEBUG LOG FINAL S2
    </script>

</body>
</html>
