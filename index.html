<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v20 - Max OOB Read / Crash Attempt)</title> <style>
        /* Estilos CSS (Ajustes para v20) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222; border: 1px solid #444; padding: 10px;
            height: 35vh; /* Reduzido um pouco para dar mais espaço ao sumário */
            overflow-y: auto; white-space: pre-wrap; margin-top: 10px;
        }
        #summary-s1, #summary-s2 { /* Sumários maiores */
            background: #2a2a2a; border: 1px solid #555; padding: 10px;
            margin-top: 15px; font-size: 13px;
            max-height: 60vh; /* *** AUMENTADO v20 *** */
            overflow-y: auto;
        }
        #summary-s1 h2, #summary-s2 h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary-s1 ul, #summary-s2 ul { padding-left: 20px; margin: 5px 0; }
        #summary-s1 li, #summary-s2 li {
             margin-bottom: 4px; /* Levemente mais espaçado */
             font-size: 14px; /* *** AUMENTADO v20 *** */
             line-height: 1.3;
        }

        /* Estilos de Log (Inalterados) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(v20 Max OOB Read / Crash Attempt) - Script 1</h1> <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1 (v20)</button>
    <div id="output"></div>
    <div id="summary-s1"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v20) - Script 2</h2> <p>Foco: PP Avançado++, OOB Read++(Max)/Crash, OOB Write->Meta/Img, API Checks, Canvas Interact.</p>
        <canvas id="interactive-canvas" width="300" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas (v20)</button>
        <div id="output-canvas"></div>
        <div id="summary-s2"></div>
    </section>

    <script>
        // --- Script 1 (v20 - Base v18.1) ---
        // Código completo do Script 1 da v18.1 (com todas as suas funções de teste)
        // ... (Omitido por brevidade - Cole aqui o Script 1 da v18.1 que você enviou) ...
         const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; let findingsS1 = []; const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good']; const log = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('completo') || lowerMsg.includes('ok') || lowerMsg.includes('recebida') || lowerMsg.includes('adicionar blob/arraybuffer ok')) { keepLog = true; } } if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; } if (!keepLog) return; if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS1.push({ type, funcName, message: sanitizedMessage, time: timestamp }); } if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } }; const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms)); const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { const FNAME = 'testCSPBypass'; log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME); try { const payloadJS = `try { log("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); alert('XSS S1 via Data URI!'); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`; const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload; scriptTag.onerror = (e) => { log(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME); }; document.body.appendChild(scriptTag); await PAUSE_S1(SHORT_PAUSE * 2); document.body.removeChild(scriptTag); } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME); } await PAUSE_S1(); try { const imgTag = document.createElement('img'); const imgSrc = 'invalid_img_' + Date.now(); imgTag.src = imgSrc; const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { log("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `; imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); await PAUSE_S1(SHORT_PAUSE * 2); document.body.removeChild(imgTag); } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME); } await PAUSE_S1(); try { const link = document.createElement('a'); link.href = "javascript:try{log('[Payload JS Href:] Executado!', 'vuln', 'XSS Payload JS Href'); alert('XSS S1 via JS Href!');}catch(e){log('[Payload JS Href:] Bloqueado: '+e.message,'good','XSS Payload JS Href');}"; link.textContent = "[Test Link JS Href - Clique Manual]"; link.style.display = 'block'; link.style.color = 'cyan'; document.getElementById('xss-target-div').appendChild(link); } catch(e) { log(`Erro ao criar link js: href: ${e.message}`, 'error', FNAME); } log("--- Teste 1 Concluído ---", 'test', FNAME); }; const testOOBReadInfoLeakEnhancedStore = async () => { const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME); const bufferSize = 32; const writeValue = 0xEE; const oobWriteOffset = bufferSize; const readRangeStart = -64; const readRangeEnd = bufferSize + 64; const allocationSize = bufferSize + 256; const baseOffsetInBuffer = 128; const oobReadOffsets = []; for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); } let writeSuccess = false; let potentialLeakFoundCount = 0; leakedValueFromOOB = null; try { const buffer = new ArrayBuffer(allocationSize); const dataView = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); } const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset; await PAUSE_S1(); try { dataView.setUint8(writeTargetAddress, writeValue); log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME); writeSuccess = true; } catch (e) { log(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); log(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME); return false; } await PAUSE_S1(); for (const readOffset of oobReadOffsets) { const readTargetAddress = baseOffsetInBuffer + readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`; if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) { try { const low = dataView.getUint32(readTargetAddress, true); const high = dataView.getUint32(readTargetAddress + 4, true); if (isPotentialPointer64(high, low)) { const vStr = `H=${toHex(high)} L=${toHex(low)}`; log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME); potentialLeakFoundCount++; if (leakedValueFromOOB === null) { leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset }; log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); } } } catch (e) {} } if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) { try { const val32 = dataView.getUint32(readTargetAddress, true); if (isPotentialData32(val32)) { log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME); potentialLeakFoundCount++; leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset }; log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME); log(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); } if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) { log(` -> Leu valor OOB escrito (${toHex(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME); } } catch (e) {} } if (readOffset % 32 === 0) await PAUSE_S1(1); } } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); } finally { const leakStatus = leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'; log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME); } return writeSuccess; }; const testOOBUAFPattern = async () => { const FNAME = 'testOOBUAFPattern'; log("--- Iniciando Teste 3: OOB Write -> UAF Pattern ---", 'test', FNAME); const buffer1Size = 64; const buffer2Size = 128; const oobWriteOffset = buffer1Size; const corruptedValue = 0xDEADBEEF; const allocationSize1 = buffer1Size + 128; const baseOffset1 = 64; let buffer1 = null, buffer2 = null; let dv1 = null; let writeOK = false; let uafTriggered = false; try { buffer1 = new ArrayBuffer(allocationSize1); dv1 = new DataView(buffer1); for (let i = 0; i < buffer1.byteLength; i++) dv1.setUint8(i, 0xBB); buffer2 = new ArrayBuffer(buffer2Size); const dv2_init = new DataView(buffer2); for (let i = 0; i < buffer2.byteLength; i++) dv2_init.setUint8(i, 0xCC); await PAUSE_S1(); const targetWriteAddr = baseOffset1 + oobWriteOffset; try { if (targetWriteAddr >= 0 && targetWriteAddr + 4 <= buffer1.byteLength) { dv1.setUint32(targetWriteAddr, corruptedValue, true); log(`VULN: Escrita OOB U32 @${oobWriteOffset} (addr ${targetWriteAddr}) parece OK.`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo Relevante (OOB Write) ***`, 'escalation', FNAME); writeOK = true; } else { log(`Offset de escrita OOB (${targetWriteAddr}) fora do buffer1.`, 'warn', FNAME); } } catch (e) { log(`Escrita OOB U32 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeOK) { await PAUSE_S1(); try { const slicedBuffer2 = buffer2.slice(0, 10); const dv2_check = new DataView(buffer2); const lengthCheck = buffer2.byteLength; log(`Uso do buffer 2 após escrita OOB parece OK (tamanho: ${lengthCheck}). Nenhuma UAF óbvia detectada.`, 'good', FNAME); } catch (e) { log(`---> VULN? ERRO ao usar buffer 2 após escrita OOB: ${e.message}`, 'critical', FNAME); log(`---> *** ALERTA: Potencial UAF ou Corrupção de Metadados detectada! O erro ao usar buffer2 PODE indicar sucesso na corrupção. ***`, 'escalation', FNAME); uafTriggered = true; console.error("Erro UAF Pattern:", e); } } } catch (e) { log(`Erro fatal no Teste 3 (OOB UAF): ${e.message}`, 'error', FNAME); console.error(e); } finally { buffer1 = null; buffer2 = null; dv1 = null; log(`--- Teste 3 Concluído (Escrita OOB: ${writeOK}, Potencial UAF/Erro: ${uafTriggered}) ---`, 'test', FNAME); } return writeOK && uafTriggered; }; const testOOBOtherTypes = async () => { const FNAME = 'testOOBOtherTypes'; log("--- Iniciando Teste 4: OOB Write/Read (Float64/BigInt64) ---", 'test', FNAME); const bufferSize = 64; const oobWriteOffset = bufferSize; const allocationSize = bufferSize + 128; const baseOffset = 64; let buffer = null; let dv = null; let writeF64OK = false; let writeB64OK = false; let readF64OK = false; let readB64OK = false; try { buffer = new ArrayBuffer(allocationSize); dv = new DataView(buffer); for (let i = 0; i < buffer.byteLength; i++) dv.setUint8(i, 0xDD); const targetAddr = baseOffset + oobWriteOffset; const writeValF64 = Math.PI; const writeValB64 = BigInt("0x1122334455667788"); try { if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) { dv.setFloat64(targetAddr, writeValF64, true); log(`Escrita OOB Float64 parece OK.`, 'vuln', FNAME); writeF64OK = true; } else { } } catch(e) { log(`Escrita OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeF64OK) { try { const readVal = dv.getFloat64(targetAddr, true); if (readVal === writeValF64) { log(`Leitura OOB Float64 CONFIRMADA (${readVal}). R/W OK.`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo R/W OOB Float64 confirmado ***`, 'escalation', FNAME); readF64OK = true; } else { } } catch(e) { log(`Leitura OOB Float64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } } await PAUSE_S1(); if (typeof DataView.prototype.setBigInt64 !== 'undefined') { try { if (targetAddr >= 0 && targetAddr + 8 <= buffer.byteLength) { dv.setBigInt64(targetAddr, writeValB64, true); log(`Escrita OOB BigInt64 parece OK.`, 'vuln', FNAME); writeB64OK = true; } else { } } catch(e) { log(`Escrita OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } if (writeB64OK) { try { const readVal = dv.getBigInt64(targetAddr, true); if (readVal === writeValB64) { log(`Leitura OOB BigInt64 CONFIRMADA (0x${readVal.toString(16)}). R/W OK.`, 'vuln', FNAME); log(`---> *** ALERTA: Primitivo R/W OOB BigInt64 confirmado ***`, 'escalation', FNAME); readB64OK = true; } else { } } catch(e) { log(`Leitura OOB BigInt64 FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); } } } else { log("BigInt64 em DataView não suportado neste navegador.", 'warn', FNAME); } } catch(e) { log(`Erro fatal no Teste 4 (OOB Types): ${e.message}`, 'error', FNAME); console.error(e); } finally { buffer = null; dv = null; log(`--- Teste 4 Concluído (F64 R/W: ${readF64OK}, B64 R/W: ${readB64OK}) ---`, 'test', FNAME); } }; const testBasicPP = async () => { const FNAME = 'testBasicPP'; log("--- Iniciando Teste 5: PP (Básica) ---", 'test', FNAME); const prop = '__pp_basic__'; const val = 'Polluted!'; let ok = false; let testObj = null; try { Object.prototype[prop] = val; await PAUSE_S1(); testObj = {}; const inheritedValue = testObj[prop]; if (inheritedValue === val) { log(`VULN: PP Básica OK! Objeto herdou a propriedade poluída.`, 'vuln', FNAME); ok = true; } else { log(`PP Básica falhou ou não detectada.`, 'good', FNAME); } } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error', FNAME); console.error(e); } finally { try { delete Object.prototype[prop]; } catch(e){ log(`Erro ao limpar Object.prototype.${prop}: ${e.message}`, 'error', FNAME); } } log(`--- Teste 5 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test', FNAME); return ok; }; const testPPJsonHijack = async () => { const FNAME = 'testPPJsonHijack'; log("--- Iniciando Teste 6: PP Hijack (JSON.stringify) ---", 'test', FNAME); const orig = JSON.stringify; let okH = false; let okL = false; let okR = false; try { JSON.stringify = function hijacked(v, r, s) { log("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln', FNAME); okH = true; try { const l = leakedValueFromOOB; let lStr = "NULO ou Indefinido"; if (l) { lStr = l.type === 'U64' ? `U64 H=${toHex(l.high)} L=${toHex(l.low)} @${l.offset}` : `U32 ${toHex(l.low)} @${l.offset}`; okL = true; log(` ---> INFO: Interação Hijack + OOB Read Leak OK.`, 'escalation', FNAME); } log(` -> Valor OOB lido: ${lStr}`, okL ? 'leak' : 'warn', FNAME); } catch(ie) { log(` -> Erro ao tentar ler leak OOB: ${ie.message}`, 'error', FNAME); console.error(ie); } const hijackReturnValue = '{"hijacked": true, "leak_read_success": ' + okL + '}'; return hijackReturnValue; }; await PAUSE_S1(); const testObject = {a:1, b: 'test'}; const result = JSON.stringify(testObject); if (result && result.includes('"hijacked": true')) { log("VULN: Retorno da função JSON.stringify sequestrada verificado!", 'vuln', FNAME); okR = true; } else if (okH) { log("AVISO: JSON.stringify sequestrado, mas retorno inesperado.", 'warn', FNAME); } else { log("JSON.stringify não foi sequestrado.", 'good', FNAME); } } catch (e) { log(`Erro fatal durante Teste 6: ${e.message}`, 'error', FNAME); console.error(e); } finally { const currentStringify = JSON.stringify; JSON.stringify = orig; if (currentStringify !== orig && JSON.stringify !== orig) { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'critical', FNAME); } else { log("JSON.stringify restaurado.", 'good', 'Cleanup');} } log(`--- Teste 6 Concluído (Hijack: ${okH}, Retorno: ${okR}, Leitura Leak: ${okL}) ---`, 'test', FNAME); return okR && okL; }; const testWebSockets = async () => { const FNAME = 'testWebSockets'; log("--- Iniciando Teste 7: WebSockets ---", 'test', FNAME); const wsUrl = "wss://websocket-echo.com/"; let ws = null; let connected = false; let messageReceived = false; let errorOccurred = false; const ppProp = '__ws_polluted__'; Object.prototype[ppProp] = 'WS Polluted!'; let ppDetected = false; const connectionPromise = new Promise((resolve, reject) => { try { ws = new WebSocket(wsUrl); try { if (ws && ws[ppProp] === 'WS Polluted!') { log(`VULN: PP afetou instância WebSocket ('${ppProp}')!`, 'vuln', FNAME); ppDetected = true; } delete Object.prototype[ppProp]; } catch(e){} ws.onopen = (event) => { log("WebSocket Conectado!", 'good', FNAME); connected = true; try { const testMsg = "Hello WebSocket Test " + Date.now(); ws.send(testMsg); try { ws.send(new Blob(["blob data"])); } catch(e) {} try { ws.send(new ArrayBuffer(16)); } catch(e) {} try { const largeSize = 1 * 1024 * 1024; const largeBuffer = new Uint8Array(largeSize).fill(0x41); ws.send(largeBuffer); } catch(e) {} } catch (e) { log(`Erro ao enviar mensagem: ${e.message}`, 'error', FNAME); errorOccurred = true; reject(e); } }; ws.onmessage = (event) => { log(`Mensagem recebida: ${String(event.data).substring(0, 100)}${String(event.data).length > 100 ? '...' : ''}`, 'good', FNAME); messageReceived = true; if (ws && ws.readyState === WebSocket.OPEN) { ws.close(1000, "Test Completed"); } resolve(); }; ws.onerror = (event) => { log(`Erro no WebSocket: ${event.type}`, 'error', FNAME); errorOccurred = true; reject(new Error("WebSocket onerror triggered")); }; ws.onclose = (event) => { log(`WebSocket Fechado. Code: ${event.code}, Reason: "${event.reason}", Clean: ${event.wasClean}`, event.wasClean ? 'good' : 'warn', FNAME); if (!connected && !errorOccurred) reject(new Error("WS fechado antes de conectar/msg.")); else resolve(); }; setTimeout(() => { if (!connected || !messageReceived) { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1001, "Timeout"); } catch(e){} reject(new Error("WebSocket timeout")); } }, 10000); } catch (e) { log(`Erro CRÍTICO ao criar WebSocket: ${e.message}`, 'critical', FNAME); errorOccurred = true; console.error(e); reject(e); } }); try { await connectionPromise; } catch(e) { } finally { try { if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(1000, "Cleanup"); } catch (e) {} ws = null; delete Object.prototype[ppProp]; log(`--- Teste 7 Concluído (Conectado: ${connected}, Msg OK: ${messageReceived}, Erro: ${errorOccurred}, PP Detect: ${ppDetected}) ---`, 'test', FNAME); } }; const testWebWorkers = async () => { const FNAME = 'testWebWorkers'; log("--- Iniciando Teste 8: Web Workers ---", 'test', FNAME); let worker = null; let workerReplied = false; let workerError = false; let ppDetectedWorker = false; const ppPropWorker = '__worker_polluted__'; Object.prototype[ppPropWorker] = 'Worker Polluted!'; const workerCode = ` self.onmessage = function(e) { let response = 'Worker received: ' + e.data; try { if (self.${ppPropWorker} === 'Worker Polluted!') { response += ' [PP Detected In Worker!]'; } } catch(err) {} self.postMessage(response); }; try { if (self.${ppPropWorker} === 'Worker Polluted!') { self.postMessage('PP Detected on Worker Self!'); } } catch(e){} `; const workerPromise = new Promise((resolve, reject) => { try { const blob = new Blob([workerCode], { type: 'application/javascript' }); const blobUrl = URL.createObjectURL(blob); worker = new Worker(blobUrl); try { if (worker && worker[ppPropWorker] === 'Worker Polluted!') { log(`VULN: PP afetou instância Worker main thread ('${ppPropWorker}')!`, 'vuln', FNAME); ppDetectedWorker = true; } } catch(e){} worker.onmessage = (event) => { log(`Mensagem do Worker: "${event.data}"`, 'good', FNAME); if (event.data.includes('Worker Polluted!')) { log(`VULN: PP detectada DENTRO worker/comunicação!`, 'vuln', FNAME); ppDetectedWorker = true; } workerReplied = true; resolve(); }; worker.onerror = (event) => { log(`Erro no Worker: ${event.message} em ${event.filename}:${event.lineno}`, 'error', FNAME); workerError = true; reject(event.error || new Error(event.message)); }; worker.postMessage("Hello Worker " + Date.now()); setTimeout(() => { if (!workerReplied) { workerError = true; reject(new Error("Worker timeout")); } }, 5000); URL.revokeObjectURL(blobUrl); } catch (e) { log(`Erro CRÍTICO criar/comunicar Worker: ${e.message}`, 'critical', FNAME); workerError = true; console.error(e); reject(e); } finally { delete Object.prototype[ppPropWorker]; } }); try { await workerPromise; } catch(e) { } finally { try { if (worker) worker.terminate(); } catch(e) {} worker = null; delete Object.prototype[ppPropWorker]; log(`--- Teste 8 Concluído (Resposta OK: ${workerReplied}, Erro: ${workerError}, PP Detect: ${ppDetectedWorker}) ---`, 'test', FNAME); } }; const testIndexedDB = async () => { const FNAME = 'testIndexedDB'; log("--- Iniciando Teste 9: IndexedDB ---", 'test', FNAME); const dbName = "TestDB_v18"; const storeName = "TestStore"; let db = null; let errorMsg = null; let addOK = false; let getOK = false; let deleteOK = false; let addComplexOK = false; try { await new Promise((resolve, reject) => { const deleteRequest = indexedDB.deleteDatabase(dbName); deleteRequest.onsuccess = () => { log("DB antigo deletado ou não existia.", 'good', FNAME); resolve(); }; deleteRequest.onerror = (e) => { log(`Erro ao deletar DB antigo: ${e.target.error}`, 'warn', FNAME); resolve(); }; deleteRequest.onblocked = () => { log("Deleção do DB bloqueada.", 'warn', FNAME); resolve(); }; setTimeout(() => reject(new Error("Timeout deletando DB")), 3000); }).catch(e => log(`Timeout/Erro na deleção prévia: ${e.message}`, 'warn', FNAME)); } catch(e) {} await PAUSE_S1(); try { db = await new Promise((resolve, reject) => { const request = indexedDB.open(dbName, 1); request.onupgradeneeded = (event) => { try { const dbInstance = event.target.result; if (!dbInstance.objectStoreNames.contains(storeName)) { dbInstance.createObjectStore(storeName, { keyPath: "id" }); } } catch (e) { log(`Erro durante onupgradeneeded: ${e.message}`, 'error', FNAME); errorMsg = `Upgrade error: ${e.message}`; reject(e); } }; request.onsuccess = (event) => { log("IndexedDB aberto com sucesso.", 'good', FNAME); resolve(event.target.result); }; request.onerror = (event) => { log(`Erro ao abrir IndexedDB: ${event.target.error}`, 'error', FNAME); errorMsg = `Open error: ${event.target.error}`; reject(event.target.error); }; setTimeout(() => reject(new Error("Timeout abrindo DB")), 5000); }); if (db) { const addData = { id: "simple_" + Date.now(), name: "TestData", value: Math.random() }; const addResult = await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readwrite"); const store = transaction.objectStore(storeName); const request = store.add(addData); request.onsuccess = (event) => { addOK = true; resolve(addData.id); }; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Add Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout add simples")), 3000); } catch (e) { reject(e); } }); log(`Adicionar registro simples ${addOK ? 'OK' : 'FALHOU'}.`, addOK ? 'good' : 'error', FNAME); if (addOK && addResult) { const getResult = await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readonly"); const store = transaction.objectStore(storeName); const request = store.get(addResult); request.onsuccess = (event) => { getOK = (event.target.result != null); resolve(event.target.result); }; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Get Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout get simples")), 3000); } catch (e) { reject(e); } }); log(`Ler registro simples ${getOK ? 'OK' : 'FALHOU'}.`, getOK ? 'good' : 'error', FNAME); if (getOK) { await new Promise((resolve, reject) => { try { const transaction = db.transaction([storeName], "readwrite"); const store = transaction.objectStore(storeName); const request = store.delete(addResult); request.onsuccess = () => { deleteOK = true; }; transaction.oncomplete = resolve; request.onerror = (event) => reject(event.target.error); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Delete Simples: ${event.target.error}`)); setTimeout(() => reject(new Error("Timeout delete simples")), 3000); } catch (e) { reject(e); } }); log(`Deletar registro simples ${deleteOK ? 'OK' : 'FALHOU'}.`, deleteOK ? 'good' : 'error', FNAME); } } const blobData = new Blob(['Test Blob Data S1 - ' + Date.now()], {type: 'text/plain'}); const bufferData = new Uint8Array([10, 20, 30, 40, Date.now() % 256]).buffer; try { await new Promise(async (resolve, reject) => { const transaction = db.transaction([storeName], "readwrite"); transaction.onerror = (event) => reject(event.target.error); transaction.onabort = (event) => reject(new Error(`Transação abortada Add Complex: ${event.target.error}`)); transaction.oncomplete = resolve; const store = transaction.objectStore(storeName); store.put({ id: 'blob_test', data: blobData }); store.put({ id: 'buffer_test', data: bufferData }); setTimeout(() => reject(new Error("Timeout add complex")), 4000); }); addComplexOK = true; log("Adicionar/Put Blob e ArrayBuffer OK.", 'good', FNAME); } catch(e) { log(`Erro ao adicionar/put Blob/ArrayBuffer: ${e?.message || String(e)}`, 'error', FNAME); errorMsg = errorMsg || `Add complex failed: ${e?.message || String(e)}`; } } } catch (e) { log(`Erro GERAL no teste IndexedDB: ${e?.message || String(e)}`, 'error', FNAME); if (!errorMsg) errorMsg = e?.message || String(e); console.error("IndexedDB Error:", e); } finally { try { if (db) db.close(); } catch (e) {} db = null; log(`--- Teste 9 Concluído (Add: ${addOK}, Get: ${getOK}, Del: ${deleteOK}, Complex: ${addComplexOK}, Erro: ${!!errorMsg}) ---`, 'test', FNAME); } }; const testDOMStress = async () => { const FNAME = 'testDOMStress'; log("--- Iniciando Teste 10: DOM Stress ---", 'test', FNAME); const container = document.body; const elementCount = 200; const cycles = 5; let errors = 0; try { for (let c = 0; c < cycles; c++) { const elements = []; for (let i = 0; i < elementCount; i++) { try { const el = document.createElement('div'); el.textContent = `Stress-${c}-${i}`; el.style.position = 'absolute'; el.style.left = `${(i * 5) % 300}px`; el.style.top = `-${10 + (c*2)}px`; el.style.color = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`; container.appendChild(el); elements.push(el); } catch (e) { errors++; } } await PAUSE_S1(50); elements.forEach(el => { try { container.removeChild(el); } catch(e) { errors++; } }); await PAUSE_S1(10); } log("Ciclos de stress concluídos.", 'good', FNAME); } catch (e) { log(`Erro GERAL durante DOM Stress: ${e.message}`, 'error', FNAME); errors++; console.error("DOM Stress Error:", e); } finally { log(`--- Teste 10 Concluído (Erros reportados: ${errors}) ---`, 'test', FNAME); } }; const runAllTests = async () => { const FNAME = 'runAllTests'; if (runBtn) runBtn.disabled = true; findingsS1 = []; const summaryDivS1 = document.getElementById('summary-s1'); if (summaryDivS1) summaryDivS1.innerHTML = ''; outputDiv.innerHTML = ''; log("==== INICIANDO Script 1 (v20) ====", 'test', FNAME); await testCSPBypass(); await PAUSE_S1(MEDIUM_PAUSE); await testOOBReadInfoLeakEnhancedStore(); await PAUSE_S1(MEDIUM_PAUSE); await testOOBUAFPattern(); await PAUSE_S1(MEDIUM_PAUSE); await testOOBOtherTypes(); await PAUSE_S1(MEDIUM_PAUSE); await testBasicPP(); await PAUSE_S1(MEDIUM_PAUSE); await testPPJsonHijack(); await PAUSE_S1(MEDIUM_PAUSE); await testWebSockets(); await PAUSE_S1(MEDIUM_PAUSE); await testWebWorkers(); await PAUSE_S1(MEDIUM_PAUSE); await testIndexedDB(); await PAUSE_S1(MEDIUM_PAUSE); await testDOMStress(); await PAUSE_S1(MEDIUM_PAUSE); log("\n==== GERANDO SUMÁRIO Script 1 ====", 'test', FNAME); if (summaryDivS1) { summaryDivS1.innerHTML = '<h2>Sumário Script 1 (Findings Críticos)</h2>'; if (findingsS1.length === 0) { summaryDivS1.innerHTML += '<p style="color:#4CAF50;">Nenhum finding crítico (vuln, critical, escalation) registrado.</p>'; } else { summaryDivS1.innerHTML += `<p style="color:#FFC107;">${findingsS1.length} finding(s) crítico(s) registrado(s):</p><ul>`; findingsS1.forEach(f => { const itemClass = f.type === 'critical' ? 'log-critical' : (f.type === 'escalation' ? 'log-escalation' : 'log-vuln'); const cleanMessage = f.message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); summaryDivS1.innerHTML += `<li class="${itemClass}">${f.time} [${f.funcName}] ${cleanMessage}</li>`; }); summaryDivS1.innerHTML += '</ul>'; } } log("\n==== Script 1 CONCLUÍDO (v20) ====", 'test', FNAME); if (runBtn) runBtn.disabled = false; };

    </script>

    <script>
        // --- Script 2: Canvas (v20 Max OOB Read / Crash Attempt) ---

        // --- Variáveis Globais ---
        const SHORT_PAUSE_CANVAS = 50; let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null; const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 70, h: 25, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Clk' }, { id: 'rect-link', x: 90, y: 10, w: 80, h: 25, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 180, y: 10, w: 100, h: 25, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ]; const imgSquareSize = 40; const imgSquareSpacing = 8; const imgSquares = []; const imgSquaresStartY = 145; let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" }; let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false; let gpuAdapter = null; let gpuDevice = null; let findingsS2 = []; let sprayHole = []; // Mantido para OOB Read

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good']; // Manter filtro da v18.1
        // logCanvas (código da v18.1 - com registro de findings)
        const logCanvas = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('n/a') || lowerMsg.includes('não suportad') || lowerMsg.includes('não disponível') || lowerMsg.includes('fail:') || lowerMsg.includes('não afetou') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('ok') || lowerMsg.includes('aberto') || lowerMsg.includes('concluído') || lowerMsg.includes('restaurado') || lowerMsg.includes('limpeza') || lowerMsg.includes('pulado') || lowerMsg.includes('resolvido') || lowerMsg.includes('sem erro') || lowerMsg.includes('finalizado') || lowerMsg.includes('restaurado') || lowerMsg.includes('sem erros gl')) { keepLog = true; } } if (!keepLog && type === 'error' && (String(message).includes('element.innerhtml setter') || String(message).includes('webgl') || String(message).includes('gpu') || String(message).includes('file system') || String(message).includes('indexeddb') || String(message).includes('fatal') || String(message).includes('critical'))) { keepLog = true; } if (!keepLog && funcName === 'CanvasClick') { keepLog = true; } if (!keepLog) return; if (!outputDivCanvas) return; const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS2.push({ type, funcName, message: sM, time: timestamp }); } if(outputDivCanvas.innerHTML.length > 600000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 300000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } };
        // PAUSE, toHexCanvas, is*, draw*, redrawAll (código v18.1)
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms)); const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); }; const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 11px mono"; ctx.textAlign="center"; ctx.textBaseline = "middle"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 1); }); ctx.textAlign="start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }}; const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? '#FFFF88' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); if (sq.text) { ctx.fillStyle = "#FFF"; ctx.font = "bold 10px mono"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2); } if (sq.url) { ctx.fillStyle = "#6cf"; ctx.font = "bold 9px mono"; ctx.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - 7); } }); ctx.textAlign = "start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); } }; const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "11px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};


        // --- Funções de Teste (Script 2 - Base v18.1 + Modificações v20) ---

        // testWebGLCheck (da v18.1)
        const testWebGLCheck = async () => { /* ...código v18.1... */ };
        // testAdvancedPP (da v18.1 - extenso, sem teste de uso)
        const testAdvancedPP = async () => { /* ...código v18.1... */ };

        // *** v20: Substitui testOOBReadEnhanced pelo "Máximo" da v19 ***
        const testOOBReadEnhanced = async () => {
            const FNAME='testOOBReadEnhanced';
            logCanvas("--- Teste: OOB Read Enhanced Scan (Max Range/Sizes + Spray) ---",'test', FNAME);
            const bufferSize=32;
            const readRangeStart=-256; // Aumentado
            const readRangeEnd=bufferSize+256; // Aumentado
            const allocationSize = bufferSize + 512 + 256; // Aumentar alocação para cobrir range maior
            const baseOffsetInBuffer = 128 + 256; // Ajustar offset base
            const fillPatternU8 = 0xCC; const fillPatternU16 = 0xCCCC; const fillPatternU32 = 0xCCCCCCCC;
            const sprayCount = 200; const sprayObjectSize = 128;
            let potentialLeakFoundCount=0; const foundPointers=[]; let loggedDataCount = 0;
            sprayHole = [];

            logCanvas(`Iniciando Heap Spray (${sprayCount} x ~${sprayObjectSize * 8} bytes)...`, 'test', FNAME);
            try { for (let i = 0; i < sprayCount; i++) { sprayHole.push(new Array(sprayObjectSize).fill(1.1 + i)); } logCanvas(`Heap Spray concluído. ${sprayHole.length} objetos mantidos.`, 'test', FNAME); } catch (e) { logCanvas(`Erro durante Heap Spray: ${e.message}`, 'error', FNAME); }
            await PAUSE(50);
            logCanvas(`AVISO: OOB Read Scan agora logará dados U8/U16 não-padrão. Log pode ser extenso.`, 'warn', FNAME);

            try{
                const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer);
                for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, fillPatternU8); }

                for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=1){
                    const readTargetAddress=baseOffsetInBuffer+readOffset;
                    const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;
                    let loggedForThisOffset = false;

                    // Tentar ler U64
                    if(readOffset % 4 === 0 && readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){
                        try{ const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true); if (low !== fillPatternU32 || high !== fillPatternU32) { if(isPotentialPointer64_S2(high,low)){ const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`; logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U64', high, low, hex:valueStr}); logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME); loggedForThisOffset = true; } else { logCanvas(` -> Data? U64 ${relOffsetStr}: H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } } }catch(e){}
                    }
                    // Tentar ler U32
                    if(!loggedForThisOffset && readOffset % 4 === 0 && readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){
                        try{ const val32=dataView.getUint32(readTargetAddress,true); if (val32 !== fillPatternU32) { let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64'); if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){ logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME); potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)}); logCanvas(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME); loggedForThisOffset = true; } else if (!alreadyLoggedAsPtr64) { logCanvas(` -> Data? U32 ${relOffsetStr}: ${toHexCanvas(val32,32)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } } }catch(e){}
                    }
                    // Tentar ler U16
                    if(!loggedForThisOffset && readOffset % 2 === 0 && readTargetAddress>=0 && readTargetAddress+2<=buffer.byteLength){
                        try{ const val16=dataView.getUint16(readTargetAddress,true); if (val16 !== fillPatternU16) { logCanvas(` -> Data? U16 ${relOffsetStr}: ${toHexCanvas(val16,16)}`, 'leak', FNAME); loggedDataCount++; loggedForThisOffset = true; } }catch(e){}
                    }
                    // Tentar ler U8
                    if(!loggedForThisOffset && readTargetAddress>=0 && readTargetAddress+1<=buffer.byteLength){
                        try{ const val8=dataView.getUint8(readTargetAddress); if (val8 !== fillPatternU8) { logCanvas(` -> Data? U8  ${relOffsetStr}: ${toHexCanvas(val8,8)}`, 'leak', FNAME); loggedDataCount++; } }catch(e){}
                    }

                    if(readOffset % 128 === 0) await PAUSE(1); // Pausa menos frequente devido ao range maior
                }
            } catch(e){ logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); }
            finally {
                logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks ptr/data32 potenciais, ${loggedDataCount} outros dados U8/U16/U32/U64 não-padrão) ---`,'test', FNAME);
                if(potentialLeakFoundCount === 0 && loggedDataCount === 0){ logCanvas("Nenhum leak ou dado não-padrão encontrado nesta varredura.", 'good', FNAME); }
                else if (foundPointers.length > 0) { console.log("Potenciais Leaks Encontrados (OOB Read Enhanced):", foundPointers); }
                sprayHole = []; // Limpa spray
            }
            await PAUSE(); return foundPointers;
        };

        // testOOBWriteMetadata (da v18.1)
        const testOOBWriteMetadata = async () => { /* ...código v18.1... */ };
        // testWebGLDeeperPlus (da v18.1)
        const testWebGLDeeperPlus = async () => { /* ...código v18.1... */ };
        // testOOBWriteToImageDataCheck (da v18.1)
        const testOOBWriteToImageDataCheck = async () => { /* ...código v18.1... */ };
        // testOOBWriteOnly (da v18.1)
        const testOOBWriteOnly = async () => { /* ...código v18.1... */ };
        // testFileSystemAccess (da v18.1)
        const testFileSystemAccess = async () => { /* ...código v18.1... */ };
        // testWebGPUCheck (da v18.1)
        const testWebGPUCheck = async () => { /* ...código v18.1... */ };

        // *** v20: ADICIONA Tentativa de Crash OOB Write (da v19) ***
        const testOOBWriteCrashAttempt = async () => {
            const FNAME = 'testOOBWriteCrashAttempt';
            logCanvas("--- Teste: Tentativa de Crash via OOB Write Agressivo ---", 'test', FNAME);
            const bufferSize = 64;
            const allocationSize = bufferSize + 256;
            const baseOffsetInBuffer = 128;
            const oobWriteOffset = bufferSize;
            const writeLength = 4096; // Tentar escrever 4KB OOB
            const writePattern = 0x41414141; // 'AAAA'
            let buffer = null; let dv = null; let writeSuccess = false;

            try { buffer = new ArrayBuffer(allocationSize); dv = new DataView(buffer); } catch (e) { logCanvas(`Erro fatal ao alocar buffer de controle: ${e.message}`, 'error', FNAME); return; }

            const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset;
            const endWriteAddr = targetWriteAddr + writeLength;
            logCanvas(`Tentando escrever ${writeLength} bytes (padrão ${toHexCanvas(writePattern)}) OOB a partir de @${oobWriteOffset} (addr ${targetWriteAddr}) até ${endWriteAddr}...`, 'test', FNAME);

            try {
                for (let currentAddr = targetWriteAddr; currentAddr < endWriteAddr; currentAddr += 4) {
                    if (currentAddr >= 0 && currentAddr + 4 <= dv.byteLength) { dv.setUint32(currentAddr, writePattern, true); }
                    else { logCanvas(`AVISO: Tentativa OOB excederia buffer alocado (${dv.byteLength}). Parando em ${currentAddr}.`, 'warn', FNAME); break; }
                }
                logCanvas(`VULN?: Escrita OOB agressiva concluída (sem erros JS). Verifique por crash.`, 'vuln', FNAME);
                logCanvas(` ---> *** ALERTA: Primitivo OOB Write usado agressivamente. Potencial DoS. ***`, 'escalation', FNAME);
                writeSuccess = true;
            } catch (e) { logCanvas(`Erro JS durante escrita OOB agressiva: ${e.message}`, 'error', FNAME); console.error(e); }

            logCanvas(`--- Teste Tentativa de Crash via OOB Write Concluído (Sucesso JS: ${writeSuccess}). Verifique o estado do navegador. ---`, 'test', FNAME);
            await PAUSE();
        };


        // --- Função Principal Canvas (v20 - Sequência Atualizada) ---
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn'); const summaryDivS2 = document.getElementById('summary-s2');
            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv || !summaryDivS2) { console.error("FATAL: Elementos essenciais S2 não encontrados!"); return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            findingsS2 = []; outputDivCanvas.innerHTML = ''; summaryDivS2.innerHTML = '';
            logCanvas("Iniciando sequência focada do Script 2 (v20)...", "test", FNAME);

            // Define quadrados interativos (mantendo os da v18.1)
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP }, { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced }, // Aponta para a versão Max agora
                                 { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq4', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq5', text: 'GPU', color: '#337BFF', action: testWebGPUCheck }, ];
            squareDefs.forEach(def => { /* ...código v18.1 para adicionar quadrados ... */ if (sqX + imgSquareSize > canvasElement.width - 5) { sqX = 10; sqY += imgSquareSize + imgSquareSpacing; } if (sqY + imgSquareSize > canvasElement.height - 15) { logCanvas(`AVISO: Não há espaço para o quadrado ${def.id} no canvas.`, 'warn', FNAME); return; } imgSquares.push({ id: def.id, x: sqX, y: sqY, size: imgSquareSize, color: def.color, text: def.text, hover: false, url: def.url, action: def.action }); sqX += imgSquareSize + imgSquareSpacing; });

            try {
                try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                redrawAll(); await PAUSE();
                try { logCanvas('User Agent: ' + navigator.userAgent, 'test', 'Environment'); } catch (e) { logCanvas('Erro ao obter User Agent.', 'error', 'Environment'); } await PAUSE();
                try { if (typeof leakedValueFromOOB !== 'undefined') { const l = leakedValueFromOOB; if(l){ const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 nulo/não encontrado.`, 'warn', FNAME); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } else { logCanvas(`-> Var 'leakedValueFromOOB' S1 N/A.`, 'error', FNAME); currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; console.error(e); }
                redrawAll(); await PAUSE();

                // --- Sequência Principal v20 ---
                await testWebGLCheck();                  await PAUSE(SHORT_PAUSE_CANVAS);
                await testAdvancedPP();                  await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced();              // v20 Max OOB Read
                await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteMetadata();             await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteToImageDataCheck();    await PAUSE(SHORT_PAUSE_CANVAS);
                // Teste OOBWriteOnly + WebGLDeeperPlus removido da sequência principal (já sabemos que GL não funciona)
                await testFileSystemAccess();             await PAUSE(SHORT_PAUSE_CANVAS);
                await testWebGPUCheck();                  await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteCrashAttempt();        // v20 Crash Attempt
                await PAUSE(SHORT_PAUSE_CANVAS);


                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME); await PAUSE(100);

                // Adicionar Listeners Interativos (código v18.1)
                logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'info', FNAME);
                // ...(código listeners v18.1)...
                if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} } canvasMoveListener = (event) => { let needsRedraw = false; try{ const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let newHoverTarget = null; let cursorStyle = 'default'; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { newHoverTarget = a.id; cursorStyle = 'pointer'; } }); imgSquares.forEach(sq => { let oldHover = sq.hover; sq.hover = false; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { newHoverTarget = sq.id; cursorStyle = sq.action ? 'crosshair' : (sq.url ? 'pointer' : 'default'); sq.hover = true; } if(oldHover !== sq.hover) needsRedraw = true; }); if (newHoverTarget !== currentHoverTarget) { currentHoverTarget = newHoverTarget; needsRedraw = true; } try { if(needsRedraw){ redrawAll(); } canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e){ logCanvas(`Erro mousemove: ${e.message}`, 'error', 'MouseMove'); console.error(e); } }catch(e){ logCanvas(`Erro no listener de mousemove: ${e.message}`, 'error', 'MouseMove'); } }; canvasClickListener = async (event) => { const FNAME_CLICK = 'CanvasClick'; try { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let clickedArea = null; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; } }); let clickedSquare = null; imgSquares.forEach((sq) => { if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquare = sq; } }); if (clickedArea) { logCanvas(`Click Área: ${clickedArea.text} (ID: ${clickedArea.id})`, 'info', FNAME_CLICK); switch (clickedArea.id) { case 'rect-log': break; case 'rect-link': try { window.open('https://google.com', '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } break; case 'rect-rerun': try { if(typeof leakedValueFromOOB !== 'undefined'){ const l=leakedValueFromOOB; if(l){const ls=l.type==='U64'?`L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Re-read Leak S1: ${ls}`,'leak', FNAME_CLICK); currentLeakData={text:ls, color:"#FF9800"};} else { logCanvas(`-> Re-read Leak S1: Nulo`, 'warn', FNAME_CLICK); currentLeakData={text:"L(S1):NULO", color:"#FFC107"};} } else { logCanvas(`-> Re-read Leak S1: Var N/A`, 'error', FNAME_CLICK); currentLeakData={text:"L(S1):Var N/A", color:"#F44336"};}}catch(e){ logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK);} redrawAll(); break; } } else if (clickedSquare) { logCanvas(`Click Quadrado ID: ${clickedSquare.id} (Texto: ${clickedSquare.text})`, 'vuln', FNAME_CLICK); if (clickedSquare.url) { try { window.open(clickedSquare.url, '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } } else if (clickedSquare.action && typeof clickedSquare.action === 'function') { let actionError = null; if (runBtnCanvas) runBtnCanvas.disabled = true; logCanvas(`Executando re-run ${clickedSquare.id} (${clickedSquare.action.name})...`, 'test', FNAME_CLICK); try { await clickedSquare.action(); logCanvas(`Re-run ${clickedSquare.id} concluído sem erro aparente.`, 'good', FNAME_CLICK); } catch (e) { logCanvas(`Erro durante re-run ${clickedSquare.id}: ${e.message}`, 'error', FNAME_CLICK); console.error(`Erro ação ${clickedSquare.id}:`, e); actionError = e; } finally { clickedSquare.color = actionError ? '#FFA500' : '#8A2BE2'; redrawAll(); if (runBtnCanvas) runBtnCanvas.disabled = false; logCanvas(`Re-run ${clickedSquare.id} finalizado.`, 'test', FNAME_CLICK); } } else { clickedSquare.text += "*"; redrawAll(); } } } catch (e) { logCanvas(`Erro GERAL listener clique: ${e.message}`, 'error', FNAME_CLICK); console.error(e); if (runBtnCanvas) runBtnCanvas.disabled = false; } };

                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                redrawAll();

            } catch(e) {
                 logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack);
            }
            finally {
                 logCanvas("\n==== GERANDO SUMÁRIO Script 2 ====", 'test', FNAME);
                 if (summaryDivS2) { /* ...código geração sumário v18.1... */ summaryDivS2.innerHTML = '<h2>Sumário Script 2 (Findings Críticos)</h2>'; if (findingsS2.length === 0) { summaryDivS2.innerHTML += '<p style="color:#4CAF50;">Nenhum finding crítico (vuln, critical, escalation) registrado.</p>'; } else { summaryDivS2.innerHTML += `<p style="color:#FFC107;">${findingsS2.length} finding(s) crítico(s) registrado(s):</p><ul>`; findingsS2.forEach(f => { const itemClass = f.type === 'critical' ? 'log-critical' : (f.type === 'escalation' ? 'log-escalation' : 'log-vuln'); const cleanMessage = f.message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); summaryDivS2.innerHTML += `<li class="${itemClass}">${f.time} [${f.funcName}] ${cleanMessage}</li>`; }); summaryDivS2.innerHTML += '</ul>'; } }
                 logCanvas("--- Fim da execução Script 2 (v20) ---", 'test', FNAME);
                 if (runBtnCanvas) runBtnCanvas.disabled = false;
            }
        };

        // Wrapper e Unload (Inalterados)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); gpuDevice = null; gpuAdapter = null; sprayHole = []; } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
