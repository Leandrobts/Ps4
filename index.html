<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Suite de Vulnerabilidades PS4</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 55vh; /* Aumentado mais para logs */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 50px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Testes de Vulnerabilidade PS4 (FW 12.02) - Script 1</h1>
    <p>Testa: XSS, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB, DOM Stress.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Suite de Vulnerabilidades PS4 - Script 2 (Canvas)</h2>
        <p>Foco: PP Avançado, OOB R/W (Metadata/ImageData), API Checks, Tentativa ROP.</p>
        <canvas id="interactive-canvas" width="300" height="100"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste S2 + ROP</button>
        <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 (v18.1 Adaptado PS4 - CORRIGIDO) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null;
        let potentialRealLibcPtr = null;
        let potentialRealKernelPtr = null;

        const BASE_LIBC = 0x180AC8000;
        const BASE_LIBKERNEL = 0x80FCA000;
        const SIZE_LIBC = 0x1200000;
        const SIZE_LIBKERNEL = 0x1100000;

        const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];

        const log = (message, type = 'info', funcName = '') => {
            let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type);
            if (!keepLog && type === 'good') {
                const lowerMsg = String(message).toLowerCase();
                if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('completo') || lowerMsg.includes('ok') || lowerMsg.includes('recebida') || lowerMsg.includes('adicionar blob/arraybuffer ok')) { keepLog = true; }
            }
            if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; }
            if (!keepLog) return;

            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';

                if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; }

                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
         };
        const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        const toHex64 = (high, low) => { if (typeof BigInt !== 'undefined') { try { const highBig = (BigInt(high >>> 0) << 32n); const lowBig = BigInt(low >>> 0); const fullBig = highBig | lowBig; return '0x' + fullBig.toString(16).toUpperCase().padStart(16, '0'); } catch(e) {} } return `H=0x${(high>>>0).toString(16).toUpperCase().padStart(8,'0')} L=0x${(low>>>0).toString(16).toUpperCase().padStart(8,'0')}`; };
        const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; };

        const testCSPBypass = async () => { /* ... (código inalterado) ... */ };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore'; log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME);
            // --- Definições Restauradas ---
            const bufferSize = 32;
            const writeValue = 0xEE;
            const oobWriteOffset = bufferSize;
            const readRangeStart = -64;
            const readRangeEnd = bufferSize + 64;
            const allocationSize = bufferSize + 256; // <<< Definição restaurada
            const baseOffsetInBuffer = 128;
            const oobReadOffsets = [];
            for (let i = readRangeStart; i < readRangeEnd; i += 4) { oobReadOffsets.push(i); }
            // --- Fim das Definições Restauradas ---

            let writeSuccess = false; let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null;
            potentialRealLibcPtr = null;
            potentialRealKernelPtr = null;

            try {
                // Agora allocationSize está definida
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;

                await PAUSE_S1();
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                    log(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME);
                    writeSuccess = true;
                } catch (e) { log(`Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) FALHOU/Bloqueada: ${e.message}`, 'good', FNAME); log(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME); return false; }

                await PAUSE_S1();
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;

                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true);
                            const high = dataView.getUint32(readTargetAddress + 4, true);
                            const valueU64Str = toHex64(high, low);
                            const isFillPattern = (high === 0xAAAAAAAA && low === 0xAAAAAAAA) || (high === 0xCCCCCCCC && low === 0xCCCCCCCC) || (high === 0xDDDDDDDD && low === 0xDDDDDDDD);
                            const isWritePattern = (valueU64Str === "0xAAAAAAAAEEAAAAAAAAAA");

                            if (!isFillPattern && !isWritePattern && (high !== 0 || low !== 0)) {
                                potentialLeakFoundCount++;
                                log(` -> OOB Read U64 ${relOffsetStr}: ${valueU64Str}`, 'leak', FNAME);
                                let isLikelyPtr = false;
                                let ptrType = "UNK";
                                if (typeof BigInt !== 'undefined') {
                                    try {
                                        const ptrBig = (BigInt(high >>> 0) << 32n) | BigInt(low >>> 0);
                                        if (ptrBig >= BASE_LIBKERNEL && ptrBig < (BASE_LIBKERNEL + SIZE_LIBKERNEL)) {
                                             log(` ---> POTENCIAL PONTEIRO KERNEL! ${valueU64Str}`, 'critical', FNAME);
                                             ptrType = "KERNEL"; isLikelyPtr = true;
                                             if (!potentialRealKernelPtr) potentialRealKernelPtr = { high, low, str: valueU64Str };
                                        } else if (ptrBig >= BASE_LIBC && ptrBig < (BASE_LIBC + SIZE_LIBC)) {
                                             log(` ---> POTENCIAL PONTEIRO LIBC! ${valueU64Str}`, 'critical', FNAME);
                                             ptrType = "LIBC"; isLikelyPtr = true;
                                             if (!potentialRealLibcPtr) potentialRealLibcPtr = { high, low, str: valueU64Str };
                                        }
                                    } catch(e) {}
                                }
                                if (leakedValueFromOOB === null) {
                                     leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset, str: valueU64Str };
                                     log(` -> PRIMEIRO LEAK U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                }
                                if (isLikelyPtr) {
                                     log(` ---> INSIGHT: O valor ${valueU64Str} parece apontar para ${ptrType}. Use um debugger para confirmar este endereço e encontrar o offset exato dentro do módulo ${ptrType} para calcular o slide ASLR.`, 'info', FNAME);
                                }
                            }
                        } catch (e) {}
                    }
                     if (readOffset % 32 === 0) await PAUSE_S1(1);
                }
            } catch (e) { log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME); console.error(e); }
            finally {
                const leakStatus = potentialRealKernelPtr ? `Leak KERNEL: ${potentialRealKernelPtr.str}` : (potentialRealLibcPtr ? `Leak LIBC: ${potentialRealLibcPtr.str}`: (leakedValueFromOOB ? `Primeiro Leak: ${leakedValueFromOOB.str}` : 'Nenhum leak U64 armazenado'));
                log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks U64 não-padrão, ${leakStatus}) ---`, 'test', FNAME);
                /* Comentário de Contexto para Exploração: (inalterado) */
            }
            return writeSuccess;
        };

        const testOOBUAFPattern = async () => { /* ... (código inalterado) ... */ };
        const testOOBOtherTypes = async () => { /* ... (código inalterado) ... */ };
        const testBasicPP = async () => { /* ... (código inalterado) ... */ };
        const testPPJsonHijack = async () => { /* ... (código inalterado) ... */ };
        const testWebSockets = async () => { /* ... (código inalterado) ... */ };
        const testWebWorkers = async () => { /* ... (código inalterado) ... */ };
        const testIndexedDB = async () => { /* ... (código inalterado) ... */ };
        const testDOMStress = async () => { /* ... (código inalterado) ... */ };

        const runAllTests = async () => {
            const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO Script 1 ====", 'test', FNAME);
            await testCSPBypass(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBReadInfoLeakEnhancedStore(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBUAFPattern(); await PAUSE_S1(MEDIUM_PAUSE);
            await testOOBOtherTypes(); await PAUSE_S1(MEDIUM_PAUSE);
            await testBasicPP(); await PAUSE_S1(MEDIUM_PAUSE);
            await testPPJsonHijack(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebSockets(); await PAUSE_S1(MEDIUM_PAUSE);
            await testWebWorkers(); await PAUSE_S1(MEDIUM_PAUSE);
            await testIndexedDB(); await PAUSE_S1(MEDIUM_PAUSE);
            await testDOMStress(); await PAUSE_S1(MEDIUM_PAUSE);
            log("\n==== Script 1 CONCLUÍDO ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };
    </script>

    <script>
        // --- Script 2: Canvas (Adaptado PS4, Tentativa ROP - CORRIGIDO) ---
        const SHORT_PAUSE_CANVAS = 50;
        // ... (listeners, areas, etc. inalteradas) ...
        const imgSquareSize = 28;
        const imgSquareSpacing = 5;
        const imgSquares = [];
        const imgSquaresStartY = 45;

        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;
        let gpuAdapter = null; let gpuDevice = null;

        let arbitraryReadWriteBuffer = null;
        let reliableWritePrimitive = null;
        let reliableReadPrimitive = null;

        // Placeholder para endereços de Gadgets ROP
        const ropGadgets = {
            pop_rdi_ret: { base: BASE_LIBC, offset: 0xDEADBEEF1 },
            pop_rsi_ret: { base: BASE_LIBC, offset: 0xDEADBEEF2 },
            pop_rdx_ret: { base: BASE_LIBC, offset: 0xDEADBEEF3 },
            mov_ptr_rdi_rsi_ret: { base: BASE_LIBC, offset: 0xDEADBEEF4 },
            sceKernelMprotect: { base: BASE_LIBKERNEL, offset: 0x24280 }, // Offset conhecido!
            sceKernelDlsym: { base: BASE_LIBKERNEL, offset: 0xDEADBEEF5 }
        };
        const shellcode = [0xCC, 0xCC, 0xCC, 0xCC];

        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good'];
        const logCanvas = (message, type = 'info', funcName = '') => { /* ... (inalterado) ... */ };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => { /* ... (inalterado) ... */ };
        const toHexCanvas64 = (high, low) => { /* ... (copiado de S1) ... */ };
        const isPotentialPointer64_S2 = (high, low) => { /* ... (inalterado) ... */ };
        const isPotentialData32_S2 = (val) => { /* ... (inalterado) ... */ };
        const drawInteractiveAreas = () => { /* ... (inalterado) ... */ };
        const drawImageSquares = () => { /* ... (inalterado) ... */ };
        const redrawAll = () => { /* ... (inalterado) ... */ };

        const testWebGLCheck = async () => { /* ... (código inalterado) ... */ };
        const testAdvancedPP = async () => { /* ... (código inalterado) ... */ };

        const testOOBReadEnhanced = async () => {
             const FNAME = 'testOOBReadEnhanced'; logCanvas("--- Teste: OOB Read Enhanced Scan ---",'test', FNAME);
             // --- Definições Restauradas ---
             const bufferSize=32;
             const readRangeStart=-128;
             const readRangeEnd=bufferSize+128;
             const allocationSize = bufferSize + 512; // <<< Definição restaurada
             const baseOffsetInBuffer = 256;
             // --- Fim das Definições Restauradas ---

             let potentialLeakFoundCount=0;
             try {
                // Agora allocationSize está definida
                const buffer=new ArrayBuffer(allocationSize);
                const dataView=new DataView(buffer);
                for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); } // Preenche com 0xCC

                for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){
                    const readTargetAddress=baseOffsetInBuffer+readOffset;
                    const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;

                    if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){
                        try{
                            const low=dataView.getUint32(readTargetAddress,true);
                            const high=dataView.getUint32(readTargetAddress+4,true);
                            const valueU64Str = toHexCanvas64(high, low);
                            const isFillPattern = (high === 0xAAAAAAAA && low === 0xAAAAAAAA) || (high === 0xCCCCCCCC && low === 0xCCCCCCCC) || (high === 0xDDDDDDDD && low === 0xDDDDDDDD);

                            if (!isFillPattern && (high !== 0 || low !== 0)) {
                                potentialLeakFoundCount++;
                                logCanvas(` -> OOB Read U64 ${relOffsetStr}: ${valueU64Str}`, 'leak', FNAME);
                                let isLikelyPtr = false;
                                let ptrType = "UNK";
                                if (typeof BigInt !== 'undefined') {
                                     try {
                                         const ptrBig = (BigInt(high >>> 0) << 32n) | BigInt(low >>> 0);
                                         if (ptrBig >= BASE_LIBKERNEL && ptrBig < (BASE_LIBKERNEL + SIZE_LIBKERNEL)) {
                                             logCanvas(` ---> POTENCIAL PONTEIRO KERNEL! ${valueU64Str}`, 'critical', FNAME);
                                             ptrType = "KERNEL"; isLikelyPtr = true;
                                             if (!potentialRealKernelPtr) potentialRealKernelPtr = { high, low, str: valueU64Str };
                                         } else if (ptrBig >= BASE_LIBC && ptrBig < (BASE_LIBC + SIZE_LIBC)) {
                                             logCanvas(` ---> POTENCIAL PONTEIRO LIBC! ${valueU64Str}`, 'critical', FNAME);
                                             ptrType = "LIBC"; isLikelyPtr = true;
                                             if (!potentialRealLibcPtr) potentialRealLibcPtr = { high, low, str: valueU64Str };
                                         }
                                     } catch(e) {}
                                }
                                if (isLikelyPtr) {
                                     logCanvas(` ---> INSIGHT: O valor ${valueU64Str} parece apontar para ${ptrType}. Use um debugger para confirmar e encontrar o offset.`, 'info', FNAME);
                                }
                            }
                        }catch(e){}
                    }
                     if(readOffset % 64 === 0) await PAUSE(1);
                }
             } catch(e) { logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); }
             finally {
                const leakStatus = potentialRealKernelPtr ? `Leak KERNEL: ${potentialRealKernelPtr.str}` : (potentialRealLibcPtr ? `Leak LIBC: ${potentialRealLibcPtr.str}`: 'Nenhum leak K/L armazenado');
                logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks U64 não-padrão, ${leakStatus}) ---`,'test', FNAME);
                /* Comentário de Contexto para Exploração: (inalterado) */
             }
             await PAUSE();
             return potentialRealKernelPtr || potentialRealLibcPtr;
        };

        const testOOBWriteMetadata = async () => { /* ... (código com offsets expandidos e filler spray inalterado da resposta anterior) ... */ };
        const testOOBWriteToImageDataCheck = async () => { /* ... (código inalterado) ... */ };
        const testOOBWriteOnly = async () => { /* ... (código inalterado) ... */ };
        const testFileSystemAccess = async () => { /* ... (código inalterado) ... */ };
        const testWebGPUCheck = async () => { /* ... (código inalterado) ... */ };
        const attemptRopExecution = async () => { /* ... (código da função conceitual ROP inalterado da resposta anterior) ... */ };

        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas'); 
            coordStatusDiv = document.getElementById('canvas-coord-status'); 
            canvasElement = document.getElementById('interactive-canvas'); 
            const runBtnCanvas = document.getElementById('runCanvasBtn');

            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) { console.error("FATAL: Elementos essenciais S2 não encontrados!"); return; }
             if (runBtnCanvas) runBtnCanvas.disabled = true;
             outputDivCanvas.innerHTML = '';
             logCanvas("Iniciando sequência Script 2 (PS4 v12.02)...", "test", FNAME);

             imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
             const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP }, { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced }, { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq4', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq5', text: 'GPU', color: '#337BFF', action: testWebGPUCheck }, ];
             squareDefs.forEach(def => { if (sqX + imgSquareSize + imgSquareSpacing > canvasElement.width -5 && sqX > 10) { sqX = 10; sqY += imgSquareSize + imgSquareSpacing; } if (sqY + imgSquareSize > canvasElement.height - 15) { logCanvas(`AVISO: Não há espaço para o quadrado ${def.id} no canvas (Y: ${sqY}). Pulando.`, 'warn', FNAME); return; } imgSquares.push({ id: def.id, x: sqX, y: sqY, size: imgSquareSize, color: def.color, text: def.text, hover: false, url: def.url, action: def.action }); sqX += imgSquareSize + imgSquareSpacing; });


            try {
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; }
                 redrawAll(); await PAUSE();
                 try { if (typeof leakedValueFromOOB !== 'undefined' && leakedValueFromOOB) { const l = leakedValueFromOOB; const ls = `L(S1):${l.type} ${l.str}@${l.offset}`; logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 nulo/não encontrado.`, 'warn', FNAME); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; console.error(e); }
                 redrawAll(); await PAUSE();

                await testWebGLCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testAdvancedPP(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced(); await PAUSE(SHORT_PAUSE_CANVAS); 
                let writePrimitiveObtained = await testOOBWriteMetadata(); await PAUSE(SHORT_PAUSE_CANVAS); 
                // await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS); 
                await testFileSystemAccess(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testWebGPUCheck(); await PAUSE(SHORT_PAUSE_CANVAS);

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME);
                await PAUSE(100);

                await attemptRopExecution();
                await PAUSE(MEDIUM_PAUSE);

                 if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} }
                 if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }
                 canvasMoveListener = (event) => { /* ... inalterado ... */ };
                 canvasClickListener = async (event) => { /* ... inalterado ... */ };
                 canvasElement.addEventListener('click', canvasClickListener);
                 canvasElement.addEventListener('mousemove', canvasMoveListener);
                 redrawAll();

            } catch(e) {
                logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack);
            }
            finally {
                logCanvas("--- Fim da execução Script 2 ---", 'test', FNAME);
                if (runBtnCanvas) runBtnCanvas.disabled = false;
            }
        };

        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { /* ... (inalterado) ... */ });
    </script>

</body>
</html>
