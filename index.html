<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (Verbose Logging)</title>
    <style>
        /* Estilos CSS Idênticos */
        /* ... */
        .verbose-log { color: #BDBDBD; font-size: 0.9em; } /* Classe para logs verbosos */
    </style>
</head>
<body>
    <h1>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (Verbose Logging)</h1>
    <select id="testSelector">
        <option value="all_tests">Run All Tests (Incl. Ext. Detection - Verbose)</option>
        <option value="oob_write_aggressive">Aggressive OOB Write (Info Leak Demo)</option>
        <option value="oob_impact_tests">OOB Impact (Metadata/Crash)</option>
        <option value="csp_bypass_aggressive">Aggressive CSP Bypass (Direct Impact)</option>
        <option value="uaf_basic_verbose">Basic Use-After-Free Tests (Verbose Log)</option>
        <option value="type_confusion_basic_verbose">Basic Type Confusion Tests (Verbose Log)</option>
    </select>
    <script>
// ======================
// CONFIGURAÇÃO E FUNÇÕES BÁSICAS (Idênticas)
// ======================
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!
// ... (Restante das funções básicas idênticas: DOMContentLoaded, log, clearLog, potentialVulnsFound, sendVulnerabilityNotification, demonstrate*) ...

// ======================
// Aggressive POC Tests (Com Logging Verboso em UAF/TC)
// ======================
const aggressiveTests = {

    // --- Testes OOB e CSP (Idênticos à versão anterior) ---
    "oob_write_aggressive": async function() { /* ... código idêntico anterior ... */ },
    "test_oob_metadata": async function() { /* ... código idêntico anterior ... */ },
    "test_oob_crash_probe": async function() { /* ... código idêntico anterior ... */ },
    "csp_bypass_aggressive": async function() { /* ... código idêntico anterior ... */ },


    // --- NOVOS TESTES DE DETECÇÃO (COM LOGGING VERBOSO) ---

    "uaf_basic_verbose": async function() { // Renomeado para clareza
        log("[UAF-VERBOSE] Attempting basic Use-After-Free scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state before potential issues.", "info");

        // Cenário 1: DOM Node reference after removal
        let parent, child, childRef, tagName, rect; // Declarar fora do try para Scoping
        try {
            log("[UAF-VERBOSE] Scenario 1: DOM Node Ref After Removal", "extended-test");
            log("[UAF-VERBOSE] Creating parent div...", "verbose-log");
            parent = document.createElement('div');
            log("[UAF-VERBOSE] Creating child span...", "verbose-log");
            child = document.createElement('span');
            log("[UAF-VERBOSE] Appending child to parent...", "verbose-log");
            parent.appendChild(child);
            log("[UAF-VERBOSE] Appending parent to body...", "verbose-log");
            document.body.appendChild(parent);

            log("[UAF-VERBOSE] Storing reference to child.", "verbose-log");
            childRef = child; // Keep reference

            log("[UAF-VERBOSE] Removing child from parent...", "verbose-log");
            parent.removeChild(child);
            log("[UAF-VERBOSE] Removing parent from body...", "verbose-log");
            document.body.removeChild(parent);
            log("[UAF-VERBOSE] Parent and child removed from DOM.", "verbose-log");

            log("[UAF-VERBOSE] Hinting GC by allocating memory...", "verbose-log");
            try { new ArrayBuffer(10 * 1024 * 1024); log("[UAF-VERBOSE] Memory allocated.", "verbose-log"); } catch(e) {log("[UAF-VERBOSE] Memory allocation failed (expected?).", "verbose-log warning");}

            log("[UAF-VERBOSE] Waiting 500ms...", "verbose-log");
            await new Promise(resolve => setTimeout(resolve, 500));

            log(`[UAF-VERBOSE] --> Accessing childRef.tagName after potential free...`, "info extended-test");
            tagName = childRef.tagName; // Potential UAF access
            log(`[UAF-VERBOSE] <-- childRef.tagName accessed. Value = ${tagName}. Type = ${typeof tagName}`, "verbose-log success");

            log(`[UAF-VERBOSE] --> Calling childRef.getBoundingClientRect() after potential free...`, "info extended-test");
            rect = childRef.getBoundingClientRect(); // Potential UAF access
            log(`[UAF-VERBOSE] <-- getBoundingClientRect called. Return type = ${typeof rect}. Properties sample: width=${rect?.width}`, "verbose-log success");

            log("[UAF-VERBOSE] Releasing childRef.", "verbose-log");
            childRef = null; // Release reference explicitly

        } catch (e) {
            log(`❌ Error in UAF Scenario 1: ${e.message}. Check preceding logs. Potential UAF?`, "danger extended-test");
            console.error("UAF Scenario 1 Error Details:", e);
            sendVulnerabilityNotification({ vulnerability: 'UAF_BASIC_SCENARIO1_ERROR', details: e.message });
        } finally {
            // Log final para indicar que o bloco terminou (se não crashou)
             log("[UAF-VERBOSE] Scenario 1 finished.", "verbose-log info");
        }

        log("[UAF-VERBOSE] Scenario 2: ArrayBuffer/TypedArray (Placeholder - complex)", "extended-test info");
        log("INFO: Reliable UAF tests for buffers usually require specific engine bugs/APIs.", "info");

        log("[UAF-VERBOSE] Completed basic UAF tests.", "extended-test info");
    },

    "type_confusion_basic_verbose": async function() { // Renomeado para clareza
        log("[TYPE-CONFUSION-VERBOSE] Attempting basic Type Confusion scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state.", "info");

        // Cenário 1: Passar tipo errado para API que espera objeto específico
        try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 1: Incorrect type to DOM API", "extended-test");

            log(`[TYPE-CONFUSION-VERBOSE] --> Sending 'window' via postMessage...`, "info extended-test");
            try {
                 window.postMessage(window, "*");
                 log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) did not throw.`, "verbose-log success");
            } catch(e_pm1) {
                 log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) threw: ${e_pm1.message}`, "verbose-log success"); // Expected usually
            }

            let fakeEvent = { target: document.body, type: "click", bubbles: false };
            log(`[TYPE-CONFUSION-VERBOSE] Created fake event object: ${JSON.stringify(fakeEvent)}`, "verbose-log");
            log(`[TYPE-CONFUSION-VERBOSE] --> Dispatching fake event object...`, "info extended-test");
            try {
                 document.dispatchEvent(fakeEvent);
                 log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) did not throw.`, "verbose-log success");
            } catch(e_de1) {
                  log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) threw: ${e_de1.message}`, "verbose-log success"); // Expected usually
            }
            log("[TYPE-CONFUSION-VERBOSE] Scenario 1 Part 1 finished.", "verbose-log info");

        } catch (e) {
            log(`❌ Error in Type Confusion Scenario 1: ${e.message}. Investigate.`, "danger extended-test");
            console.error("Type Confusion Scenario 1 Error:", e);
            sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO1_ERROR', details: e.message });
        } finally {
             log("[TYPE-CONFUSION-VERBOSE] Scenario 1 finished.", "verbose-log info");
        }

         // Cenário 2: Confusão entre Primitivos e Objetos
         try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 2: Primitive vs Object", "extended-test");
             let numPrimitive = 5;
             let numObject = new Number(5);
             log(`[TYPE-CONFUSION-VERBOSE] numPrimitive = ${numPrimitive} (type: ${typeof numPrimitive})`, "verbose-log");
             log(`[TYPE-CONFUSION-VERBOSE] numObject = ${numObject} (type: ${typeof numObject})`, "verbose-log");

             log(`[TYPE-CONFUSION-VERBOSE] --> Calling numPrimitive.toFixed(numObject)...`, "info extended-test");
             try {
                 let result = numPrimitive.toFixed(numObject);
                 log(`[TYPE-CONFUSION-VERBOSE] <-- numPrimitive.toFixed(numObject) returned: ${result}. Type: ${typeof result}`, "verbose-log success");
             } catch(e_tf1) {
                  log(`[TYPE-CONFUSION-VERBOSE] <-- numPrimitive.toFixed(numObject) threw: ${e_tf1.message}`, "danger extended-test"); // Error here might indicate interesting behavior
                   sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numObject) error: ${e_tf1.message}` });
             }

             log(`[TYPE-CONFUSION-VERBOSE] --> Calling numObject.toFixed(numPrimitive)...`, "info extended-test");
              try {
                 let result2 = numObject.toFixed(numPrimitive);
                 log(`[TYPE-CONFUSION-VERBOSE] <-- numObject.toFixed(numPrimitive) returned: ${result2}. Type: ${typeof result2}`, "verbose-log success");
             } catch(e_tf2) {
                  log(`[TYPE-CONFUSION-VERBOSE] <-- numObject.toFixed(numPrimitive) threw: ${e_tf2.message}`, "danger extended-test"); // Error here might indicate interesting behavior
                  sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numPrimitive) error: ${e_tf2.message}` });
             }


         } catch(e) {
             log(`❌ Error in Type Confusion Scenario 2: ${e.message}. Investigate.`, "danger extended-test");
             console.error("Type Confusion Scenario 2 Error:", e);
             sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: e.message });
         } finally {
             log("[TYPE-CONFUSION-VERBOSE] Scenario 2 finished.", "verbose-log info");
         }

        log("[TYPE-CONFUSION-VERBOSE] Completed basic Type Confusion tests.", "extended-test info");
    },

    // --- Executor Principal Atualizado ---
    "all_tests": async function() { // Mantido nome anterior, mas agora inclui testes verbosos
        log("=== Running All Tests (Incl. Extended Detection - Verbose Log) ===", "section");
        // ... (execução sequencial idêntica à anterior, chamando as novas funções renomeadas) ...
        await aggressiveTests["oob_write_aggressive"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));
        if (potentialVulnsFound.oobWrite) { await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000)); await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000)); }
        else { log("Skipping OOB impact tests.", "warning"); }
        await aggressiveTests["csp_bypass_aggressive"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        await aggressiveTests["uaf_basic_verbose"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000)); // Chama a versão verbosa
        await aggressiveTests["type_confusion_basic_verbose"](); // Chama a versão verbosa
        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },
    "oob_impact_tests": async function() { /* ... código idêntico anterior ... */ }
    // Adiciona os testes individuais verbosos ao objeto para serem selecionáveis
    ,"uaf_basic": async function() { await this.uaf_basic_verbose(); } // Alias para manter compatibilidade se necessário
    ,"type_confusion_basic": async function() { await this.type_confusion_basic_verbose(); } // Alias
};
aggressiveTests["uaf_basic_verbose"] = aggressiveTests.uaf_basic_verbose; // Garante que está no objeto
aggressiveTests["type_confusion_basic_verbose"] = aggressiveTests.type_confusion_basic_verbose; // Garante que está no objeto


// ======================
// Test Runner (Atualizado para novas opções)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;
    // Renomeado no select, ajustar aqui também
    const testFunctionToRun = (selectedTest === 'uaf_basic' || selectedTest === 'type_confusion_basic')
                             ? selectedTest + '_verbose' // Roda a versão verbosa mesmo se o valor antigo for selecionado
                             : selectedTest;

    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first.", "warning"); }
    clearLog(); log(`=== Starting Test: ${testFunctionToRun} ===`, "section"); // Usa o nome da função real

    if (aggressiveTests[testFunctionToRun]) {
        await aggressiveTests[testFunctionToRun](); // Chama a função de teste correta
        log(`\n=== Test Execution for "${testFunctionToRun}" Completed. Review logs & endpoint. ===`, "section");
    } else {
        log(`Error: Test "${testFunctionToRun}" not found.`, "danger");
    }
}
</script>
</body>
</html>
