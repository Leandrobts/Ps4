<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v17 - Base Original + Fase 2 Isolada</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } /* ... (restante dos estilos) ... */
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; } .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
    </style>
</head>
<body>
    <h1>PoC v17 - Base Original + Fase 2 Isolada</h1>
    <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="350" height="200"></canvas>
    <div id="canvas-coord-status">Passe o mouse sobre o canvas ↑</div>
    <p>Fase 1: PoC Original (XSS s/ alert). Fase 2: Aprofundamento Isolado.</p>
    <button id="runBtn" onclick="runEverythingSequentially()">Iniciar Teste Completo</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const coordStatusDiv = document.getElementById('canvas-coord-status');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        const LONG_PAUSE = 3000; // Pausa longa entre fases
        let leakedValueFromOOB = null; // Global para valor OOB da Fase 1
        let canvasClickListener = null;
        let canvasMoveListener = null;
        let xssRanFlag = false; // Global para flag XSS da Fase 1
        let rectArea = { x: 10, y: 10, w: 30, h: 30 }; // Global p/ Canvas Listener
        let linkArea = { x: 150, y: 100, w: 60, h: 30 }; // Global p/ Canvas Listener

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... (implementação completa) ... */ };

        // --- Helpers (toHex, Heurísticas) ---
        const toHex = (val, bits = 32) => { /* ... (implementação completa) ... */ };
        const isPotentialPointer64 = (high, low) => { /* ... (heurística original) ... */ };
        const isPotentialData32 = (val) => { /* ... (heurística original) ... */ };


        // ========================================================
        // --- FASE 1: Código Original Modificado Minimamente ---
        // ========================================================
        log("Definindo Funções Originais da Fase 1 (XSS sem alert)", "info");

        // Teste Original 1: CSP Bypass / XSS (SEM ALERT)
        const originalTestCSPBypass = async () => {
            log("--- [Fase 1] Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            xssRanFlag = false;
            // 1.1 Data URI (Sem Alert)
            log("Tentando XSS via data: URI (sem alert)...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE));
            try {
                const payloadJS = `try { log("[Payload Data/F1:] Executado!", "vuln"); window.xssRanFlag = true; } catch(e) { log("[Payload Data/F1:] Bloqueado: " + e.message, "good"); }`; // Sem alert
                const encodedPayload = btoa(payloadJS); const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,'+encodedPayload; scriptTag.onerror = () => { log("[F1] ERRO data: URI!","error"); }; document.body.appendChild(scriptTag); log("[F1] Tag data: URI adicionada.",'info');
            } catch (e) { log(`[F1] Erro data URI: ${e.message}`,'error'); }
            await new Promise(r=>setTimeout(r,SHORT_PAUSE*2));
            // 1.2 Onerror (Sem Alert)
            log("Tentando XSS DOM via onerror (sem alert)...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img'); imgTag.src = 'invalid_'+Date.now();
                const onerrorPayload = `
                    try {
                        log("[F1] Payload onerror iniciado!", "info");
                        const target = document.getElementById('xss-target-div');
                        if (target) { target.innerHTML = '<h2 class="log-vuln">[F1] XSS DOM ONERROR!</h2>'; }
                        window.xssRanFlag = true; // Define a flag
                        log("[F1] XSS DOM via onerror realizado no log! Flag setada.", "vuln");
                    } catch(e) { log("[F1] Erro payload onerror: " + e.message, "warn"); }`; // Sem alert
                imgTag.setAttribute('onerror', onerrorPayload); document.body.appendChild(imgTag); log("[F1] Tag img onerror adicionada.",'info');
            } catch (e) { log(`[F1] Erro img onerror: ${e.message}`,'error'); }
            await new Promise(r => setTimeout(r, MEDIUM_PAUSE)); // Pausa p/ onerror
            log(`--- [Fase 1] Teste 1 Concluído (Flag XSS = ${xssRanFlag}) ---`, 'test');
            // Não retorna valor explícito, mas define flag global
        };

        // Teste Original 2: OOB Write/Read (Lógica Original)
        const originalTestOOBReadInfoLeakEnhancedStore = async () => {
             log("--- [Fase 1] Iniciando Teste 2: OOB Write/Read Extensivo ---", 'test');
             // ... (Código EXATO de testOOBReadInfoLeakEnhancedStore da PRIMEIRA mensagem) ...
             // ... (A lógica original armazenava o PRIMEIRO valor U64/U32 "interessante" encontrado) ...
             log("--- [Fase 1] Teste 2 Concluído (aparentemente) ---", 'test');
             // A função original não retornava valor, mas vamos adicionar para robustez do await
             return true;
        };

        // Teste Original 3: PP Básica (Lógica Original + return)
        const originalTestBasicPP = async () => {
             log("--- [Fase 1] Iniciando Teste 3: PP Básica ---", 'test');
             const testProp = '__pp_basic_test__'; const testValue = 'Polluted!'; let success = false;
             try { /* ... (lógica exata do testBasicPP original) ... */ } catch (e) { log(`Erro PP Básico: ${e.message}`, 'error'); success = false; } finally { /* ... (lógica exata do finally original) ... */ }
             log(`--- [Fase 1] Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
             return success; // Retorna status
        };

        // Teste Original 4: PP Hijack (Lógica Original + return)
        const originalTestPPJsonHijack = async () => {
             log("--- [Fase 1] Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
             const originalStringify = JSON.stringify; let hijackSuccessful=false; let interactionSuccessful=false; let hijackReturnedCorrectly=false;
             try { /* ... (lógica exata do testPPJsonHijack original) ... */ } catch (e) { log(`Erro PP Hijack JSON: ${e.message}`, 'error'); hijackReturnedCorrectly = false; } finally { /* ... (lógica exata do finally original) ... */ }
             log(`--- [Fase 1] Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou'}) ---`, 'test');
             return hijackReturnedCorrectly; // Retorna status
        };

        // Função para rodar a Fase 1 (lógica original de runAllTests)
        const runPhase1_Original = async () => {
             log("==== [Fase 1] INICIANDO runPhase1_Original ====", 'critical');
             // Chamadas na ordem original
             await originalTestCSPBypass();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestOOBReadInfoLeakEnhancedStore();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestBasicPP();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
             await originalTestPPJsonHijack();
             await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE)); // Pausa final original
             log("==== [Fase 1] runPhase1_Original CONCLUÍDA ====", 'critical');
             log(`==== [Fase 1] Estado Pós-Fase 1: xssFlag=<span class="math-inline">\{xssRanFlag\}, OOB\=</span>{leakedValueFromOOB?'Stored':'null'} ====`,'info');
        };


        // ==========================================================
        // --- FASE 2: Testes Adicionais Isolados ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");

        // Definições dos testes A, B, C, F, J, K, D/E Combinado
        // (Usando as implementações da v15.5, com interações)
        const testBasicDataCollection = async () => { /* ... */ log("--- [Fase 2] A: Coleta Dados Concluído ---", 'test'); };
        const testEnvironmentProbing = async () => { /* ... */ log("--- [Fase 2] B: Sondagem Ambiente Concluído ---", 'test'); };
        const testAdvancedFingerprinting = async () => { /* ... */ log("--- [Fase 2] C: Fingerprinting Adv Concluído ---", 'test'); };
        const testErrorObservation = async () => { /* ... */ log("--- [Fase 2] F: Observação Erros Concluído ---", 'test'); };
        const testAdvancedPP = async () => { /* ... */ log("--- [Fase 2] J: PP Avançada Concluído ---", 'test'); };
        const testPPGadgetAttempts = async () => { /* ... */ log("--- [Fase 2] K: PP Gadgets Concluído ---", 'test'); };
        const testComprehensiveCanvas = async () => { /* ... (Código D/E combinado v15.5, sem stress desenho, lendo xssRanFlag/OOB) ... */ log("--- [Fase 2] D/E: Canvas Completo Concluído ---", 'test'); };

        // Função para rodar a Fase 2
        const runPhase2_NewTests = async () => {
            log("==== [Fase 2] INICIANDO runPhase2_NewTests ====", 'critical');
            await testBasicDataCollection(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // A
            await testEnvironmentProbing(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // B
            await testAdvancedFingerprinting(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // C
            await testErrorObservation(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // F
            await testAdvancedPP(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // J
            await testPPGadgetAttempts(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // K
            await testComprehensiveCanvas(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // D/E Combinado
            log("==== [Fase 2] runPhase2_NewTests CONCLUÍDA ====", 'critical');
        }


        // --- Função Principal ---
        const runEverythingSequentially = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v17 (Base Original + Fase 2 Isolada) ====", 'critical');

            log(">>> Iniciando Fase 1 (Testes Originais Fiéis) <<<", 'warn');
            // Executa Fase 1 - SEM try/catch extra, para manter originalidade
            //
