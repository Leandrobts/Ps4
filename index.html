<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - Teste v10 (PP Hijack setTimeout + OOB Read)</title>
    <style>
        /* Estilos CSS (iguais aos anteriores) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - Teste v10 (PP Hijack setTimeout + OOB Read)</h1>
    <p>Testa: XSS, OOB R/W, PP Básica, PP Hijack (setTimeout p/ OOB Read).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 100; // ms
        const MEDIUM_PAUSE = 500; // ms

        // --- Globals ---
        let oobDataView = null; // Para guardar o DataView do teste OOB
        let oobBaseOffset = 0;  // Para guardar o offset base do buffer OOB
        const OOB_READ_TARGET_OFFSET = 32; // Offset OOB para tentar ler no hijack

        // --- Função de Log ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Teste 1: CSP Bypass / XSS ---
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // ... (código igual ao script v9) ...
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now(); // Fonte inválida única
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };


        // --- Teste 2: Configurar Ambiente OOB R/W ---
        // Apenas configura o buffer e DataView, e confirma OOB Write.
        // Guarda o DataView e baseOffset globalmente para Teste 4.
        const setupOOBEnvironment = async () => {
            log("--- Iniciando Teste 2: Configurar Ambiente OOB R/W ---", 'test');
            const bufferSize = 32;
            const writeValue = 0xEE;
            const oobWriteOffset = 32; // Offset para confirmar escrita
            let writeSuccess = false;
            oobDataView = null; // Reseta globais
            oobBaseOffset = 0;

            try {
                const buffer = new ArrayBuffer(bufferSize + 256); // Buffer grande
                const localDataView = new DataView(buffer);
                const localBaseOffset = 128;

                // Preenche com padrão
                for (let i = 0; i < buffer.byteLength; i++) { localDataView.setUint8(i, 0xAA); }

                // Confirma a escrita OOB
                const writeTargetAddress = localBaseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset} (addr ${writeTargetAddress}) para confirmar...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    localDataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                    writeSuccess = true;
                    // Guarda as referências se a escrita funcionou
                    oobDataView = localDataView;
                    oobBaseOffset = localBaseOffset;
                    log(`Ambiente OOB (DataView/BaseOffset) configurado para Teste 4.`, 'info');
                } catch (e) {
                    log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good');
                }
            } catch (e) { log(`Erro inesperado durante configuração OOB: ${e.message}`, 'error'); }

            log(`--- Teste 2 Concluído (Ambiente OOB ${writeSuccess ? 'Configurado' : 'Falhou'}) ---`, 'test');
            return writeSuccess;
        };


        // --- Teste 3: Prototype Pollution (Básica) ---
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            // ... (código igual ao script v9) ...
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: PP Hijack (setTimeout para acionar OOB Read) ---
        // NOVO: Tenta sequestrar setTimeout e fazer OOB Read a partir dele
        const testPPSetTimeoutHijack = async () => {
            log("--- Iniciando Teste 4: PP Hijack (setTimeout p/ OOB Read) ---", 'test');
            const originalSetTimeout = window.setTimeout; // Guarda a função original
            let hijackSuccessful = false;
            let oobReadAttempted = false;

            // Variável para garantir que o hijack só execute a lógica uma vez
            let hijackExecuted = false;

            try {
                log("Tentando sobrescrever window.setTimeout...", 'subtest');
                window.setTimeout = function hijackedSetTimeout(callback, delay, ...args) {
                    // Executa a lógica do hijack apenas uma vez para evitar loops infinitos
                    if (!hijackExecuted) {
                        hijackExecuted = true; // Marca como executado
                        log("===> VULN: DENTRO DA FUNÇÃO setTimeout SEQUESTRADA! <===", 'vuln');
                        hijackSuccessful = true;

                        // Tenta realizar a leitura OOB usando o ambiente do Teste 2
                        log(`  -> Hijack: Tentando OOB Read U32 @${OOB_READ_TARGET_OFFSET} usando DataView global...`, 'info');
                        oobReadAttempted = true;
                        if (oobDataView && oobBaseOffset !== 0) {
                            const readTargetAddress = oobBaseOffset + OOB_READ_TARGET_OFFSET;
                            try {
                                const val32 = oobDataView.getUint32(readTargetAddress, true);
                                log(`  -> Hijack: Leitura OOB U32 @${OOB_READ_TARGET_OFFSET} retornou: ${toHex(val32, 32)}`, 'leak');
                            } catch (e) {
                                log(`  -> Hijack: Leitura OOB U32 @${OOB_READ_TARGET_OFFSET} FALHOU: ${e.message}`, 'error');
                            }
                        } else {
                            log(`  -> Hijack: Falha - Ambiente OOB (DataView/BaseOffset) não está configurado.`, 'warn');
                        }
                         // Chama log() novamente para provar controlo
                         log("  -> Hijack: Log interno executado.", 'vuln');
                    }

                    // Chama o setTimeout original para não quebrar completamente a funcionalidade
                    // É crucial chamar o original DEPOIS da nossa lógica para evitar recursão infinita imediata
                    // se o callback chamar setTimeout novamente.
                    // Passa os argumentos originais.
                    return originalSetTimeout.call(window, callback, delay, ...args);
                };

                log("Ambiente setTimeout sequestrado.", 'info');
                log("Teste 5 irá chamar setTimeout para acionar o hijack.", 'info');

            } catch (e) {
                log(`Erro durante configuração do PP Hijack setTimeout: ${e.message}`, 'error');
                // Restaura em caso de erro na configuração
                window.setTimeout = originalSetTimeout;
            }
            // Não restauramos aqui, o Teste 5 precisa da versão sequestrada
            log(`--- Teste 4 Concluído (Setup PP Hijack setTimeout ${hijackSuccessful ? 'Realizado' : 'Falhou'}) ---`, 'test');
            return hijackSuccessful;
        };

         // --- Teste 5: Acionar setTimeout Sequestrado ---
         const triggerHijackedSetTimeout = async () => {
            log("--- Iniciando Teste 5: Acionar setTimeout Sequestrado ---", 'test');
            const originalSetTimeout = window.setTimeout; // Pega a versão atual (sequestrada ou não)

            log("Chamando setTimeout(..., 10) para acionar o hijack...", 'subtest');
            await new Promise(resolve => {
                originalSetTimeout(() => {
                    log("Callback do setTimeout original (ou sequestrado) executado.", 'info');
                    resolve(); // Resolve a promessa quando o callback original (ou o hijack) terminar
                }, 10); // Delay pequeno
            });

            // Restaura a função setTimeout original AGORA, após o teste
            // (Assume que testPPSetTimeoutHijack guardou a original corretamente)
             if (window.setTimeout !== testPPSetTimeoutHijack.originalSetTimeout && typeof testPPSetTimeoutHijack.originalSetTimeout === 'function') {
                 // A linha acima tem um erro lógico, a original está no escopo da função anterior.
                 // Precisamos guardá-la globalmente ou restaurar de outra forma.
                 // SOLUÇÃO SIMPLES: Recarrega a página ou assume que foi restaurada no finally do teste anterior (se desse erro)
                 // Para este PoC, vamos apenas logar e não tentar restaurar aqui para evitar complexidade.
                 log("AVISO: Restauração manual do setTimeout não implementada neste ponto.", 'warn');
             } else {
                 // log("setTimeout parece já ter sido restaurado ou não foi sequestrado.", 'info');
             }

             log("--- Teste 5 Concluído (Verificar logs do hijack no Teste 4) ---", 'test');
         }


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO TODOS OS TESTES COMBINADOS v10 (PP Hijack setTimeout) ====", 'critical');

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            const step2_success = await setupOOBEnvironment(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            // Só continua se o ambiente OOB foi configurado
            if (step2_success) {
                await testBasicPP(); // Teste 3
                await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

                const step4_success = await testPPSetTimeoutHijack(); // Teste 4 (Setup Hijack)
                await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

                // Só aciona se o hijack foi configurado
                if (step4_success) {
                    await triggerHijackedSetTimeout(); // Teste 5 (Aciona Hijack)
                    await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
                } else {
                     log("Teste 5 ignorado (Falha no setup do hijack).", 'warn');
                }
            } else {
                 log("Testes 3, 4 e 5 ignorados (Falha na configuração do ambiente OOB).", 'warn');
            }

            log("\n==== TODOS OS TESTES COMBINADOS v10 CONCLUÍDOS ====", 'critical');
            // Tenta restaurar setTimeout globalmente (melhor esforço)
            // Nota: Isso requer que a variável `originalSetTimeout` seja acessível globalmente.
            // Refatoração necessária para fazer isso corretamente.
            // Como está, a restauração só acontece se o teste 4 falhar no try/catch.
            log("AVISO: Restauração final do setTimeout pode não ter ocorrido.", "warn");

            if (runBtn) runBtn.disabled = false;
        };

        // Guarda a referência original globalmente ANTES de qualquer hijack
        const originalSetTimeoutRef = window.setTimeout;
        // Adiciona a referência ao escopo da função de teste para restauração no finally
        // (Isso ainda não está ideal, a restauração deve ser mais robusta)
        testPPSetTimeoutHijack.originalSetTimeout = originalSetTimeoutRef;


        // Opcional: descomente para rodar automaticamente ao carregar
        // document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
