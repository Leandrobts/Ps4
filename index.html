<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Focused Tests (v18.2 - OOB Spray + Canvas Stress + Larger Summary)</title> {/* v18.2 */}
    <style>
        /* Estilos CSS (Ajustes para v18.2) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output, #output-canvas {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 35vh; /* *** AJUSTADO v18.2: Reduzido para dar espaço ao sumário *** */
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        #summary-s1, #summary-s2 {
            background: #2a2a2a;
            border: 1px solid #555;
            padding: 10px;
            margin-top: 15px;
            font-size: 13px;
            max-height: 65vh; /* *** MODIFICADO v18.2: Aumentado para screenshot *** */
            overflow-y: auto; /* Mantém scroll se conteúdo for MUITO grande */
        }
        #summary-s1 h2, #summary-s2 h2 { margin-top: 0; color: #eee; font-size: 15px; border-bottom: 1px solid #444; padding-bottom: 5px;}
        #summary-s1 ul, #summary-s2 ul { padding-left: 20px; margin: 5px 0; }
        #summary-s1 li, #summary-s2 li { margin-bottom: 3px; }

        /* Estilos de Log (Inalterados) */
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }

        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 60px; overflow-y: auto; }
        #interactive-canvas { display: block; border: 1px solid #444; margin-top: 5px; background-color: #333; cursor: default; }
        #canvas-coord-status { color: #aaa; font-size: 12px; height: 15px; }
        hr { border: 1px solid #555; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>(v18.2 - OOB Spray + Canvas Stress) - Script 1</h1> {/* v18.2 */}
    <p>Testa: XSS++, OOB R/W (Tipos), PP Básica/Hijack, IndexedDB++, DOM Stress, APIs Web.</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Testes S1 (v18.2)</button>
    <div id="output"></div>
    <div id="summary-s1"></div>
    <div id="xss-target-div">Área para teste de XSS DOM (Script 1).</div>

    <hr>

    <section>
        <h2>Teste de Canvas Focado (v18.2) - Script 2</h2> {/* v18.2 */}
        <p>Foco: PP Avançado++, OOB R/W (Metadata/ImageData/SprayRead), API Checks (GL/GPU/FS), Canvas Stress/Interact.</p>
        <canvas id="interactive-canvas" width="300" height="200"></canvas>
        <div id="canvas-coord-status">Passe o mouse sobre o canvas ?</div>
        <button id="runCanvasBtn" onclick="runCanvasTest()">Iniciar Teste Canvas (v18.2)</button>
        <div id="output-canvas"></div>
        <div id="summary-s2"></div>
    </section>

    <script>
        // --- Script 1 (Base v18.1 - Inalterado) ---
        // Código completo do Script 1 da versão v18.1 fornecida por você
        // ... (Omitido por brevidade, usar o código que você forneceu) ...
        const outputDiv = document.getElementById('output'); const runBtn = document.getElementById('runBtn'); const SHORT_PAUSE = 50; const MEDIUM_PAUSE = 500; let leakedValueFromOOB = null; let findingsS1 = []; const IMPORTANT_LOG_TYPES_S1 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good']; const log = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S1.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('bloqueado') || lowerMsg.includes('falhou') || lowerMsg.includes('não afetou') || lowerMsg.includes('não encontrado') || lowerMsg.includes('não suportado') || lowerMsg.includes('não disponível') || lowerMsg.includes('completo') || lowerMsg.includes('ok') || lowerMsg.includes('recebida') || lowerMsg.includes('adicionar blob/arraybuffer ok')) { keepLog = true; } } if (!keepLog && funcName.includes('Payload') && type !== 'info') { keepLog = true; } if (!keepLog) return; if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS1.push({ type, funcName, message: sanitizedMessage, time: timestamp }); } if(outputDiv.innerHTML.length > 600000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 300000); outputDiv.innerHTML = `<span>[Log S1 Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { console.error("Erro log S1:", e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } }; const PAUSE_S1 = (ms = SHORT_PAUSE) => new Promise(r => setTimeout(r, ms)); const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); }; const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const testCSPBypass = async () => { /* ...código v18.1... */ }; const testOOBReadInfoLeakEnhancedStore = async () => { /* ...código v18.1... */ }; const testOOBUAFPattern = async () => { /* ...código v18.1... */ }; const testOOBOtherTypes = async () => { /* ...código v18.1... */ }; const testBasicPP = async () => { /* ...código v18.1... */ }; const testPPJsonHijack = async () => { /* ...código v18.1... */ }; const testWebSockets = async () => { /* ...código v18.1... */ }; const testWebWorkers = async () => { /* ...código v18.1... */ }; const testIndexedDB = async () => { /* ...código v18.1... */ }; const testDOMStress = async () => { /* ...código v18.1... */ }; const runAllTests = async () => { /* ...código v18.1... */ };

    </script>

    <script>
        // --- Script 2: Canvas (v18.2 - OOB Spray + Canvas Stress + Larger Summary) ---

        // --- Variáveis Globais --- (v18.1)
        const SHORT_PAUSE_CANVAS = 50; let canvasClickListener = null; let canvasMoveListener = null; let currentHoverTarget = null; const interactiveAreas = [ { id: 'rect-log', x: 10, y: 10, w: 70, h: 25, color: '#FF5733', hoverColor: '#FF8C66', text: 'Log Clk' }, { id: 'rect-link', x: 90, y: 10, w: 80, h: 25, color: '#337BFF', hoverColor: '#66A3FF', text: 'Abrir Link' }, { id: 'rect-rerun', x: 180, y: 10, w: 100, h: 25, color: '#4CAF50', hoverColor: '#80C883', text: 'Re-ler Leak S1' } ]; const imgSquareSize = 40; const imgSquareSpacing = 8; const imgSquares = []; const imgSquaresStartY = 145; let currentLeakData = { text: "Leak(S1): N/A", color: "#AAAAAA" }; let outputDivCanvas = null; let coordStatusDiv = null; let canvasElement = null; let ctx = null; let glContext = null; let isWebGL2 = false; let gpuAdapter = null; let gpuDevice = null; let findingsS2 = [];
        let sprayHole = []; // *** v18.2: Adicionado para spray OOB Read ***

        // --- Funções Helper ---
        const IMPORTANT_LOG_TYPES_S2 = ['test', 'vuln', 'critical', 'error', 'escalation', 'leak', 'ptr', 'good', 'warn']; // v18.2: Mantendo WARN
        // logCanvas (código da v18.1 - inalterado)
        const logCanvas = (message, type = 'info', funcName = '') => { let keepLog = IMPORTANT_LOG_TYPES_S2.includes(type); if (!keepLog && type === 'good') { const lowerMsg = String(message).toLowerCase(); if (lowerMsg.includes('n/a') || lowerMsg.includes('não suportad') || lowerMsg.includes('não disponível') || lowerMsg.includes('fail:') || lowerMsg.includes('não afetou') || lowerMsg.includes('nenhum leak') || lowerMsg.includes('escrita oob falhou/bloqueada') || lowerMsg.includes('nenhuma corrupção detectada') || lowerMsg.includes('ok') || lowerMsg.includes('aberto') || lowerMsg.includes('concluído') || lowerMsg.includes('restaurado') || lowerMsg.includes('limpeza') || lowerMsg.includes('pulado') || lowerMsg.includes('resolvido') || lowerMsg.includes('sem erro') || lowerMsg.includes('finalizado') || lowerMsg.includes('restaurado') || lowerMsg.includes('sem erros gl') || lowerMsg.includes('desenho de') || lowerMsg.includes('createimagedata')) { keepLog = true; } } if (!keepLog && type === 'error' && (String(message).includes('element.innerhtml setter') || String(message).includes('webgl') || String(message).includes('gpu') || String(message).includes('file system') || String(message).includes('indexeddb') || String(message).includes('fatal') || String(message).includes('critical'))) { keepLog = true; } if (!keepLog && funcName === 'CanvasClick') { keepLog = true; } if (!keepLog) return; if (!outputDivCanvas) return; const logPrefix = `[CANVAS-${type.toUpperCase()}]`; const funcPrefix = funcName ? `[${funcName}] ` : ''; const logMsg = `${logPrefix} ${funcPrefix}${message}`; console.log(logMsg); try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sM = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if (['vuln', 'critical', 'escalation'].includes(type)) { findingsS2.push({ type, funcName, message: sM, time: timestamp }); } if(outputDivCanvas.innerHTML.length > 600000){ outputDivCanvas.innerHTML = outputDivCanvas.innerHTML.substring(outputDivCanvas.innerHTML.length - 300000); outputDivCanvas.innerHTML = `<span>[Log S2 Truncado...]</span>\n` + outputDivCanvas.innerHTML; } outputDivCanvas.innerHTML += `<span class="log-${logClass}">${timestamp} ${funcPrefix}${sM}\n</span>`; outputDivCanvas.scrollTop = outputDivCanvas.scrollHeight; } catch(e) { console.error("logCanvas ERRO:", e); if (outputDivCanvas) outputDivCanvas.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; } };
        // Funções PAUSE, toHexCanvas, is*, draw*, redrawAll (inalteradas da v18.1)
        const PAUSE = (ms = SHORT_PAUSE_CANVAS) => new Promise(r => setTimeout(r, ms)); const toHexCanvas = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let n = Number(val); if (bits <= 32) { n >>>= 0; } const p = Math.ceil(bits / 4); return '0x' + n.toString(16).toUpperCase().padStart(p, '0'); }; const isPotentialPointer64_S2 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; if (high === 0 && low < 0x100000) return false; return true; }; const isPotentialData32_S2 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; if (val < 0x1000) return false; return true; }; const drawInteractiveAreas = () => { if (!ctx) return; try { interactiveAreas.forEach(a => { ctx.fillStyle = (currentHoverTarget === a.id)?a.hoverColor:a.color; ctx.fillRect(a.x, a.y, a.w, a.h); ctx.fillStyle="#FFF"; ctx.font="bold 11px mono"; ctx.textAlign="center"; ctx.textBaseline = "middle"; ctx.fillText(a.text, a.x + a.w / 2, a.y + a.h / 2 + 1); }); ctx.textAlign="start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawAreas: ${e.message}`, 'error', 'drawInteractiveAreas'); }}; const drawImageSquares = () => { if (!ctx) return; try { imgSquares.forEach(sq => { ctx.fillStyle = sq.hover ? '#FFFF88' : sq.color; ctx.fillRect(sq.x, sq.y, sq.size, sq.size); ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1; ctx.strokeRect(sq.x, sq.y, sq.size, sq.size); if (sq.text) { ctx.fillStyle = "#FFF"; ctx.font = "bold 10px mono"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(sq.text, sq.x + sq.size / 2, sq.y + sq.size / 2); } if (sq.url) { ctx.fillStyle = "#6cf"; ctx.font = "bold 9px mono"; ctx.fillText("LINK", sq.x + sq.size / 2, sq.y + sq.size - 7); } }); ctx.textAlign = "start"; ctx.textBaseline = "alphabetic"; } catch(e) { logCanvas(`Erro drawSquares: ${e.message}`, 'error', 'drawImageSquares'); } }; const redrawAll = () => { if (!ctx || !canvasElement) return; try { ctx.save(); ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); ctx.fillStyle = "#334"; ctx.fillRect(0, 0, canvasElement.width, canvasElement.height); drawInteractiveAreas(); drawImageSquares(); ctx.fillStyle = currentLeakData.color; ctx.font = "11px mono"; ctx.textAlign = "start"; ctx.fillText(currentLeakData.text, 10, canvasElement.height - 5); ctx.restore(); } catch(e) { logCanvas(`Erro redrawAll: ${e.message}`, 'error', 'redrawAll'); }};


        // --- Funções de Teste (Script 2 - Base v18.1 + Modificações v18.2) ---

        // testWebGLCheck, testAdvancedPP (código v18.1)
        const testWebGLCheck = async () => { /* ...código v18.1... */ }; const testAdvancedPP = async () => { /* ...código v18.1... */ };

        // *** v18.2: OOB Read Enhanced com Heap Spray ***
        const testOOBReadEnhanced = async () => {
             const FNAME = 'testOOBReadEnhanced';
             logCanvas("--- Teste: OOB Read Enhanced Scan (Spray Added) ---",'test', FNAME); // Título atualizado
             const bufferSize=32; const readRangeStart=-128; const readRangeEnd=bufferSize+128; const allocationSize = bufferSize + 512; const baseOffsetInBuffer = 256;
             const sprayCount = 200; // Número de objetos para spray
             const sprayObjectSize = 128; // Tamanho de cada array no spray

             let potentialLeakFoundCount=0; const foundPointers=[];
             sprayHole = []; // Limpar spray anterior

             logCanvas(`Iniciando Heap Spray (${sprayCount} x ~${sprayObjectSize * 8} bytes)...`, 'test', FNAME);
             try { /* ... spray logic v17 ... */ for (let i = 0; i < sprayCount; i++) { sprayHole.push(new Array(sprayObjectSize).fill(1.1 + i)); } logCanvas(`Heap Spray concluído. ${sprayHole.length} objetos mantidos.`, 'test', FNAME); } catch (e) { logCanvas(`Erro durante Heap Spray: ${e.message}`, 'error', FNAME); }
             await PAUSE(50);

             try{
                 const buffer=new ArrayBuffer(allocationSize); const dataView=new DataView(buffer);
                 for(let i=0; i<buffer.byteLength; i++){ dataView.setUint8(i, 0xCC); }

                 // Lógica de leitura OOB Read da v18.1 (mais simples, sem log U8/U16 extra)
                 for(let readOffset=readRangeStart; readOffset<readRangeEnd; readOffset+=4){
                     const readTargetAddress=baseOffsetInBuffer+readOffset; const relOffsetStr = `@${readOffset} (addr ${readTargetAddress})`;
                     if(readTargetAddress>=0 && readTargetAddress+8<=buffer.byteLength){
                         try{
                             const low=dataView.getUint32(readTargetAddress,true); const high=dataView.getUint32(readTargetAddress+4,true);
                             if (low === 0xCCCCCCCC && high === 0xCCCCCCCC) continue;
                             if(isPotentialPointer64_S2(high,low)){
                                 const valueStr=`H=${toHexCanvas(high,32)} L=${toHexCanvas(low,32)}`;
                                 logCanvas(` -> PTR? U64 ${relOffsetStr}: ${valueStr}`,'ptr', FNAME);
                                 potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U64', high, low, hex:valueStr});
                                 logCanvas(` ---> *** ALERTA: Primitivo Relevante (OOB Read Pointer Leak) ***`, 'escalation', FNAME);
                              }
                         }catch(e){}
                     }
                     else if(readTargetAddress>=0 && readTargetAddress+4<=buffer.byteLength){
                         try{
                             const val32=dataView.getUint32(readTargetAddress,true);
                              if (val32 === 0xCCCCCCCC) continue;
                              let alreadyLoggedAsPtr64 = foundPointers.some(p => p.offset === readOffset && p.type === 'U64');
                             if(!alreadyLoggedAsPtr64 && isPotentialData32_S2(val32) && !isPotentialPointer64_S2(0,val32)){
                                 logCanvas(` -> Leak U32? ${relOffsetStr}: ${toHexCanvas(val32,32)}`,'leak', FNAME);
                                 potentialLeakFoundCount++; foundPointers.push({offset:readOffset, type:'U32', value:val32, hex:toHexCanvas(val32)});
                                 logCanvas(` ---> *** ALERTA: Potencial Vazamento Info OOB Read U32 ***`, 'escalation', FNAME);
                              }
                         }catch(e){}
                     }
                     if(readOffset % 64 === 0) await PAUSE(1);
                 }
             }catch(e){ logCanvas(`Erro fatal no Teste OOB Read Scan: ${e.message}`,'error', FNAME); console.error(e); }
             finally {
                 logCanvas(`--- Teste OOB Read Scan Concluído (${potentialLeakFoundCount} leaks potenciais encontrados) ---`,'test', FNAME);
                 if(potentialLeakFoundCount === 0){ logCanvas("Nenhum leak potencial óbvio encontrado nesta varredura.", 'good', FNAME); }
                 else if (foundPointers.length > 0) { console.log("Potenciais Leaks Encontrados (OOB Read Enhanced):", foundPointers); }
                 sprayHole = []; // Limpar spray
             }
             await PAUSE(); return foundPointers;
        };

        // testOOBWriteMetadata, testWebGLDeeperPlus, testOOBWriteToImageDataCheck, testOOBWriteOnly (código v18.1)
        const testOOBWriteMetadata = async () => { /* ...código v18.1... */ };
        const testWebGLDeeperPlus = async () => { /* ...código v18.1... */ };
        const testOOBWriteToImageDataCheck = async () => { /* ...código v18.1... */ };
        const testOOBWriteOnly = async () => { /* ...código v18.1... */ };
        // testFileSystemAccess, testWebGPUCheck (código v18.1)
        const testFileSystemAccess = async () => { /* ...código v18.1... */ };
        const testWebGPUCheck = async () => { /* ...código v18.1... */ };

        // *** v18.2: Reintroduzindo testCanvasStress da v19 ***
        const testCanvasStress = async () => {
            const FNAME = 'testCanvasStress';
            logCanvas("--- Teste: Stress e Limites do Canvas 2D (Agressivo v18.2) ---", 'test', FNAME); // Título atualizado
            if (!ctx) { logCanvas("Contexto 2D não disponível, pulando teste de stress.", 'warn', FNAME); return; }

            // 1. Desenhar MUITAS formas
            const numShapes = 5000; // Aumentado
            logCanvas(`Desenhando ${numShapes} retângulos sobrepostos...`, 'test', FNAME);
            const startTimeShapes = performance.now();
            try { /* ... código desenho v19 ... */ for (let i = 0; i < numShapes; i++) { ctx.fillStyle = `rgba(${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.random()*0.5 + 0.1})`; ctx.fillRect(Math.random() * canvasElement.width * 0.9, Math.random() * canvasElement.height * 0.9, 30, 30); if (i % 500 === 0) await PAUSE(1); } const durationShapes = performance.now() - startTimeShapes; logCanvas(`Desenho de ${numShapes} retângulos concluído em ${durationShapes.toFixed(1)} ms.`, 'good', FNAME); } catch(e) { logCanvas(`Erro ao desenhar muitas formas: ${e.message}`, 'error', FNAME); console.error(e); }
            await PAUSE(50);

            // 2. Usar caminhos complexos
            logCanvas(`Desenhando caminho complexo (beziers, arcos)...`, 'test', FNAME);
            try { /* ... código caminho v19 ... */ ctx.beginPath(); ctx.moveTo(75, 75); ctx.bezierCurveTo(100, 175, 250, 175, 275, 75); ctx.quadraticCurveTo(175, 25, 75, 75); ctx.moveTo(150, 150); ctx.arcTo(250, 50, 250, 200, 50); ctx.lineTo(250, 200); ctx.lineWidth = 3; ctx.strokeStyle = 'cyan'; ctx.stroke(); logCanvas(`Desenho de caminho complexo OK.`, 'good', FNAME); } catch (e) { logCanvas(`Erro ao desenhar caminho complexo: ${e.message}`, 'error', FNAME); console.error(e); }
            await PAUSE(50);

             // 3. Tentar desenhar canvas em si mesmo
            logCanvas(`Tentando desenhar canvas em si mesmo (drawImage)...`, 'test', FNAME);
            try { /* ... código self-draw v19 ... */ ctx.drawImage(canvasElement, 50, 50, 100, 100); logCanvas(`Desenhar canvas em si mesmo (drawImage) executado.`, 'good', FNAME); } catch (e) { logCanvas(`Erro ao tentar desenhar canvas em si mesmo: ${e.message}`, 'error', FNAME); console.error(e); }
            await PAUSE(50);

            // 4. Tentar criar ImageData grande
            const largeW = 4096; const largeH = 4096;
            logCanvas(`Tentando ctx.createImageData(${largeW}, ${largeH})...`, 'test', FNAME);
            try { /* ... código createImageData v19 ... */ const largeImageData = ctx.createImageData(largeW, largeH); if (largeImageData && largeImageData.width === largeW && largeImageData.height === largeH) { logCanvas(`SUCESSO: createImageData(${largeW}, ${largeH}) funcionou.`, 'good', FNAME); } else { logCanvas(`AVISO: createImageData(${largeW}, ${largeH}) retornou resultado inesperado.`, 'warn', FNAME); } } catch (e) { logCanvas(`Erro ao criar ImageData grande (${largeW}x${largeH}): ${e.message}`, 'error', FNAME); console.error(e); }

             logCanvas("--- Teste Stress e Limites do Canvas 2D Concluído ---", 'test', FNAME);
             await PAUSE();
        };


        // --- Função Principal Canvas --- (v18.2 - Chama testes modificados e novos)
        const runCanvasTestSequence = async () => {
            const FNAME = 'runCanvasTestSequence';
            // ...(Get elements, check)...
            outputDivCanvas = document.getElementById('output-canvas'); coordStatusDiv = document.getElementById('canvas-coord-status'); canvasElement = document.getElementById('interactive-canvas'); const runBtnCanvas = document.getElementById('runCanvasBtn'); const summaryDivS2 = document.getElementById('summary-s2'); if (!outputDivCanvas || !runBtnCanvas || !canvasElement || !coordStatusDiv || !summaryDivS2) { console.error("FATAL: Elementos essenciais S2 não encontrados!"); return; }
            if (runBtnCanvas) runBtnCanvas.disabled = true; findingsS2 = []; outputDivCanvas.innerHTML = ''; summaryDivS2.innerHTML = ''; // Limpar sumário antigo

            logCanvas("Iniciando sequência focada do Script 2 (v18.2)...", "test", FNAME);

            // ...(Init squares - v18.1)...
            imgSquares.length = 0; let sqX = 10; let sqY = imgSquaresStartY; const squareDefs = [ { id: 'imgSq0', text: 'Meta', color: '#FF5733', action: testOOBWriteMetadata }, { id: 'imgSq1', text: 'PP++', color: '#C70039', action: testAdvancedPP }, { id: 'imgSq2', text: 'OOBRd', color: '#E67E22', action: testOOBReadEnhanced }, { id: 'imgSq3', text: 'ImgDt', color: '#900C3F', action: testOOBWriteToImageDataCheck }, { id: 'imgSq4', text: 'File', color: '#581845', action: testFileSystemAccess }, { id: 'imgSq5', text: 'GPU', color: '#337BFF', action: testWebGPUCheck }, ]; squareDefs.forEach(def => { /* ... código v18.1 ... */ });

            try {
                // ...(Get ctx, read leak S1 - v18.1)...
                 try { ctx = canvasElement.getContext('2d'); if (!ctx) throw new Error("Falha Ctx 2D."); } catch(e) { logCanvas(`Falha Ctx 2D: ${e.message}`, 'critical', FNAME); throw e; } redrawAll(); await PAUSE(); try { if (typeof leakedValueFromOOB !== 'undefined') { const l = leakedValueFromOOB; if(l){ const ls = l.type==='U64' ? `L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}` : `L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Leak S1 encontrado: ${ls}`, 'leak', FNAME); currentLeakData = {text: ls, color: "#FF9800"};} else { logCanvas(`-> Leak S1 nulo/não encontrado.`, 'warn', FNAME); currentLeakData = {text:"L(S1):NULO", color:"#FFC107"}; } } else { logCanvas(`-> Var 'leakedValueFromOOB' S1 N/A.`, 'error', FNAME); currentLeakData = {text:"L(S1):Var N/A", color:"#F44336"}; } } catch (e) { logCanvas(`Erro leak S1: ${e.message}`, 'error', FNAME); currentLeakData = {text:"L(S1):ERRO", color:"#F44336"}; console.error(e); } redrawAll(); await PAUSE();

                // --- Sequência Principal v18.2 ---
                await testWebGLCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testAdvancedPP(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBReadEnhanced(); // v18.2 com Spray
                await PAUSE(SHORT_PAUSE_CANVAS);
                await testOOBWriteMetadata(); await PAUSE(SHORT_PAUSE_CANVAS);
                // Interação WebGL removida (é N/A)
                await testOOBWriteToImageDataCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testFileSystemAccess(); await PAUSE(SHORT_PAUSE_CANVAS);
                await testWebGPUCheck(); await PAUSE(SHORT_PAUSE_CANVAS);
                // *** v18.2: Adiciona chamada ao Canvas Stress ***
                await testCanvasStress(); await PAUSE(SHORT_PAUSE_CANVAS);

                logCanvas("--- Sequência principal de testes focados concluída ---", 'test', FNAME); await PAUSE(100);

                // ...(Setup Listeners - v18.1)...
                logCanvas("Adicionando listeners interativos (Canvas + Quadrados)...", 'info', FNAME); if(canvasClickListener && canvasElement) { try { canvasElement.removeEventListener('click', canvasClickListener); } catch(e){} } if(canvasMoveListener && canvasElement) { try { canvasElement.removeEventListener('mousemove', canvasMoveListener); } catch(e){} } canvasMoveListener = (event) => { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let needsRedraw = false; let newHoverTarget = null; let cursorStyle = 'default'; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { newHoverTarget = a.id; cursorStyle = 'pointer'; } }); imgSquares.forEach(sq => { let oldHover = sq.hover; sq.hover = false; if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { newHoverTarget = sq.id; cursorStyle = sq.action ? 'crosshair' : (sq.url ? 'pointer' : 'default'); sq.hover = true; } if(oldHover !== sq.hover) needsRedraw = true; }); if (newHoverTarget !== currentHoverTarget) { currentHoverTarget = newHoverTarget; needsRedraw = true; } try { if(needsRedraw){ redrawAll(); } canvasElement.style.cursor = cursorStyle; if(coordStatusDiv) coordStatusDiv.textContent=`Coords: X=${x.toFixed(0)}, Y=${y.toFixed(0)}`; } catch(e){ logCanvas(`Erro mousemove: ${e.message}`, 'error', 'MouseMove'); console.error(e); } }; canvasClickListener = async (event) => { const FNAME_CLICK = 'CanvasClick'; try { const rect = canvasElement.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; let clickedArea = null; interactiveAreas.forEach(a => { if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) { clickedArea = a; } }); let clickedSquare = null; imgSquares.forEach((sq) => { if (x >= sq.x && x <= sq.x + sq.size && y >= sq.y && y <= sq.y + sq.size) { clickedSquare = sq; } }); if (clickedArea) { logCanvas(`Click Área: ${clickedArea.text} (ID: ${clickedArea.id})`, 'info', FNAME_CLICK); switch (clickedArea.id) { case 'rect-log': logCanvas('Click no botão de log (ação simulada).', 'info', FNAME_CLICK); break; case 'rect-link': logCanvas('Abrindo link externo (google.com)...', 'info', FNAME_CLICK); try { window.open('https://google.com', '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } break; case 'rect-rerun': logCanvas('Re-lendo leak S1...', 'info', FNAME_CLICK); try { if(typeof leakedValueFromOOB !== 'undefined'){ const l=leakedValueFromOOB; if(l){const ls=l.type==='U64'?`L(S1):U64 H=${toHexCanvas(l.high)} L=${toHexCanvas(l.low)}@${l.offset}`:`L(S1):U32 ${toHexCanvas(l.low)}@${l.offset}`; logCanvas(`-> Re-read Leak S1: ${ls}`,'leak', FNAME_CLICK); currentLeakData={text:ls, color:"#FF9800"};} else { logCanvas(`-> Re-read Leak S1: Nulo`, 'warn', FNAME_CLICK); currentLeakData={text:"L(S1):NULO", color:"#FFC107"};} } else { logCanvas(`-> Re-read Leak S1: Var N/A`, 'error', FNAME_CLICK); currentLeakData={text:"L(S1):Var N/A", color:"#F44336"};}}catch(e){ logCanvas(`Erro re-ler leak S1: ${e.message}`,'error', FNAME_CLICK);} redrawAll(); break; } } else if (clickedSquare) { logCanvas(`Click Quadrado ID: ${clickedSquare.id} (Texto: ${clickedSquare.text})`, 'vuln', FNAME_CLICK); if (clickedSquare.url) { logCanvas(`Abrindo URL: ${clickedSquare.url}`, 'info', FNAME_CLICK); try { window.open(clickedSquare.url, '_blank'); } catch (e) { logCanvas('Erro window.open: ' + e.message, 'error', FNAME_CLICK); } } else if (clickedSquare.action && typeof clickedSquare.action === 'function') { let actionError = null; if (runBtnCanvas) runBtnCanvas.disabled = true; logCanvas(`Executando re-run ${clickedSquare.id} (${clickedSquare.action.name})...`, 'test', FNAME_CLICK); try { await clickedSquare.action(); logCanvas(`Re-run ${clickedSquare.id} concluído sem erro aparente.`, 'good', FNAME_CLICK); } catch (e) { logCanvas(`Erro durante re-run ${clickedSquare.id}: ${e.message}`, 'error', FNAME_CLICK); console.error(`Erro ação ${clickedSquare.id}:`, e); actionError = e; } finally { clickedSquare.color = actionError ? '#FFA500' : '#8A2BE2'; redrawAll(); if (runBtnCanvas) runBtnCanvas.disabled = false; logCanvas(`Re-run ${clickedSquare.id} finalizado.`, 'test', FNAME_CLICK); } } else { logCanvas(`Nenhuma ação definida para o quadrado ${clickedSquare.id}.`, 'info', FNAME_CLICK); clickedSquare.text += "*"; redrawAll(); } } } catch (e) { logCanvas(`Erro GERAL listener clique: ${e.message}`, 'error', FNAME_CLICK); console.error(e); if (runBtnCanvas) runBtnCanvas.disabled = false; } };
                 canvasElement.addEventListener('click', canvasClickListener); canvasElement.addEventListener('mousemove', canvasMoveListener); redrawAll();

            } catch(e) {
                 logCanvas(`Erro GERAL SCRIPT 2: ${e.message}`, 'critical', FNAME); console.error("Erro GERAL SCRIPT 2:", e); if(e.stack) console.error(e.stack);
             }
             finally {
                 logCanvas("\n==== GERANDO SUMÁRIO Script 2 ====", 'test', FNAME);
                 if (summaryDivS2) { // ...(lógica sumário v18.1)...
                 }
                 logCanvas("--- Fim da execução Script 2 (v18.2) ---", 'test', FNAME);
                 if (runBtnCanvas) runBtnCanvas.disabled = false;
             }
        };

        // Wrapper e Unload (Inalterados)
        const runCanvasTest = async () => { await runCanvasTestSequence(); };
        window.addEventListener('unload', () => { try { if (canvasClickListener && canvasElement) canvasElement.removeEventListener('click', canvasClickListener); if (canvasMoveListener && canvasElement) canvasElement.removeEventListener('mousemove', canvasMoveListener); gpuDevice = null; gpuAdapter = null; sprayHole = []; } catch(e) {} console.log("[Canvas Unload] Limpeza OK."); });
    </script>

</body>
</html>
