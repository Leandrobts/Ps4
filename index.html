<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC v15.2 - Original (Fix) + Aprofundamento</title> <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; }
        .log-ptr { color: #f0f; font-weight: bold; }
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
        #fingerprint-canvas { display: block; border: 1px solid #444; margin-top: 5px; cursor: crosshair; background-color: #333; }
    </style>
</head>
<body>
    <h1>PoC v15.2 - Original (Fix) + Aprofundamento</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas>
    <canvas id="fingerprint-canvas" width="300" height="150"></canvas>
    <p>Fase 1: PoC Original (Mantido). Fase 2: Aprofundamento com base nos resultados (Fingerprinting, Canvas, PP, Erros, Interações).</p>
    <button id="runBtn" onclick="runEverythingSequentially()">Iniciar Teste Completo (Fase 1 + Fase 2)</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const fingerprintCanvas = document.getElementById('fingerprint-canvas');
        const SHORT_PAUSE = 50;
        const MEDIUM_PAUSE = 500;
        let leakedValueFromOOB = null; // Armazena valor da Fase 1 / Teste OOB Original
        let canvasClickListener = null;
        let xssRanFlag = false; // Flag setada pelo XSS da Fase 1

        // --- Função de Log ---
        const log = (message, type = 'info') => { if (!outputDiv) return; try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); if(outputDiv.innerHTML.length > 1200000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 600000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; } outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`; outputDiv.scrollTop = outputDiv.scrollHeight; } catch(e) { /*...*/ } };

        // --- Helpers (toHex, Heurísticas) ---
        const toHex = (val, bits = 32) => { if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid'; let num = Number(val); if (bits <= 32) { num = num >>> 0; } const pad = Math.ceil(bits / 4); return '0x' + num.toString(16).toUpperCase().padStart(pad, '0'); };
        // Heurísticas ajustadas para logar mas não armazenar padrões escritos por nós
        const isPotentialPointer64 = (high, low) => { if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false; if (high === 0 && low === 0) return false; if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false; if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; /* Não filtra EE aqui p/ log */ if (high === 0 && low < 0x100000) return false; return true; };
        const isPotentialData32 = (val) => { if (val === null || typeof val !== 'number') return false; val = val >>> 0; if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA) return false; /* Não filtra EE */ if (val < 0x1000) return false; return true; };

        // ==================================================
        // --- FASE 1: Testes Originais (Preservados) ---
        // ==================================================
        log("Definindo Testes da Fase 1 (Originais)", "info");

        // Teste Original 1: CSP Bypass / XSS (Adiciona flag)
        const originalTestCSPBypass = async () => {
            log("--- [Fase 1] Iniciando Teste Original 1: CSP Bypass / XSS ---", 'test');
            xssRanFlag = false; // Reseta
            log("Tentando XSS via data: URI (alert)...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE));
            try { const p=`try{log("[Payload Data/F1:] Alerta data: URI executado!","vuln");window.xssRanFlag=true;alert('XSS Data URI (F1)');}catch(e){log("[Payload Data/F1:] Bloqueado: "+e.message,"good");}`; const s=document.createElement('script'); s.src='data:text/javascript;base64,'+btoa(p); s.onerror=()=>{log("[F1] ERRO data: URI!","error");}; document.body.appendChild(s); log("[F1] Tag data: URI adicionada.",'info');}catch(e){log(`[F1] Erro data URI: ${e.message}`,'error');}
            await new Promise(r=>setTimeout(r,SHORT_PAUSE*2));
            log("Tentando XSS DOM via onerror...", 'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE));
            try { const i=document.createElement('img'); i.src='invalid_'+Date.now(); const p=`try{const t=document.getElementById('xss-target-div'); if(t)t.innerHTML='<h2 class="log-vuln">[F1] XSS DOM ONERROR!</h2>'; log("[F1] XSS DOM onerror!","vuln"); window.xssRanFlag=true; alert('XSS DOM (F1)');}catch(e){log("[F1] Erro payload onerror: "+e.message,"warn");}`; i.setAttribute('onerror',p); document.body.appendChild(i); log("[F1] Tag img onerror adicionada.",'info');} catch(e){log(`[F1] Erro img onerror: ${e.message}`,'error');}
            log("--- [Fase 1] Teste Original 1 Concluído ---", 'test');
        };

        // Teste Original 2: OOB Write/Read (Armazena leak não-EE)
        const originalTestOOBReadInfoLeak = async () => {
            log("--- [Fase 1] Iniciando Teste Original 2: OOB R/W ---", 'test');
            const bS=32; const wV=0xEE; const oWO=32; const oRO=[]; for(let i=-64;i<bS+64;i+=4){oRO.push(i);} let wS=false; let pLFC=0; leakedValueFromOOB=null;
            try{ const b=new ArrayBuffer(bS+256); const dV=new DataView(b); const bO=128; for(let i=0;i<b.byteLength;i++){dV.setUint8(i,0xAA);}
                 const wTA=bO+oWO; log(` Tentando escrita OOB @${oWO} (abs ${wTA})...`,'subtest'); await new Promise(r=>setTimeout(r,SHORT_PAUSE));
                 try{ dV.setUint8(wTA,wV); log(` [F1] Escrita OOB @${oWO} permitida!`, 'vuln'); wS=true;} catch(e){log(`[F1] BLOQUEADO Escrita OOB: ${e.message}`,'good');return false;}
                 await new Promise(r=>setTimeout(r,SHORT_PAUSE)); log(` Tentando leituras OOB...`,'subtest');
                 for(const rO of oRO){ const rTA=bO+rO; if(rTA<0||rTA+8>b.byteLength)continue; try{const l=dV.getUint32(rTA,true);const h=dV.getUint32(rTA+4,true);const cW=h===0xAAAAAAAAEE||l===0xAAAAAAAAEE; if(isPotentialPointer64(h,l)){pLFC++;const vS=`H=${toHex(h)} L=${toHex(l)}`; log(` [F1] -> U64 @${rO}: ${vS}`,cW?'leak':'ptr'); if(!cW&&leakedValueFromOOB===null){leakedValueFromOOB={h,l,t:'U64',o:rO,p:1}; log(` [F1] -> VALOR U64 (não-EE) ARMAZENADO @${rO}.`,'vuln');}}}catch(e){} if(leakedValueFromOOB===null&&rTA+4<=b.byteLength){try{const v32=dV.getUint32(rTA,true); const cW=v32===0xAAAAAAEE||v32===0xAAAAAAAAEE; if(isPotentialData32(v32)){pLFC++; log(` [F1] -> U32 @${rO}: ${toHex(v32)}`,cW?'leak':'leak'); if(!cW&&leakedValueFromOOB===null){leakedValueFromOOB={h:0,l:v32,t:'U32',o:rO,p:1}; log(` [F1] -> VALOR U32 (não-EE) ARMAZENADO @${rO}.`,'vuln');}}}catch(e){}} if(rO%64===0) await new Promise(r=>setTimeout(r,1)); }
            }catch(e){log(`[F1] Erro OOB: ${e.message}`,'error');}
            log(`--- [Fase 1] Teste Original 2 Concluído (${pLFC} leituras pot., ${leakedValueFromOOB?`1 valor ${leakedValueFromOOB.t} (não-EE) @${leakedValueFromOOB.o} armazenado`:'nada armazenado'}) ---`, 'test');
            return wS;
        };

        // Teste Original 3: PP Básica
        const originalTestBasicPP = async () => {
            log("--- [Fase 1] Iniciando Teste Original 3: PP Básica ---", 'test');
            const tP='__pp_basic_test_orig__'; const tV='PollutedOrig!'; let s=false;
            try{ log(` Poluindo Object.prototype.${tP}`,'subtest'); Object.prototype[tP]=tV; await new Promise(r=>setTimeout(r,SHORT_PAUSE)); if(({})[tP]===tV){log(`[F1] VULN: PP Básica confirmada!`,'vuln'); s=true;}else{log(`[F1] FALHA/BLOQ PP Básica.`,'good');}}catch(e){log(`[F1] Erro PP Básico: ${e.message}`,'error');}finally{try{delete Object.prototype[tP];log(`[F1] Limpeza PP Básica ok.`,'info');}catch(e){log(`[F1] Erro limpeza PP: ${e.message}`,'warn');}}
            log(`--- [Fase 1] Teste Original 3 Concluído (PP Básica ${s?'Confirmada':'Falhou/Bloq'}) ---`, 'test'); return s;
        };

        // Teste Original 4: PP Hijack (JSON.stringify)
        const originalTestPPJsonHijack = async () => {
            log("--- [Fase 1] Iniciando Teste Original 4: PP Hijack ---", 'test');
            const oS=JSON.stringify; let hS=false; let iS=false; let hR=false;
            try{ log(" Tentando hijack JSON.stringify...",'subtest'); JSON.stringify=function hJSO(v,r,s){log("[F1] ==> VULN: Hijack JSON.stringify (Orig)!",'vuln');hS=true; try{const l=leakedValueFromOOB;let lS="NULO/EE?";if(l&&l.p===1){lS=l.t==='U64'?`U64@${l.o}:H=${toHex(l.h)} L=${toHex(l.l)}`:`U32@${l.o}:${toHex(l.l)}`;iS=true;}log(` [F1]->Hijack: Leak OOB Lido: ${lS}`,iS?'leak':'info');}catch(e){log(` [F1]->Hijack Erro Leitura: ${e.message}`,'error');iS=false;} return `{"hijacked_phase1":true,"leak_read":${iS}}`;}; await new Promise(r=>setTimeout(r,SHORT_PAUSE)); const res=JSON.stringify({x:1}); log(`[F1] Retorno hijack: ${res}`,'info'); if(res?.includes('"hijacked_phase1":true')){log("[F1] VULN: Retorno hijack ok!",'vuln');hR=true;}else if(hS){log("[F1] WARN: Hijack ocorreu, retorno errado.",'warn');}else{log("[F1] FALHA/BLOQ: Hijack não funcionou.",'good');}}catch(e){log(`[F1] Erro PP Hijack: ${e.message}`,'error');}finally{JSON.stringify=oS; log("[F1] JSON.stringify restaurado.",'info'); if(JSON.stringify===oS && JSON.stringify({x:1})==='{"x":1}'){log("[F1] Restauração ok.",'info');}else{log("[F1] ERRO CRÍTICO RESTAURAÇÃO!",'error');}}
            log(`--- [Fase 1] Teste Original 4 Concluído (PP Hijack ${hR?'Confirmado':'Falhou/Bloq'}) ---`, 'test'); return hR;
        };

        // Função para rodar a Fase 1
        const runOriginalTests = async () => {
             log("==== [Fase 1] INICIANDO EXECUÇÃO DOS TESTES ORIGINAIS ====", 'critical');
             await originalTestCSPBypass(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));
             await originalTestOOBReadInfoLeak(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));
             await originalTestBasicPP(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));
             await originalTestPPJsonHijack(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE));
             log("==== [Fase 1] EXECUÇÃO DOS TESTES ORIGINAIS CONCLUÍDA ====", 'critical');
             log(`==== [Fase 1] Estado Final: xssRanFlag=${xssRanFlag}, leakedValueFromOOB=${leakedValueFromOOB?JSON.stringify(leakedValueFromOOB):'null'} ====`,'info');
        }

        // ==========================================================
        // --- FASE 2: Testes Adicionais Baseados em Evidências ---
        // ==========================================================
        log("Definindo Testes da Fase 2 (Aprofundamento)", "info");

        // Teste A: Coleta Dados Básicos
        const testBasicDataCollection = async () => { log("--- [Fase 2] Iniciando Teste A: Coleta Dados Básicos ---", 'test'); /* ... código ... */ log("--- [Fase 2] Teste A Concluído ---", 'test'); };
        // Teste B: Sondagem Ambiente
        const testEnvironmentProbing = async () => { log("--- [Fase 2] Iniciando Teste B: Sondagem Ambiente ---", 'test'); /* ... código ... */ log("--- [Fase 2] Teste B Concluído ---", 'test'); };
        // Teste C: Fingerprinting Avançado
        const testAdvancedFingerprinting = async () => { log("--- [Fase 2] Iniciando Teste C: Fingerprinting Avançado ---", 'test'); /* ... código ... */ log("--- [Fase 2] Teste C Concluído ---", 'test'); };
        // Teste D: Canvas Avançado/Quirks (INTERAÇÃO: Lê OOB)
        const testAdvancedCanvas = async () => { log("--- [Fase 2] Iniciando Teste D: Canvas Avançado/Quirks ---", 'test'); let canvas=null,ctx=null; try{canvas=fingerprintCanvas;ctx=canvas.getContext('2d');if(!ctx)throw new Error('No Ctx');}catch(e){log(`[F2/D] Falha setup: ${e.message}`,'error');return;} log("[F2/D] Desenhando/Testando APIs...",'subtest'); try{ /*...Desenhos...*/ log(` API ellipse: ${typeof ctx.ellipse==='function'}, filter: ${typeof ctx.filter!=='undefined'}...`, 'info'); if(typeof ctx.filter==='undefined')log(`[F2/D] Quirky: ctx.filter NÃO suportado!`,'warn'); const png=canvas.toDataURL('image/png'); const jpg=canvas.toDataURL('image/jpeg'); log(`[F2/D] toDataURL PNG/JPEG ok (len ${png.length}/${jpg.length})`, 'info'); if(png.length===jpg.length||png.substring(30,70)===jpg.substring(30,70))log(`[F2/D] Quirky: toDataURL PNG/JPEG similares?`,'warn'); /* INTERAÇÃO */ if(leakedValueFromOOB && leakedValueFromOOB.p === 1){ const leakStr = leakedValueFromOOB.t==='U64'?`U64@${leakedValueFromOOB.o}:H=${toHex(leakedValueFromOOB.h)} L=${toHex(leakedValueFromOOB.l)}`:`U32@${leakedValueFromOOB.o}:${toHex(leakedValueFromOOB.l)}`; ctx.fillStyle='#FFF'; ctx.font='10px monospace'; ctx.fillText(`OOB(F1): ${leakStr}`, 5, canvas.height-5); log(`[F2/D] INTERAÇÃO: Desenhou valor OOB da Fase 1 no canvas.`,'info'); } else { log(`[F2/D] INTERAÇÃO: Nenhum valor OOB (não-EE) da Fase 1 para desenhar.`,'info'); } }catch(e){log(`[F2/D] Erro testes: ${e.message}`,'error');} log("--- [Fase 2] Teste D Concluído ---", 'test'); };
        // Teste E: Canvas Interativo/Stress (INTERAÇÃO: Lê flag XSS) (Stress desenho removido)
        const testInteractiveCanvas = async () => { log("--- [Fase 2] Iniciando Teste E: Canvas Interativo/Stress ---", 'test'); let canvas=null,ctx=null; const rA={x:10,y:10,w:30,h:30}; const lA={x:150,y:100,w:60,h:30}; try{canvas=fingerprintCanvas;ctx=canvas.getContext('2d'); if(!ctx)throw new Error('No Ctx'); ctx.fillStyle="rgba(0,255,0,0.5)";ctx.fillRect(lA.x,lA.y,lA.w,lA.h); ctx.fillStyle="#fff"; ctx.font="12px mono"; ctx.fillText("Link?",lA.x+5,lA.y+18);}catch(e){log(`[F2/E] Falha setup: ${e.message}`,'error');return;} log("Adicionando listener 'click'...", 'subtest'); if(canvasClickListener&&canvas){try{canvas.removeEventListener('click',canvasClickListener);}catch(e){}} canvasClickListener=(ev)=>{try{const r=canvas.getBoundingClientRect();const x=ev.clientX-r.left; const y=ev.clientY-r.top; let area='fora'; if(x>=rA.x&&x<=rA.x+rA.w&&y>=rA.y&&y<=rA.y+rA.h)area='Rect(D)'; else if(x>=lA.x&&x<=lA.x+lA.w&&y>=lA.y&&y<=lA.y+lA.h)area='LinkArea'; log(`[F2/E] Click! Area:${area}. (Flag XSS F1: ${xssRanFlag})`,'info');}catch(e){log(`[F2/E] Erro click: ${e.message}`,'error');}}; try{canvas.addEventListener('click',canvasClickListener); log("[F2/E] Listener adicionado.",'info');}catch(e){log(`[F2/E] Erro add listener: ${e.message}`,'error');} await new Promise(r=>setTimeout(r,SHORT_PAUSE)); log("Stress toDataURL/measureText...", 'subtest'); /* ... (Stress URL e measureText de v15/v15.1) ... */ log("--- [Fase 2] Teste E Concluído ---", 'test'); };
        // Teste F: Observação Erros Detalhada
        const testErrorObservation = async () => { log("--- [Fase 2] Iniciando Teste F: Observação Erros ---", 'test'); /* ... (código Teste F v15) ... */ log("--- [Fase 2] Teste F Concluído ---", 'test'); };
        // Teste J: PP Avançada (`__proto__`, Array)
        const testAdvancedPP = async () => { log("--- [Fase 2] Iniciando Teste J: PP Avançada ---", 'test'); /* ... (código Teste J v15) ... */ log("--- [Fase 2] Teste J Concluído ---", 'test'); };
        // Teste K: Tentativas PP Gadget Especulativo
        const testPPGadgetAttempts = async () => { log("--- [Fase 2] Iniciando Teste K: PP Gadgets Especulativos ---", 'test'); /* ... (código Teste K v15) ... */ log("--- [Fase 2] Teste K Concluído ---", 'test'); };
        // Teste L: PP Hijack - não incluído na Fase 2 por padrão

        // Função para rodar a Fase 2
        const runNewTests = async () => {
            log("==== [Fase 2] INICIANDO EXECUÇÃO DOS TESTES ADICIONAIS ====", 'critical');
            log("INFO: Testes da Fase 2 podem usar resultados da Fase 1 (ex: OOB Leak, Flag XSS)", "info");
            // Ordem: Coleta -> Canvas -> Erros -> PP
            await testBasicDataCollection(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // A
            await testEnvironmentProbing(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // B
            await testAdvancedFingerprinting(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // C
            await testAdvancedCanvas(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // D (interage OOB)
            await testInteractiveCanvas(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // E (interage XSS flag)
            await testErrorObservation(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // F
            await testAdvancedPP(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // J
            await testPPGadgetAttempts(); await new Promise(r=>setTimeout(r,MEDIUM_PAUSE)); // K
            log("==== [Fase 2] EXECUÇÃO DOS TESTES ADICIONAIS CONCLUÍDA ====", 'critical');
        }

        // --- Função Principal ---
        const runEverythingSequentially = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v15.2 (Original Preservado + Aprofundamento) ====", 'critical');
            await runOriginalTests(); // Roda Fase 1
            log("\n >> Pausa Entre Fases <<\n", "warn"); await new Promise(r => setTimeout(r, MEDIUM_PAUSE * 2));
            await runNewTests(); // Roda Fase 2
            log("\n==== PoC Final v15.2 CONCLUÍDA (Fase 1 + Fase 2) ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // Limpeza listener
        window.addEventListener('unload', () => { if (canvasClickListener && fingerprintCanvas) { try { fingerprintCanvas.removeEventListener('click', canvasClickListener); } catch(e){} } });
        // document.addEventListener('DOMContentLoaded', runEverythingSequentially);

    </script>

</body>
</html>
