<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Exploit - Data Collection Script (Revisado)</title>
    <style>
        #output {
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>Data Collection Script (Revisado)</h1>
    <div id="output"></div>

    <script>
        const log = (message, type = 'info') => {
            const outputDiv = document.getElementById('output');
            if (outputDiv) {
                outputDiv.innerHTML += `<span style="color: ${type === 'error' ? 'red' : type === 'warning' ? 'orange' : 'blue'};">${new Date().toLocaleTimeString()} - ${message}\n</span>`;
            } else {
                console.error('Elemento #output não encontrado!');
            }
        };

        const prepareData = () => {
            log("Função prepareData() iniciada e concluída (para consistência).", 'info');
            let bufferSize = 64;
            let buffer = new ArrayBuffer(bufferSize);
            let view = new Uint8Array(buffer);
            return {
                buffer,
                view,
                bufferSize
            };
        };

        const collectPropertyModificationData = () => {
            log("\n--- Teste 1: Coletar Dados de Modificação de Propriedades ---", 'critical');
            prepareData();

            const propTarget1 = document.getElementById('propTarget1');
            const propTarget2 = document.getElementById('propTarget2');
            const propTarget3 = document.getElementById('propTarget3');
            const propTarget4 = document.getElementById('propTarget4');

            if (propTarget1) {
                try {
                    propTarget1.dataset.newValue = 'MODIFIED!';
                    log(`dataset.newValue modificado: ${propTarget1.dataset.newValue}`, 'info');
                } catch (e) {
                    log(`Erro ao modificar dataset: ${e}`, 'error');
                }
            } else {
                log('Elemento #propTarget1 não encontrado!', 'error');
            }

            if (propTarget2) {
                try {
                    propTarget2.style.backgroundColor = 'yellow';
                    propTarget2.style.color = 'black';
                    log(`style modificado (backgroundColor, color): ${propTarget2.style.backgroundColor}, ${propTarget2.style.color}`, 'info');
                } catch (e) {
                    log(`Erro ao modificar style: ${e}`, 'error');
                }
            } else {
                log('Elemento #propTarget2 não encontrado!', 'error');
            }

            if (propTarget3) {
                try {
                    propTarget3.setAttribute('customAttr', 'MODIFIED!');
                    log(`customAttr modificado: ${propTarget3.getAttribute('customAttr')}`, 'info');
                } catch (e) {
                    log(`Erro ao modificar customAttr: ${e}`, 'error');
                }
            } else {
                log('Elemento #propTarget3 não encontrado!', 'error');
            }

            if (propTarget4) {
                try {
                    Object.prototype.injectedProperty = 'INJECTED!';
                    log(`Tentativa de modificar prototype. Verifique se 'injectedProperty' existe em outros objetos.`, 'warning');
                    // Adicione código para verificar se a propriedade foi realmente injetada em outros objetos, se possível.
                    for (let key in window) {
                        try {
                            if (window[key] && window[key].injectedProperty) {
                                log(`Propriedade injetada em window.${key}: ${window[key].injectedProperty}`, 'info');
                            }
                        } catch (e) {
                            log(`Erro ao verificar window.${key}: ${e}`, 'error');
                        }
                    }
                } catch (e) {
                    log(`Erro ao modificar prototype: ${e}`, 'error');
                }
            } else {
                log('Elemento #propTarget4 não encontrado!', 'error');
            }
        };

        const collectCanvasData = () => {
            log("\n--- Teste 2: Coletar Dados da API Canvas 2D ---", 'critical');
            prepareData();

            const rwCanvas1 = document.getElementById('rwCanvas1');
            const rwCanvas2 = document.getElementById('rwCanvas2');
            const patternCanvas = document.getElementById('patternCanvas');

            // Função auxiliar para ler dados do canvas e registrar
            const readCanvasData = (canvas, description) => {
                if (canvas) {
                    try {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                            log(`${description} RGBA: ${Array.from(imageData).join(',')}`, 'info');
                        } else {
                            log(`Erro ao obter contexto 2D para ${description}`, 'error');
                        }
                    } catch (e) {
                        log(`Erro ao ler dados do canvas ${description}: ${e}`, 'error');
                    }
                } else {
                    log(`Elemento ${canvas.id} não encontrado!`, 'error');
                }
            };

            // Escrever e ler um padrão simples
            if (rwCanvas1) {
                try {
                    const ctx1 = rwCanvas1.getContext('2d');
                    if (ctx1) {
                        ctx1.fillStyle = 'blue';
                        ctx1.fillRect(0, 0, 1, 1);
                        readCanvasData(rwCanvas1, 'Canvas 1 (1x1)');
                    }
                } catch (e) {
                    log(`Erro ao escrever/ler Canvas 1: ${e}`, 'error');
                }
            }

            if (rwCanvas2) {
                try {
                    const ctx2 = rwCanvas2.getContext('2d');
                    if (ctx2) {
                        ctx2.fillStyle = 'red';
                        ctx2.fillRect(0, 1, 1, 1);
                        readCanvasData(rwCanvas2, 'Canvas 2 (1x2)');
                    }
                } catch (e) {
                    log(`Erro ao escrever/ler Canvas 2: ${e}`, 'error');
                }
            }

            // Testar leitura de área maior (se possível)
            if (rwCanvas1) {
                try {
                    const ctx = rwCanvas1.getContext('2d');
                    if (ctx) {
                        const imageData = ctx.getImageData(0, 0, rwCanvas1.width, rwCanvas1.height);
                        log(`Área maior Canvas 1 RGBA: ${Array.from(new Uint8Array(imageData.data.buffer)).join(',')}`, 'info');
                    }
                } catch (e) {
                    log(`Erro ao ler área maior do Canvas 1: ${e}`, 'warning'); // Usando 'warning' para indicar possível limitação
                }
            }

            // Testar padrão R/W
            if (patternCanvas) {
                try {
                    const ctx = patternCanvas.getContext('2d');
                    if (ctx) {
                        const writeData = new Uint8Array([255, 0, 0, 255, 0, 0, 255, 255]); // Vermelho, Azul
                        const imageDataWrite = new ImageData(new Uint8ClampedArray(writeData.buffer), patternCanvas.width, patternCanvas.height);
                        ctx.putImageData(imageDataWrite, 0, 0);
                        log('Padrão escrito (vermelho, azul).', 'info');
                        const readImageData = ctx.getImageData(0, 0, patternCanvas.width, patternCanvas.height);
                        log(`Padrão lido (RGBA): ${Array.from(new Uint8Array(readImageData.data.buffer)).join(',')}`, 'info');
                    }
                } catch (e) {
                    log(`Erro ao testar padrão R/W: ${e}`, 'error');
                }
            }
        };

        const collectMemoryReadData = () => {
            log("\n--- Teste 3: Coletar Dados de Leitura de Memória ---", 'critical');
            prepareData();

            let globalLeakedBuffer = new ArrayBuffer(8);
            let globalLeakedObject = {
                secret1: "AAA",
                secret2: "BBB"
            };
            let view = new Uint8Array(globalLeakedBuffer);
            view[0] = 0x41;
            view[1] = 0x42;

            // Tentar ler ArrayBuffer
            try {
                let temp = new Uint8Array(globalLeakedBuffer);
                log(`Leitura ArrayBuffer: ${temp[0]},${temp[1]}`, 'info');
            } catch (e) {
                log(`Erro ao ler ArrayBuffer: ${e}`, 'error');
            }

            // Tentar ler propriedade de objeto
            try {
                log(`Leitura Objeto: ${globalLeakedObject.secret1},${globalLeakedObject.secret2}`, 'info');
            } catch (e) {
                log(`Erro ao ler Objeto: ${e}`, 'error');
            }

            // Tentar vazar informações de erro
            try {
                throw new Error('Teste de Erro com Dados Sensíveis: ' + globalLeakedBuffer);
            } catch (e) {
                log(`Informação de erro: ${e.message}`, 'warning'); // Usando warning para destacar
            }

            // Tentar ler com atob/btoa
            try {
                const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(globalLeakedBuffer)));
                log(`Leitura com btoa: ${base64}`, 'info');
                const decoded = atob(base64);
                log(`Decodificado: ${decoded.charCodeAt(0)},${decoded.charCodeAt(1)}`, 'info');
            } catch (e) {
                log(`Erro com btoa/atob: ${e}`, 'error');
            }
        };

        const collectMemoryLayoutData = () => {
            log("\n--- Teste 4: Coletar Dados de Layout de Memória ---", 'critical');
            prepareData();

            const buffer1 = new ArrayBuffer(32);
            const view1 = new Uint8Array(buffer1);
            for (let i = 0; i < 32; i++) {
                view1[i] = i;
            }
            log(`Leitura Sequencial: ${Array.from(view1).join(',')}`, 'info');

            const buffer2 = new ArrayBuffer(64);
            const view2 = new Uint32Array(buffer2);
            let spacedData = [];
            for (let i = 0; i < 16; i++) {
                view2[i] = i * 4;
                spacedData.push(view2[i]);
            }
            log(`Leitura Espaçada (Uint32): ${spacedData.join(',')}`, 'info');

            // Coletar informações sobre buffers globais (pode ser extenso/perigoso)
            let globalBuffers = [];
            try {
                for (let key in window) {
                    try {
                        if (window[key] instanceof ArrayBuffer) {
                            globalBuffers.push(key);
                        }
                    } catch (e) {
                        log(`Erro ao verificar window.${key}: ${e}`, 'error');
                    }
                }
                log(`Buffers Globais Encontrados: ${globalBuffers.join(',')}`, 'warning'); // Usando warning
            } catch (e) {
                log(`Erro ao inspecionar buffers globais: ${e}`, 'error');
            }

            // Tentativa de Overlap (simplificado - precisa de técnicas mais avançadas)
            try {
                const overlapBuffer1 = new ArrayBuffer(16);
                const overlapView1 = new Uint8Array(overlapBuffer1);
                const overlapBuffer2 = new ArrayBuffer(16);
                const overlapView2 = new Uint8Array(overlapBuffer2);

                for (let i = 0; i < 16; i++) {
                    overlapView1[i] = i * 2;
                }

                // Simulação simplificada (precisa de técnicas de heap spraying para controle real)
                // Aqui apenas demonstramos a intenção de sobrescrever, não garantimos sucesso
                let overlapResult = overlapView1[8];
                overlapView2[8] = 60; // Tentativa de sobrescrever
                log(`Tentativa de Overlap: ${overlapResult}`, 'warning'); // Valor antes da tentativa
                log(`Valor após tentativa: ${overlapView1[8]}`, 'warning');
            } catch (e) {
                log(`Erro na tentativa de overlap: ${e}`, 'error');
            }
        };

        const main = () => {
            log("Script de Coleta de Dados Iniciado", 'critical');
            collectPropertyModificationData();
            collectCanvasData();
            collectMemoryReadData();
            collectMemoryLayoutData();
            log("Script de Coleta de Dados Concluído", 'critical');
        };

        // Iniciar a coleta de dados após o carregamento do DOM
        document.addEventListener('DOMContentLoaded', main);
    </script>

    <h2>Teste 1: Primitiva de Modificação de Propriedades (Robustos)</h2>
    <div id="propTarget1" data-original="Valor A" style="border: 1px solid black; padding: 10px; margin: 5px; cursor: pointer;">Clique para modificar dataset</div>
    <pre id="propResult1"></pre>
    <div id="propTarget2" style="border: 1px solid black; padding: 10px; margin: 5px; cursor: pointer; background-color: #f0f0f0;">Clique para modificar style</div>
    <pre id="propResult2"></pre>
    <div id="propTarget3" customAttr="Initial" style="border: 1px solid black; padding: 10px; margin: 5px; cursor: pointer;">Clique para modificar atributo customizado</div>
    <pre id="propResult3"></pre>
    <div id="propTarget4" style="border: 1px solid black; padding: 10px; margin: 5px; cursor: pointer;">Clique para tentar modificar prototype</div>
    <pre id="propResult4"></pre>
    <hr>

    <h2>Teste 2: Exploração da API Canvas 2D (Leitura/Escrita Precisa e Robustos)</h2>
    <canvas id="rwCanvas1" width="2" height="1" style="border: 1px solid black; cursor: pointer;"></canvas>
    <pre id="rwResult1"></pre>
    <canvas id="rwCanvas2" width="1" height="2" style="border: 1px solid black; cursor: pointer; margin-top: 5px;"></canvas>
    <pre id="rwResult2"></pre>
    <button id="readCanvasButton">Clique para ler área maior do canvas</button>
    <pre id="readCanvasResult"></pre>
    <div id="patternCanvasContainer">
        <canvas id="patternCanvas" width="2" height="1" style="border: 1px solid black; cursor: pointer;"></canvas>
        <pre id="patternCanvasResult"></pre>
    </div>
    <hr>

    <h2>Teste 3: Tentativa de Primitiva de Leitura de Memória (Exploratória e Robustos)</h2>
    <button id="memoryReadButton1">Tentar ler ArrayBuffer (indiretamente - global)</button>
    <pre id="memoryReadResult1"></pre>
    <button id="memoryReadButton2">Tentar ler propriedade de objeto (indiretamente - global)</button>
    <pre id="memoryReadResult2"></pre>
    <button id="memoryReadButton3">Tentar vazar informações de erro (global)</button>
    <pre id="memoryReadResult3"></pre>
    <button id="memoryReadButton4">Tentar ler com `atob`/`btoa` (global)</button>
    <pre id="memoryReadResult4"></pre>

    <h2>Teste 4: Analisar a Disposição da Memória</h2>
</body>

</html>
