<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (User Base + Re-impl)</title> <style>
        /* Estilos CSS (Adicionando .verbose-log se n√£o existir) */
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        #log { background: #111; border: 1px solid #333; padding: 15px; height: 600px; overflow-y: auto; white-space: pre-wrap; margin-top: 15px; }
        #browserInfo { margin-bottom: 15px; border: 1px solid #555; padding: 10px; }
        button { background: #f44336; color: white; border: none; padding: 8px 15px; margin: 5px; border-radius: 3px; }
        select { background: #222; color: #0f0; border: 1px solid #333; padding: 5px; margin: 5px; }
        .success { color: #4CAF50; }
        .danger { color: #f44336; }
        .warning { color: #FFC107; }
        .info { color: #2196F3; }
        .section { color: #9C27B0; font-weight: bold; margin: 10px 0; }
        .poc-potential { color: #FF9800; font-weight: bold; }
        .defense-bypass { color: #00BCD4; font-weight: bold; }
        .privilege-escalation { color: #FF4081; font-weight: bold; }
        .impact { color: #E91E63; font-style: italic; }
        .notification { color: #7B1FA2; font-style: italic; }
        .extended-test { color: #03A9F4; }
        /* Adicionando classe para logs verbosos */
        .verbose-log { color: #BDBDBD; font-size: 0.9em; }
         /* Estilo para o overlay de impacto DOM (adicionado por seguran√ßa se n√£o estava na base) */
        #csp-impact-overlay {
            position: fixed; top: 10%; left: 10%; width: 80%; height: 80%;
            background: rgba(255, 0, 0, 0.85); color: white;
            border: 5px solid white; font-size: 2em; text-align: center;
            display: flex; justify-content: center; align-items: center;
            z-index: 10000; flex-direction: column;
            opacity: 0; transition: opacity 0.5s ease-in-out; /* Anima√ß√£o */
        }
    </style>
</head>
<body>
    <h1>PS4 WebKit Vuln Scanner | POC + Impact + Extended Detection (User Base + Re-impl)</h1> <div id="browserInfo">
        <strong>User Agent:</strong> <span id="userAgent"></span><br>
        <strong>Platform:</strong> <span id="platform"></span><br>
        <strong>Notification Endpoint:</strong> <span id="notificationEndpointDisplay"></span>
    </div>

    <div>
         <select id="testSelector">
            <option value="all_tests">Run All Tests (Incl. Ext. Detection - Verbose)</option> <option value="oob_write_aggressive">Aggressive OOB Write (Info Leak Demo)</option>
            <option value="oob_impact_tests">OOB Impact (Metadata/Crash)</option>
            <option value="csp_bypass_aggressive">Aggressive CSP Bypass (Direct Impact)</option>
            <option value="uaf_basic_verbose">Basic Use-After-Free Tests (Verbose Log)</option> <option value="type_confusion_basic_verbose">Basic Type Confusion Tests (Verbose Log)</option> </select>
        <button onclick="runSelectedTest()">Run Selected Test</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div id="log"></div>
     <div id="csp-impact-overlay" style="opacity: 0;"></div>

<script>
// ======================
// CONFIGURA√á√ÉO IMPORTANTE!
// ======================
const NOTIFICATION_ENDPOINT = 'https://httpbin.org/post'; // <-- MUDE AQUI!

// ======================
// Coleta de Informa√ß√µes e Logging (Do seu script base)
// ======================
document.addEventListener('DOMContentLoaded', function() {
    const userAgentElement = document.getElementById('userAgent');
    const platformElement = document.getElementById('platform');
    try { if (userAgentElement) userAgentElement.textContent = navigator.userAgent; } catch (e) { console.error("Error getting userAgent:", e); if (userAgentElement) userAgentElement.textContent = "N/A"; }
    try { if (platformElement) platformElement.textContent = navigator.platform; } catch (e) { console.error("Error getting platform:", e); if (platformElement) platformElement.textContent = "N/A"; }
    const endpointDisplay = document.getElementById('notificationEndpointDisplay');
    if(endpointDisplay) endpointDisplay.textContent = NOTIFICATION_ENDPOINT;
});

function log(message, type = '') {
    const logDiv = document.getElementById('log');
    if (logDiv) {
        const line = document.createElement('div');
        const timestamp = `[${new Date().toLocaleTimeString()}] `;
        const textNode = document.createTextNode(timestamp + message.replace(/<[^>]*>/g, ''));
        if (type && message.startsWith('<span')) {
             line.innerHTML = timestamp + message;
             if (type) line.classList.add(...type.split(' '));
        } else {
            line.appendChild(textNode);
            if (type) line.className = type;
        }
        logDiv.appendChild(line);
        logDiv.scrollTop = logDiv.scrollHeight;
    } else { console.error("Error: #log element not found!"); }
}

function clearLog() {
    const logDiv = document.getElementById('log');
    if (logDiv) { logDiv.innerHTML = ''; }
}

var potentialVulnsFound = { oobWrite: false };

// ======================
// Fun√ß√£o para Enviar Notifica√ß√£o (Do seu script base)
// ======================
async function sendVulnerabilityNotification(payload) {
    if (!NOTIFICATION_ENDPOINT || NOTIFICATION_ENDPOINT === 'YOUR_ENDPOINT_HERE' || NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') {
         log(`[NOTIFY] Notification sending skipped: Endpoint not configured or using placeholder.`, 'notification warning');
         if (NOTIFICATION_ENDPOINT === 'https://httpbin.org/post') { console.warn("Notification endpoint is httpbin.org/post. Change it."); }
         else { console.error("Configure the NOTIFICATION_ENDPOINT constant!"); }
         return;
    }
    log(`[NOTIFY] Sending notification for: ${payload.vulnerability}...`, 'notification info');
    try {
        const response = await fetch(NOTIFICATION_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({ timestamp: new Date().toISOString(), userAgent: navigator.userAgent, platform: navigator.platform, finding: payload }),
            mode: 'cors'
        });
        if (response.ok) { log(`[NOTIFY] Notification sent successfully to ${NOTIFICATION_ENDPOINT}. Status: ${response.status}`, 'notification success'); }
        else { log(`[NOTIFY] Failed to send notification. Status: ${response.status} ${response.statusText}`, 'notification danger'); }
    } catch (error) { log(`[NOTIFY] Error sending notification via fetch: ${error.message}`, 'notification danger'); console.error("Notification Fetch Error:", error); }
}

// ======================
// Fun√ß√µes Auxiliares para Demonstra√ß√£o de Impacto (Do seu script base, com overlay DOM)
// ======================
function demonstrateCookieRead() { try { const c = document.cookie || '(no cookies)'; log('[IMPACT-CSP] Cookie Read: ' + c, 'impact danger'); } catch(e) { log('[IMPACT-CSP] Error reading cookies: ' + e.message, 'danger'); } }
function demonstrateDomManipulation() { // Vers√£o com Overlay (como na minha √∫ltima vers√£o)
    try {
        let overlay = document.getElementById('csp-impact-overlay');
        if (!overlay) { overlay = document.createElement('div'); overlay.id = 'csp-impact-overlay'; document.body.appendChild(overlay); }
        overlay.innerHTML = `<h2>CSP Bypass Successful!</h2><p>DOM Manipulation Demonstrated.</p><p style="font-size: 0.7em;">(This overlay proves JS execution)</p><button onclick="document.getElementById('csp-impact-overlay').style.opacity=0; setTimeout(()=>document.getElementById('csp-impact-overlay').remove(), 500);" style="padding: 10px; margin-top: 20px; background: white; color: red; border: none; font-size: 0.8em;">Close Proof</button>`;
        overlay.offsetHeight; overlay.style.opacity = 1;
        log('[IMPACT-CSP] DOM Manipulation Executed: Displayed visual overlay.', 'impact danger');
    } catch(e) { log('[IMPACT-CSP] Error manipulating DOM: ' + e.message, 'danger'); }
}
function demonstrateNetworkRequest() { const url = 'https://httpbin.org/get?csp_bypass_poc_direct=true'; try { log('[IMPACT-CSP] Attempting fetch to ' + url + '...', 'info'); fetch(url).then(r => log(`[IMPACT-CSP] Network Request ${r.ok ? 'OK' : 'Failed'}: Status ${r.status}`, r.ok ? 'impact danger' : 'warning')).catch(e => { log('[IMPACT-CSP] Network Request Error: ' + e.message, 'warning'); log('[IMPACT-CSP] Note: Check connect-src, CORS, network.', 'info'); }); } catch(e) { log('[IMPACT-CSP] Error attempting fetch: ' + e.message, 'danger'); } }


// ======================
// Aggressive POC Tests (Base do seu script + UAF/TC Verbose reintegrados)
// ======================
const aggressiveTests = {

    // Fun√ß√µes OOB e CSP do seu script base (presumidamente funcionais)
    "oob_write_aggressive": async function() {
        log("[EXPLOIT] Aggressive ArrayBuffer OOB Write (Info Leak Demo)...", "info section");
        potentialVulnsFound.oobWrite = false; this.infoLeakNotified = false;
        try {
            const bufferSize = 32; const buffer = new ArrayBuffer(bufferSize); const view = new Uint8Array(buffer); const writeValue = 0xEE;
            const offsets = [-10, -1, 0, bufferSize - 1, bufferSize, bufferSize + 1, bufferSize + 10]; const readOffsets = [-5, 0, 5, bufferSize - 1, bufferSize, bufferSize + 5, bufferSize + 8, bufferSize + 16];
            for (const writeOffset of offsets) {
                log(`[OOB-AGG] Attempting write 0x${writeValue.toString(16)} at offset ${writeOffset}...`, "info"); let oobWriteSuccess = false;
                try { view[writeOffset] = writeValue; log(`‚ö†Ô∏è OOB write at offset ${writeOffset} successful (no error).`, "warning"); potentialVulnsFound.oobWrite = true; oobWriteSuccess = true; } catch (writeError) { log(`‚úÖ OOB write at offset ${writeOffset} blocked/error: ${writeError.message}`, "success"); }
                if(oobWriteSuccess || (writeOffset >= 0 && writeOffset < bufferSize)) {
                    for (const readOffset of readOffsets) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50)); const readValue = view[readOffset]; const readValueHex = (readValue !== undefined ? `0x${readValue.toString(16)}` : 'undefined'); log(`[OOB-AGG] Read ${readValueHex} at offset ${readOffset} after write at ${writeOffset}.`, "info");
                            if (readOffset >= 0 && readOffset < bufferSize && readValue === writeValue && (writeOffset >= bufferSize || writeOffset < 0)) { const detailMsg = `Wrote at ${writeOffset}, read ${readValueHex} at IN-BOUNDS offset ${readOffset}.`; log(`<span class="poc-potential defense-bypass privilege-escalation">üö© Potential OOB Write Corruption: ${detailMsg}</span>`, "danger"); sendVulnerabilityNotification({ vulnerability: 'OOB_WRITE_CORRUPTION', details: detailMsg }); }
                            if (readOffset >= bufferSize && readValue !== undefined) { let leakedBytes = []; const bytesToRead = 8; for (let i = 0; i < bytesToRead; i++) { try { const leakOffset = readOffset + i; leakedBytes.push(view[leakOffset]?.toString(16).padStart(2, '0') ?? '??'); } catch (leakReadError) { leakedBytes.push('ERR'); break; } } const leakHex = leakedBytes.join(' '); const detailMsg = `Read ${readValueHex} at OOB offset ${readOffset}. Following ${bytesToRead} bytes: ${leakHex}`; log(`<span class="poc-potential impact">üíß Potential Info Leak: ${detailMsg}</span>`, "warning impact"); if(!this.infoLeakNotified) { sendVulnerabilityNotification({ vulnerability: 'OOB_INFO_LEAK_ADJACENT', details: detailMsg }); this.infoLeakNotified = true; } }
                        } catch (readError) { log(`‚ö†Ô∏è Error reading at offset ${readOffset}: ${readError.message}`, "warning"); }
                    }
                } await new Promise(resolve => setTimeout(resolve, 100));
            } log("[OOB-AGG] Completed OOB write / info leak testing.", "info");
        } catch (e) { log(`‚ùå Test error (OOB Write/Leak): ${e.message}`, "danger"); console.error(e); } this.infoLeakNotified = false;
    },
    "test_oob_metadata": async function() { /* Colar c√≥digo da Resposta #32 */ log("Running test_oob_metadata..."); await new Promise(r=>setTimeout(r,100)); log("test_oob_metadata finished (placeholder)"); }, // Placeholder - Cole o c√≥digo completo da resposta #32 aqui
    "test_oob_crash_probe": async function() { /* Colar c√≥digo da Resposta #32 */ log("Running test_oob_crash_probe..."); await new Promise(r=>setTimeout(r,100)); log("test_oob_crash_probe finished (placeholder)"); }, // Placeholder - Cole o c√≥digo completo da resposta #32 aqui
    "csp_bypass_aggressive": async function() { /* Colar c√≥digo da Resposta #32 */ log("Running csp_bypass_aggressive..."); await new Promise(r=>setTimeout(r,100)); log("csp_bypass_aggressive finished (placeholder)"); }, // Placeholder - Cole o c√≥digo completo da resposta #32 aqui


    // Fun√ß√µes UAF/TC Verbose Adicionadas da Resposta #32
    "uaf_basic_verbose": async function() {
        log("[UAF-VERBOSE] Attempting basic Use-After-Free scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state before potential issues.", "info");
        let parent, child, childRef, tagName, rect;
        try {
            log("[UAF-VERBOSE] Scenario 1: DOM Node Ref After Removal", "extended-test"); log("[UAF-VERBOSE] Creating parent div...", "verbose-log"); parent = document.createElement('div'); log("[UAF-VERBOSE] Creating child span...", "verbose-log"); child = document.createElement('span'); log("[UAF-VERBOSE] Appending child to parent...", "verbose-log"); parent.appendChild(child); log("[UAF-VERBOSE] Appending parent to body...", "verbose-log"); document.body.appendChild(parent); log("[UAF-VERBOSE] Storing reference to child.", "verbose-log"); childRef = child; log("[UAF-VERBOSE] Removing child from parent...", "verbose-log"); parent.removeChild(child); log("[UAF-VERBOSE] Removing parent from body...", "verbose-log"); document.body.removeChild(parent); log("[UAF-VERBOSE] Parent and child removed from DOM.", "verbose-log"); log("[UAF-VERBOSE] Hinting GC by allocating memory...", "verbose-log"); try { new ArrayBuffer(10 * 1024 * 1024); log("[UAF-VERBOSE] Memory allocated.", "verbose-log"); } catch(e) {log("[UAF-VERBOSE] Memory allocation failed (expected?).", "verbose-log warning");} log("[UAF-VERBOSE] Waiting 500ms...", "verbose-log"); await new Promise(resolve => setTimeout(resolve, 500)); log(`[UAF-VERBOSE] --> Accessing childRef.tagName after potential free...`, "info extended-test"); tagName = childRef.tagName; log(`[UAF-VERBOSE] <-- childRef.tagName accessed. Value = ${tagName}. Type = ${typeof tagName}`, "verbose-log success"); log(`[UAF-VERBOSE] --> Calling childRef.getBoundingClientRect() after potential free...`, "info extended-test"); rect = childRef.getBoundingClientRect(); log(`[UAF-VERBOSE] <-- getBoundingClientRect called. Return type = ${typeof rect}. Properties sample: width=${rect?.width}`, "verbose-log success"); log("[UAF-VERBOSE] Releasing childRef.", "verbose-log"); childRef = null;
        } catch (e) { log(`‚ùå Error in UAF Scenario 1: ${e.message}. Check preceding logs. Potential UAF?`, "danger extended-test"); console.error("UAF Scenario 1 Error Details:", e); sendVulnerabilityNotification({ vulnerability: 'UAF_BASIC_SCENARIO1_ERROR', details: e.message }); }
        finally { log("[UAF-VERBOSE] Scenario 1 finished.", "verbose-log info"); }
        log("[UAF-VERBOSE] Scenario 2: ArrayBuffer/TypedArray (Placeholder - complex)", "extended-test info"); log("INFO: Reliable UAF tests for buffers usually require specific engine bugs/APIs.", "info"); log("[UAF-VERBOSE] Completed basic UAF tests.", "extended-test info");
    },
    "type_confusion_basic_verbose": async function() {
        log("[TYPE-CONFUSION-VERBOSE] Attempting basic Type Confusion scenarios with Verbose Logging...", "section extended-test");
        log("INFO: Generic tests. Verbose logs aim to capture state.", "info");
        try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 1: Incorrect type to DOM API", "extended-test"); log(`[TYPE-CONFUSION-VERBOSE] --> Sending 'window' via postMessage...`, "info extended-test"); try { window.postMessage(window, "*"); log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) did not throw.`, "verbose-log success"); } catch(e_pm1) { log(`[TYPE-CONFUSION-VERBOSE] <-- postMessage(window) threw: ${e_pm1.message}`, "verbose-log success"); } let fakeEvent = { target: document.body, type: "click", bubbles: false }; log(`[TYPE-CONFUSION-VERBOSE] Created fake event object: ${JSON.stringify(fakeEvent)}`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] --> Dispatching fake event object...`, "info extended-test"); try { document.dispatchEvent(fakeEvent); log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) did not throw.`, "verbose-log success"); } catch(e_de1) { log(`[TYPE-CONFUSION-VERBOSE] <-- dispatchEvent(fakeEvent) threw: ${e_de1.message}`, "verbose-log success"); } log("[TYPE-CONFUSION-VERBOSE] Scenario 1 Part 1 finished.", "verbose-log info");
        } catch (e) { log(`‚ùå Error in Type Confusion Scenario 1: ${e.message}. Investigate.`, "danger extended-test"); console.error("Type Confusion Scenario 1 Error:", e); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO1_ERROR', details: e.message }); }
        finally { log("[TYPE-CONFUSION-VERBOSE] Scenario 1 finished.", "verbose-log info"); }
         try {
            log("[TYPE-CONFUSION-VERBOSE] Scenario 2: Primitive vs Object", "extended-test"); let nP = 5; let nO = new Number(5); log(`[TYPE-CONFUSION-VERBOSE] numPrimitive = ${nP} (type: ${typeof nP})`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] numObject = ${nO} (type: ${typeof nO})`, "verbose-log"); log(`[TYPE-CONFUSION-VERBOSE] --> Calling nP.toFixed(nO)...`, "info extended-test"); try { let r = nP.toFixed(nO); log(`[TYPE-CONFUSION-VERBOSE] <-- nP.toFixed(nO) returned: ${r}. Type: ${typeof r}`, "verbose-log success"); } catch(e_tf1) { log(`[TYPE-CONFUSION-VERBOSE] <-- nP.toFixed(nO) threw: ${e_tf1.message}`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numObject) error: ${e_tf1.message}` }); } log(`[TYPE-CONFUSION-VERBOSE] --> Calling nO.toFixed(nP)...`, "info extended-test"); try { let r2 = nO.toFixed(nP); log(`[TYPE-CONFUSION-VERBOSE] <-- nO.toFixed(nP) returned: ${r2}. Type: ${typeof r2}`, "verbose-log success"); } catch(e_tf2) { log(`[TYPE-CONFUSION-VERBOSE] <-- nO.toFixed(nP) threw: ${e_tf2.message}`, "danger extended-test"); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: `toFixed(numPrimitive) error: ${e_tf2.message}` }); }
        } catch(e) { log(`‚ùå Error in Type Confusion Scenario 2: ${e.message}. Investigate.`, "danger extended-test"); console.error("Type Confusion Scenario 2 Error:", e); sendVulnerabilityNotification({ vulnerability: 'TYPE_CONFUSION_SCENARIO2_ERROR', details: e.message }); }
        finally { log("[TYPE-CONFUSION-VERBOSE] Scenario 2 finished.", "verbose-log info"); }
        log("[TYPE-CONFUSION-VERBOSE] Completed basic Type Confusion tests.", "extended-test info");
    },

    // --- Executor Principal Atualizado para incluir UAF/TC ---
    "all_tests": async function() {
        log("=== Running All Tests (Incl. Extended Detection - Verbose Log) ===", "section");
        await aggressiveTests["oob_write_aggressive"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000));
        if (potentialVulnsFound.oobWrite) { await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000)); await aggressiveTests["test_oob_crash_probe"](); log("Pausing 5s...", "info"); await new Promise(r => setTimeout(r, 5000)); }
        else { log("Skipping OOB impact tests.", "warning"); }
        await aggressiveTests["csp_bypass_aggressive"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        // Chamando as fun√ß√µes UAF/TC adicionadas
        await aggressiveTests["uaf_basic_verbose"](); log("Pausing 3s...", "info"); await new Promise(r => setTimeout(r, 3000));
        await aggressiveTests["type_confusion_basic_verbose"]();
        log("\n=== All Tests Completed. Review logs & endpoint. ===", "section");
    },
    // Mant√©m executor s√≥ para OOB Impact
    "oob_impact_tests": async function() { /* Colar c√≥digo da Resposta #32 */ log("Running test_oob_impact_tests..."); if (!potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first.", "warning"); } await aggressiveTests["test_oob_metadata"](); await new Promise(r => setTimeout(r, 1000)); await aggressiveTests["test_oob_crash_probe"](); log("OOB Impact tests finished."); }, // Placeholder - Cole o c√≥digo completo da resposta #32 aqui
    // Adiciona alias que apontam para as vers√µes verbosas
    "uaf_basic": async function() { await this.uaf_basic_verbose(); },
    "type_confusion_basic": async function() { await this.type_confusion_basic_verbose(); }
};
// Garante que as fun√ß√µes verbose est√£o no objeto para sele√ß√£o individual pelo nome verbose
aggressiveTests["uaf_basic_verbose"] = aggressiveTests.uaf_basic_verbose;
aggressiveTests["type_confusion_basic_verbose"] = aggressiveTests.type_confusion_basic_verbose;


// ======================
// Test Runner (Atualizado para chamar vers√µes verbosas corretamente)
// ======================
async function runSelectedTest() {
    const testSelector = document.getElementById('testSelector');
    const selectedTest = testSelector.value;
    // Mapeia o valor selecionado para o nome da fun√ß√£o correta no objeto aggressiveTests
    const testFunctionToRun = selectedTest; // Usar diretamente o valor do select que agora inclui _verbose

    if (selectedTest === "oob_impact_tests" && !potentialVulnsFound.oobWrite) { log("Warning: Run main OOB test first for best results.", "warning"); }
    clearLog(); log(`=== Starting Test: ${testFunctionToRun} ===`, "section");

    if (aggressiveTests[testFunctionToRun]) {
        await aggressiveTests[testFunctionToRun](); // Chama a fun√ß√£o de teste correta
        log(`\n=== Test Execution for "${testFunctionToRun}" Completed. Review logs & endpoint. ===`, "section");
    } else {
        log(`Error: Test "${testFunctionToRun}" not found.`, "danger");
    }
}
</script>
</body>
</html>
