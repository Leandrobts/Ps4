<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OOB 64 + Data Collector</title> <style>
        /* Estilos CSS (sem alterações) */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output { background: #222; border: 1px solid #444; padding: 10px; height: 80vh; overflow-y: auto; white-space: pre-wrap; margin-top: 10px; }
        .log-info { color: #6cf; }
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; }
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; }
        .log-vuln { color: #ff4444; font-weight: bold; } /* Vermelho para vulnerabilidade confirmada */
        .log-good { color: #4CAF50; } /* Verde para bloqueio esperado / falha */
        .log-warn { color: #FFC107; }
        .log-error { color: #f44336; }
        .log-leak { color: #FF9800; font-weight: bold; } /* Laranja para leaks genéricos */
        .log-ptr { color: #f0f; font-weight: bold; } /* Magenta para POTENCIAIS ponteiros */
        #xss-target-div { border: 2px dotted red; padding: 5px; margin: 15px 0; color: yellow; min-height: 40px; }
    </style>
</head>
<body>
    <h1>Info Leak Finder & Data Collector</h1> <canvas id="webgl-canvas" width="1" height="1" style="display: none;"></canvas> <p>Testa: XSS, OOB R/W (Info Leak), PP Básica, PP Hijack (JSON.stringify com Interação), Coleta de Dados do Ambiente.</p> <button id="runBtn" onclick="runAllTests()">Iniciar Todos os Testes</button>
    <div id="output"></div>
    <div id="xss-target-div">Área para teste de XSS DOM.</div>

    <script>
        // --- Globals & Setup ---
        const outputDiv = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const SHORT_PAUSE = 50; // ms
        const MEDIUM_PAUSE = 500; // ms
        let leakedValueFromOOB = null; // Armazena valor do Info Leak

        // --- Função de Log ---
        const log = (message, type = 'info') => {
            if (!outputDiv) return;
            try {
                // Usando a data e hora local do Brasil (aproximado via fuso horário -03:00 - ajuste se necessário)
                // Nota: Isto pega o fuso horário do SISTEMA do usuário, não garante ser do Brasil.
                // Para garantir Brasil, seria necessário uma biblioteca ou ajuste manual mais complexo.
                // const timestamp = `[${new Date().toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' } )}]`;
                // Usando hora local do navegador para simplicidade:
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                // Sanitiza a mensagem para evitar XSS no próprio log
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                // Limita o tamanho do log
                if(outputDiv.innerHTML.length > 500000){
                    outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 250000);
                    outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML;
                }
                outputDiv.innerHTML += `<span class="log-${type}">${timestamp} ${sanitizedMessage}\n</span>`;
                outputDiv.scrollTop = outputDiv.scrollHeight; // Auto-scroll
            } catch(e) { console.error("Erro na função log:", e); outputDiv = null; }
        };

        // Helper para formatar números como hex
        const toHex = (val, bits = 32) => {
            if (typeof val !== 'number' || !isFinite(val)) return 'NaN/Invalid';
            let num = Number(val);
            if (bits <= 32) { num = num >>> 0; } // Trata como Uint32
            const pad = Math.ceil(bits / 4);
            return '0x' + num.toString(16).toUpperCase().padStart(pad, '0');
        }

        // --- Heurística Simples para Detetar Potenciais Ponteiros (64-bit) ---
        const isPotentialPointer64 = (high, low) => {
            if (high === null || low === null || typeof high !== 'number' || typeof low !== 'number') return false;
            if (high === 0 && low === 0) return false;
            if (high === 0xFFFFFFFF && low === 0xFFFFFFFF) return false;
            if (high === 0xAAAAAAAA && low === 0xAAAAAAAA) return false; // Nosso padrão
            // Verifica se o byte 'EE' da nossa escrita está presente (caso Teste 2)
            if (high === 0xAAAAAAAAEE || low === 0xAAAAAAAAEE) return false; // Filtra nosso próprio padrão escrito
            if (high === 0 && low < 0x100000) return false; // Valores muito pequenos
            // Heurística adicional: ponteiros de código ou dados frequentemente têm bits mais altos definidos em 64 bits
            // Isto é muito genérico e dependente da arquitetura/SO
            // if (high === 0 && (low >>> 24) === 0) return false; // Ex: 0x00......
            // if ((high >>> 16) === 0) return false; // Ex: 0x0000...._........ (pode filtrar demais)
            return true; // Se passou, PODE ser um ponteiro
        };

        // --- Heurística Simples para Detetar Potenciais Dados U32 ---
        const isPotentialData32 = (val) => {
            if (val === null || typeof val !== 'number') return false;
            val = val >>> 0; // Trata como Uint32
            if (val === 0 || val === 0xFFFFFFFF || val === 0xAAAAAAAA || val === 0xAAAAAAEE) return false; // Nossos padrões
            if (val < 0x1000) return false; // Filtra valores muito pequenos
            return true; // Se passou, PODE ser dados interessantes
        }

        // --- Teste 1: CSP Bypass / XSS ---
        const testCSPBypass = async () => {
            log("--- Iniciando Teste 1: CSP Bypass / XSS ---", 'test');
            // 1.1 Teste com data: URI
            log("Tentando XSS via data: URI (alert)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const payloadJS = `try { alert('XSS via Data URI! Teste 1.1'); log("[Payload Data:] Alerta data: URI executado!", "vuln"); } catch(e) { log("[Payload Data:] Alerta data: URI bloqueado: " + e.message, "good"); }`;
                const encodedPayload = btoa(payloadJS);
                const scriptTag = document.createElement('script');
                scriptTag.src = 'data:text/javascript;base64,' + encodedPayload;
                scriptTag.onerror = () => { log("ERRO: Falha ao carregar script data: URI!", 'error'); };
                document.body.appendChild(scriptTag);
                log("Tag <script> data: URI adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar script data: URI: ${e.message}`, 'error'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE * 2));

            // 1.2 Teste com onerror
            log("Tentando XSS DOM via inline handler (onerror)...", 'subtest');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
            try {
                const imgTag = document.createElement('img');
                imgTag.src = 'invalid_image_source_' + Date.now();
                const onerrorPayload = `
                    try {
                        const target = document.getElementById('xss-target-div');
                        if (target) {
                            target.innerHTML = '<h2 class="log-vuln">XSS DOM via ONERROR Executado! (Teste 1.2)</h2>';
                            log("XSS DOM via onerror realizado!", "vuln");
                        } else { log("Alvo XSS DOM (onerror) não encontrado.", "error"); }
                        alert('XSS_DOM_ONERROR Teste 1.2');
                    } catch(e) { log("Erro no payload onerror: " + e.message, "warn"); }
                `;
                imgTag.setAttribute('onerror', onerrorPayload);
                document.body.appendChild(imgTag);
                log("Tag <img> com onerror adicionada.", 'info');
            } catch (e) { log(`Erro ao criar/adicionar img onerror: ${e.message}`, 'error'); }
            log("--- Teste 1 Concluído (Verificar alertas/DOM) ---", 'test');
        };

        // --- Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado com Armazenamento) ---
        const testOOBReadInfoLeakEnhancedStore = async () => {
            log("--- Iniciando Teste 2: OOB Write/Read Extensivo (Info Leak Aprimorado) ---", 'test');
            const bufferSize = 32; // Tamanho lógico
            const extraPadding = 256; // Espaço extra para tentativas OOB
            const writeValue = 0xEE;
            const oobWriteOffset = bufferSize + 8; // Escreve um pouco além do buffer lógico, mas dentro do padding
            const oobReadOffsets = [];
            // Lê de antes do buffer lógico até depois, cobrindo a área de escrita
            for (let i = -bufferSize; i < bufferSize + extraPadding / 2; i += 4) { oobReadOffsets.push(i); }
            let writeSuccess = false;
            let potentialLeakFoundCount = 0;
            leakedValueFromOOB = null; // Reseta

            try {
                // Aloca buffer maior que o necessário para ter espaço para OOB R/W (dentro do buffer alocado)
                const allocatedSize = bufferSize + extraPadding;
                const buffer = new ArrayBuffer(allocatedSize);
                const dataView = new DataView(buffer);
                // Offset base para o início do buffer lógico dentro do buffer alocado
                const baseOffset = extraPadding / 2;

                // Preenche todo o buffer alocado com um padrão
                for (let i = 0; i < buffer.byteLength; i++) { dataView.setUint8(i, 0xAA); }
                log(`Buffer alocado (${allocatedSize} bytes), preenchido com 0xAA. Buffer lógico começa em ${baseOffset}.`, 'info');

                const writeTargetAddress = baseOffset + oobWriteOffset;
                log(`Tentando escrita OOB U8 @ offset relativo ${oobWriteOffset} (endereço absoluto ${writeTargetAddress})...`, 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

                if (writeTargetAddress < 0 || writeTargetAddress >= buffer.byteLength) {
                     log(`AVISO: Endereço de escrita (${writeTargetAddress}) está fora do buffer alocado (${buffer.byteLength}). Teste OOB write abortado.`, 'warn');
                     log("--- Teste 2 Interrompido (Endereço de escrita inválido) ---", 'test');
                     return false;
                }

                try {
                    dataView.setUint8(writeTargetAddress, writeValue);
                    // Verifica se realmente escreveu
                    if (dataView.getUint8(writeTargetAddress) === writeValue) {
                        log(`SUCESSO: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) realizada com valor 0x${writeValue.toString(16).toUpperCase()}.`, 'good'); // Verde aqui indica sucesso da operação, não vuln
                        writeSuccess = true;
                    } else {
                         log(`FALHA: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) parece não ter funcionado (valor lido != escrito).`, 'warn');
                    }
                } catch (e) {
                    // Erro aqui seria o esperado em um ambiente seguro se o offset fosse realmente fora do buffer alocado
                    log(`ERRO/BLOQUEADO?: Escrita OOB U8 @${oobWriteOffset} (abs ${writeTargetAddress}) falhou: ${e.message}`, 'error');
                    log("--- Teste 2 Interrompido (Escrita OOB falhou/bloqueada) ---", 'test');
                    return false; // Não adianta ler se a escrita falhou
                }

                 if (!writeSuccess) {
                     log("--- Teste 2 Interrompido (Escrita OOB não confirmada) ---", 'test');
                     return false;
                 }

                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                log(`Tentando leituras OOB U32/U64 em ${oobReadOffsets.length} offsets relativos...`, 'subtest');
                for (const readOffset of oobReadOffsets) {
                    const readTargetAddress = baseOffset + readOffset;

                    // Verifica limites para leitura U64 (precisa de 8 bytes)
                    if (readTargetAddress < 0 || readTargetAddress + 8 > buffer.byteLength) continue;

                    let valueStrU64 = 'N/A';
                    let high = null, low = null;
                    try {
                        low = dataView.getUint32(readTargetAddress, true); // Little Endian
                        high = dataView.getUint32(readTargetAddress + 4, true); // Little Endian
                        valueStrU64 = `H=${toHex(high, 32)} L=${toHex(low, 32)}`;

                        if (isPotentialPointer64(high, low)) {
                            log(`  -> POTENCIAL PONTEIRO? U64 @${readOffset} (abs ${readTargetAddress}): ${valueStrU64}`, 'ptr');
                            potentialLeakFoundCount++;
                            if (leakedValueFromOOB === null) { // Armazena o primeiro potencial ponteiro REAL (filtrado)
                                leakedValueFromOOB = { high, low, type: 'U64', offset: readOffset };
                                log(`  -> VALOR U64 ARMAZENADO (offset ${readOffset}).`, 'vuln'); // Vuln aqui indica armazenamento
                            }
                        } else if (high !== 0xAAAAAAAA || low !== 0xAAAAAAAA) {
                             // Loga se for diferente do padrão, mesmo que não seja "ponteiro" pela heurística
                             // Evita logar apenas AAAAAAAA_AAAAAAAA
                             //log(`  -> Lido U64 @${readOffset} (abs ${readTargetAddress}): ${valueStrU64}`, 'info');
                        }
                    } catch (e) { /* Ignora erros de leitura individuais */ }

                    // Tenta ler U32 (se não achou U64 ainda ou só para logar)
                    // Verifica limites para leitura U32 (precisa de 4 bytes)
                    if (readTargetAddress < 0 || readTargetAddress + 4 > buffer.byteLength) continue;
                     let val32 = null;
                     try {
                         val32 = dataView.getUint32(readTargetAddress, true);
                         if (isPotentialData32(val32)) {
                             log(`  -> Leak U32? @${readOffset} (abs ${readTargetAddress}): ${toHex(val32, 32)}`, 'leak');
                             potentialLeakFoundCount++;
                             if (leakedValueFromOOB === null) { // Armazena se for o primeiro leak potencial e não for nosso padrão
                                 leakedValueFromOOB = { high: 0, low: val32, type: 'U32', offset: readOffset };
                                 log(`  -> VALOR U32 ARMAZENADO (offset ${readOffset}).`, 'vuln');
                             }
                         } else if (val32 !== 0xAAAAAAAA && val32 !== 0) {
                              // Loga se for diferente do padrão ou zero, mas não "interessante"
                              //log(`  -> Lido U32 @${readOffset} (abs ${readTargetAddress}): ${toHex(val32, 32)}`, 'info');
                         }
                    } catch(e) {/* Ignora */}

                    // Pequena pausa para não travar o navegador em loops longos
                    if (readOffset % 64 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            } catch (e) { log(`Erro inesperado durante o teste Info Leak: ${e.message}`, 'error'); }

            log(`--- Teste 2 Concluído (${potentialLeakFoundCount} potenciais leaks detectados, ${leakedValueFromOOB ? `1 valor ${leakedValueFromOOB.type} armazenado do offset relativo ${leakedValueFromOOB.offset}` : 'nenhum valor armazenado'}) ---`, 'test');
            // Retorna true se a escrita foi bem sucedida, indicando que o teste pôde prosseguir
            // Não indica necessariamente uma vulnerabilidade real de leitura.
            return writeSuccess;
        };


        // --- Teste 3: Prototype Pollution (Básica) ---
        const testBasicPP = async () => {
            log("--- Iniciando Teste 3: Prototype Pollution (Básica) ---", 'test');
            const testProp = '__pp_basic_test__';
            const testValue = 'Polluted!';
            let success = false;
            try {
                log(`Poluindo Object.prototype.${testProp} = "${testValue}"`, 'subtest');
                Object.prototype[testProp] = testValue;
                log("Verificando herança em objeto vazio {}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const obj = {};
                if (obj[testProp] === testValue) {
                    log(`VULN: PP Básica confirmada! Objeto vazio herdou a propriedade.`, 'vuln');
                    success = true;
                } else {
                    log(`FALHA/BLOQUEADO: PP Básica não confirmada. Objeto vazio NÃO herdou a propriedade.`, 'good');
                }
            } catch (e) { log(`Erro durante teste PP Básico: ${e.message}`, 'error'); }
            finally {
                try {
                    delete Object.prototype[testProp];
                    log(`Limpeza de Object.prototype.${testProp} realizada.`, 'info');
                 } catch(e){ log(`Erro na limpeza de Object.prototype.${testProp}: ${e.message}`, 'warn');}
            }
            log(`--- Teste 3 Concluído (PP Básica ${success ? 'Confirmada' : 'Falhou/Bloqueada'}) ---`, 'test');
            return success;
        };

        // --- Teste 4: PP Hijack (JSON.stringify com Interação) ---
        const testPPJsonHijack = async () => {
            log("--- Iniciando Teste 4: PP Hijack (JSON.stringify) ---", 'test');
            const originalStringify = JSON.stringify;
            let hijackSuccessful = false;
            let interactionSuccessful = false;
            let hijackReturnedCorrectly = false;

            try {
                log("Tentando sobrescrever JSON.stringify...", 'subtest');
                JSON.stringify = function hijackedStringify(value, replacer, space) {
                    log("===> VULN: DENTRO DA FUNÇÃO JSON.stringify SEQUESTRADA! <===", 'vuln');
                    hijackSuccessful = true;

                    log(`  -> Hijack: Tentando aceder ao valor vazado do Teste 2...`, 'info');
                    try {
                        const leak = leakedValueFromOOB; // Acessa a variável global
                        let leakStr = "NULO ou não encontrado/armazenado";
                        if (leak) {
                            leakStr = leak.type === 'U64' ? `U64 @${leak.offset}: H=${toHex(leak.high)} L=${toHex(leak.low)}` : `U32 @${leak.offset}: ${toHex(leak.low)}`;
                            interactionSuccessful = true; // Interação bem-sucedida se leak não for nulo
                        }
                        log(`  -> Hijack: Valor armazenado de OOB Read (Teste 2) é: ${leakStr}`, interactionSuccessful ? 'leak' : 'info');
                    } catch(interactionError) {
                        log(`  -> Hijack: Erro ao aceder/logar valor vazado: ${interactionError.message}`, 'error');
                        interactionSuccessful = false;
                    }
                    // Retorna um valor fixo para indicar que o hijack funcionou e se a interação ocorreu
                    return `{"hijacked": true, "original_value": "skipped", "leak_accessed": ${interactionSuccessful}}`;
                };

                log("Testando a função JSON.stringify sequestrada com {a: 1, b: 'teste'}...", 'subtest');
                await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));
                const testObject = { a: 1, b: 'teste' };
                // Log do objeto original usando a função original (antes que seja restaurada)
                // try { log(`Objeto original (via original func): ${originalStringify(testObject)}`, 'info'); } catch(e){}

                const result = JSON.stringify(testObject); // Chama a versão sequestrada
                log(`Resultado retornado por JSON.stringify(): ${result}`, 'info');

                if (result && result.includes('"hijacked": true')) {
                    log("VULN: Retorno da função JSON.stringify sequestrada confirmado!", 'vuln');
                    hijackReturnedCorrectly = true;
                    if (!interactionSuccessful && leakedValueFromOOB !== null) {
                         log("AVISO: Hijack funcionou, mas falhou em reportar o valor vazado que foi armazenado.", 'warn');
                    }
                } else if (hijackSuccessful) {
                    log("AVISO: Função JSON.stringify foi sequestrada, mas o retorno não foi o esperado.", 'warn');
                } else {
                    log("FALHA/BLOQUEADO: Sequestro de JSON.stringify não funcionou.", 'good');
                }

            } catch (e) { log(`Erro durante teste PP Hijack JSON: ${e.message}`, 'error'); }
            finally {
                // CRÍTICO: Restaurar a função original
                JSON.stringify = originalStringify;
                log("Função JSON.stringify restaurada.", 'info');
                // Verificar restauração
                if (JSON.stringify === originalStringify && typeof JSON.stringify({a:1}) === 'string' && JSON.stringify({a:1}) === '{"a":1}') {
                     log("Restauração de stringify confirmada.", 'info');
                } else {
                     log("ERRO CRÍTICO: FALHA ao restaurar JSON.stringify! Funcionalidade do navegador pode estar comprometida.", 'error');
                }
            }
            log(`--- Teste 4 Concluído (PP Hijack JSON ${hijackReturnedCorrectly ? 'Confirmado' : 'Falhou/Bloqueado'}) ---`, 'test');
            return hijackReturnedCorrectly;
        };

        // --- Teste 5: Coleta de Dados do Ambiente (Fingerprinting) ---
        const testDataCollection = async () => {
            log("--- Iniciando Teste 5: Coleta de Dados do Ambiente ---", 'test');
            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // --- Informações do Navegador (Navigator) ---
            log("Coletando dados de Navigator...", 'subtest');
            try { log(`  navigator.userAgent: ${navigator.userAgent}`, 'info'); } catch(e) { log(`  Erro lendo userAgent: ${e.message}`, 'warn'); }
            try { log(`  navigator.language: ${navigator.language}`, 'info'); } catch(e) { log(`  Erro lendo language: ${e.message}`, 'warn'); }
            try { log(`  navigator.languages: ${navigator.languages ? navigator.languages.join(', ') : 'N/A'}`, 'info'); } catch(e) { log(`  Erro lendo languages: ${e.message}`, 'warn'); }
            try { log(`  navigator.platform: ${navigator.platform}`, 'info'); } catch(e) { log(`  Erro lendo platform: ${e.message}`, 'warn'); }
            try { log(`  navigator.vendor: ${navigator.vendor}`, 'info'); } catch(e) { log(`  Erro lendo vendor: ${e.message}`, 'warn'); }
            try { log(`  navigator.hardwareConcurrency: ${navigator.hardwareConcurrency}`, 'info'); } catch(e) { log(`  Erro lendo hardwareConcurrency: ${e.message}`, 'warn'); }
            try { log(`  navigator.deviceMemory: ${navigator.deviceMemory || 'N/A'}`, 'info'); } catch(e) { log(`  Erro lendo deviceMemory: ${e.message}`, 'warn'); }
            try { log(`  navigator.cookieEnabled: ${navigator.cookieEnabled}`, 'info'); } catch(e) { log(`  Erro lendo cookieEnabled: ${e.message}`, 'warn'); }
            try { log(`  navigator.webdriver: ${navigator.webdriver === true ? 'True' : 'False/N/A'}`, 'info'); } catch(e) { log(`  Erro lendo webdriver: ${e.message}`, 'warn'); }
            try {
                const plugins = navigator.plugins;
                let pluginList = 'N/A';
                if (plugins && plugins.length > 0) {
                    pluginList = Array.from(plugins).map(p => p.name).join('; ');
                }
                log(`  navigator.plugins: ${plugins ? plugins.length : 0} (${pluginList})`, 'info');
            } catch(e) { log(`  Erro lendo plugins: ${e.message}`, 'warn'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // --- Informações da Tela (Screen) ---
            log("Coletando dados da Tela...", 'subtest');
            try { log(`  screen.width x screen.height: ${screen.width}x${screen.height}`, 'info'); } catch(e) { log(`  Erro lendo width/height: ${e.message}`, 'warn'); }
            try { log(`  screen.availWidth x screen.availHeight: ${screen.availWidth}x${screen.availHeight}`, 'info'); } catch(e) { log(`  Erro lendo availWidth/availHeight: ${e.message}`, 'warn'); }
            try { log(`  screen.colorDepth: ${screen.colorDepth}`, 'info'); } catch(e) { log(`  Erro lendo colorDepth: ${e.message}`, 'warn'); }
            try { log(`  screen.pixelDepth: ${screen.pixelDepth}`, 'info'); } catch(e) { log(`  Erro lendo pixelDepth: ${e.message}`, 'warn'); }
            try { log(`  window.devicePixelRatio: ${window.devicePixelRatio || 'N/A'}`, 'info'); } catch(e) { log(`  Erro lendo devicePixelRatio: ${e.message}`, 'warn'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // --- Informações de Armazenamento e Recursos ---
            log("Coletando dados de Recursos/Armazenamento...", 'subtest');
            try { log(`  typeof(Storage) !== 'undefined': ${typeof(Storage) !== 'undefined'}`, 'info'); } catch(e) { log(`  Erro verificando Storage: ${e.message}`, 'warn'); }
            try { log(`  localStorage disponível: ${!!window.localStorage}`, 'info'); } catch(e) { log(`  Erro verificando localStorage: ${e.message}`, 'warn'); }
            try { log(`  sessionStorage disponível: ${!!window.sessionStorage}`, 'info'); } catch(e) { log(`  Erro verificando sessionStorage: ${e.message}`, 'warn'); }
            try { log(`  indexedDB disponível: ${!!window.indexedDB}`, 'info'); } catch(e) { log(`  Erro verificando indexedDB: ${e.message}`, 'warn'); }
            try { log(`  WebSockets disponíveis: ${!!window.WebSocket}`, 'info'); } catch(e) { log(`  Erro verificando WebSocket: ${e.message}`, 'warn'); }
            try { log(`  WebAssembly disponível: ${typeof(WebAssembly) === 'object'}`, 'info'); } catch(e) { log(`  Erro verificando WebAssembly: ${e.message}`, 'warn'); }
            try { log(`  ServiceWorker disponível: ${'serviceWorker' in navigator}`, 'info'); } catch(e) { log(`  Erro verificando ServiceWorker: ${e.message}`, 'warn'); }
            try { log(`  WebRTC (RTCPeerConnection) disponível: ${!!window.RTCPeerConnection}`, 'info'); } catch(e) { log(`  Erro verificando WebRTC: ${e.message}`, 'warn'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

            // --- Informações de Tempo e Performance ---
            log("Coletando dados de Tempo/Performance...", 'subtest');
            try { log(`  Fuso horário (offset minutos): ${new Date().getTimezoneOffset()}`, 'info'); } catch(e) { log(`  Erro lendo timezoneOffset: ${e.message}`, 'warn'); }
            try {
                const start = performance.now();
                // Loop simples para teste de performance relativo
                let count = 0;
                for(let i = 0; i < 1000000; i++) { count++; }
                const end = performance.now();
                log(`  performance.now() disponível: Sim. Loop(1M) levou ${ (end - start).toFixed(2) } ms. Count: ${count}`, 'info');
            } catch(e) { log(`  Erro no teste performance.now(): ${e.message}`, 'warn'); }

            await new Promise(resolve => setTimeout(resolve, SHORT_PAUSE));

             // --- Informações de WebGL ---
            log("Coletando dados de WebGL...", 'subtest');
            try {
                const canvas = document.getElementById('webgl-canvas');
                if (!canvas) throw new Error('Canvas element not found');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    let vendor = 'N/A';
                    let renderer = 'N/A';
                    if (debugInfo) {
                        vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                        renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    } else {
                        // Fallback se a extensão debug não estiver disponível
                        vendor = gl.getParameter(gl.VENDOR) || 'N/A';
                        renderer = gl.getParameter(gl.RENDERER) || 'N/A';
                    }
                    log(`  WebGL Vendor: ${vendor}`, 'info');
                    log(`  WebGL Renderer: ${renderer}`, 'info');
                } else {
                    log('  Contexto WebGL não disponível.', 'warn');
                }
            } catch (e) {
                log(`  Erro ao obter dados WebGL: ${e.message}`, 'error');
            }

            log("--- Teste 5 Concluído ---", 'test');
        }; // Fim de testDataCollection


        // --- Função Principal para Rodar Todos os Testes ---
        const runAllTests = async () => {
            if (runBtn) runBtn.disabled = true;
            log("==== INICIANDO PoC Final v10 (Coleta de Dados Adicionada) ====", 'critical'); // Versão atualizada

            // Teste 5: Coleta de Dados primeiro, pode ser útil ter o contexto antes
            await testDataCollection();
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testCSPBypass(); // Teste 1
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testOOBReadInfoLeakEnhancedStore(); // Teste 2
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testBasicPP(); // Teste 3
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));

            await testPPJsonHijack(); // Teste 4
            await new Promise(resolve => setTimeout(resolve, MEDIUM_PAUSE));


            log("\n==== PoC Final v10 CONCLUÍDA ====", 'critical'); // Versão atualizada
            if (runBtn) runBtn.disabled = false;
        };

        // document.addEventListener('DOMContentLoaded', runAllTests); // Descomente para rodar automaticamente
    </script>

</body>
</html>
